// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_3D_BANDPASS_METADATA: Metadata = {
    id: "85554b333e3bdcbc05fde6959f1cb444905c3dd7.boutiques",
    name: "3dBandpass",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V3dBandpassParameters {
    "@type": "afni.3dBandpass";
    "prefix"?: string | null | undefined;
    "automask": boolean;
    "blur"?: number | null | undefined;
    "despike": boolean;
    "highpass": number;
    "lowpass": number;
    "in_file": InputPathType;
    "localPV"?: number | null | undefined;
    "mask"?: InputPathType | null | undefined;
    "nfft"?: number | null | undefined;
    "no_detrend": boolean;
    "normalize": boolean;
    "notrans": boolean;
    "orthogonalize_dset"?: InputPathType | null | undefined;
    "orthogonalize_file"?: Array<InputPathType> | null | undefined;
    "outputtype"?: "NIFTI" | "AFNI" | "NIFTI_GZ" | null | undefined;
    "tr"?: number | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "afni.3dBandpass": v_3d_bandpass_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "afni.3dBandpass": v_3d_bandpass_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `v_3d_bandpass(...)`.
 *
 * @interface
 */
interface V3dBandpassOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output file from 3dbandpass.
     */
    out_file: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param highpass Highpass.
 * @param lowpass Lowpass.
 * @param in_file Input file to 3dbandpass.
 * @param prefix Prefix for output file.
 * @param automask Create a mask from the input dataset.
 * @param blur Blur (inside the mask only) with a filter width (fwhm) of 'fff' millimeters.
 * @param despike Despike each time series before other processing. hopefully, you don't actually need to do this, which is why it is optional.
 * @param local_pv Replace each vector by the local principal vector (aka first singular vector) from a neighborhood of radius 'rrr' millimeters. note that the pv time series is l2 normalized. this option is mostly for bob cox to have fun with.
 * @param mask Mask file.
 * @param nfft Set the fft length [must be a legal value].
 * @param no_detrend Skip the quadratic detrending of the input that occurs before the fft-based bandpassing. you would only want to do this if the dataset had been detrended already in some other program.
 * @param normalize Make all output time series have l2 norm = 1 (i.e., sum of squares = 1).
 * @param notrans Don't check for initial positive transients in the data. the test is a little slow, so skipping it is ok, if you know the data time series are transient-free.
 * @param orthogonalize_dset Orthogonalize each voxel to the corresponding voxel time series in dataset 'fset', which must have the same spatial and temporal grid structure as the main input dataset. at present, only one '-dsort' option is allowed.
 * @param orthogonalize_file Also orthogonalize input to columns in f.1d. multiple '-ort' options are allowed.
 * @param outputtype 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
 * @param tr Set time step (tr) in sec [default=from dataset header].
 *
 * @returns Parameter dictionary
 */
function v_3d_bandpass_params(
    highpass: number,
    lowpass: number,
    in_file: InputPathType,
    prefix: string | null = null,
    automask: boolean = false,
    blur: number | null = null,
    despike: boolean = false,
    local_pv: number | null = null,
    mask: InputPathType | null = null,
    nfft: number | null = null,
    no_detrend: boolean = false,
    normalize: boolean = false,
    notrans: boolean = false,
    orthogonalize_dset: InputPathType | null = null,
    orthogonalize_file: Array<InputPathType> | null = null,
    outputtype: "NIFTI" | "AFNI" | "NIFTI_GZ" | null = null,
    tr: number | null = null,
): V3dBandpassParameters {
    const params = {
        "@type": "afni.3dBandpass" as const,
        "automask": automask,
        "despike": despike,
        "highpass": highpass,
        "lowpass": lowpass,
        "in_file": in_file,
        "no_detrend": no_detrend,
        "normalize": normalize,
        "notrans": notrans,
    };
    if (prefix !== null) {
        params["prefix"] = prefix;
    }
    if (blur !== null) {
        params["blur"] = blur;
    }
    if (local_pv !== null) {
        params["localPV"] = local_pv;
    }
    if (mask !== null) {
        params["mask"] = mask;
    }
    if (nfft !== null) {
        params["nfft"] = nfft;
    }
    if (orthogonalize_dset !== null) {
        params["orthogonalize_dset"] = orthogonalize_dset;
    }
    if (orthogonalize_file !== null) {
        params["orthogonalize_file"] = orthogonalize_file;
    }
    if (outputtype !== null) {
        params["outputtype"] = outputtype;
    }
    if (tr !== null) {
        params["tr"] = tr;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function v_3d_bandpass_cargs(
    params: V3dBandpassParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("3dBandpass");
    if ((params["prefix"] ?? null) !== null) {
        cargs.push(
            "-prefix",
            (params["prefix"] ?? null)
        );
    }
    if ((params["automask"] ?? null)) {
        cargs.push("-automask");
    }
    if ((params["blur"] ?? null) !== null) {
        cargs.push(
            "-blur",
            String((params["blur"] ?? null))
        );
    }
    if ((params["despike"] ?? null)) {
        cargs.push("-despike");
    }
    cargs.push(String((params["highpass"] ?? null)));
    cargs.push(String((params["lowpass"] ?? null)));
    cargs.push(execution.inputFile((params["in_file"] ?? null)));
    if ((params["localPV"] ?? null) !== null) {
        cargs.push(
            "-localPV",
            String((params["localPV"] ?? null))
        );
    }
    if ((params["mask"] ?? null) !== null) {
        cargs.push(
            "-mask",
            execution.inputFile((params["mask"] ?? null))
        );
    }
    if ((params["nfft"] ?? null) !== null) {
        cargs.push(
            "-nfft",
            String((params["nfft"] ?? null))
        );
    }
    if ((params["no_detrend"] ?? null)) {
        cargs.push("-nodetrend");
    }
    if ((params["normalize"] ?? null)) {
        cargs.push("-norm");
    }
    if ((params["notrans"] ?? null)) {
        cargs.push("-notrans");
    }
    if ((params["orthogonalize_dset"] ?? null) !== null) {
        cargs.push(
            "-dsort",
            execution.inputFile((params["orthogonalize_dset"] ?? null))
        );
    }
    if ((params["orthogonalize_file"] ?? null) !== null) {
        cargs.push(
            "-ort",
            ...(params["orthogonalize_file"] ?? null).map(f => execution.inputFile(f))
        );
    }
    if ((params["outputtype"] ?? null) !== null) {
        cargs.push((params["outputtype"] ?? null));
    }
    if ((params["tr"] ?? null) !== null) {
        cargs.push(
            "-dt",
            String((params["tr"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function v_3d_bandpass_outputs(
    params: V3dBandpassParameters,
    execution: Execution,
): V3dBandpassOutputs {
    const ret: V3dBandpassOutputs = {
        root: execution.outputFile("."),
        out_file: ((params["prefix"] ?? null) !== null) ? execution.outputFile([(params["prefix"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * Program to lowpass and/or highpass each voxel time series in a dataset, offering more/different options than Fourier.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param execution The execution object.
 *
 * @returns NamedTuple of outputs (described in `V3dBandpassOutputs`).
 */
function v_3d_bandpass_execute(
    params: V3dBandpassParameters,
    execution: Execution,
): V3dBandpassOutputs {
    params = execution.params(params)
    const cargs = v_3d_bandpass_cargs(params, execution)
    const ret = v_3d_bandpass_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * Program to lowpass and/or highpass each voxel time series in a dataset, offering more/different options than Fourier.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param highpass Highpass.
 * @param lowpass Lowpass.
 * @param in_file Input file to 3dbandpass.
 * @param prefix Prefix for output file.
 * @param automask Create a mask from the input dataset.
 * @param blur Blur (inside the mask only) with a filter width (fwhm) of 'fff' millimeters.
 * @param despike Despike each time series before other processing. hopefully, you don't actually need to do this, which is why it is optional.
 * @param local_pv Replace each vector by the local principal vector (aka first singular vector) from a neighborhood of radius 'rrr' millimeters. note that the pv time series is l2 normalized. this option is mostly for bob cox to have fun with.
 * @param mask Mask file.
 * @param nfft Set the fft length [must be a legal value].
 * @param no_detrend Skip the quadratic detrending of the input that occurs before the fft-based bandpassing. you would only want to do this if the dataset had been detrended already in some other program.
 * @param normalize Make all output time series have l2 norm = 1 (i.e., sum of squares = 1).
 * @param notrans Don't check for initial positive transients in the data. the test is a little slow, so skipping it is ok, if you know the data time series are transient-free.
 * @param orthogonalize_dset Orthogonalize each voxel to the corresponding voxel time series in dataset 'fset', which must have the same spatial and temporal grid structure as the main input dataset. at present, only one '-dsort' option is allowed.
 * @param orthogonalize_file Also orthogonalize input to columns in f.1d. multiple '-ort' options are allowed.
 * @param outputtype 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
 * @param tr Set time step (tr) in sec [default=from dataset header].
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dBandpassOutputs`).
 */
function v_3d_bandpass(
    highpass: number,
    lowpass: number,
    in_file: InputPathType,
    prefix: string | null = null,
    automask: boolean = false,
    blur: number | null = null,
    despike: boolean = false,
    local_pv: number | null = null,
    mask: InputPathType | null = null,
    nfft: number | null = null,
    no_detrend: boolean = false,
    normalize: boolean = false,
    notrans: boolean = false,
    orthogonalize_dset: InputPathType | null = null,
    orthogonalize_file: Array<InputPathType> | null = null,
    outputtype: "NIFTI" | "AFNI" | "NIFTI_GZ" | null = null,
    tr: number | null = null,
    runner: Runner | null = null,
): V3dBandpassOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_3D_BANDPASS_METADATA);
    const params = v_3d_bandpass_params(highpass, lowpass, in_file, prefix, automask, blur, despike, local_pv, mask, nfft, no_detrend, normalize, notrans, orthogonalize_dset, orthogonalize_file, outputtype, tr)
    return v_3d_bandpass_execute(params, execution);
}


export {
      V3dBandpassOutputs,
      V3dBandpassParameters,
      V_3D_BANDPASS_METADATA,
      v_3d_bandpass,
      v_3d_bandpass_cargs,
      v_3d_bandpass_execute,
      v_3d_bandpass_outputs,
      v_3d_bandpass_params,
};
