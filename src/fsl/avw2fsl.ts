// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const AVW2FSL_METADATA: Metadata = {
    id: "3abb23590e6582f19536788936776d60f70fce47.boutiques",
    name: "avw2fsl",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface Avw2fslParameters {
    "@type"?: "fsl/avw2fsl";
    "source": Array<string>;
    "destination": string;
    "archive": boolean;
    "attributes_only": boolean;
    "backup"?: string | null | undefined;
    "backup_noarg": boolean;
    "copy_contents": boolean;
    "no_dereference_preserve_links": boolean;
    "force": boolean;
    "interactive": boolean;
    "follow_symlinks_cmdline": boolean;
    "hard_link": boolean;
    "dereference": boolean;
    "no_clobber": boolean;
    "no_dereference": boolean;
    "preserve": boolean;
    "preserve_attr"?: string | null | undefined;
    "preserve_context": boolean;
    "no_preserve"?: string | null | undefined;
    "parents": boolean;
    "recursive": boolean;
    "reflink"?: string | null | undefined;
    "remove_destination": boolean;
    "sparse"?: string | null | undefined;
    "strip_trailing_slashes": boolean;
    "symbolic_link": boolean;
    "suffix"?: string | null | undefined;
    "target_directory"?: string | null | undefined;
    "no_target_directory": boolean;
    "update": boolean;
    "verbose": boolean;
    "one_file_system": boolean;
    "selinux_context": boolean;
    "context"?: string | null | undefined;
    "help": boolean;
    "version": boolean;
}
type Avw2fslParametersTagged = Required<Pick<Avw2fslParameters, '@type'>> & Avw2fslParameters;


/**
 * Output object returned when calling `Avw2fslParameters(...)`.
 *
 * @interface
 */
interface Avw2fslOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Destination file or directory where the source is copied.
     */
    output_dest: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param source Source file(s) or directory to copy.
 * @param destination Destination file or directory where the source is to be copied.
 * @param archive Archive mode; same as -dR --preserve=all.
 * @param attributes_only Don't copy the file data, just the attributes.
 * @param backup Make a backup of each existing destination file.
 * @param backup_noarg Like --backup but does not accept an argument.
 * @param copy_contents Copy contents of special files when recursive.
 * @param no_dereference_preserve_links Same as --no-dereference --preserve=links.
 * @param force If an existing destination file cannot be opened, remove it and try again.
 * @param interactive Prompt before overwrite.
 * @param follow_symlinks_cmdline Follow command-line symbolic links in SOURCE.
 * @param hard_link Hard link files instead of copying.
 * @param dereference Always follow symbolic links in SOURCE.
 * @param no_clobber Do not overwrite an existing file.
 * @param no_dereference Never follow symbolic links in SOURCE.
 * @param preserve Preserve mode, ownership, and timestamps.
 * @param preserve_attr Preserve the specified attributes (default: mode,ownership,timestamps).
 * @param preserve_context Deprecated, same as --preserve=context.
 * @param no_preserve Don't preserve the specified attributes.
 * @param parents Use full source file name under DIRECTORY.
 * @param recursive Copy directories recursively.
 * @param reflink Control clone/CoW copies.
 * @param remove_destination Remove each existing destination file before attempting to open it.
 * @param sparse Control creation of sparse files.
 * @param strip_trailing_slashes Remove any trailing slashes from each SOURCE argument.
 * @param symbolic_link Make symbolic links instead of copying.
 * @param suffix Override the usual backup suffix.
 * @param target_directory Specify the target directory.
 * @param no_target_directory Treat DEST as a normal file.
 * @param update Copy only when the SOURCE file is newer than the destination file or when the destination file is missing.
 * @param verbose Explain what is being done.
 * @param one_file_system Stay on this file system.
 * @param selinux_context Set SELinux security context of destination file to default type.
 * @param context Like -Z, or if CTX is specified set the SELinux or SMACK security context to CTX.
 * @param help Display this help and exit.
 * @param version Output version information and exit.
 *
 * @returns Parameter dictionary
 */
function avw2fsl_params(
    source: Array<string>,
    destination: string,
    archive: boolean = false,
    attributes_only: boolean = false,
    backup: string | null = null,
    backup_noarg: boolean = false,
    copy_contents: boolean = false,
    no_dereference_preserve_links: boolean = false,
    force: boolean = false,
    interactive: boolean = false,
    follow_symlinks_cmdline: boolean = false,
    hard_link: boolean = false,
    dereference: boolean = false,
    no_clobber: boolean = false,
    no_dereference: boolean = false,
    preserve: boolean = false,
    preserve_attr: string | null = null,
    preserve_context: boolean = false,
    no_preserve: string | null = null,
    parents: boolean = false,
    recursive: boolean = false,
    reflink: string | null = null,
    remove_destination: boolean = false,
    sparse: string | null = null,
    strip_trailing_slashes: boolean = false,
    symbolic_link: boolean = false,
    suffix: string | null = null,
    target_directory: string | null = null,
    no_target_directory: boolean = false,
    update: boolean = false,
    verbose: boolean = false,
    one_file_system: boolean = false,
    selinux_context: boolean = false,
    context: string | null = null,
    help: boolean = false,
    version: boolean = false,
): Avw2fslParametersTagged {
    const params = {
        "@type": "fsl/avw2fsl" as const,
        "source": source,
        "destination": destination,
        "archive": archive,
        "attributes_only": attributes_only,
        "backup_noarg": backup_noarg,
        "copy_contents": copy_contents,
        "no_dereference_preserve_links": no_dereference_preserve_links,
        "force": force,
        "interactive": interactive,
        "follow_symlinks_cmdline": follow_symlinks_cmdline,
        "hard_link": hard_link,
        "dereference": dereference,
        "no_clobber": no_clobber,
        "no_dereference": no_dereference,
        "preserve": preserve,
        "preserve_context": preserve_context,
        "parents": parents,
        "recursive": recursive,
        "remove_destination": remove_destination,
        "strip_trailing_slashes": strip_trailing_slashes,
        "symbolic_link": symbolic_link,
        "no_target_directory": no_target_directory,
        "update": update,
        "verbose": verbose,
        "one_file_system": one_file_system,
        "selinux_context": selinux_context,
        "help": help,
        "version": version,
    };
    if (backup !== null) {
        params["backup"] = backup;
    }
    if (preserve_attr !== null) {
        params["preserve_attr"] = preserve_attr;
    }
    if (no_preserve !== null) {
        params["no_preserve"] = no_preserve;
    }
    if (reflink !== null) {
        params["reflink"] = reflink;
    }
    if (sparse !== null) {
        params["sparse"] = sparse;
    }
    if (suffix !== null) {
        params["suffix"] = suffix;
    }
    if (target_directory !== null) {
        params["target_directory"] = target_directory;
    }
    if (context !== null) {
        params["context"] = context;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function avw2fsl_cargs(
    params: Avw2fslParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("avw2fsl");
    cargs.push(...(params["source"] ?? null));
    cargs.push((params["destination"] ?? null));
    if ((params["archive"] ?? false)) {
        cargs.push("-a");
    }
    if ((params["attributes_only"] ?? false)) {
        cargs.push("--attributes-only");
    }
    if ((params["backup"] ?? null) !== null) {
        cargs.push(["--backup=", (params["backup"] ?? null)].join(''));
    }
    if ((params["backup_noarg"] ?? false)) {
        cargs.push("-b");
    }
    if ((params["copy_contents"] ?? false)) {
        cargs.push("--copy-contents");
    }
    if ((params["no_dereference_preserve_links"] ?? false)) {
        cargs.push("-d");
    }
    if ((params["force"] ?? false)) {
        cargs.push("-f");
    }
    if ((params["interactive"] ?? false)) {
        cargs.push("-i");
    }
    if ((params["follow_symlinks_cmdline"] ?? false)) {
        cargs.push("-H");
    }
    if ((params["hard_link"] ?? false)) {
        cargs.push("-l");
    }
    if ((params["dereference"] ?? false)) {
        cargs.push("-L");
    }
    if ((params["no_clobber"] ?? false)) {
        cargs.push("-n");
    }
    if ((params["no_dereference"] ?? false)) {
        cargs.push("-P");
    }
    if ((params["preserve"] ?? false)) {
        cargs.push("-p");
    }
    if ((params["preserve_attr"] ?? null) !== null) {
        cargs.push(["--preserve=", (params["preserve_attr"] ?? null)].join(''));
    }
    if ((params["preserve_context"] ?? false)) {
        cargs.push("-c");
    }
    if ((params["no_preserve"] ?? null) !== null) {
        cargs.push(["--no-preserve=", (params["no_preserve"] ?? null)].join(''));
    }
    if ((params["parents"] ?? false)) {
        cargs.push("--parents");
    }
    if ((params["recursive"] ?? false)) {
        cargs.push("-R");
    }
    if ((params["reflink"] ?? null) !== null) {
        cargs.push(["--reflink=", (params["reflink"] ?? null)].join(''));
    }
    if ((params["remove_destination"] ?? false)) {
        cargs.push("--remove-destination");
    }
    if ((params["sparse"] ?? null) !== null) {
        cargs.push(["--sparse=", (params["sparse"] ?? null)].join(''));
    }
    if ((params["strip_trailing_slashes"] ?? false)) {
        cargs.push("--strip-trailing-slashes");
    }
    if ((params["symbolic_link"] ?? false)) {
        cargs.push("-s");
    }
    if ((params["suffix"] ?? null) !== null) {
        cargs.push(["-S=", (params["suffix"] ?? null)].join(''));
    }
    if ((params["target_directory"] ?? null) !== null) {
        cargs.push(["-t=", (params["target_directory"] ?? null)].join(''));
    }
    if ((params["no_target_directory"] ?? false)) {
        cargs.push("-T");
    }
    if ((params["update"] ?? false)) {
        cargs.push("-u");
    }
    if ((params["verbose"] ?? false)) {
        cargs.push("-v");
    }
    if ((params["one_file_system"] ?? false)) {
        cargs.push("-x");
    }
    if ((params["selinux_context"] ?? false)) {
        cargs.push("-Z");
    }
    if ((params["context"] ?? null) !== null) {
        cargs.push(["--context=", (params["context"] ?? null)].join(''));
    }
    if ((params["help"] ?? false)) {
        cargs.push("--help");
    }
    if ((params["version"] ?? false)) {
        cargs.push("--version");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function avw2fsl_outputs(
    params: Avw2fslParameters,
    execution: Execution,
): Avw2fslOutputs {
    const ret: Avw2fslOutputs = {
        root: execution.outputFile("."),
        output_dest: execution.outputFile([(params["destination"] ?? null)].join('')),
    };
    return ret;
}


/**
 * avw2fsl
 *
 * Processing script to copy files and directories.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `Avw2fslOutputs`).
 */
function avw2fsl_execute(
    params: Avw2fslParameters,
    runner: Runner | null = null,
): Avw2fslOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(AVW2FSL_METADATA);
    params = execution.params(params)
    const cargs = avw2fsl_cargs(params, execution)
    const ret = avw2fsl_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * avw2fsl
 *
 * Processing script to copy files and directories.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param source Source file(s) or directory to copy.
 * @param destination Destination file or directory where the source is to be copied.
 * @param archive Archive mode; same as -dR --preserve=all.
 * @param attributes_only Don't copy the file data, just the attributes.
 * @param backup Make a backup of each existing destination file.
 * @param backup_noarg Like --backup but does not accept an argument.
 * @param copy_contents Copy contents of special files when recursive.
 * @param no_dereference_preserve_links Same as --no-dereference --preserve=links.
 * @param force If an existing destination file cannot be opened, remove it and try again.
 * @param interactive Prompt before overwrite.
 * @param follow_symlinks_cmdline Follow command-line symbolic links in SOURCE.
 * @param hard_link Hard link files instead of copying.
 * @param dereference Always follow symbolic links in SOURCE.
 * @param no_clobber Do not overwrite an existing file.
 * @param no_dereference Never follow symbolic links in SOURCE.
 * @param preserve Preserve mode, ownership, and timestamps.
 * @param preserve_attr Preserve the specified attributes (default: mode,ownership,timestamps).
 * @param preserve_context Deprecated, same as --preserve=context.
 * @param no_preserve Don't preserve the specified attributes.
 * @param parents Use full source file name under DIRECTORY.
 * @param recursive Copy directories recursively.
 * @param reflink Control clone/CoW copies.
 * @param remove_destination Remove each existing destination file before attempting to open it.
 * @param sparse Control creation of sparse files.
 * @param strip_trailing_slashes Remove any trailing slashes from each SOURCE argument.
 * @param symbolic_link Make symbolic links instead of copying.
 * @param suffix Override the usual backup suffix.
 * @param target_directory Specify the target directory.
 * @param no_target_directory Treat DEST as a normal file.
 * @param update Copy only when the SOURCE file is newer than the destination file or when the destination file is missing.
 * @param verbose Explain what is being done.
 * @param one_file_system Stay on this file system.
 * @param selinux_context Set SELinux security context of destination file to default type.
 * @param context Like -Z, or if CTX is specified set the SELinux or SMACK security context to CTX.
 * @param help Display this help and exit.
 * @param version Output version information and exit.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `Avw2fslOutputs`).
 */
function avw2fsl(
    source: Array<string>,
    destination: string,
    archive: boolean = false,
    attributes_only: boolean = false,
    backup: string | null = null,
    backup_noarg: boolean = false,
    copy_contents: boolean = false,
    no_dereference_preserve_links: boolean = false,
    force: boolean = false,
    interactive: boolean = false,
    follow_symlinks_cmdline: boolean = false,
    hard_link: boolean = false,
    dereference: boolean = false,
    no_clobber: boolean = false,
    no_dereference: boolean = false,
    preserve: boolean = false,
    preserve_attr: string | null = null,
    preserve_context: boolean = false,
    no_preserve: string | null = null,
    parents: boolean = false,
    recursive: boolean = false,
    reflink: string | null = null,
    remove_destination: boolean = false,
    sparse: string | null = null,
    strip_trailing_slashes: boolean = false,
    symbolic_link: boolean = false,
    suffix: string | null = null,
    target_directory: string | null = null,
    no_target_directory: boolean = false,
    update: boolean = false,
    verbose: boolean = false,
    one_file_system: boolean = false,
    selinux_context: boolean = false,
    context: string | null = null,
    help: boolean = false,
    version: boolean = false,
    runner: Runner | null = null,
): Avw2fslOutputs {
    const params = avw2fsl_params(source, destination, archive, attributes_only, backup, backup_noarg, copy_contents, no_dereference_preserve_links, force, interactive, follow_symlinks_cmdline, hard_link, dereference, no_clobber, no_dereference, preserve, preserve_attr, preserve_context, no_preserve, parents, recursive, reflink, remove_destination, sparse, strip_trailing_slashes, symbolic_link, suffix, target_directory, no_target_directory, update, verbose, one_file_system, selinux_context, context, help, version)
    return avw2fsl_execute(params, runner);
}


export {
      AVW2FSL_METADATA,
      Avw2fslOutputs,
      avw2fsl,
      avw2fsl_execute,
      avw2fsl_params,
};
