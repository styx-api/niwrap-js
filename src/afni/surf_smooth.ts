// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const SURF_SMOOTH_METADATA: Metadata = {
    id: "d0ac15b4d6012045723c7c4f0af6a5d57c2f0583.boutiques",
    name: "SurfSmooth",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface SurfSmoothParameters {
    "@type"?: "afni/SurfSmooth";
    "surface": string;
    "method": string;
    "input_data"?: InputPathType | null | undefined;
    "target_fwhm"?: number | null | undefined;
    "fwhm"?: number | null | undefined;
    "number_iterations"?: number | null | undefined;
    "output_file"?: string | null | undefined;
    "band_pass_frequency"?: number | null | undefined;
    "lambda_mu"?: string | null | undefined;
    "interp_weights"?: string | null | undefined;
    "node_mask"?: InputPathType | null | undefined;
    "surface_output"?: InputPathType | null | undefined;
    "dbg_node"?: number | null | undefined;
    "use_neighbors_outside_mask": boolean;
    "talk_suma": boolean;
    "refresh_rate"?: number | null | undefined;
}
type SurfSmoothParametersTagged = Required<Pick<SurfSmoothParameters, '@type'>> & SurfSmoothParameters;


/**
 * Output object returned when calling `SurfSmoothParameters(...)`.
 *
 * @interface
 */
interface SurfSmoothOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Name of the output file.
     */
    out_file: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param surface Option for specifying the surface to smooth or the domain over which DSET is defined.
 * @param method Name of smoothing method to use. Choose from: HEAT_07, HEAT_05, LM, NN_geom
 * @param input_data File containing data (in 1D or NIML format). Required for HEAT_05 and HEAT_07 methods.
 * @param target_fwhm Blur so that the final FWHM of the data is TF mm. Only for HEAT_07 method.
 * @param fwhm Effective Full Width at Half Maximum for smoothing. Required for HEAT_05 and optional for HEAT_07 methods.
 * @param number_iterations Number of smoothing iterations (default is 100 for LM and NN_geom, -1 for HEAT methods).
 * @param output_file Name of output file. Default based on method being used.
 * @param band_pass_frequency Bandpass frequency for LM method (0 < k < 10).
 * @param lambda_mu Lambda and Mu parameters for LM method. Sample values are: 0.6307 and -0.6732.
 * @param interp_weights Set interpolation weights for LM method. Options: Equal, Fujiwara, Desbrun.
 * @param node_mask Apply operations only to nodes listed in the given mask.
 * @param surface_output Writes the surface with smoothed coordinates to disk. For LM and NN_geom methods.
 * @param dbg_node Output debug information for node 'node'.
 * @param use_neighbors_outside_mask Allow value from a node neighboring node n to contribute to the value at n even if the neighbor is not in the mask.
 * @param talk_suma Send progress with each iteration to SUMA for real-time visualization.
 * @param refresh_rate Maximum number of updates to SUMA per second.
 *
 * @returns Parameter dictionary
 */
function surf_smooth_params(
    surface: string,
    method: string,
    input_data: InputPathType | null = null,
    target_fwhm: number | null = null,
    fwhm: number | null = null,
    number_iterations: number | null = null,
    output_file: string | null = null,
    band_pass_frequency: number | null = null,
    lambda_mu: string | null = null,
    interp_weights: string | null = null,
    node_mask: InputPathType | null = null,
    surface_output: InputPathType | null = null,
    dbg_node: number | null = null,
    use_neighbors_outside_mask: boolean = false,
    talk_suma: boolean = false,
    refresh_rate: number | null = null,
): SurfSmoothParametersTagged {
    const params = {
        "@type": "afni/SurfSmooth" as const,
        "surface": surface,
        "method": method,
        "use_neighbors_outside_mask": use_neighbors_outside_mask,
        "talk_suma": talk_suma,
    };
    if (input_data !== null) {
        params["input_data"] = input_data;
    }
    if (target_fwhm !== null) {
        params["target_fwhm"] = target_fwhm;
    }
    if (fwhm !== null) {
        params["fwhm"] = fwhm;
    }
    if (number_iterations !== null) {
        params["number_iterations"] = number_iterations;
    }
    if (output_file !== null) {
        params["output_file"] = output_file;
    }
    if (band_pass_frequency !== null) {
        params["band_pass_frequency"] = band_pass_frequency;
    }
    if (lambda_mu !== null) {
        params["lambda_mu"] = lambda_mu;
    }
    if (interp_weights !== null) {
        params["interp_weights"] = interp_weights;
    }
    if (node_mask !== null) {
        params["node_mask"] = node_mask;
    }
    if (surface_output !== null) {
        params["surface_output"] = surface_output;
    }
    if (dbg_node !== null) {
        params["dbg_node"] = dbg_node;
    }
    if (refresh_rate !== null) {
        params["refresh_rate"] = refresh_rate;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function surf_smooth_cargs(
    params: SurfSmoothParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("SurfSmooth");
    cargs.push(
        "-SURF_1",
        (params["surface"] ?? null)
    );
    cargs.push(
        "-met",
        (params["method"] ?? null)
    );
    if ((params["input_data"] ?? null) !== null) {
        cargs.push(
            "-input",
            execution.inputFile((params["input_data"] ?? null))
        );
    }
    if ((params["target_fwhm"] ?? null) !== null) {
        cargs.push(
            "-target_fwhm",
            String((params["target_fwhm"] ?? null))
        );
    }
    if ((params["fwhm"] ?? null) !== null) {
        cargs.push(
            "-fwhm",
            String((params["fwhm"] ?? null))
        );
    }
    if ((params["number_iterations"] ?? null) !== null) {
        cargs.push(
            "-Niter",
            String((params["number_iterations"] ?? null))
        );
    }
    if ((params["output_file"] ?? null) !== null) {
        cargs.push(
            "-output",
            (params["output_file"] ?? null)
        );
    }
    if ((params["band_pass_frequency"] ?? null) !== null) {
        cargs.push(
            "-kpb",
            String((params["band_pass_frequency"] ?? null))
        );
    }
    if ((params["lambda_mu"] ?? null) !== null) {
        cargs.push(
            "-lm",
            (params["lambda_mu"] ?? null)
        );
    }
    if ((params["interp_weights"] ?? null) !== null) {
        cargs.push(
            "-iw",
            (params["interp_weights"] ?? null)
        );
    }
    if ((params["node_mask"] ?? null) !== null) {
        cargs.push(
            "-MASK",
            execution.inputFile((params["node_mask"] ?? null))
        );
    }
    if ((params["surface_output"] ?? null) !== null) {
        cargs.push(
            "-surf_out",
            execution.inputFile((params["surface_output"] ?? null))
        );
    }
    if ((params["dbg_node"] ?? null) !== null) {
        cargs.push(
            "-dbg_n",
            String((params["dbg_node"] ?? null))
        );
    }
    if ((params["use_neighbors_outside_mask"] ?? false)) {
        cargs.push("-use_neighbors_outside_mask");
    }
    if ((params["talk_suma"] ?? false)) {
        cargs.push("-talk_suma");
    }
    if ((params["refresh_rate"] ?? null) !== null) {
        cargs.push(
            "-refresh_rate",
            String((params["refresh_rate"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function surf_smooth_outputs(
    params: SurfSmoothParameters,
    execution: Execution,
): SurfSmoothOutputs {
    const ret: SurfSmoothOutputs = {
        root: execution.outputFile("."),
        out_file: ((params["output_file"] ?? null) !== null) ? execution.outputFile([(params["output_file"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * SurfSmooth
 *
 * Tool for smoothing data on surfaces using various methods.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `SurfSmoothOutputs`).
 */
function surf_smooth_execute(
    params: SurfSmoothParameters,
    runner: Runner | null = null,
): SurfSmoothOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(SURF_SMOOTH_METADATA);
    params = execution.params(params)
    const cargs = surf_smooth_cargs(params, execution)
    const ret = surf_smooth_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * SurfSmooth
 *
 * Tool for smoothing data on surfaces using various methods.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param surface Option for specifying the surface to smooth or the domain over which DSET is defined.
 * @param method Name of smoothing method to use. Choose from: HEAT_07, HEAT_05, LM, NN_geom
 * @param input_data File containing data (in 1D or NIML format). Required for HEAT_05 and HEAT_07 methods.
 * @param target_fwhm Blur so that the final FWHM of the data is TF mm. Only for HEAT_07 method.
 * @param fwhm Effective Full Width at Half Maximum for smoothing. Required for HEAT_05 and optional for HEAT_07 methods.
 * @param number_iterations Number of smoothing iterations (default is 100 for LM and NN_geom, -1 for HEAT methods).
 * @param output_file Name of output file. Default based on method being used.
 * @param band_pass_frequency Bandpass frequency for LM method (0 < k < 10).
 * @param lambda_mu Lambda and Mu parameters for LM method. Sample values are: 0.6307 and -0.6732.
 * @param interp_weights Set interpolation weights for LM method. Options: Equal, Fujiwara, Desbrun.
 * @param node_mask Apply operations only to nodes listed in the given mask.
 * @param surface_output Writes the surface with smoothed coordinates to disk. For LM and NN_geom methods.
 * @param dbg_node Output debug information for node 'node'.
 * @param use_neighbors_outside_mask Allow value from a node neighboring node n to contribute to the value at n even if the neighbor is not in the mask.
 * @param talk_suma Send progress with each iteration to SUMA for real-time visualization.
 * @param refresh_rate Maximum number of updates to SUMA per second.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `SurfSmoothOutputs`).
 */
function surf_smooth(
    surface: string,
    method: string,
    input_data: InputPathType | null = null,
    target_fwhm: number | null = null,
    fwhm: number | null = null,
    number_iterations: number | null = null,
    output_file: string | null = null,
    band_pass_frequency: number | null = null,
    lambda_mu: string | null = null,
    interp_weights: string | null = null,
    node_mask: InputPathType | null = null,
    surface_output: InputPathType | null = null,
    dbg_node: number | null = null,
    use_neighbors_outside_mask: boolean = false,
    talk_suma: boolean = false,
    refresh_rate: number | null = null,
    runner: Runner | null = null,
): SurfSmoothOutputs {
    const params = surf_smooth_params(surface, method, input_data, target_fwhm, fwhm, number_iterations, output_file, band_pass_frequency, lambda_mu, interp_weights, node_mask, surface_output, dbg_node, use_neighbors_outside_mask, talk_suma, refresh_rate)
    return surf_smooth_execute(params, runner);
}


export {
      SURF_SMOOTH_METADATA,
      SurfSmoothOutputs,
      surf_smooth,
      surf_smooth_execute,
      surf_smooth_params,
};
