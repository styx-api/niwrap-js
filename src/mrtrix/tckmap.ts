// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const TCKMAP_METADATA: Metadata = {
    id: "6c3a1a0072e37f35d493f0f168ff70a6ce77b20d.boutiques",
    name: "tckmap",
    package: "mrtrix",
    container_image_tag: "mrtrix3/mrtrix3:3.0.4",
};


interface TckmapVariousStringParameters {
    "@type"?: "VariousString";
    "obj": string;
}
type TckmapVariousStringParametersTagged = Required<Pick<TckmapVariousStringParameters, '@type'>> & TckmapVariousStringParameters;


interface TckmapVariousFileParameters {
    "@type"?: "VariousFile";
    "obj": InputPathType;
}
type TckmapVariousFileParametersTagged = Required<Pick<TckmapVariousFileParameters, '@type'>> & TckmapVariousFileParameters;


interface TckmapConfigParameters {
    "@type"?: "config";
    "key": string;
    "value": string;
}
type TckmapConfigParametersTagged = Required<Pick<TckmapConfigParameters, '@type'>> & TckmapConfigParameters;


interface TckmapParameters {
    "@type"?: "mrtrix/tckmap";
    "template"?: InputPathType | null | undefined;
    "vox"?: Array<number> | null | undefined;
    "datatype"?: string | null | undefined;
    "dec": boolean;
    "dixel"?: TckmapVariousStringParametersTagged | TckmapVariousFileParametersTagged | null | undefined;
    "tod"?: number | null | undefined;
    "contrast"?: string | null | undefined;
    "image"?: InputPathType | null | undefined;
    "vector_file"?: InputPathType | null | undefined;
    "stat_vox"?: string | null | undefined;
    "stat_tck"?: string | null | undefined;
    "fwhm_tck"?: number | null | undefined;
    "map_zero": boolean;
    "backtrack": boolean;
    "upsample"?: number | null | undefined;
    "precise": boolean;
    "ends_only": boolean;
    "tck_weights_in"?: InputPathType | null | undefined;
    "info": boolean;
    "quiet": boolean;
    "debug": boolean;
    "force": boolean;
    "nthreads"?: number | null | undefined;
    "config"?: Array<TckmapConfigParameters> | null | undefined;
    "help": boolean;
    "version": boolean;
    "tracks": InputPathType;
    "output": string;
}
type TckmapParametersTagged = Required<Pick<TckmapParameters, '@type'>> & TckmapParameters;


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function tckmap_dixel_cargs_dyn_fn(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "VariousString": tckmap_various_string_cargs,
        "VariousFile": tckmap_various_file_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function tckmap_dixel_outputs_dyn_fn(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @param obj String object.
 *
 * @returns Parameter dictionary
 */
function tckmap_various_string_params(
    obj: string,
): TckmapVariousStringParametersTagged {
    const params = {
        "@type": "VariousString" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckmap_various_string_cargs(
    params: TckmapVariousStringParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["obj"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj File object.
 *
 * @returns Parameter dictionary
 */
function tckmap_various_file_params(
    obj: InputPathType,
): TckmapVariousFileParametersTagged {
    const params = {
        "@type": "VariousFile" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckmap_various_file_cargs(
    params: TckmapVariousFileParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["obj"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param key temporarily set the value of an MRtrix config file entry.
 * @param value temporarily set the value of an MRtrix config file entry.
 *
 * @returns Parameter dictionary
 */
function tckmap_config_params(
    key: string,
    value: string,
): TckmapConfigParametersTagged {
    const params = {
        "@type": "config" as const,
        "key": key,
        "value": value,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckmap_config_cargs(
    params: TckmapConfigParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-config");
    cargs.push((params["key"] ?? null));
    cargs.push((params["value"] ?? null));
    return cargs;
}


/**
 * Output object returned when calling `TckmapParameters(...)`.
 *
 * @interface
 */
interface TckmapOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output track-weighted image
     */
    output: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param tracks the input track file.
 * @param output the output track-weighted image
 * @param template an image file to be used as a template for the output (the output image will have the same transform and field of view).
 * @param vox provide either an isotropic voxel size (in mm), or comma-separated list of 3 voxel dimensions.
 * @param datatype specify output image data type.
 * @param dec perform track mapping in directionally-encoded colour (DEC) space
 * @param dixel map streamlines to dixels within each voxel; requires either a number of dixels (references an internal direction set), or a path to a text file containing a set of directions stored as azimuth/elevation pairs
 * @param tod generate a Track Orientation Distribution (TOD) in each voxel; need to specify the maximum spherical harmonic degree lmax to use when generating Apodised Point Spread Functions
 * @param contrast define the desired form of contrast for the output image
Options are: tdi, length, invlength, scalar_map, scalar_map_count, fod_amp, curvature, vector_file (default: tdi)
 * @param image provide the scalar image map for generating images with 'scalar_map' / 'scalar_map_count' contrast, or the spherical harmonics image for 'fod_amp' contrast
 * @param vector_file provide the vector data file for generating images with 'vector_file' contrast
 * @param stat_vox define the statistic for choosing the final voxel intensities for a given contrast type given the individual values from the tracks passing through each voxel. 
Options are: sum, min, mean, max (default: sum)
 * @param stat_tck define the statistic for choosing the contribution to be made by each streamline as a function of the samples taken along their lengths. 
Only has an effect for 'scalar_map', 'fod_amp' and 'curvature' contrast types. 
Options are: sum, min, mean, max, median, mean_nonzero, gaussian, ends_min, ends_mean, ends_max, ends_prod (default: mean)
 * @param fwhm_tck when using gaussian-smoothed per-track statistic, specify the desired full-width half-maximum of the Gaussian smoothing kernel (in mm)
 * @param map_zero if a streamline has zero contribution based on the contrast & statistic, typically it is not mapped; use this option to still contribute to the map even if this is the case (these non-contributing voxels can then influence the mean value in each voxel of the map)
 * @param backtrack when using -stat_tck ends_*, if the streamline endpoint is outside the FoV, backtrack along the streamline trajectory until an appropriate point is found
 * @param upsample upsample the tracks by some ratio using Hermite interpolation before mappping
(If omitted, an appropriate ratio will be determined automatically)
 * @param precise use a more precise streamline mapping strategy, that accurately quantifies the length through each voxel (these lengths are then taken into account during TWI calculation)
 * @param ends_only only map the streamline endpoints to the image
 * @param tck_weights_in specify a text scalar file containing the streamline weights
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 *
 * @returns Parameter dictionary
 */
function tckmap_params(
    tracks: InputPathType,
    output: string,
    template: InputPathType | null = null,
    vox: Array<number> | null = null,
    datatype: string | null = null,
    dec: boolean = false,
    dixel: TckmapVariousStringParametersTagged | TckmapVariousFileParametersTagged | null = null,
    tod: number | null = null,
    contrast: string | null = null,
    image: InputPathType | null = null,
    vector_file: InputPathType | null = null,
    stat_vox: string | null = null,
    stat_tck: string | null = null,
    fwhm_tck: number | null = null,
    map_zero: boolean = false,
    backtrack: boolean = false,
    upsample: number | null = null,
    precise: boolean = false,
    ends_only: boolean = false,
    tck_weights_in: InputPathType | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<TckmapConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
): TckmapParametersTagged {
    const params = {
        "@type": "mrtrix/tckmap" as const,
        "dec": dec,
        "map_zero": map_zero,
        "backtrack": backtrack,
        "precise": precise,
        "ends_only": ends_only,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help,
        "version": version,
        "tracks": tracks,
        "output": output,
    };
    if (template !== null) {
        params["template"] = template;
    }
    if (vox !== null) {
        params["vox"] = vox;
    }
    if (datatype !== null) {
        params["datatype"] = datatype;
    }
    if (dixel !== null) {
        params["dixel"] = dixel;
    }
    if (tod !== null) {
        params["tod"] = tod;
    }
    if (contrast !== null) {
        params["contrast"] = contrast;
    }
    if (image !== null) {
        params["image"] = image;
    }
    if (vector_file !== null) {
        params["vector_file"] = vector_file;
    }
    if (stat_vox !== null) {
        params["stat_vox"] = stat_vox;
    }
    if (stat_tck !== null) {
        params["stat_tck"] = stat_tck;
    }
    if (fwhm_tck !== null) {
        params["fwhm_tck"] = fwhm_tck;
    }
    if (upsample !== null) {
        params["upsample"] = upsample;
    }
    if (tck_weights_in !== null) {
        params["tck_weights_in"] = tck_weights_in;
    }
    if (nthreads !== null) {
        params["nthreads"] = nthreads;
    }
    if (config !== null) {
        params["config"] = config;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckmap_cargs(
    params: TckmapParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("tckmap");
    if ((params["template"] ?? null) !== null) {
        cargs.push(
            "-template",
            execution.inputFile((params["template"] ?? null))
        );
    }
    if ((params["vox"] ?? null) !== null) {
        cargs.push(
            "-vox",
            (params["vox"] ?? null).map(String).join(",")
        );
    }
    if ((params["datatype"] ?? null) !== null) {
        cargs.push(
            "-datatype",
            (params["datatype"] ?? null)
        );
    }
    if ((params["dec"] ?? false)) {
        cargs.push("-dec");
    }
    if ((params["dixel"] ?? null) !== null) {
        cargs.push(
            "-dixel",
            ...tckmap_dixel_cargs_dyn_fn((params["dixel"] ?? null)["@type"])((params["dixel"] ?? null), execution)
        );
    }
    if ((params["tod"] ?? null) !== null) {
        cargs.push(
            "-tod",
            String((params["tod"] ?? null))
        );
    }
    if ((params["contrast"] ?? null) !== null) {
        cargs.push(
            "-contrast",
            (params["contrast"] ?? null)
        );
    }
    if ((params["image"] ?? null) !== null) {
        cargs.push(
            "-image",
            execution.inputFile((params["image"] ?? null))
        );
    }
    if ((params["vector_file"] ?? null) !== null) {
        cargs.push(
            "-vector_file",
            execution.inputFile((params["vector_file"] ?? null))
        );
    }
    if ((params["stat_vox"] ?? null) !== null) {
        cargs.push(
            "-stat_vox",
            (params["stat_vox"] ?? null)
        );
    }
    if ((params["stat_tck"] ?? null) !== null) {
        cargs.push(
            "-stat_tck",
            (params["stat_tck"] ?? null)
        );
    }
    if ((params["fwhm_tck"] ?? null) !== null) {
        cargs.push(
            "-fwhm_tck",
            String((params["fwhm_tck"] ?? null))
        );
    }
    if ((params["map_zero"] ?? false)) {
        cargs.push("-map_zero");
    }
    if ((params["backtrack"] ?? false)) {
        cargs.push("-backtrack");
    }
    if ((params["upsample"] ?? null) !== null) {
        cargs.push(
            "-upsample",
            String((params["upsample"] ?? null))
        );
    }
    if ((params["precise"] ?? false)) {
        cargs.push("-precise");
    }
    if ((params["ends_only"] ?? false)) {
        cargs.push("-ends_only");
    }
    if ((params["tck_weights_in"] ?? null) !== null) {
        cargs.push(
            "-tck_weights_in",
            execution.inputFile((params["tck_weights_in"] ?? null))
        );
    }
    if ((params["info"] ?? false)) {
        cargs.push("-info");
    }
    if ((params["quiet"] ?? false)) {
        cargs.push("-quiet");
    }
    if ((params["debug"] ?? false)) {
        cargs.push("-debug");
    }
    if ((params["force"] ?? false)) {
        cargs.push("-force");
    }
    if ((params["nthreads"] ?? null) !== null) {
        cargs.push(
            "-nthreads",
            String((params["nthreads"] ?? null))
        );
    }
    if ((params["config"] ?? null) !== null) {
        cargs.push(...(params["config"] ?? null).map(s => tckmap_config_cargs(s, execution)).flat());
    }
    if ((params["help"] ?? false)) {
        cargs.push("-help");
    }
    if ((params["version"] ?? false)) {
        cargs.push("-version");
    }
    cargs.push(execution.inputFile((params["tracks"] ?? null)));
    cargs.push((params["output"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function tckmap_outputs(
    params: TckmapParameters,
    execution: Execution,
): TckmapOutputs {
    const ret: TckmapOutputs = {
        root: execution.outputFile("."),
        output: execution.outputFile([(params["output"] ?? null)].join('')),
    };
    return ret;
}


/**
 * tckmap
 *
 * Use track data as a form of contrast for producing a high-resolution image.
 *
 * Note: if you run into limitations with RAM usage, make sure you output the results to a .mif file or .mih / .dat file pair - this will avoid the allocation of an additional buffer to store the output for write-out.
 *
 * References:
 *
 * * For TDI or DEC TDI:
 * Calamante, F.; Tournier, J.-D.; Jackson, G. D. & Connelly, A. Track-density imaging (TDI): Super-resolution white matter imaging using whole-brain track-density mapping. NeuroImage, 2010, 53, 1233-1243
 *
 * * If using -contrast length and -stat_vox mean:
 * Pannek, K.; Mathias, J. L.; Bigler, E. D.; Brown, G.; Taylor, J. D. & Rose, S. E. The average pathlength map: A diffusion MRI tractography-derived index for studying brain pathology. NeuroImage, 2011, 55, 133-141
 *
 * * If using -dixel option with TDI contrast only:
 * Smith, R.E., Tournier, J-D., Calamante, F., Connelly, A. A novel paradigm for automated segmentation of very large whole-brain probabilistic tractography data sets. In proc. ISMRM, 2011, 19, 673
 *
 * * If using -dixel option with any other contrast:
 * Pannek, K., Raffelt, D., Salvado, O., Rose, S. Incorporating directional information in diffusion tractography derived maps: angular track imaging (ATI). In Proc. ISMRM, 2012, 20, 1912
 *
 * * If using -tod option:
 * Dhollander, T., Emsell, L., Van Hecke, W., Maes, F., Sunaert, S., Suetens, P. Track Orientation Density Imaging (TODI) and Track Orientation Distribution (TOD) based tractography. NeuroImage, 2014, 94, 312-336
 *
 * * If using other contrasts / statistics:
 * Calamante, F.; Tournier, J.-D.; Smith, R. E. & Connelly, A. A generalised framework for super-resolution track-weighted imaging. NeuroImage, 2012, 59, 2494-2503
 *
 * * If using -precise mapping option:
 * Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT: Spherical-deconvolution informed filtering of tractograms. NeuroImage, 2013, 67, 298-312 (Appendix 3).
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `TckmapOutputs`).
 */
function tckmap_execute(
    params: TckmapParameters,
    runner: Runner | null = null,
): TckmapOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(TCKMAP_METADATA);
    params = execution.params(params)
    const cargs = tckmap_cargs(params, execution)
    const ret = tckmap_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * tckmap
 *
 * Use track data as a form of contrast for producing a high-resolution image.
 *
 * Note: if you run into limitations with RAM usage, make sure you output the results to a .mif file or .mih / .dat file pair - this will avoid the allocation of an additional buffer to store the output for write-out.
 *
 * References:
 *
 * * For TDI or DEC TDI:
 * Calamante, F.; Tournier, J.-D.; Jackson, G. D. & Connelly, A. Track-density imaging (TDI): Super-resolution white matter imaging using whole-brain track-density mapping. NeuroImage, 2010, 53, 1233-1243
 *
 * * If using -contrast length and -stat_vox mean:
 * Pannek, K.; Mathias, J. L.; Bigler, E. D.; Brown, G.; Taylor, J. D. & Rose, S. E. The average pathlength map: A diffusion MRI tractography-derived index for studying brain pathology. NeuroImage, 2011, 55, 133-141
 *
 * * If using -dixel option with TDI contrast only:
 * Smith, R.E., Tournier, J-D., Calamante, F., Connelly, A. A novel paradigm for automated segmentation of very large whole-brain probabilistic tractography data sets. In proc. ISMRM, 2011, 19, 673
 *
 * * If using -dixel option with any other contrast:
 * Pannek, K., Raffelt, D., Salvado, O., Rose, S. Incorporating directional information in diffusion tractography derived maps: angular track imaging (ATI). In Proc. ISMRM, 2012, 20, 1912
 *
 * * If using -tod option:
 * Dhollander, T., Emsell, L., Van Hecke, W., Maes, F., Sunaert, S., Suetens, P. Track Orientation Density Imaging (TODI) and Track Orientation Distribution (TOD) based tractography. NeuroImage, 2014, 94, 312-336
 *
 * * If using other contrasts / statistics:
 * Calamante, F.; Tournier, J.-D.; Smith, R. E. & Connelly, A. A generalised framework for super-resolution track-weighted imaging. NeuroImage, 2012, 59, 2494-2503
 *
 * * If using -precise mapping option:
 * Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT: Spherical-deconvolution informed filtering of tractograms. NeuroImage, 2013, 67, 298-312 (Appendix 3).
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param tracks the input track file.
 * @param output the output track-weighted image
 * @param template an image file to be used as a template for the output (the output image will have the same transform and field of view).
 * @param vox provide either an isotropic voxel size (in mm), or comma-separated list of 3 voxel dimensions.
 * @param datatype specify output image data type.
 * @param dec perform track mapping in directionally-encoded colour (DEC) space
 * @param dixel map streamlines to dixels within each voxel; requires either a number of dixels (references an internal direction set), or a path to a text file containing a set of directions stored as azimuth/elevation pairs
 * @param tod generate a Track Orientation Distribution (TOD) in each voxel; need to specify the maximum spherical harmonic degree lmax to use when generating Apodised Point Spread Functions
 * @param contrast define the desired form of contrast for the output image
Options are: tdi, length, invlength, scalar_map, scalar_map_count, fod_amp, curvature, vector_file (default: tdi)
 * @param image provide the scalar image map for generating images with 'scalar_map' / 'scalar_map_count' contrast, or the spherical harmonics image for 'fod_amp' contrast
 * @param vector_file provide the vector data file for generating images with 'vector_file' contrast
 * @param stat_vox define the statistic for choosing the final voxel intensities for a given contrast type given the individual values from the tracks passing through each voxel. 
Options are: sum, min, mean, max (default: sum)
 * @param stat_tck define the statistic for choosing the contribution to be made by each streamline as a function of the samples taken along their lengths. 
Only has an effect for 'scalar_map', 'fod_amp' and 'curvature' contrast types. 
Options are: sum, min, mean, max, median, mean_nonzero, gaussian, ends_min, ends_mean, ends_max, ends_prod (default: mean)
 * @param fwhm_tck when using gaussian-smoothed per-track statistic, specify the desired full-width half-maximum of the Gaussian smoothing kernel (in mm)
 * @param map_zero if a streamline has zero contribution based on the contrast & statistic, typically it is not mapped; use this option to still contribute to the map even if this is the case (these non-contributing voxels can then influence the mean value in each voxel of the map)
 * @param backtrack when using -stat_tck ends_*, if the streamline endpoint is outside the FoV, backtrack along the streamline trajectory until an appropriate point is found
 * @param upsample upsample the tracks by some ratio using Hermite interpolation before mappping
(If omitted, an appropriate ratio will be determined automatically)
 * @param precise use a more precise streamline mapping strategy, that accurately quantifies the length through each voxel (these lengths are then taken into account during TWI calculation)
 * @param ends_only only map the streamline endpoints to the image
 * @param tck_weights_in specify a text scalar file containing the streamline weights
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `TckmapOutputs`).
 */
function tckmap(
    tracks: InputPathType,
    output: string,
    template: InputPathType | null = null,
    vox: Array<number> | null = null,
    datatype: string | null = null,
    dec: boolean = false,
    dixel: TckmapVariousStringParametersTagged | TckmapVariousFileParametersTagged | null = null,
    tod: number | null = null,
    contrast: string | null = null,
    image: InputPathType | null = null,
    vector_file: InputPathType | null = null,
    stat_vox: string | null = null,
    stat_tck: string | null = null,
    fwhm_tck: number | null = null,
    map_zero: boolean = false,
    backtrack: boolean = false,
    upsample: number | null = null,
    precise: boolean = false,
    ends_only: boolean = false,
    tck_weights_in: InputPathType | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<TckmapConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
    runner: Runner | null = null,
): TckmapOutputs {
    const params = tckmap_params(tracks, output, template, vox, datatype, dec, dixel, tod, contrast, image, vector_file, stat_vox, stat_tck, fwhm_tck, map_zero, backtrack, upsample, precise, ends_only, tck_weights_in, info, quiet, debug, force, nthreads, config, help, version)
    return tckmap_execute(params, runner);
}


export {
      TCKMAP_METADATA,
      TckmapOutputs,
      tckmap,
      tckmap_config_params,
      tckmap_execute,
      tckmap_params,
      tckmap_various_file_params,
      tckmap_various_string_params,
};
