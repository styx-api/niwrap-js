// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_3D_UNIFIZE_METADATA: Metadata = {
    id: "6277d1cde4dea26d7a71d4b0fc2e2e04b1054790.boutiques",
    name: "3dUnifize",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V3dUnifizeParameters {
    "__STYXTYPE__": "3dUnifize";
    "cl_frac"?: number | null | undefined;
    "epi": boolean;
    "gm": boolean;
    "no_duplo": boolean;
    "num_threads"?: number | null | undefined;
    "outputtype"?: "NIFTI" | "AFNI" | "NIFTI_GZ" | null | undefined;
    "quiet": boolean;
    "rbt"?: Array<number> | null | undefined;
    "prefix"?: string | null | undefined;
    "scale_file"?: InputPathType | null | undefined;
    "t2": boolean;
    "t2_up"?: number | null | undefined;
    "urad"?: number | null | undefined;
    "in_file": InputPathType;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "3dUnifize": v_3d_unifize_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "3dUnifize": v_3d_unifize_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `v_3d_unifize(...)`.
 *
 * @interface
 */
interface V3dUnifizeOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output image file name.
     */
    out_file: OutputPathType | null;
    /**
     * Scale factor file.
     */
    scale_file_outfile: OutputPathType | null;
}


function v_3d_unifize_params(
    in_file: InputPathType,
    cl_frac: number | null = null,
    epi: boolean = false,
    gm: boolean = false,
    no_duplo: boolean = false,
    num_threads: number | null = null,
    outputtype: "NIFTI" | "AFNI" | "NIFTI_GZ" | null = null,
    quiet: boolean = false,
    rbt: Array<number> | null = null,
    prefix: string | null = null,
    scale_file: InputPathType | null = null,
    t2: boolean = false,
    t2_up: number | null = null,
    urad: number | null = null,
): V3dUnifizeParameters {
    /**
     * Build parameters.
    
     * @param in_file Input file to 3dunifize.
     * @param cl_frac Option for afni experts only.set the automask 'clip level fraction'. must be between 0.1 and 0.9. a small fraction means to make the initial threshold for clipping (a la 3dcliplevel) smaller, which will tend to make the mask larger.  [default=0.1].
     * @param epi Assume the input dataset is a t2 (or t2\*) weighted epi time series. after computing the scaling, apply it to all volumes (trs) in the input dataset. that is, a given voxel will be scaled by the same factor at each tr. this option also implies '-noduplo' and '-t2'.this option turns off '-gm' if you turned it on.
     * @param gm Also scale to unifize 'gray matter' = lower intensity voxels (to aid in registering images from different scanners).
     * @param no_duplo Do not use the 'duplo down' step; this can be useful for lower resolution datasets.
     * @param num_threads Set number of threads.
     * @param outputtype 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
     * @param quiet Don't print the progress messages.
     * @param rbt (a float, a float, a float). Option for afni experts only.specify the 3 parameters for the algorithm:r = radius; same as given by option '-urad', [default=18.3]b = bottom percentile of normalizing data range, [default=70.0]r = top percentile of normalizing data range, [default=80.0].
     * @param prefix Output image file name.
     * @param scale_file Output file name to save the scale factor used at each voxel .
     * @param t2 Treat the input as if it were t2-weighted, rather than t1-weighted. this processing is done simply by inverting the image contrast, processing it as if that result were t1-weighted, and then re-inverting the results counts of voxel overlap, i.e., each voxel will contain the number of masks that it is set in.
     * @param t2_up Option for afni experts only.set the upper percentile point used for t2-t1 inversion. allowed to be anything between 90 and 100 (inclusive), with default to 98.5  (for no good reason).
     * @param urad Sets the radius (in voxels) of the ball used for the sneaky trick. default value is 18.3, and should be changed proportionally if the dataset voxel size differs significantly from 1 mm.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "3dUnifize" as const,
        "epi": epi,
        "gm": gm,
        "no_duplo": no_duplo,
        "quiet": quiet,
        "t2": t2,
        "in_file": in_file,
    };
    if (cl_frac !== null) {
        params["cl_frac"] = cl_frac;
    }
    if (num_threads !== null) {
        params["num_threads"] = num_threads;
    }
    if (outputtype !== null) {
        params["outputtype"] = outputtype;
    }
    if (rbt !== null) {
        params["rbt"] = rbt;
    }
    if (prefix !== null) {
        params["prefix"] = prefix;
    }
    if (scale_file !== null) {
        params["scale_file"] = scale_file;
    }
    if (t2_up !== null) {
        params["t2_up"] = t2_up;
    }
    if (urad !== null) {
        params["urad"] = urad;
    }
    return params;
}


function v_3d_unifize_cargs(
    params: V3dUnifizeParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("3dUnifize");
    if ((params["cl_frac"] ?? null) !== null) {
        cargs.push(
            "-clfrac",
            String((params["cl_frac"] ?? null))
        );
    }
    if ((params["epi"] ?? null)) {
        cargs.push("-EPI");
    }
    if ((params["gm"] ?? null)) {
        cargs.push("-GM");
    }
    if ((params["no_duplo"] ?? null)) {
        cargs.push("-noduplo");
    }
    if ((params["num_threads"] ?? null) !== null) {
        cargs.push(String((params["num_threads"] ?? null)));
    }
    if ((params["outputtype"] ?? null) !== null) {
        cargs.push((params["outputtype"] ?? null));
    }
    if ((params["quiet"] ?? null)) {
        cargs.push("-quiet");
    }
    if ((params["rbt"] ?? null) !== null) {
        cargs.push(
            "-rbt",
            ...(params["rbt"] ?? null).map(String)
        );
    }
    if ((params["prefix"] ?? null) !== null) {
        cargs.push(
            "-prefix",
            (params["prefix"] ?? null)
        );
    }
    if ((params["scale_file"] ?? null) !== null) {
        cargs.push(
            "-ssave",
            execution.inputFile((params["scale_file"] ?? null))
        );
    }
    if ((params["t2"] ?? null)) {
        cargs.push("-T2");
    }
    if ((params["t2_up"] ?? null) !== null) {
        cargs.push(
            "-T2up",
            String((params["t2_up"] ?? null))
        );
    }
    if ((params["urad"] ?? null) !== null) {
        cargs.push(
            "-Urad",
            String((params["urad"] ?? null))
        );
    }
    cargs.push(
        "-input",
        execution.inputFile((params["in_file"] ?? null))
    );
    return cargs;
}


function v_3d_unifize_outputs(
    params: V3dUnifizeParameters,
    execution: Execution,
): V3dUnifizeOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: V3dUnifizeOutputs = {
        root: execution.outputFile("."),
        out_file: ((params["prefix"] ?? null) !== null) ? execution.outputFile([(params["prefix"] ?? null)].join('')) : null,
        scale_file_outfile: ((params["scale_file"] ?? null) !== null) ? execution.outputFile([path.basename((params["scale_file"] ?? null))].join('')) : null,
    };
    return ret;
}


function v_3d_unifize_execute(
    params: V3dUnifizeParameters,
    execution: Execution,
): V3dUnifizeOutputs {
    /**
     * 3dUnifize - for uniformizing image intensity
     * * The input dataset is supposed to be a T1-weighted volume, possibly already skull-stripped (e.g., via 3dSkullStrip). However, this program can be a useful step to take BEFORE 3dSkullStrip, since the latter program can fail if the input volume is strongly shaded -- 3dUnifize will (mostly) remove such shading artifacts.
     * * The output dataset has the white matter (WM) intensity approximately uniformized across space, and scaled to peak at about 1000.
     * * The output dataset is always stored in float format!
     * * If the input dataset has more than 1 sub-brick, only sub-brick #0 will be processed!
     * * Want to correct EPI datasets for nonuniformity? You can try the new and experimental [Mar 2017] '-EPI' option.
     * * The principal motive for this program is for use in an image registration script, and it may or may not be useful otherwise.
     * * This program replaces the older (and very different) 3dUniformize, which is no longer maintained and may sublimate at any moment. (In other words, we do not recommend the use of 3dUniformize.).
     * 
     * Author: AFNI Developers
     * 
     * URL: https://afni.nimh.nih.gov/
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `V3dUnifizeOutputs`).
     */
    params = execution.params(params)
    const cargs = v_3d_unifize_cargs(params, execution)
    const ret = v_3d_unifize_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function v_3d_unifize(
    in_file: InputPathType,
    cl_frac: number | null = null,
    epi: boolean = false,
    gm: boolean = false,
    no_duplo: boolean = false,
    num_threads: number | null = null,
    outputtype: "NIFTI" | "AFNI" | "NIFTI_GZ" | null = null,
    quiet: boolean = false,
    rbt: Array<number> | null = null,
    prefix: string | null = null,
    scale_file: InputPathType | null = null,
    t2: boolean = false,
    t2_up: number | null = null,
    urad: number | null = null,
    runner: Runner | null = null,
): V3dUnifizeOutputs {
    /**
     * 3dUnifize - for uniformizing image intensity
     * * The input dataset is supposed to be a T1-weighted volume, possibly already skull-stripped (e.g., via 3dSkullStrip). However, this program can be a useful step to take BEFORE 3dSkullStrip, since the latter program can fail if the input volume is strongly shaded -- 3dUnifize will (mostly) remove such shading artifacts.
     * * The output dataset has the white matter (WM) intensity approximately uniformized across space, and scaled to peak at about 1000.
     * * The output dataset is always stored in float format!
     * * If the input dataset has more than 1 sub-brick, only sub-brick #0 will be processed!
     * * Want to correct EPI datasets for nonuniformity? You can try the new and experimental [Mar 2017] '-EPI' option.
     * * The principal motive for this program is for use in an image registration script, and it may or may not be useful otherwise.
     * * This program replaces the older (and very different) 3dUniformize, which is no longer maintained and may sublimate at any moment. (In other words, we do not recommend the use of 3dUniformize.).
     * 
     * Author: AFNI Developers
     * 
     * URL: https://afni.nimh.nih.gov/
    
     * @param in_file Input file to 3dunifize.
     * @param cl_frac Option for afni experts only.set the automask 'clip level fraction'. must be between 0.1 and 0.9. a small fraction means to make the initial threshold for clipping (a la 3dcliplevel) smaller, which will tend to make the mask larger.  [default=0.1].
     * @param epi Assume the input dataset is a t2 (or t2\*) weighted epi time series. after computing the scaling, apply it to all volumes (trs) in the input dataset. that is, a given voxel will be scaled by the same factor at each tr. this option also implies '-noduplo' and '-t2'.this option turns off '-gm' if you turned it on.
     * @param gm Also scale to unifize 'gray matter' = lower intensity voxels (to aid in registering images from different scanners).
     * @param no_duplo Do not use the 'duplo down' step; this can be useful for lower resolution datasets.
     * @param num_threads Set number of threads.
     * @param outputtype 'nifti' or 'afni' or 'nifti_gz'. Afni output filetype.
     * @param quiet Don't print the progress messages.
     * @param rbt (a float, a float, a float). Option for afni experts only.specify the 3 parameters for the algorithm:r = radius; same as given by option '-urad', [default=18.3]b = bottom percentile of normalizing data range, [default=70.0]r = top percentile of normalizing data range, [default=80.0].
     * @param prefix Output image file name.
     * @param scale_file Output file name to save the scale factor used at each voxel .
     * @param t2 Treat the input as if it were t2-weighted, rather than t1-weighted. this processing is done simply by inverting the image contrast, processing it as if that result were t1-weighted, and then re-inverting the results counts of voxel overlap, i.e., each voxel will contain the number of masks that it is set in.
     * @param t2_up Option for afni experts only.set the upper percentile point used for t2-t1 inversion. allowed to be anything between 90 and 100 (inclusive), with default to 98.5  (for no good reason).
     * @param urad Sets the radius (in voxels) of the ball used for the sneaky trick. default value is 18.3, and should be changed proportionally if the dataset voxel size differs significantly from 1 mm.
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `V3dUnifizeOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_3D_UNIFIZE_METADATA);
    const params = v_3d_unifize_params(in_file, cl_frac, epi, gm, no_duplo, num_threads, outputtype, quiet, rbt, prefix, scale_file, t2, t2_up, urad)
    return v_3d_unifize_execute(params, execution);
}


export {
      V3dUnifizeOutputs,
      V3dUnifizeParameters,
      V_3D_UNIFIZE_METADATA,
      v_3d_unifize,
      v_3d_unifize_params,
};
