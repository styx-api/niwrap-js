// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_3D_ZIPPER_ZAPPER_METADATA: Metadata = {
    id: "39018d2cee2f860298e557f60f6ddf79a0d96337.boutiques",
    name: "3dZipperZapper",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V3dZipperZapperParameters {
    "@type"?: "afni/3dZipperZapper";
    "input_file": InputPathType;
    "output_prefix": string;
    "mask_file"?: InputPathType | null | undefined;
    "min_slice_nvox"?: number | null | undefined;
    "min_streak_len"?: number | null | undefined;
    "do_out_slice_param": boolean;
    "no_out_bad_mask": boolean;
    "no_out_text_vals": boolean;
    "dont_use_streak": boolean;
    "dont_use_drop": boolean;
    "dont_use_corr": boolean;
    "min_streak_val"?: number | null | undefined;
    "min_drop_frac"?: number | null | undefined;
    "min_drop_diff"?: number | null | undefined;
    "min_corr_len"?: number | null | undefined;
    "min_corr_corr"?: number | null | undefined;
}
type V3dZipperZapperParametersTagged = Required<Pick<V3dZipperZapperParameters, '@type'>> & V3dZipperZapperParameters;


/**
 * Output object returned when calling `V3dZipperZapperParameters(...)`.
 *
 * @interface
 */
interface V3dZipperZapperOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Mask of potentially bad slices across the input dataset.
     */
    bad_slice_mask: OutputPathType;
    /**
     * 1D file containing a list of the bad volumes.
     */
    bad_volumes_list: OutputPathType;
    /**
     * 1D file of the per-volume parameters used to detect badness.
     */
    per_volume_params: OutputPathType;
    /**
     * 1D file of the slices within which calculations were made.
     */
    calculated_slices: OutputPathType;
    /**
     * Text file with the selector string of *good* volumes.
     */
    good_volumes_selector: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param input_file Input 3D+time file of DWIs or EPIs.
 * @param output_prefix Prefix for output file name.
 * @param mask_file Optional input of a single volume mask file, which gets applied to each volume in the input file.
 * @param min_slice_nvox Set the minimum number of voxels to be in the mask for a given slice to be included in the calculations.
 * @param min_streak_len Minimum number of slices in a row to look for fluctuations within.
 * @param do_out_slice_param Output the map of slice parameters.
 * @param no_out_bad_mask Do not output the mask of 'bad' slices.
 * @param no_out_text_vals Do not output the 1D files of the slice parameter values.
 * @param dont_use_streak Turn off the 'streak' criterion for identifying bad slices.
 * @param dont_use_drop Turn off the 'drop' criterion for identifying bad slices.
 * @param dont_use_corr Turn off the 'corr' criterion for identifying bad slices.
 * @param min_streak_val Minimum magnitude of voxelwise relative differences to perhaps be problematic.
 * @param min_drop_frac Minimum fraction for judging if the change in 'slice parameter' differences between neighboring slices might be a sign of badness.
 * @param min_drop_diff Minimum 'slice parameter' value within a single slice that might be considered a bad sign.
 * @param min_corr_len Minimum number of slices in a row to look for consecutive anticorrelations in brightness differences.
 * @param min_corr_corr Threshold for the magnitude of anticorrelations to be considered potentially bad.
 *
 * @returns Parameter dictionary
 */
function v_3d_zipper_zapper_params(
    input_file: InputPathType,
    output_prefix: string,
    mask_file: InputPathType | null = null,
    min_slice_nvox: number | null = null,
    min_streak_len: number | null = null,
    do_out_slice_param: boolean = false,
    no_out_bad_mask: boolean = false,
    no_out_text_vals: boolean = false,
    dont_use_streak: boolean = false,
    dont_use_drop: boolean = false,
    dont_use_corr: boolean = false,
    min_streak_val: number | null = null,
    min_drop_frac: number | null = null,
    min_drop_diff: number | null = null,
    min_corr_len: number | null = null,
    min_corr_corr: number | null = null,
): V3dZipperZapperParametersTagged {
    const params = {
        "@type": "afni/3dZipperZapper" as const,
        "input_file": input_file,
        "output_prefix": output_prefix,
        "do_out_slice_param": do_out_slice_param,
        "no_out_bad_mask": no_out_bad_mask,
        "no_out_text_vals": no_out_text_vals,
        "dont_use_streak": dont_use_streak,
        "dont_use_drop": dont_use_drop,
        "dont_use_corr": dont_use_corr,
    };
    if (mask_file !== null) {
        params["mask_file"] = mask_file;
    }
    if (min_slice_nvox !== null) {
        params["min_slice_nvox"] = min_slice_nvox;
    }
    if (min_streak_len !== null) {
        params["min_streak_len"] = min_streak_len;
    }
    if (min_streak_val !== null) {
        params["min_streak_val"] = min_streak_val;
    }
    if (min_drop_frac !== null) {
        params["min_drop_frac"] = min_drop_frac;
    }
    if (min_drop_diff !== null) {
        params["min_drop_diff"] = min_drop_diff;
    }
    if (min_corr_len !== null) {
        params["min_corr_len"] = min_corr_len;
    }
    if (min_corr_corr !== null) {
        params["min_corr_corr"] = min_corr_corr;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function v_3d_zipper_zapper_cargs(
    params: V3dZipperZapperParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("3dZipperZapper");
    cargs.push(
        "-input",
        execution.inputFile((params["input_file"] ?? null))
    );
    cargs.push(
        "-prefix",
        (params["output_prefix"] ?? null)
    );
    if ((params["mask_file"] ?? null) !== null) {
        cargs.push(
            "-mask",
            execution.inputFile((params["mask_file"] ?? null))
        );
    }
    if ((params["min_slice_nvox"] ?? null) !== null) {
        cargs.push(
            "-min_slice_nvox",
            String((params["min_slice_nvox"] ?? null))
        );
    }
    if ((params["min_streak_len"] ?? null) !== null) {
        cargs.push(
            "-min_streak_len",
            String((params["min_streak_len"] ?? null))
        );
    }
    if ((params["do_out_slice_param"] ?? false)) {
        cargs.push("-do_out_slice_param");
    }
    if ((params["no_out_bad_mask"] ?? false)) {
        cargs.push("-no_out_bad_mask");
    }
    if ((params["no_out_text_vals"] ?? false)) {
        cargs.push("-no_out_text_vals");
    }
    if ((params["dont_use_streak"] ?? false)) {
        cargs.push("-dont_use_streak");
    }
    if ((params["dont_use_drop"] ?? false)) {
        cargs.push("-dont_use_drop");
    }
    if ((params["dont_use_corr"] ?? false)) {
        cargs.push("-dont_use_corr");
    }
    if ((params["min_streak_val"] ?? null) !== null) {
        cargs.push(
            "-min_streak_val",
            String((params["min_streak_val"] ?? null))
        );
    }
    if ((params["min_drop_frac"] ?? null) !== null) {
        cargs.push(
            "-min_drop_frac",
            String((params["min_drop_frac"] ?? null))
        );
    }
    if ((params["min_drop_diff"] ?? null) !== null) {
        cargs.push(
            "-min_drop_diff",
            String((params["min_drop_diff"] ?? null))
        );
    }
    if ((params["min_corr_len"] ?? null) !== null) {
        cargs.push(
            "-min_corr_len",
            String((params["min_corr_len"] ?? null))
        );
    }
    if ((params["min_corr_corr"] ?? null) !== null) {
        cargs.push(
            "-min_corr_corr",
            String((params["min_corr_corr"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function v_3d_zipper_zapper_outputs(
    params: V3dZipperZapperParameters,
    execution: Execution,
): V3dZipperZapperOutputs {
    const ret: V3dZipperZapperOutputs = {
        root: execution.outputFile("."),
        bad_slice_mask: execution.outputFile([(params["output_prefix"] ?? null), "_badmask.nii.gz"].join('')),
        bad_volumes_list: execution.outputFile([(params["output_prefix"] ?? null), "_badvols.1D"].join('')),
        per_volume_params: execution.outputFile([(params["output_prefix"] ?? null), "_param.1D"].join('')),
        calculated_slices: execution.outputFile([(params["output_prefix"] ?? null), "_sli.1D"].join('')),
        good_volumes_selector: execution.outputFile([(params["output_prefix"] ?? null), "_goodvols.txt"].join('')),
    };
    return ret;
}


/**
 * 3dZipperZapper
 *
 * A basic program to highlight problematic volumes in data sets, especially EPI/DWI data sets with interleaved acquisition.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dZipperZapperOutputs`).
 */
function v_3d_zipper_zapper_execute(
    params: V3dZipperZapperParameters,
    runner: Runner | null = null,
): V3dZipperZapperOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_3D_ZIPPER_ZAPPER_METADATA);
    params = execution.params(params)
    const cargs = v_3d_zipper_zapper_cargs(params, execution)
    const ret = v_3d_zipper_zapper_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * 3dZipperZapper
 *
 * A basic program to highlight problematic volumes in data sets, especially EPI/DWI data sets with interleaved acquisition.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param input_file Input 3D+time file of DWIs or EPIs.
 * @param output_prefix Prefix for output file name.
 * @param mask_file Optional input of a single volume mask file, which gets applied to each volume in the input file.
 * @param min_slice_nvox Set the minimum number of voxels to be in the mask for a given slice to be included in the calculations.
 * @param min_streak_len Minimum number of slices in a row to look for fluctuations within.
 * @param do_out_slice_param Output the map of slice parameters.
 * @param no_out_bad_mask Do not output the mask of 'bad' slices.
 * @param no_out_text_vals Do not output the 1D files of the slice parameter values.
 * @param dont_use_streak Turn off the 'streak' criterion for identifying bad slices.
 * @param dont_use_drop Turn off the 'drop' criterion for identifying bad slices.
 * @param dont_use_corr Turn off the 'corr' criterion for identifying bad slices.
 * @param min_streak_val Minimum magnitude of voxelwise relative differences to perhaps be problematic.
 * @param min_drop_frac Minimum fraction for judging if the change in 'slice parameter' differences between neighboring slices might be a sign of badness.
 * @param min_drop_diff Minimum 'slice parameter' value within a single slice that might be considered a bad sign.
 * @param min_corr_len Minimum number of slices in a row to look for consecutive anticorrelations in brightness differences.
 * @param min_corr_corr Threshold for the magnitude of anticorrelations to be considered potentially bad.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dZipperZapperOutputs`).
 */
function v_3d_zipper_zapper(
    input_file: InputPathType,
    output_prefix: string,
    mask_file: InputPathType | null = null,
    min_slice_nvox: number | null = null,
    min_streak_len: number | null = null,
    do_out_slice_param: boolean = false,
    no_out_bad_mask: boolean = false,
    no_out_text_vals: boolean = false,
    dont_use_streak: boolean = false,
    dont_use_drop: boolean = false,
    dont_use_corr: boolean = false,
    min_streak_val: number | null = null,
    min_drop_frac: number | null = null,
    min_drop_diff: number | null = null,
    min_corr_len: number | null = null,
    min_corr_corr: number | null = null,
    runner: Runner | null = null,
): V3dZipperZapperOutputs {
    const params = v_3d_zipper_zapper_params(input_file, output_prefix, mask_file, min_slice_nvox, min_streak_len, do_out_slice_param, no_out_bad_mask, no_out_text_vals, dont_use_streak, dont_use_drop, dont_use_corr, min_streak_val, min_drop_frac, min_drop_diff, min_corr_len, min_corr_corr)
    return v_3d_zipper_zapper_execute(params, runner);
}


export {
      V3dZipperZapperOutputs,
      V_3D_ZIPPER_ZAPPER_METADATA,
      v_3d_zipper_zapper,
      v_3d_zipper_zapper_execute,
      v_3d_zipper_zapper_params,
};
