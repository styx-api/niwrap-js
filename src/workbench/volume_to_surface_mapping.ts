// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const VOLUME_TO_SURFACE_MAPPING_METADATA: Metadata = {
    id: "8506ce44812c4aebe401b46dcdf27231e04f47d0.workbench",
    name: "volume-to-surface-mapping",
    package: "workbench",
    container_image_tag: "nx10x/workbench:2.1.0",
};


interface VolumeToSurfaceMappingVolumeRoiParamsDict {
    "@type"?: "volume-roi";
    "roi-volume": InputPathType;
    "weighted": boolean;
}
type VolumeToSurfaceMappingVolumeRoiParamsDictTagged = Required<Pick<VolumeToSurfaceMappingVolumeRoiParamsDict, '@type'>> & VolumeToSurfaceMappingVolumeRoiParamsDict;


interface VolumeToSurfaceMappingDilateMissingParamsDict {
    "@type"?: "dilate-missing";
    "dist": number;
    "nearest": boolean;
}
type VolumeToSurfaceMappingDilateMissingParamsDictTagged = Required<Pick<VolumeToSurfaceMappingDilateMissingParamsDict, '@type'>> & VolumeToSurfaceMappingDilateMissingParamsDict;


interface VolumeToSurfaceMappingBadVerticesOutParamsDict {
    "@type"?: "bad-vertices-out";
    "roi-out": string;
}
type VolumeToSurfaceMappingBadVerticesOutParamsDictTagged = Required<Pick<VolumeToSurfaceMappingBadVerticesOutParamsDict, '@type'>> & VolumeToSurfaceMappingBadVerticesOutParamsDict;


interface VolumeToSurfaceMappingOutputWeightsParamsDict {
    "@type"?: "output-weights";
    "vertex": number;
    "weights-out": string;
}
type VolumeToSurfaceMappingOutputWeightsParamsDictTagged = Required<Pick<VolumeToSurfaceMappingOutputWeightsParamsDict, '@type'>> & VolumeToSurfaceMappingOutputWeightsParamsDict;


interface VolumeToSurfaceMappingRibbonConstrainedParamsDict {
    "@type"?: "ribbon-constrained";
    "inner-surf": InputPathType;
    "outer-surf": InputPathType;
    "volume-roi"?: VolumeToSurfaceMappingVolumeRoiParamsDict | null | undefined;
    "dilate-missing"?: VolumeToSurfaceMappingDilateMissingParamsDict | null | undefined;
    "subdiv-num"?: number | null | undefined;
    "thin-columns": boolean;
    "scale"?: number | null | undefined;
    "method"?: string | null | undefined;
    "bad-vertices-out"?: VolumeToSurfaceMappingBadVerticesOutParamsDict | null | undefined;
    "output-weights"?: VolumeToSurfaceMappingOutputWeightsParamsDict | null | undefined;
    "text-out"?: string | null | undefined;
}
type VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged = Required<Pick<VolumeToSurfaceMappingRibbonConstrainedParamsDict, '@type'>> & VolumeToSurfaceMappingRibbonConstrainedParamsDict;


interface VolumeToSurfaceMappingMyelinStyleParamsDict {
    "@type"?: "myelin-style";
    "ribbon-roi": InputPathType;
    "thickness": InputPathType;
    "sigma": number;
    "legacy-bug": boolean;
}
type VolumeToSurfaceMappingMyelinStyleParamsDictTagged = Required<Pick<VolumeToSurfaceMappingMyelinStyleParamsDict, '@type'>> & VolumeToSurfaceMappingMyelinStyleParamsDict;


interface VolumeToSurfaceMappingParamsDict {
    "@type"?: "workbench/volume-to-surface-mapping";
    "metric-out": string;
    "trilinear": boolean;
    "enclosing": boolean;
    "cubic": boolean;
    "ribbon-constrained"?: VolumeToSurfaceMappingRibbonConstrainedParamsDict | null | undefined;
    "myelin-style"?: VolumeToSurfaceMappingMyelinStyleParamsDict | null | undefined;
    "subvol"?: string | null | undefined;
    "volume": InputPathType;
    "surface": InputPathType;
}
type VolumeToSurfaceMappingParamsDictTagged = Required<Pick<VolumeToSurfaceMappingParamsDict, '@type'>> & VolumeToSurfaceMappingParamsDict;


/**
 * Build parameters.
 *
 * @param roi_volume the roi volume file
 * @param weighted treat the roi values as weightings rather than binary
 *
 * @returns Parameter dictionary
 */
function volume_to_surface_mapping_volume_roi(
    roi_volume: InputPathType,
    weighted: boolean = false,
): VolumeToSurfaceMappingVolumeRoiParamsDictTagged {
    const params = {
        "@type": "volume-roi" as const,
        "roi-volume": roi_volume,
        "weighted": weighted,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_to_surface_mapping_volume_roi_cargs(
    params: VolumeToSurfaceMappingVolumeRoiParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-volume-roi",
        execution.inputFile((params["roi-volume"] ?? null)),
        "-weighted"
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param dist distance in mm for dilation (can be small, like 1mm)
 * @param nearest use nearest neighbor dilation (mainly useful for integer data)
 *
 * @returns Parameter dictionary
 */
function volume_to_surface_mapping_dilate_missing(
    dist: number,
    nearest: boolean = false,
): VolumeToSurfaceMappingDilateMissingParamsDictTagged {
    const params = {
        "@type": "dilate-missing" as const,
        "dist": dist,
        "nearest": nearest,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_to_surface_mapping_dilate_missing_cargs(
    params: VolumeToSurfaceMappingDilateMissingParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-dilate-missing",
        String((params["dist"] ?? null)),
        "-nearest"
    );
    return cargs;
}


/**
 * Output object returned when calling `VolumeToSurfaceMappingBadVerticesOutParamsDict | null(...)`.
 *
 * @interface
 */
interface VolumeToSurfaceMappingBadVerticesOutOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output metric file of vertices that have no data
     */
    roi_out: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param roi_out the output metric file of vertices that have no data
 *
 * @returns Parameter dictionary
 */
function volume_to_surface_mapping_bad_vertices_out(
    roi_out: string,
): VolumeToSurfaceMappingBadVerticesOutParamsDictTagged {
    const params = {
        "@type": "bad-vertices-out" as const,
        "roi-out": roi_out,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_to_surface_mapping_bad_vertices_out_cargs(
    params: VolumeToSurfaceMappingBadVerticesOutParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-bad-vertices-out",
        (params["roi-out"] ?? null)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function volume_to_surface_mapping_bad_vertices_out_outputs(
    params: VolumeToSurfaceMappingBadVerticesOutParamsDict,
    execution: Execution,
): VolumeToSurfaceMappingBadVerticesOutOutputs {
    const ret: VolumeToSurfaceMappingBadVerticesOutOutputs = {
        root: execution.outputFile("."),
        roi_out: execution.outputFile([(params["roi-out"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `VolumeToSurfaceMappingOutputWeightsParamsDict | null(...)`.
 *
 * @interface
 */
interface VolumeToSurfaceMappingOutputWeightsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * volume to write the weights to
     */
    weights_out: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param vertex the vertex number to get the voxel weights for, 0-based
 * @param weights_out volume to write the weights to
 *
 * @returns Parameter dictionary
 */
function volume_to_surface_mapping_output_weights(
    vertex: number,
    weights_out: string,
): VolumeToSurfaceMappingOutputWeightsParamsDictTagged {
    const params = {
        "@type": "output-weights" as const,
        "vertex": vertex,
        "weights-out": weights_out,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_to_surface_mapping_output_weights_cargs(
    params: VolumeToSurfaceMappingOutputWeightsParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-output-weights",
        String((params["vertex"] ?? null)),
        (params["weights-out"] ?? null)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function volume_to_surface_mapping_output_weights_outputs(
    params: VolumeToSurfaceMappingOutputWeightsParamsDict,
    execution: Execution,
): VolumeToSurfaceMappingOutputWeightsOutputs {
    const ret: VolumeToSurfaceMappingOutputWeightsOutputs = {
        root: execution.outputFile("."),
        weights_out: execution.outputFile([(params["weights-out"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `VolumeToSurfaceMappingRibbonConstrainedParamsDict | null(...)`.
 *
 * @interface
 */
interface VolumeToSurfaceMappingRibbonConstrainedOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Outputs from `volume_to_surface_mapping_bad_vertices_out_outputs`.
     */
    bad_vertices_out: VolumeToSurfaceMappingBadVerticesOutOutputs | null;
    /**
     * Outputs from `volume_to_surface_mapping_output_weights_outputs`.
     */
    output_weights: VolumeToSurfaceMappingOutputWeightsOutputs | null;
}


/**
 * Build parameters.
 *
 * @param inner_surf the inner surface of the ribbon
 * @param outer_surf the outer surface of the ribbon
 * @param volume_roi use a volume roi
 * @param dilate_missing use dilation for small vertices that 'missed' the geometry tests
 * @param subdiv_num voxel divisions while estimating voxel weights

number of subdivisions, default 3
 * @param thin_columns use non-overlapping polyhedra
 * @param scale reduce weight to voxels that aren't near <surface>

value to multiply the local thickness by, to get the gaussian sigma
 * @param method instead of a weighted average of voxels, interpolate at subpoints inside the ribbon

interpolation method, must be CUBIC, ENCLOSING_VOXEL, or TRILINEAR
 * @param bad_vertices_out output an ROI of which vertices didn't intersect any valid voxels
 * @param output_weights write the voxel weights for a vertex to a volume file
 * @param text_out write the voxel weights for all vertices to a text file

output - the output text filename
 *
 * @returns Parameter dictionary
 */
function volume_to_surface_mapping_ribbon_constrained(
    inner_surf: InputPathType,
    outer_surf: InputPathType,
    volume_roi: VolumeToSurfaceMappingVolumeRoiParamsDict | null = null,
    dilate_missing: VolumeToSurfaceMappingDilateMissingParamsDict | null = null,
    subdiv_num: number | null = null,
    thin_columns: boolean = false,
    scale: number | null = null,
    method: string | null = null,
    bad_vertices_out: VolumeToSurfaceMappingBadVerticesOutParamsDict | null = null,
    output_weights: VolumeToSurfaceMappingOutputWeightsParamsDict | null = null,
    text_out: string | null = null,
): VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged {
    const params = {
        "@type": "ribbon-constrained" as const,
        "inner-surf": inner_surf,
        "outer-surf": outer_surf,
        "thin-columns": thin_columns,
    };
    if (volume_roi !== null) {
        params["volume-roi"] = volume_roi;
    }
    if (dilate_missing !== null) {
        params["dilate-missing"] = dilate_missing;
    }
    if (subdiv_num !== null) {
        params["subdiv-num"] = subdiv_num;
    }
    if (scale !== null) {
        params["scale"] = scale;
    }
    if (method !== null) {
        params["method"] = method;
    }
    if (bad_vertices_out !== null) {
        params["bad-vertices-out"] = bad_vertices_out;
    }
    if (output_weights !== null) {
        params["output-weights"] = output_weights;
    }
    if (text_out !== null) {
        params["text-out"] = text_out;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_to_surface_mapping_ribbon_constrained_cargs(
    params: VolumeToSurfaceMappingRibbonConstrainedParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-ribbon-constrained",
        execution.inputFile((params["inner-surf"] ?? null)),
        execution.inputFile((params["outer-surf"] ?? null)),
        ...volume_to_surface_mapping_volume_roi_cargs((params["volume-roi"] ?? null), execution),
        ...volume_to_surface_mapping_dilate_missing_cargs((params["dilate-missing"] ?? null), execution),
        "-voxel-subdiv",
        String((params["subdiv-num"] ?? null)),
        "-thin-columns",
        "-gaussian",
        String((params["scale"] ?? null)),
        "-interpolate",
        (params["method"] ?? null),
        ...volume_to_surface_mapping_bad_vertices_out_cargs((params["bad-vertices-out"] ?? null), execution),
        ...volume_to_surface_mapping_output_weights_cargs((params["output-weights"] ?? null), execution),
        "-output-weights-text",
        (params["text-out"] ?? null)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function volume_to_surface_mapping_ribbon_constrained_outputs(
    params: VolumeToSurfaceMappingRibbonConstrainedParamsDict,
    execution: Execution,
): VolumeToSurfaceMappingRibbonConstrainedOutputs {
    const ret: VolumeToSurfaceMappingRibbonConstrainedOutputs = {
        root: execution.outputFile("."),
        bad_vertices_out: (params["bad-vertices-out"] ?? null) ? (volume_to_surface_mapping_bad_vertices_out_outputs((params["bad-vertices-out"] ?? null), execution) ?? null) : null,
        output_weights: (params["output-weights"] ?? null) ? (volume_to_surface_mapping_output_weights_outputs((params["output-weights"] ?? null), execution) ?? null) : null,
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @param ribbon_roi an roi volume of the cortical ribbon for this hemisphere
 * @param thickness a metric file of cortical thickness
 * @param sigma gaussian kernel in mm for weighting voxels within range
 * @param legacy_bug emulate old v1.2.3 and earlier code that didn't follow a cylinder cutoff
 *
 * @returns Parameter dictionary
 */
function volume_to_surface_mapping_myelin_style(
    ribbon_roi: InputPathType,
    thickness: InputPathType,
    sigma: number,
    legacy_bug: boolean = false,
): VolumeToSurfaceMappingMyelinStyleParamsDictTagged {
    const params = {
        "@type": "myelin-style" as const,
        "ribbon-roi": ribbon_roi,
        "thickness": thickness,
        "sigma": sigma,
        "legacy-bug": legacy_bug,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_to_surface_mapping_myelin_style_cargs(
    params: VolumeToSurfaceMappingMyelinStyleParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-myelin-style",
        execution.inputFile((params["ribbon-roi"] ?? null)),
        execution.inputFile((params["thickness"] ?? null)),
        String((params["sigma"] ?? null)),
        "-legacy-bug"
    );
    return cargs;
}


/**
 * Output object returned when calling `VolumeToSurfaceMappingParamsDict(...)`.
 *
 * @interface
 */
interface VolumeToSurfaceMappingOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output metric file
     */
    metric_out: OutputPathType;
    /**
     * Outputs from `volume_to_surface_mapping_ribbon_constrained_outputs`.
     */
    ribbon_constrained: VolumeToSurfaceMappingRibbonConstrainedOutputs | null;
}


/**
 * Build parameters.
 *
 * @param metric_out the output metric file
 * @param volume the volume to map data from
 * @param surface the surface to map the data onto
 * @param trilinear use trilinear volume interpolation
 * @param enclosing use value of the enclosing voxel
 * @param cubic use cubic splines
 * @param ribbon_constrained use ribbon constrained mapping algorithm
 * @param myelin_style use the method from myelin mapping
 * @param subvol select a single subvolume to map

the subvolume number or name
 *
 * @returns Parameter dictionary
 */
function volume_to_surface_mapping_params(
    metric_out: string,
    volume: InputPathType,
    surface: InputPathType,
    trilinear: boolean = false,
    enclosing: boolean = false,
    cubic: boolean = false,
    ribbon_constrained: VolumeToSurfaceMappingRibbonConstrainedParamsDict | null = null,
    myelin_style: VolumeToSurfaceMappingMyelinStyleParamsDict | null = null,
    subvol: string | null = null,
): VolumeToSurfaceMappingParamsDictTagged {
    const params = {
        "@type": "workbench/volume-to-surface-mapping" as const,
        "metric-out": metric_out,
        "trilinear": trilinear,
        "enclosing": enclosing,
        "cubic": cubic,
        "volume": volume,
        "surface": surface,
    };
    if (ribbon_constrained !== null) {
        params["ribbon-constrained"] = ribbon_constrained;
    }
    if (myelin_style !== null) {
        params["myelin-style"] = myelin_style;
    }
    if (subvol !== null) {
        params["subvol"] = subvol;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_to_surface_mapping_cargs(
    params: VolumeToSurfaceMappingParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "wb_command",
        "-volume-to-surface-mapping",
        (params["metric-out"] ?? null),
        "-trilinear",
        "-enclosing",
        "-cubic",
        ...volume_to_surface_mapping_ribbon_constrained_cargs((params["ribbon-constrained"] ?? null), execution),
        ...volume_to_surface_mapping_myelin_style_cargs((params["myelin-style"] ?? null), execution),
        "-subvol-select",
        (params["subvol"] ?? null)
    );
    cargs.push(execution.inputFile((params["volume"] ?? null)));
    cargs.push(execution.inputFile((params["surface"] ?? null)));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function volume_to_surface_mapping_outputs(
    params: VolumeToSurfaceMappingParamsDict,
    execution: Execution,
): VolumeToSurfaceMappingOutputs {
    const ret: VolumeToSurfaceMappingOutputs = {
        root: execution.outputFile("."),
        metric_out: execution.outputFile([(params["metric-out"] ?? null)].join('')),
        ribbon_constrained: (params["ribbon-constrained"] ?? null) ? (volume_to_surface_mapping_ribbon_constrained_outputs((params["ribbon-constrained"] ?? null), execution) ?? null) : null,
    };
    return ret;
}


/**
 * MAP VOLUME TO SURFACE.
 *
 * You must specify exactly one mapping method.  Enclosing voxel uses the value from the voxel the vertex lies inside, while trilinear does a 3D linear interpolation based on the voxels immediately on each side of the vertex's position.
 *
 * The ribbon mapping method constructs a polyhedron from the vertex's neighbors on each surface, and estimates the amount of this polyhedron's volume that falls inside any nearby voxels, to use as the weights for sampling.  If -thin-columns is specified, the polyhedron uses the edge midpoints and triangle centroids, so that neighboring vertices do not have overlapping polyhedra.  This may require increasing -voxel-subdiv to get enough samples in each voxel to reliably land inside these smaller polyhedra.  The volume ROI is useful to exclude partial volume effects of voxels the surfaces pass through, and will cause the mapping to ignore voxels that don't have a positive value in the mask.  The subdivision number specifies how it approximates the amount of the volume the polyhedron intersects, by splitting each voxel into NxNxN pieces, and checking whether the center of each piece is inside the polyhedron.  If you have very large voxels, consider increasing this if you get zeros in your output.  The -gaussian option makes it act more like the myelin method, where the distance of a voxel from <surface> is used to downweight the voxel.  The -interpolate suboption, instead of doing a weighted average of voxels, interpolates from the volume at the subdivided points inside the ribbon.  If using both -interpolate and the -weighted suboption to -volume-roi, the roi volume weights are linearly interpolated, unless the -interpolate method is ENCLOSING_VOXEL, in which case ENCLOSING_VOXEL is also used for sampling the roi volume weights.
 *
 * The myelin style method uses part of the caret5 myelin mapping command to do the mapping: for each surface vertex, take all voxels that are in a cylinder with radius and height equal to cortical thickness, centered on the vertex and aligned with the surface normal, and that are also within the ribbon ROI, and apply a gaussian kernel with the specified sigma to them to get the weights to use.  The -legacy-bug flag reverts to the unintended behavior present from the initial implementation up to and including v1.2.3, which had only the tangential cutoff and a bounding box intended to be larger than where the cylinder cutoff should have been.
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `VolumeToSurfaceMappingOutputs`).
 */
function volume_to_surface_mapping_execute(
    params: VolumeToSurfaceMappingParamsDict,
    runner: Runner | null = null,
): VolumeToSurfaceMappingOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(VOLUME_TO_SURFACE_MAPPING_METADATA);
    params = execution.params(params)
    const cargs = volume_to_surface_mapping_cargs(params, execution)
    const ret = volume_to_surface_mapping_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * MAP VOLUME TO SURFACE.
 *
 * You must specify exactly one mapping method.  Enclosing voxel uses the value from the voxel the vertex lies inside, while trilinear does a 3D linear interpolation based on the voxels immediately on each side of the vertex's position.
 *
 * The ribbon mapping method constructs a polyhedron from the vertex's neighbors on each surface, and estimates the amount of this polyhedron's volume that falls inside any nearby voxels, to use as the weights for sampling.  If -thin-columns is specified, the polyhedron uses the edge midpoints and triangle centroids, so that neighboring vertices do not have overlapping polyhedra.  This may require increasing -voxel-subdiv to get enough samples in each voxel to reliably land inside these smaller polyhedra.  The volume ROI is useful to exclude partial volume effects of voxels the surfaces pass through, and will cause the mapping to ignore voxels that don't have a positive value in the mask.  The subdivision number specifies how it approximates the amount of the volume the polyhedron intersects, by splitting each voxel into NxNxN pieces, and checking whether the center of each piece is inside the polyhedron.  If you have very large voxels, consider increasing this if you get zeros in your output.  The -gaussian option makes it act more like the myelin method, where the distance of a voxel from <surface> is used to downweight the voxel.  The -interpolate suboption, instead of doing a weighted average of voxels, interpolates from the volume at the subdivided points inside the ribbon.  If using both -interpolate and the -weighted suboption to -volume-roi, the roi volume weights are linearly interpolated, unless the -interpolate method is ENCLOSING_VOXEL, in which case ENCLOSING_VOXEL is also used for sampling the roi volume weights.
 *
 * The myelin style method uses part of the caret5 myelin mapping command to do the mapping: for each surface vertex, take all voxels that are in a cylinder with radius and height equal to cortical thickness, centered on the vertex and aligned with the surface normal, and that are also within the ribbon ROI, and apply a gaussian kernel with the specified sigma to them to get the weights to use.  The -legacy-bug flag reverts to the unintended behavior present from the initial implementation up to and including v1.2.3, which had only the tangential cutoff and a bounding box intended to be larger than where the cylinder cutoff should have been.
 *
 * @param metric_out the output metric file
 * @param volume the volume to map data from
 * @param surface the surface to map the data onto
 * @param trilinear use trilinear volume interpolation
 * @param enclosing use value of the enclosing voxel
 * @param cubic use cubic splines
 * @param ribbon_constrained use ribbon constrained mapping algorithm
 * @param myelin_style use the method from myelin mapping
 * @param subvol select a single subvolume to map

the subvolume number or name
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `VolumeToSurfaceMappingOutputs`).
 */
function volume_to_surface_mapping(
    metric_out: string,
    volume: InputPathType,
    surface: InputPathType,
    trilinear: boolean = false,
    enclosing: boolean = false,
    cubic: boolean = false,
    ribbon_constrained: VolumeToSurfaceMappingRibbonConstrainedParamsDict | null = null,
    myelin_style: VolumeToSurfaceMappingMyelinStyleParamsDict | null = null,
    subvol: string | null = null,
    runner: Runner | null = null,
): VolumeToSurfaceMappingOutputs {
    const params = volume_to_surface_mapping_params(metric_out, volume, surface, trilinear, enclosing, cubic, ribbon_constrained, myelin_style, subvol)
    return volume_to_surface_mapping_execute(params, runner);
}


export {
      VOLUME_TO_SURFACE_MAPPING_METADATA,
      VolumeToSurfaceMappingBadVerticesOutOutputs,
      VolumeToSurfaceMappingBadVerticesOutParamsDict,
      VolumeToSurfaceMappingBadVerticesOutParamsDictTagged,
      VolumeToSurfaceMappingDilateMissingParamsDict,
      VolumeToSurfaceMappingDilateMissingParamsDictTagged,
      VolumeToSurfaceMappingMyelinStyleParamsDict,
      VolumeToSurfaceMappingMyelinStyleParamsDictTagged,
      VolumeToSurfaceMappingOutputWeightsOutputs,
      VolumeToSurfaceMappingOutputWeightsParamsDict,
      VolumeToSurfaceMappingOutputWeightsParamsDictTagged,
      VolumeToSurfaceMappingOutputs,
      VolumeToSurfaceMappingParamsDict,
      VolumeToSurfaceMappingParamsDictTagged,
      VolumeToSurfaceMappingRibbonConstrainedOutputs,
      VolumeToSurfaceMappingRibbonConstrainedParamsDict,
      VolumeToSurfaceMappingRibbonConstrainedParamsDictTagged,
      VolumeToSurfaceMappingVolumeRoiParamsDict,
      VolumeToSurfaceMappingVolumeRoiParamsDictTagged,
      volume_to_surface_mapping,
      volume_to_surface_mapping_bad_vertices_out,
      volume_to_surface_mapping_dilate_missing,
      volume_to_surface_mapping_execute,
      volume_to_surface_mapping_myelin_style,
      volume_to_surface_mapping_output_weights,
      volume_to_surface_mapping_params,
      volume_to_surface_mapping_ribbon_constrained,
      volume_to_surface_mapping_volume_roi,
};
