// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const CIFTI_PARCELLATE_METADATA: Metadata = {
    id: "7b2f49ca19798d787ca04a1e72ba218c146a3ab4.workbench",
    name: "cifti-parcellate",
    package: "workbench",
};


interface CiftiParcellateSpatialWeightsParamsDict {
    "@type"?: "spatial-weights";
    "left-surf"?: InputPathType | null | undefined;
    "right-surf"?: InputPathType | null | undefined;
    "cerebellum-surf"?: InputPathType | null | undefined;
    "left-metric"?: InputPathType | null | undefined;
    "right-metric"?: InputPathType | null | undefined;
    "cerebellum-metric"?: InputPathType | null | undefined;
}
type CiftiParcellateSpatialWeightsParamsDictTagged = Required<Pick<CiftiParcellateSpatialWeightsParamsDict, '@type'>> & CiftiParcellateSpatialWeightsParamsDict;


interface CiftiParcellateExcludeOutliersParamsDict {
    "@type"?: "exclude-outliers";
    "sigma-below": number;
    "sigma-above": number;
}
type CiftiParcellateExcludeOutliersParamsDictTagged = Required<Pick<CiftiParcellateExcludeOutliersParamsDict, '@type'>> & CiftiParcellateExcludeOutliersParamsDict;


interface CiftiParcellateParamsDict {
    "@type"?: "workbench/cifti-parcellate";
    "cifti-out": string;
    "spatial-weights"?: CiftiParcellateSpatialWeightsParamsDict | null | undefined;
    "weight-cifti"?: InputPathType | null | undefined;
    "method"?: string | null | undefined;
    "exclude-outliers"?: CiftiParcellateExcludeOutliersParamsDict | null | undefined;
    "only-numeric": boolean;
    "value"?: number | null | undefined;
    "mask-out"?: string | null | undefined;
    "legacy-mode": boolean;
    "include-empty": boolean;
    "cifti-in": InputPathType;
    "cifti-label": InputPathType;
    "direction": string;
}
type CiftiParcellateParamsDictTagged = Required<Pick<CiftiParcellateParamsDict, '@type'>> & CiftiParcellateParamsDict;


/**
 * Build parameters.
 *
 * @param left_surf use a surface for left vertex areas

the left surface to use, areas are in mm^2
 * @param right_surf use a surface for right vertex areas

the right surface to use, areas are in mm^2
 * @param cerebellum_surf use a surface for cerebellum vertex areas

the cerebellum surface to use, areas are in mm^2
 * @param left_metric use a metric file for left vertex weights

metric file containing left vertex weights
 * @param right_metric use a metric file for right vertex weights

metric file containing right vertex weights
 * @param cerebellum_metric use a metric file for cerebellum vertex weights

metric file containing cerebellum vertex weights
 *
 * @returns Parameter dictionary
 */
function cifti_parcellate_spatial_weights(
    left_surf: InputPathType | null = null,
    right_surf: InputPathType | null = null,
    cerebellum_surf: InputPathType | null = null,
    left_metric: InputPathType | null = null,
    right_metric: InputPathType | null = null,
    cerebellum_metric: InputPathType | null = null,
): CiftiParcellateSpatialWeightsParamsDictTagged {
    const params = {
        "@type": "spatial-weights" as const,
    };
    if (left_surf !== null) {
        params["left-surf"] = left_surf;
    }
    if (right_surf !== null) {
        params["right-surf"] = right_surf;
    }
    if (cerebellum_surf !== null) {
        params["cerebellum-surf"] = cerebellum_surf;
    }
    if (left_metric !== null) {
        params["left-metric"] = left_metric;
    }
    if (right_metric !== null) {
        params["right-metric"] = right_metric;
    }
    if (cerebellum_metric !== null) {
        params["cerebellum-metric"] = cerebellum_metric;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function cifti_parcellate_spatial_weights_cargs(
    params: CiftiParcellateSpatialWeightsParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["left-surf"] ?? null) !== null || (params["right-surf"] ?? null) !== null || (params["cerebellum-surf"] ?? null) !== null || (params["left-metric"] ?? null) !== null || (params["right-metric"] ?? null) !== null || (params["cerebellum-metric"] ?? null) !== null) {
        cargs.push(
            "-spatial-weights",
            "-left-area-surf",
            (((params["left-surf"] ?? null) !== null) ? execution.inputFile((params["left-surf"] ?? null)) : ""),
            "-right-area-surf",
            (((params["right-surf"] ?? null) !== null) ? execution.inputFile((params["right-surf"] ?? null)) : ""),
            "-cerebellum-area-surf",
            (((params["cerebellum-surf"] ?? null) !== null) ? execution.inputFile((params["cerebellum-surf"] ?? null)) : ""),
            "-left-area-metric",
            (((params["left-metric"] ?? null) !== null) ? execution.inputFile((params["left-metric"] ?? null)) : ""),
            "-right-area-metric",
            (((params["right-metric"] ?? null) !== null) ? execution.inputFile((params["right-metric"] ?? null)) : ""),
            "-cerebellum-area-metric",
            (((params["cerebellum-metric"] ?? null) !== null) ? execution.inputFile((params["cerebellum-metric"] ?? null)) : "")
        );
    }
    return cargs;
}


/**
 * Build parameters.
 *
 * @param sigma_below number of standard deviations below the mean to include
 * @param sigma_above number of standard deviations above the mean to include
 *
 * @returns Parameter dictionary
 */
function cifti_parcellate_exclude_outliers(
    sigma_below: number,
    sigma_above: number,
): CiftiParcellateExcludeOutliersParamsDictTagged {
    const params = {
        "@type": "exclude-outliers" as const,
        "sigma-below": sigma_below,
        "sigma-above": sigma_above,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function cifti_parcellate_exclude_outliers_cargs(
    params: CiftiParcellateExcludeOutliersParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-exclude-outliers",
        String((params["sigma-below"] ?? null)),
        String((params["sigma-above"] ?? null))
    );
    return cargs;
}


/**
 * Output object returned when calling `CiftiParcellateParamsDict(...)`.
 *
 * @interface
 */
interface CiftiParcellateOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * output cifti file
     */
    cifti_out: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param cifti_out output cifti file
 * @param cifti_in the cifti file to parcellate
 * @param cifti_label a cifti label file to use for the parcellation
 * @param direction which mapping to parcellate (integer, ROW, or COLUMN)
 * @param spatial_weights use voxel volume and either vertex areas or metric files as weights
 * @param weight_cifti use a cifti file containing weights

the weights to use, as a cifti file
 * @param method specify method of parcellation (default MEAN, or MODE if label data)

the method to use to assign parcel values from the values of member brainordinates
 * @param exclude_outliers exclude non-numeric values and outliers from each parcel by standard deviation
 * @param only_numeric exclude non-numeric values
 * @param value specify value to use in empty parcels (default 0)

the value to fill empty parcels with
 * @param mask_out output a matching pscalar file that has 0s in empty parcels, and 1s elsewhere

the output mask file
 * @param legacy_mode use the old behavior, parcels are defined by the intersection between labels and valid data, and empty parcels are discarded
 * @param include_empty deprecated: now the default behavior
 *
 * @returns Parameter dictionary
 */
function cifti_parcellate_params(
    cifti_out: string,
    cifti_in: InputPathType,
    cifti_label: InputPathType,
    direction: string,
    spatial_weights: CiftiParcellateSpatialWeightsParamsDict | null = null,
    weight_cifti: InputPathType | null = null,
    method: string | null = null,
    exclude_outliers: CiftiParcellateExcludeOutliersParamsDict | null = null,
    only_numeric: boolean = false,
    value: number | null = null,
    mask_out: string | null = null,
    legacy_mode: boolean = false,
    include_empty: boolean = false,
): CiftiParcellateParamsDictTagged {
    const params = {
        "@type": "workbench/cifti-parcellate" as const,
        "cifti-out": cifti_out,
        "only-numeric": only_numeric,
        "legacy-mode": legacy_mode,
        "include-empty": include_empty,
        "cifti-in": cifti_in,
        "cifti-label": cifti_label,
        "direction": direction,
    };
    if (spatial_weights !== null) {
        params["spatial-weights"] = spatial_weights;
    }
    if (weight_cifti !== null) {
        params["weight-cifti"] = weight_cifti;
    }
    if (method !== null) {
        params["method"] = method;
    }
    if (exclude_outliers !== null) {
        params["exclude-outliers"] = exclude_outliers;
    }
    if (value !== null) {
        params["value"] = value;
    }
    if (mask_out !== null) {
        params["mask-out"] = mask_out;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function cifti_parcellate_cargs(
    params: CiftiParcellateParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["spatial-weights"] ?? null) !== null || (params["weight-cifti"] ?? null) !== null || (params["method"] ?? null) !== null || (params["exclude-outliers"] ?? null) !== null || (params["only-numeric"] ?? false) || (params["value"] ?? null) !== null || (params["mask-out"] ?? null) !== null || (params["legacy-mode"] ?? false) || (params["include-empty"] ?? false)) {
        cargs.push(
            "wb_command",
            "-cifti-parcellate",
            (params["cifti-out"] ?? null),
            ...(((params["spatial-weights"] ?? null) !== null) ? cifti_parcellate_spatial_weights_cargs((params["spatial-weights"] ?? null), execution) : []),
            "-cifti-weights",
            (((params["weight-cifti"] ?? null) !== null) ? execution.inputFile((params["weight-cifti"] ?? null)) : ""),
            "-method",
            (((params["method"] ?? null) !== null) ? (params["method"] ?? null) : ""),
            ...(((params["exclude-outliers"] ?? null) !== null) ? cifti_parcellate_exclude_outliers_cargs((params["exclude-outliers"] ?? null), execution) : []),
            (((params["only-numeric"] ?? false)) ? "-only-numeric" : ""),
            "-fill-value",
            (((params["value"] ?? null) !== null) ? String((params["value"] ?? null)) : ""),
            "-nonempty-mask-out",
            (((params["mask-out"] ?? null) !== null) ? (params["mask-out"] ?? null) : ""),
            (((params["legacy-mode"] ?? false)) ? "-legacy-mode" : ""),
            (((params["include-empty"] ?? false)) ? "-include-empty" : "")
        );
    }
    cargs.push(execution.inputFile((params["cifti-in"] ?? null)));
    cargs.push(execution.inputFile((params["cifti-label"] ?? null)));
    cargs.push((params["direction"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function cifti_parcellate_outputs(
    params: CiftiParcellateParamsDict,
    execution: Execution,
): CiftiParcellateOutputs {
    const ret: CiftiParcellateOutputs = {
        root: execution.outputFile("."),
        cifti_out: execution.outputFile([(params["cifti-out"] ?? null)].join('')),
    };
    return ret;
}


/**
 * PARCELLATE A CIFTI FILE.
 *
 * Each label (other than the unlabeled key) in the cifti label file will be treated as a parcel, and all rows or columns of data within the parcel are averaged together to form the parcel's output row or column.  If -legacy-mode is specified, parcels will be defined as the overlap between a label and the data, with no errors for missing data vertices or voxels, and empty parcels discarded.  The direction can be either an integer starting from 1, or the strings 'ROW' or 'COLUMN'.  For dtseries or dscalar, use COLUMN.  If you are parcellating a dconn in both directions, parcellating by ROW first will use much less memory.
 *
 * NOTE: the parcels in the output file are sorted by the numeric label keys, in ascending order.
 *
 * The parameter to the -method option must be one of the following:
 *
 * MAX: the maximum value
 * MIN: the minimum value
 * INDEXMAX: the 1-based index of the maximum value
 * INDEXMIN: the 1-based index of the minimum value
 * SUM: add all values
 * PRODUCT: multiply all values
 * MEAN: the mean of the data
 * STDEV: the standard deviation (N denominator)
 * SAMPSTDEV: the sample standard deviation (N-1 denominator)
 * VARIANCE: the variance of the data
 * TSNR: mean divided by sample standard deviation (N-1 denominator)
 * COV: sample standard deviation (N-1 denominator) divided by mean
 * L2NORM: square root of sum of squares
 * MEDIAN: the median of the data
 * MODE: the mode of the data
 * COUNT_NONZERO: the number of nonzero elements in the data
 *
 * The -*-weights options are mutually exclusive and may only be used with MEAN (default), SUM, STDEV, SAMPSTDEV, VARIANCE, MEDIAN, or MODE (default for label data).
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `CiftiParcellateOutputs`).
 */
function cifti_parcellate_execute(
    params: CiftiParcellateParamsDict,
    runner: Runner | null = null,
): CiftiParcellateOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(CIFTI_PARCELLATE_METADATA);
    params = execution.params(params)
    const cargs = cifti_parcellate_cargs(params, execution)
    const ret = cifti_parcellate_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * PARCELLATE A CIFTI FILE.
 *
 * Each label (other than the unlabeled key) in the cifti label file will be treated as a parcel, and all rows or columns of data within the parcel are averaged together to form the parcel's output row or column.  If -legacy-mode is specified, parcels will be defined as the overlap between a label and the data, with no errors for missing data vertices or voxels, and empty parcels discarded.  The direction can be either an integer starting from 1, or the strings 'ROW' or 'COLUMN'.  For dtseries or dscalar, use COLUMN.  If you are parcellating a dconn in both directions, parcellating by ROW first will use much less memory.
 *
 * NOTE: the parcels in the output file are sorted by the numeric label keys, in ascending order.
 *
 * The parameter to the -method option must be one of the following:
 *
 * MAX: the maximum value
 * MIN: the minimum value
 * INDEXMAX: the 1-based index of the maximum value
 * INDEXMIN: the 1-based index of the minimum value
 * SUM: add all values
 * PRODUCT: multiply all values
 * MEAN: the mean of the data
 * STDEV: the standard deviation (N denominator)
 * SAMPSTDEV: the sample standard deviation (N-1 denominator)
 * VARIANCE: the variance of the data
 * TSNR: mean divided by sample standard deviation (N-1 denominator)
 * COV: sample standard deviation (N-1 denominator) divided by mean
 * L2NORM: square root of sum of squares
 * MEDIAN: the median of the data
 * MODE: the mode of the data
 * COUNT_NONZERO: the number of nonzero elements in the data
 *
 * The -*-weights options are mutually exclusive and may only be used with MEAN (default), SUM, STDEV, SAMPSTDEV, VARIANCE, MEDIAN, or MODE (default for label data).
 *
 * @param cifti_out output cifti file
 * @param cifti_in the cifti file to parcellate
 * @param cifti_label a cifti label file to use for the parcellation
 * @param direction which mapping to parcellate (integer, ROW, or COLUMN)
 * @param spatial_weights use voxel volume and either vertex areas or metric files as weights
 * @param weight_cifti use a cifti file containing weights

the weights to use, as a cifti file
 * @param method specify method of parcellation (default MEAN, or MODE if label data)

the method to use to assign parcel values from the values of member brainordinates
 * @param exclude_outliers exclude non-numeric values and outliers from each parcel by standard deviation
 * @param only_numeric exclude non-numeric values
 * @param value specify value to use in empty parcels (default 0)

the value to fill empty parcels with
 * @param mask_out output a matching pscalar file that has 0s in empty parcels, and 1s elsewhere

the output mask file
 * @param legacy_mode use the old behavior, parcels are defined by the intersection between labels and valid data, and empty parcels are discarded
 * @param include_empty deprecated: now the default behavior
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `CiftiParcellateOutputs`).
 */
function cifti_parcellate(
    cifti_out: string,
    cifti_in: InputPathType,
    cifti_label: InputPathType,
    direction: string,
    spatial_weights: CiftiParcellateSpatialWeightsParamsDict | null = null,
    weight_cifti: InputPathType | null = null,
    method: string | null = null,
    exclude_outliers: CiftiParcellateExcludeOutliersParamsDict | null = null,
    only_numeric: boolean = false,
    value: number | null = null,
    mask_out: string | null = null,
    legacy_mode: boolean = false,
    include_empty: boolean = false,
    runner: Runner | null = null,
): CiftiParcellateOutputs {
    const params = cifti_parcellate_params(cifti_out, cifti_in, cifti_label, direction, spatial_weights, weight_cifti, method, exclude_outliers, only_numeric, value, mask_out, legacy_mode, include_empty)
    return cifti_parcellate_execute(params, runner);
}


export {
      CIFTI_PARCELLATE_METADATA,
      CiftiParcellateExcludeOutliersParamsDict,
      CiftiParcellateExcludeOutliersParamsDictTagged,
      CiftiParcellateOutputs,
      CiftiParcellateParamsDict,
      CiftiParcellateParamsDictTagged,
      CiftiParcellateSpatialWeightsParamsDict,
      CiftiParcellateSpatialWeightsParamsDictTagged,
      cifti_parcellate,
      cifti_parcellate_exclude_outliers,
      cifti_parcellate_execute,
      cifti_parcellate_params,
      cifti_parcellate_spatial_weights,
};
