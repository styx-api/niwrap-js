// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const SURF_PATCH_METADATA: Metadata = {
    id: "08104785816f45db8ccb07c9651feda313b200a8.boutiques",
    name: "SurfPatch",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface SurfPatchParameters {
    "@type"?: "afni/SurfPatch";
    "spec_file": InputPathType;
    "surf_A": InputPathType;
    "surf_B": InputPathType;
    "nodefile": InputPathType;
    "inode": number;
    "ilabel": number;
    "prefix": string;
    "hits"?: number | null | undefined;
    "masklabel"?: string | null | undefined;
    "vol": boolean;
    "vol_only": boolean;
    "patch2surf": boolean;
    "coord_gain"?: number | null | undefined;
    "check_bowtie": boolean;
    "fix_bowtie": boolean;
    "ok_bowtie": boolean;
    "adjust_contour": boolean;
    "do_not_adjust_contour": boolean;
    "stitched_surface"?: InputPathType | null | undefined;
    "flip_orientation": boolean;
    "verbosity"?: number | null | undefined;
}
type SurfPatchParametersTagged = Required<Pick<SurfPatchParameters, '@type'>> & SurfPatchParameters;


/**
 * Output object returned when calling `SurfPatchParameters(...)`.
 *
 * @interface
 */
interface SurfPatchOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output patch for surface A
     */
    outpatch_a: OutputPathType;
    /**
     * Output patch for surface B
     */
    outpatch_b: OutputPathType;
    /**
     * Stitched surface file
     */
    out_stitched_surface: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param spec_file Spec file containing input surfaces
 * @param surf_a Input surface A
 * @param surf_b Input surface B
 * @param nodefile File containing nodes defining the patch
 * @param inode Index of the column containing the nodes
 * @param ilabel Index of the column containing labels of the nodes in column inode
 * @param prefix Prefix of output patch
 * @param hits Minimum number of nodes specified for a triangle to be made a part of the patch (1 <= min_hits <= 3); default is 2
 * @param masklabel Only nodes that are labeled with this label are considered for the patch
 * @param vol Calculate the volume formed by the patch on surf_A and surf_B. Requires only two surfaces specified with surf_A and surf_B.
 * @param vol_only Only calculate the volume, don't write out patches.
 * @param patch2surf Turn surface patch into a surface where only nodes used in forming the mesh are preserved.
 * @param coord_gain Multiply node coordinates by a gain. Useful for enlarging tiny patches for easier viewing in SUMA.
 * @param check_bowtie Check if the patch has a section hanging by one node to the rest of the mesh. Default when -vol or -vol_only are used.
 * @param fix_bowtie Modify patch to eliminate bowties.
 * @param ok_bowtie Do not check for, or fix bowties. Default when -vol* are not used.
 * @param adjust_contour Shrink patch contours at nodes that were not in nodefile.
 * @param do_not_adjust_contour Do not adjust contours. This is the default.
 * @param stitched_surface Write out the stitched surface used to calculate the volume.
 * @param flip_orientation Change orientation of triangles before writing surfaces.
 * @param verbosity Set verbosity level, 1 is the default.
 *
 * @returns Parameter dictionary
 */
function surf_patch_params(
    spec_file: InputPathType,
    surf_a: InputPathType,
    surf_b: InputPathType,
    nodefile: InputPathType,
    inode: number,
    ilabel: number,
    prefix: string,
    hits: number | null = null,
    masklabel: string | null = null,
    vol: boolean = false,
    vol_only: boolean = false,
    patch2surf: boolean = false,
    coord_gain: number | null = null,
    check_bowtie: boolean = false,
    fix_bowtie: boolean = false,
    ok_bowtie: boolean = false,
    adjust_contour: boolean = false,
    do_not_adjust_contour: boolean = false,
    stitched_surface: InputPathType | null = null,
    flip_orientation: boolean = false,
    verbosity: number | null = null,
): SurfPatchParametersTagged {
    const params = {
        "@type": "afni/SurfPatch" as const,
        "spec_file": spec_file,
        "surf_A": surf_a,
        "surf_B": surf_b,
        "nodefile": nodefile,
        "inode": inode,
        "ilabel": ilabel,
        "prefix": prefix,
        "vol": vol,
        "vol_only": vol_only,
        "patch2surf": patch2surf,
        "check_bowtie": check_bowtie,
        "fix_bowtie": fix_bowtie,
        "ok_bowtie": ok_bowtie,
        "adjust_contour": adjust_contour,
        "do_not_adjust_contour": do_not_adjust_contour,
        "flip_orientation": flip_orientation,
    };
    if (hits !== null) {
        params["hits"] = hits;
    }
    if (masklabel !== null) {
        params["masklabel"] = masklabel;
    }
    if (coord_gain !== null) {
        params["coord_gain"] = coord_gain;
    }
    if (stitched_surface !== null) {
        params["stitched_surface"] = stitched_surface;
    }
    if (verbosity !== null) {
        params["verbosity"] = verbosity;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function surf_patch_cargs(
    params: SurfPatchParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("SurfPatch");
    cargs.push(execution.inputFile((params["spec_file"] ?? null)));
    cargs.push(
        "-surf_A",
        execution.inputFile((params["surf_A"] ?? null))
    );
    cargs.push(
        "-surf_B",
        execution.inputFile((params["surf_B"] ?? null))
    );
    cargs.push(
        "-input",
        execution.inputFile((params["nodefile"] ?? null))
    );
    cargs.push(String((params["inode"] ?? null)));
    cargs.push(String((params["ilabel"] ?? null)));
    cargs.push(
        "-prefix",
        (params["prefix"] ?? null)
    );
    if ((params["hits"] ?? null) !== null) {
        cargs.push(
            "-hits",
            String((params["hits"] ?? null))
        );
    }
    if ((params["masklabel"] ?? null) !== null) {
        cargs.push(
            "-masklabel",
            (params["masklabel"] ?? null)
        );
    }
    if ((params["vol"] ?? false)) {
        cargs.push("-vol");
    }
    if ((params["vol_only"] ?? false)) {
        cargs.push("-vol_only");
    }
    if ((params["patch2surf"] ?? false)) {
        cargs.push("-patch2surf");
    }
    if ((params["coord_gain"] ?? null) !== null) {
        cargs.push(
            "-coord_gain",
            String((params["coord_gain"] ?? null))
        );
    }
    if ((params["check_bowtie"] ?? false)) {
        cargs.push("-check_bowtie");
    }
    if ((params["fix_bowtie"] ?? false)) {
        cargs.push("-fix_bowtie");
    }
    if ((params["ok_bowtie"] ?? false)) {
        cargs.push("-ok_bowtie");
    }
    if ((params["adjust_contour"] ?? false)) {
        cargs.push("-adjust_contour");
    }
    if ((params["do_not_adjust_contour"] ?? false)) {
        cargs.push("-do-not-adjust_contour");
    }
    if ((params["stitched_surface"] ?? null) !== null) {
        cargs.push(
            "-stitched_surface",
            execution.inputFile((params["stitched_surface"] ?? null))
        );
    }
    if ((params["flip_orientation"] ?? false)) {
        cargs.push("-flip_orientation");
    }
    if ((params["verbosity"] ?? null) !== null) {
        cargs.push(
            "-verb",
            String((params["verbosity"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function surf_patch_outputs(
    params: SurfPatchParameters,
    execution: Execution,
): SurfPatchOutputs {
    const ret: SurfPatchOutputs = {
        root: execution.outputFile("."),
        outpatch_a: execution.outputFile([(params["prefix"] ?? null), "_A"].join('')),
        outpatch_b: execution.outputFile([(params["prefix"] ?? null), "_B"].join('')),
        out_stitched_surface: execution.outputFile([(params["prefix"] ?? null), "_stitched"].join('')),
    };
    return ret;
}


/**
 * SurfPatch
 *
 * Creates a patch of surface formed by nodes in a nodefile and optionally calculates the volume between the same patch on two isotopic surfaces.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `SurfPatchOutputs`).
 */
function surf_patch_execute(
    params: SurfPatchParameters,
    runner: Runner | null = null,
): SurfPatchOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(SURF_PATCH_METADATA);
    params = execution.params(params)
    const cargs = surf_patch_cargs(params, execution)
    const ret = surf_patch_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * SurfPatch
 *
 * Creates a patch of surface formed by nodes in a nodefile and optionally calculates the volume between the same patch on two isotopic surfaces.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param spec_file Spec file containing input surfaces
 * @param surf_a Input surface A
 * @param surf_b Input surface B
 * @param nodefile File containing nodes defining the patch
 * @param inode Index of the column containing the nodes
 * @param ilabel Index of the column containing labels of the nodes in column inode
 * @param prefix Prefix of output patch
 * @param hits Minimum number of nodes specified for a triangle to be made a part of the patch (1 <= min_hits <= 3); default is 2
 * @param masklabel Only nodes that are labeled with this label are considered for the patch
 * @param vol Calculate the volume formed by the patch on surf_A and surf_B. Requires only two surfaces specified with surf_A and surf_B.
 * @param vol_only Only calculate the volume, don't write out patches.
 * @param patch2surf Turn surface patch into a surface where only nodes used in forming the mesh are preserved.
 * @param coord_gain Multiply node coordinates by a gain. Useful for enlarging tiny patches for easier viewing in SUMA.
 * @param check_bowtie Check if the patch has a section hanging by one node to the rest of the mesh. Default when -vol or -vol_only are used.
 * @param fix_bowtie Modify patch to eliminate bowties.
 * @param ok_bowtie Do not check for, or fix bowties. Default when -vol* are not used.
 * @param adjust_contour Shrink patch contours at nodes that were not in nodefile.
 * @param do_not_adjust_contour Do not adjust contours. This is the default.
 * @param stitched_surface Write out the stitched surface used to calculate the volume.
 * @param flip_orientation Change orientation of triangles before writing surfaces.
 * @param verbosity Set verbosity level, 1 is the default.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `SurfPatchOutputs`).
 */
function surf_patch(
    spec_file: InputPathType,
    surf_a: InputPathType,
    surf_b: InputPathType,
    nodefile: InputPathType,
    inode: number,
    ilabel: number,
    prefix: string,
    hits: number | null = null,
    masklabel: string | null = null,
    vol: boolean = false,
    vol_only: boolean = false,
    patch2surf: boolean = false,
    coord_gain: number | null = null,
    check_bowtie: boolean = false,
    fix_bowtie: boolean = false,
    ok_bowtie: boolean = false,
    adjust_contour: boolean = false,
    do_not_adjust_contour: boolean = false,
    stitched_surface: InputPathType | null = null,
    flip_orientation: boolean = false,
    verbosity: number | null = null,
    runner: Runner | null = null,
): SurfPatchOutputs {
    const params = surf_patch_params(spec_file, surf_a, surf_b, nodefile, inode, ilabel, prefix, hits, masklabel, vol, vol_only, patch2surf, coord_gain, check_bowtie, fix_bowtie, ok_bowtie, adjust_contour, do_not_adjust_contour, stitched_surface, flip_orientation, verbosity)
    return surf_patch_execute(params, runner);
}


export {
      SURF_PATCH_METADATA,
      SurfPatchOutputs,
      surf_patch,
      surf_patch_execute,
      surf_patch_params,
};
