// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRIS_CURVATURE_METADATA: Metadata = {
    id: "e92c22042bd610ff8fb2a3672334f4c3c5724995.boutiques",
    name: "mris_curvature",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface MrisCurvatureParameters {
    "@type"?: "freesurfer/mris_curvature";
    "save_curvature_files": boolean;
    "max_principal_curvature": boolean;
    "mgh_output_format": boolean;
    "min_principal_curvature": boolean;
    "iterative_averages"?: number | null | undefined;
    "neighborhood_size"?: number | null | undefined;
    "random_seed"?: number | null | undefined;
    "curvatures"?: string | null | undefined;
    "H_curvature"?: string | null | undefined;
    "K_curvature"?: string | null | undefined;
    "k1_curvature"?: string | null | undefined;
    "k2_curvature"?: string | null | undefined;
    "k1k2_curvature"?: string | null | undefined;
    "input_surface": InputPathType;
}
type MrisCurvatureParametersTagged = Required<Pick<MrisCurvatureParameters, '@type'>> & MrisCurvatureParameters;


/**
 * Output object returned when calling `MrisCurvatureParameters(...)`.
 *
 * @interface
 */
interface MrisCurvatureOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param input_surface Input surface file
 * @param save_curvature_files Save curvature files (will only generate screen output without this option)
 * @param max_principal_curvature Save 1st (max) principal curvature in ?h.<surface>.max file
 * @param mgh_output_format Save outputs in .mgz format
 * @param min_principal_curvature Save 2nd (min) principal curvature in ?h.<surface>.min file
 * @param iterative_averages Perform <avgs> iterative averages of curvature measure before saving
 * @param neighborhood_size Set neighborhood size to nbrs
 * @param random_seed Set random number generator to seed N
 * @param curvatures Stand-alone option to save H (mean), K (gaussian), k1, and k2 curvatures to stem.{curvname}.mgz
 * @param h_curvature Stand-alone option to save H mean curvature to stem.H.mgz
 * @param k_curvature Stand-alone option to save K gaussian curvature to stem.K.mgz
 * @param k1_curvature Stand-alone option to save k1 (primary principle) curvature to stem.k1.mgz
 * @param k2_curvature Stand-alone option to save k2 (secondary principle) curvature to stem.k2.mgz
 * @param k1k2_curvature Stand-alone option to save k1 and k2 curvature to stem.{k1,k2}.mgz
 *
 * @returns Parameter dictionary
 */
function mris_curvature_params(
    input_surface: InputPathType,
    save_curvature_files: boolean = false,
    max_principal_curvature: boolean = false,
    mgh_output_format: boolean = false,
    min_principal_curvature: boolean = false,
    iterative_averages: number | null = null,
    neighborhood_size: number | null = null,
    random_seed: number | null = null,
    curvatures: string | null = null,
    h_curvature: string | null = null,
    k_curvature: string | null = null,
    k1_curvature: string | null = null,
    k2_curvature: string | null = null,
    k1k2_curvature: string | null = null,
): MrisCurvatureParametersTagged {
    const params = {
        "@type": "freesurfer/mris_curvature" as const,
        "save_curvature_files": save_curvature_files,
        "max_principal_curvature": max_principal_curvature,
        "mgh_output_format": mgh_output_format,
        "min_principal_curvature": min_principal_curvature,
        "input_surface": input_surface,
    };
    if (iterative_averages !== null) {
        params["iterative_averages"] = iterative_averages;
    }
    if (neighborhood_size !== null) {
        params["neighborhood_size"] = neighborhood_size;
    }
    if (random_seed !== null) {
        params["random_seed"] = random_seed;
    }
    if (curvatures !== null) {
        params["curvatures"] = curvatures;
    }
    if (h_curvature !== null) {
        params["H_curvature"] = h_curvature;
    }
    if (k_curvature !== null) {
        params["K_curvature"] = k_curvature;
    }
    if (k1_curvature !== null) {
        params["k1_curvature"] = k1_curvature;
    }
    if (k2_curvature !== null) {
        params["k2_curvature"] = k2_curvature;
    }
    if (k1k2_curvature !== null) {
        params["k1k2_curvature"] = k1k2_curvature;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mris_curvature_cargs(
    params: MrisCurvatureParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mris_curvature");
    if ((params["save_curvature_files"] ?? false)) {
        cargs.push("-w");
    }
    if ((params["max_principal_curvature"] ?? false)) {
        cargs.push("-max");
    }
    if ((params["mgh_output_format"] ?? false)) {
        cargs.push("-mgh");
    }
    if ((params["min_principal_curvature"] ?? false)) {
        cargs.push("-min");
    }
    if ((params["iterative_averages"] ?? null) !== null) {
        cargs.push(
            "-a",
            String((params["iterative_averages"] ?? null))
        );
    }
    if ((params["neighborhood_size"] ?? null) !== null) {
        cargs.push(
            "-nbrs",
            String((params["neighborhood_size"] ?? null))
        );
    }
    if ((params["random_seed"] ?? null) !== null) {
        cargs.push(
            "-seed",
            String((params["random_seed"] ?? null))
        );
    }
    if ((params["curvatures"] ?? null) !== null) {
        cargs.push(
            "-curvs",
            (params["curvatures"] ?? null)
        );
    }
    if ((params["H_curvature"] ?? null) !== null) {
        cargs.push(
            "-H",
            (params["H_curvature"] ?? null)
        );
    }
    if ((params["K_curvature"] ?? null) !== null) {
        cargs.push(
            "-K",
            (params["K_curvature"] ?? null)
        );
    }
    if ((params["k1_curvature"] ?? null) !== null) {
        cargs.push(
            "-k1",
            (params["k1_curvature"] ?? null)
        );
    }
    if ((params["k2_curvature"] ?? null) !== null) {
        cargs.push(
            "-k2",
            (params["k2_curvature"] ?? null)
        );
    }
    if ((params["k1k2_curvature"] ?? null) !== null) {
        cargs.push(
            "-k1k2",
            (params["k1k2_curvature"] ?? null)
        );
    }
    cargs.push(execution.inputFile((params["input_surface"] ?? null)));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mris_curvature_outputs(
    params: MrisCurvatureParameters,
    execution: Execution,
): MrisCurvatureOutputs {
    const ret: MrisCurvatureOutputs = {
        root: execution.outputFile("."),
    };
    return ret;
}


/**
 * mris_curvature
 *
 * Compute the second fundamental form of a cortical surface to generate mean and Gaussian curvature.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrisCurvatureOutputs`).
 */
function mris_curvature_execute(
    params: MrisCurvatureParameters,
    runner: Runner | null = null,
): MrisCurvatureOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRIS_CURVATURE_METADATA);
    params = execution.params(params)
    const cargs = mris_curvature_cargs(params, execution)
    const ret = mris_curvature_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * mris_curvature
 *
 * Compute the second fundamental form of a cortical surface to generate mean and Gaussian curvature.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param input_surface Input surface file
 * @param save_curvature_files Save curvature files (will only generate screen output without this option)
 * @param max_principal_curvature Save 1st (max) principal curvature in ?h.<surface>.max file
 * @param mgh_output_format Save outputs in .mgz format
 * @param min_principal_curvature Save 2nd (min) principal curvature in ?h.<surface>.min file
 * @param iterative_averages Perform <avgs> iterative averages of curvature measure before saving
 * @param neighborhood_size Set neighborhood size to nbrs
 * @param random_seed Set random number generator to seed N
 * @param curvatures Stand-alone option to save H (mean), K (gaussian), k1, and k2 curvatures to stem.{curvname}.mgz
 * @param h_curvature Stand-alone option to save H mean curvature to stem.H.mgz
 * @param k_curvature Stand-alone option to save K gaussian curvature to stem.K.mgz
 * @param k1_curvature Stand-alone option to save k1 (primary principle) curvature to stem.k1.mgz
 * @param k2_curvature Stand-alone option to save k2 (secondary principle) curvature to stem.k2.mgz
 * @param k1k2_curvature Stand-alone option to save k1 and k2 curvature to stem.{k1,k2}.mgz
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrisCurvatureOutputs`).
 */
function mris_curvature(
    input_surface: InputPathType,
    save_curvature_files: boolean = false,
    max_principal_curvature: boolean = false,
    mgh_output_format: boolean = false,
    min_principal_curvature: boolean = false,
    iterative_averages: number | null = null,
    neighborhood_size: number | null = null,
    random_seed: number | null = null,
    curvatures: string | null = null,
    h_curvature: string | null = null,
    k_curvature: string | null = null,
    k1_curvature: string | null = null,
    k2_curvature: string | null = null,
    k1k2_curvature: string | null = null,
    runner: Runner | null = null,
): MrisCurvatureOutputs {
    const params = mris_curvature_params(input_surface, save_curvature_files, max_principal_curvature, mgh_output_format, min_principal_curvature, iterative_averages, neighborhood_size, random_seed, curvatures, h_curvature, k_curvature, k1_curvature, k2_curvature, k1k2_curvature)
    return mris_curvature_execute(params, runner);
}


export {
      MRIS_CURVATURE_METADATA,
      MrisCurvatureOutputs,
      mris_curvature,
      mris_curvature_execute,
      mris_curvature_params,
};
