// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_3D_MEAN_METADATA: Metadata = {
    id: "c3ac13b34415144da277586edf4aa7b38c139609.boutiques",
    name: "3dMean",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V3dMeanParameters {
    "@type"?: "afni/3dMean";
    "input_files": Array<InputPathType>;
    "verbose": boolean;
    "prefix"?: string | null | undefined;
    "datum"?: string | null | undefined;
    "fscale": boolean;
    "gscale": boolean;
    "nscale": boolean;
    "non_zero": boolean;
    "stdev": boolean;
    "sqr": boolean;
    "sum": boolean;
    "count": boolean;
    "max": boolean;
    "min": boolean;
    "absmax": boolean;
    "signed_absmax": boolean;
    "mask_inter": boolean;
    "mask_union": boolean;
    "weightset"?: InputPathType | null | undefined;
}
type V3dMeanParametersTagged = Required<Pick<V3dMeanParameters, '@type'>> & V3dMeanParameters;


/**
 * Output object returned when calling `V3dMeanParameters(...)`.
 *
 * @interface
 */
interface V3dMeanOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output dataset
     */
    output_file: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param input_files Input datasets
 * @param verbose Print out some information along the way
 * @param prefix Sets the prefix of the output dataset
 * @param datum Sets the datum of the output dataset
 * @param fscale Force scaling of the output to the maximum integer range
 * @param gscale Force scaling of the output to the maximum integer range, with uniform scaling factor for each sub-brick
 * @param nscale Don't do any scaling on output to byte or short datasets. Only use if you want the output dataset to be integer-valued.
 * @param non_zero Use only non-zero values for calculation of mean, min, max, sum, squares
 * @param stdev Calculate the standard deviation, sqrt(variance), instead of the mean (cannot be used with -sqr, -sum or -non_zero)
 * @param sqr Average the squares, instead of the values
 * @param sum Just take the sum (don't divide by number of datasets)
 * @param count Compute only the count of non-zero voxels
 * @param max Find the maximum at each voxel
 * @param min Find the minimum at each voxel
 * @param absmax Find maximum absolute value at each voxel
 * @param signed_absmax Find extremes with maximum absolute value but preserve sign
 * @param mask_inter Create a simple intersection mask
 * @param mask_union Create a simple union mask
 * @param weightset Sum of N dsets will be weighted by N volume WSET. This weight dataset must be of type float.
 *
 * @returns Parameter dictionary
 */
function v_3d_mean_params(
    input_files: Array<InputPathType>,
    verbose: boolean = false,
    prefix: string | null = null,
    datum: string | null = null,
    fscale: boolean = false,
    gscale: boolean = false,
    nscale: boolean = false,
    non_zero: boolean = false,
    stdev: boolean = false,
    sqr: boolean = false,
    sum: boolean = false,
    count: boolean = false,
    max: boolean = false,
    min: boolean = false,
    absmax: boolean = false,
    signed_absmax: boolean = false,
    mask_inter: boolean = false,
    mask_union: boolean = false,
    weightset: InputPathType | null = null,
): V3dMeanParametersTagged {
    const params = {
        "@type": "afni/3dMean" as const,
        "input_files": input_files,
        "verbose": verbose,
        "fscale": fscale,
        "gscale": gscale,
        "nscale": nscale,
        "non_zero": non_zero,
        "stdev": stdev,
        "sqr": sqr,
        "sum": sum,
        "count": count,
        "max": max,
        "min": min,
        "absmax": absmax,
        "signed_absmax": signed_absmax,
        "mask_inter": mask_inter,
        "mask_union": mask_union,
    };
    if (prefix !== null) {
        params["prefix"] = prefix;
    }
    if (datum !== null) {
        params["datum"] = datum;
    }
    if (weightset !== null) {
        params["weightset"] = weightset;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function v_3d_mean_cargs(
    params: V3dMeanParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("3dMean");
    cargs.push(...(params["input_files"] ?? null).map(f => execution.inputFile(f)));
    if ((params["verbose"] ?? false)) {
        cargs.push("-verbose");
    }
    if ((params["prefix"] ?? null) !== null) {
        cargs.push(
            "-prefix",
            (params["prefix"] ?? null)
        );
    }
    if ((params["datum"] ?? null) !== null) {
        cargs.push(
            "-datum",
            (params["datum"] ?? null)
        );
    }
    if ((params["fscale"] ?? false)) {
        cargs.push("-fscale");
    }
    if ((params["gscale"] ?? false)) {
        cargs.push("-gscale");
    }
    if ((params["nscale"] ?? false)) {
        cargs.push("-nscale");
    }
    if ((params["non_zero"] ?? false)) {
        cargs.push("-non_zero");
    }
    if ((params["stdev"] ?? false)) {
        cargs.push("-sd");
    }
    if ((params["sqr"] ?? false)) {
        cargs.push("-sqr");
    }
    if ((params["sum"] ?? false)) {
        cargs.push("-sum");
    }
    if ((params["count"] ?? false)) {
        cargs.push("-count");
    }
    if ((params["max"] ?? false)) {
        cargs.push("-max");
    }
    if ((params["min"] ?? false)) {
        cargs.push("-min");
    }
    if ((params["absmax"] ?? false)) {
        cargs.push("-absmax");
    }
    if ((params["signed_absmax"] ?? false)) {
        cargs.push("-signed_absmax");
    }
    if ((params["mask_inter"] ?? false)) {
        cargs.push("-mask_inter");
    }
    if ((params["mask_union"] ?? false)) {
        cargs.push("-mask_union");
    }
    if ((params["weightset"] ?? null) !== null) {
        cargs.push(
            "-weightset",
            execution.inputFile((params["weightset"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function v_3d_mean_outputs(
    params: V3dMeanParameters,
    execution: Execution,
): V3dMeanOutputs {
    const ret: V3dMeanOutputs = {
        root: execution.outputFile("."),
        output_file: ((params["prefix"] ?? null) !== null) ? execution.outputFile([(params["prefix"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * 3dMean
 *
 * Takes the voxel-by-voxel mean of all input datasets; designed to be faster than 3dcalc.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dMeanOutputs`).
 */
function v_3d_mean_execute(
    params: V3dMeanParameters,
    runner: Runner | null = null,
): V3dMeanOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_3D_MEAN_METADATA);
    params = execution.params(params)
    const cargs = v_3d_mean_cargs(params, execution)
    const ret = v_3d_mean_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * 3dMean
 *
 * Takes the voxel-by-voxel mean of all input datasets; designed to be faster than 3dcalc.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param input_files Input datasets
 * @param verbose Print out some information along the way
 * @param prefix Sets the prefix of the output dataset
 * @param datum Sets the datum of the output dataset
 * @param fscale Force scaling of the output to the maximum integer range
 * @param gscale Force scaling of the output to the maximum integer range, with uniform scaling factor for each sub-brick
 * @param nscale Don't do any scaling on output to byte or short datasets. Only use if you want the output dataset to be integer-valued.
 * @param non_zero Use only non-zero values for calculation of mean, min, max, sum, squares
 * @param stdev Calculate the standard deviation, sqrt(variance), instead of the mean (cannot be used with -sqr, -sum or -non_zero)
 * @param sqr Average the squares, instead of the values
 * @param sum Just take the sum (don't divide by number of datasets)
 * @param count Compute only the count of non-zero voxels
 * @param max Find the maximum at each voxel
 * @param min Find the minimum at each voxel
 * @param absmax Find maximum absolute value at each voxel
 * @param signed_absmax Find extremes with maximum absolute value but preserve sign
 * @param mask_inter Create a simple intersection mask
 * @param mask_union Create a simple union mask
 * @param weightset Sum of N dsets will be weighted by N volume WSET. This weight dataset must be of type float.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dMeanOutputs`).
 */
function v_3d_mean(
    input_files: Array<InputPathType>,
    verbose: boolean = false,
    prefix: string | null = null,
    datum: string | null = null,
    fscale: boolean = false,
    gscale: boolean = false,
    nscale: boolean = false,
    non_zero: boolean = false,
    stdev: boolean = false,
    sqr: boolean = false,
    sum: boolean = false,
    count: boolean = false,
    max: boolean = false,
    min: boolean = false,
    absmax: boolean = false,
    signed_absmax: boolean = false,
    mask_inter: boolean = false,
    mask_union: boolean = false,
    weightset: InputPathType | null = null,
    runner: Runner | null = null,
): V3dMeanOutputs {
    const params = v_3d_mean_params(input_files, verbose, prefix, datum, fscale, gscale, nscale, non_zero, stdev, sqr, sum, count, max, min, absmax, signed_absmax, mask_inter, mask_union, weightset)
    return v_3d_mean_execute(params, runner);
}


export {
      V3dMeanOutputs,
      V_3D_MEAN_METADATA,
      v_3d_mean,
      v_3d_mean_execute,
      v_3d_mean_params,
};
