// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const FIRST_UTILS_METADATA: Metadata = {
    id: "6dbc43105b317c1f45e4941bb84ccadbb98a7ba3.boutiques",
    name: "first_utils",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface FirstUtilsParameters {
    "@type"?: "fsl/first_utils";
    "input_file": InputPathType;
    "output_name": string;
    "norm_factors"?: InputPathType | null | undefined;
    "reference_image"?: InputPathType | null | undefined;
    "extra_path"?: InputPathType | null | undefined;
    "flirt_matrices"?: InputPathType | null | undefined;
    "use_scale": boolean;
    "dice_overlap": boolean;
    "input_mesh"?: InputPathType | null | undefined;
    "use_norm": boolean;
    "surface_out": boolean;
    "threshold"?: number | null | undefined;
    "mesh_label"?: string | null | undefined;
    "use_bvars": boolean;
    "use_recon_mni": boolean;
    "vertex_analysis": boolean;
    "use_recon_native": boolean;
    "use_rigid_align": boolean;
    "design_matrix"?: InputPathType | null | undefined;
    "recon_mesh_from_bvars": boolean;
    "read_bvars": boolean;
    "mesh_to_vol": boolean;
    "centre_origin": boolean;
    "save_vertices"?: InputPathType | null | undefined;
    "verbose": boolean;
    "use_pca_filter": boolean;
    "num_modes"?: number | null | undefined;
    "single_boundary_corr": boolean;
    "do_mvglm": boolean;
    "concat_bvars": boolean;
    "debug_mode": boolean;
    "help": boolean;
}
type FirstUtilsParametersTagged = Required<Pick<FirstUtilsParameters, '@type'>> & FirstUtilsParameters;


/**
 * Output object returned when calling `FirstUtilsParameters(...)`.
 *
 * @interface
 */
interface FirstUtilsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param input_file Filename of input image/mesh/bvars
 * @param output_name Output name
 * @param norm_factors Filename of normalization factors
 * @param reference_image Filename of reference image
 * @param extra_path Specifies extra path to image in .bvars file
 * @param flirt_matrices Text file containing filenames of flirt matrices
 * @param use_scale Do stats
 * @param dice_overlap Calculates Dice overlap
 * @param input_mesh Filename of input mesh
 * @param use_norm Normalize volumes measurements
 * @param surface_out Output vertex analysis on the surface
 * @param threshold Threshold for clean up
 * @param mesh_label Specifies the label used to fill the mesh
 * @param use_bvars Operate using the mode parameters output from FIRST
 * @param use_recon_mni Reconstruct meshes in MNI space
 * @param vertex_analysis Perform vertex-wise stats from bvars
 * @param use_recon_native Reconstruct meshes in native space
 * @param use_rigid_align Register meshes using 6 degree of freedom (7 if useScale is used)
 * @param design_matrix Filename of fsl design matrix
 * @param recon_mesh_from_bvars Convert bvars to mesh
 * @param read_bvars Read bvars from binary format
 * @param mesh_to_vol Convert mesh to an image
 * @param centre_origin Places origin of mesh at the centre of the image
 * @param save_vertices Filename for saving matrix of vertex coords: (all x, then all y, then all z) by Nsubjects
 * @param verbose Output F-stats to standard out
 * @param use_pca_filter Smooths the surface by truncating the mode parameters
 * @param num_modes Number of modes to retain per structure
 * @param single_boundary_corr Correct boundary voxels of a single structure
 * @param do_mvglm Perform multivariate general linear model analysis
 * @param concat_bvars Concat bvars from binary format
 * @param debug_mode Turn on debugging mode
 * @param help Display help message
 *
 * @returns Parameter dictionary
 */
function first_utils_params(
    input_file: InputPathType,
    output_name: string,
    norm_factors: InputPathType | null = null,
    reference_image: InputPathType | null = null,
    extra_path: InputPathType | null = null,
    flirt_matrices: InputPathType | null = null,
    use_scale: boolean = false,
    dice_overlap: boolean = false,
    input_mesh: InputPathType | null = null,
    use_norm: boolean = false,
    surface_out: boolean = false,
    threshold: number | null = null,
    mesh_label: string | null = null,
    use_bvars: boolean = false,
    use_recon_mni: boolean = false,
    vertex_analysis: boolean = false,
    use_recon_native: boolean = false,
    use_rigid_align: boolean = false,
    design_matrix: InputPathType | null = null,
    recon_mesh_from_bvars: boolean = false,
    read_bvars: boolean = false,
    mesh_to_vol: boolean = false,
    centre_origin: boolean = false,
    save_vertices: InputPathType | null = null,
    verbose: boolean = false,
    use_pca_filter: boolean = false,
    num_modes: number | null = null,
    single_boundary_corr: boolean = false,
    do_mvglm: boolean = false,
    concat_bvars: boolean = false,
    debug_mode: boolean = false,
    help: boolean = false,
): FirstUtilsParametersTagged {
    const params = {
        "@type": "fsl/first_utils" as const,
        "input_file": input_file,
        "output_name": output_name,
        "use_scale": use_scale,
        "dice_overlap": dice_overlap,
        "use_norm": use_norm,
        "surface_out": surface_out,
        "use_bvars": use_bvars,
        "use_recon_mni": use_recon_mni,
        "vertex_analysis": vertex_analysis,
        "use_recon_native": use_recon_native,
        "use_rigid_align": use_rigid_align,
        "recon_mesh_from_bvars": recon_mesh_from_bvars,
        "read_bvars": read_bvars,
        "mesh_to_vol": mesh_to_vol,
        "centre_origin": centre_origin,
        "verbose": verbose,
        "use_pca_filter": use_pca_filter,
        "single_boundary_corr": single_boundary_corr,
        "do_mvglm": do_mvglm,
        "concat_bvars": concat_bvars,
        "debug_mode": debug_mode,
        "help": help,
    };
    if (norm_factors !== null) {
        params["norm_factors"] = norm_factors;
    }
    if (reference_image !== null) {
        params["reference_image"] = reference_image;
    }
    if (extra_path !== null) {
        params["extra_path"] = extra_path;
    }
    if (flirt_matrices !== null) {
        params["flirt_matrices"] = flirt_matrices;
    }
    if (input_mesh !== null) {
        params["input_mesh"] = input_mesh;
    }
    if (threshold !== null) {
        params["threshold"] = threshold;
    }
    if (mesh_label !== null) {
        params["mesh_label"] = mesh_label;
    }
    if (design_matrix !== null) {
        params["design_matrix"] = design_matrix;
    }
    if (save_vertices !== null) {
        params["save_vertices"] = save_vertices;
    }
    if (num_modes !== null) {
        params["num_modes"] = num_modes;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function first_utils_cargs(
    params: FirstUtilsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("first_utils");
    cargs.push(
        "-i",
        execution.inputFile((params["input_file"] ?? null))
    );
    cargs.push(
        "-o",
        (params["output_name"] ?? null)
    );
    if ((params["norm_factors"] ?? null) !== null) {
        cargs.push(
            "-g",
            execution.inputFile((params["norm_factors"] ?? null))
        );
    }
    if ((params["reference_image"] ?? null) !== null) {
        cargs.push(
            "-r",
            execution.inputFile((params["reference_image"] ?? null))
        );
    }
    if ((params["extra_path"] ?? null) !== null) {
        cargs.push(
            "-a",
            execution.inputFile((params["extra_path"] ?? null))
        );
    }
    if ((params["flirt_matrices"] ?? null) !== null) {
        cargs.push(
            "-f",
            execution.inputFile((params["flirt_matrices"] ?? null))
        );
    }
    if ((params["use_scale"] ?? false)) {
        cargs.push("--useScale");
    }
    if ((params["dice_overlap"] ?? false)) {
        cargs.push("--overlap");
    }
    if ((params["input_mesh"] ?? null) !== null) {
        cargs.push(
            "-m",
            execution.inputFile((params["input_mesh"] ?? null))
        );
    }
    if ((params["use_norm"] ?? false)) {
        cargs.push("--useNorm");
    }
    if ((params["surface_out"] ?? false)) {
        cargs.push("--surfaceout");
    }
    if ((params["threshold"] ?? null) !== null) {
        cargs.push(
            "-p",
            String((params["threshold"] ?? null))
        );
    }
    if ((params["mesh_label"] ?? null) !== null) {
        cargs.push(
            "-l",
            (params["mesh_label"] ?? null)
        );
    }
    if ((params["use_bvars"] ?? false)) {
        cargs.push("--usebvars");
    }
    if ((params["use_recon_mni"] ?? false)) {
        cargs.push("--useReconMNI");
    }
    if ((params["vertex_analysis"] ?? false)) {
        cargs.push("--vertexAnalysis");
    }
    if ((params["use_recon_native"] ?? false)) {
        cargs.push("--useReconNative");
    }
    if ((params["use_rigid_align"] ?? false)) {
        cargs.push("--useRigidAlign");
    }
    if ((params["design_matrix"] ?? null) !== null) {
        cargs.push(
            "-d",
            execution.inputFile((params["design_matrix"] ?? null))
        );
    }
    if ((params["recon_mesh_from_bvars"] ?? false)) {
        cargs.push("--reconMeshFromBvars");
    }
    if ((params["read_bvars"] ?? false)) {
        cargs.push("--readBvars");
    }
    if ((params["mesh_to_vol"] ?? false)) {
        cargs.push("--meshToVol");
    }
    if ((params["centre_origin"] ?? false)) {
        cargs.push("--centreOrigin");
    }
    if ((params["save_vertices"] ?? null) !== null) {
        cargs.push(
            "--saveVertices",
            execution.inputFile((params["save_vertices"] ?? null))
        );
    }
    if ((params["verbose"] ?? false)) {
        cargs.push("-v");
    }
    if ((params["use_pca_filter"] ?? false)) {
        cargs.push("--usePCAfilter");
    }
    if ((params["num_modes"] ?? null) !== null) {
        cargs.push(
            "-n",
            String((params["num_modes"] ?? null))
        );
    }
    if ((params["single_boundary_corr"] ?? false)) {
        cargs.push("--singleBoundaryCorr");
    }
    if ((params["do_mvglm"] ?? false)) {
        cargs.push("--doMVGLM");
    }
    if ((params["concat_bvars"] ?? false)) {
        cargs.push("--concatBvars");
    }
    if ((params["debug_mode"] ?? false)) {
        cargs.push("--debug");
    }
    if ((params["help"] ?? false)) {
        cargs.push("-h");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function first_utils_outputs(
    params: FirstUtilsParameters,
    execution: Execution,
): FirstUtilsOutputs {
    const ret: FirstUtilsOutputs = {
        root: execution.outputFile("."),
    };
    return ret;
}


/**
 * first_utils
 *
 * Utilities for handling FIRST's input and output files.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FirstUtilsOutputs`).
 */
function first_utils_execute(
    params: FirstUtilsParameters,
    runner: Runner | null = null,
): FirstUtilsOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(FIRST_UTILS_METADATA);
    params = execution.params(params)
    const cargs = first_utils_cargs(params, execution)
    const ret = first_utils_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * first_utils
 *
 * Utilities for handling FIRST's input and output files.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param input_file Filename of input image/mesh/bvars
 * @param output_name Output name
 * @param norm_factors Filename of normalization factors
 * @param reference_image Filename of reference image
 * @param extra_path Specifies extra path to image in .bvars file
 * @param flirt_matrices Text file containing filenames of flirt matrices
 * @param use_scale Do stats
 * @param dice_overlap Calculates Dice overlap
 * @param input_mesh Filename of input mesh
 * @param use_norm Normalize volumes measurements
 * @param surface_out Output vertex analysis on the surface
 * @param threshold Threshold for clean up
 * @param mesh_label Specifies the label used to fill the mesh
 * @param use_bvars Operate using the mode parameters output from FIRST
 * @param use_recon_mni Reconstruct meshes in MNI space
 * @param vertex_analysis Perform vertex-wise stats from bvars
 * @param use_recon_native Reconstruct meshes in native space
 * @param use_rigid_align Register meshes using 6 degree of freedom (7 if useScale is used)
 * @param design_matrix Filename of fsl design matrix
 * @param recon_mesh_from_bvars Convert bvars to mesh
 * @param read_bvars Read bvars from binary format
 * @param mesh_to_vol Convert mesh to an image
 * @param centre_origin Places origin of mesh at the centre of the image
 * @param save_vertices Filename for saving matrix of vertex coords: (all x, then all y, then all z) by Nsubjects
 * @param verbose Output F-stats to standard out
 * @param use_pca_filter Smooths the surface by truncating the mode parameters
 * @param num_modes Number of modes to retain per structure
 * @param single_boundary_corr Correct boundary voxels of a single structure
 * @param do_mvglm Perform multivariate general linear model analysis
 * @param concat_bvars Concat bvars from binary format
 * @param debug_mode Turn on debugging mode
 * @param help Display help message
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FirstUtilsOutputs`).
 */
function first_utils(
    input_file: InputPathType,
    output_name: string,
    norm_factors: InputPathType | null = null,
    reference_image: InputPathType | null = null,
    extra_path: InputPathType | null = null,
    flirt_matrices: InputPathType | null = null,
    use_scale: boolean = false,
    dice_overlap: boolean = false,
    input_mesh: InputPathType | null = null,
    use_norm: boolean = false,
    surface_out: boolean = false,
    threshold: number | null = null,
    mesh_label: string | null = null,
    use_bvars: boolean = false,
    use_recon_mni: boolean = false,
    vertex_analysis: boolean = false,
    use_recon_native: boolean = false,
    use_rigid_align: boolean = false,
    design_matrix: InputPathType | null = null,
    recon_mesh_from_bvars: boolean = false,
    read_bvars: boolean = false,
    mesh_to_vol: boolean = false,
    centre_origin: boolean = false,
    save_vertices: InputPathType | null = null,
    verbose: boolean = false,
    use_pca_filter: boolean = false,
    num_modes: number | null = null,
    single_boundary_corr: boolean = false,
    do_mvglm: boolean = false,
    concat_bvars: boolean = false,
    debug_mode: boolean = false,
    help: boolean = false,
    runner: Runner | null = null,
): FirstUtilsOutputs {
    const params = first_utils_params(input_file, output_name, norm_factors, reference_image, extra_path, flirt_matrices, use_scale, dice_overlap, input_mesh, use_norm, surface_out, threshold, mesh_label, use_bvars, use_recon_mni, vertex_analysis, use_recon_native, use_rigid_align, design_matrix, recon_mesh_from_bvars, read_bvars, mesh_to_vol, centre_origin, save_vertices, verbose, use_pca_filter, num_modes, single_boundary_corr, do_mvglm, concat_bvars, debug_mode, help)
    return first_utils_execute(params, runner);
}


export {
      FIRST_UTILS_METADATA,
      FirstUtilsOutputs,
      first_utils,
      first_utils_execute,
      first_utils_params,
};
