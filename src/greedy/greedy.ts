// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const GREEDY_METADATA: Metadata = {
    id: "cb84db88438f1674b1e435e7a18e6b4755de1b18.boutiques",
    name: "greedy",
    package: "greedy",
    container_image_tag: "pyushkevich/itksnap:v3.8.2",
};


interface GreedyInputImagesParameters {
    "@type"?: "input_images";
    "fixed": InputPathType;
    "moving": InputPathType;
}
type GreedyInputImagesParametersTagged = Required<Pick<GreedyInputImagesParameters, '@type'>> & GreedyInputImagesParameters;


interface GreedyInvertParameters {
    "@type"?: "invert";
    "inwarp": InputPathType;
    "outwarp": string;
}
type GreedyInvertParametersTagged = Required<Pick<GreedyInvertParameters, '@type'>> & GreedyInvertParameters;


interface GreedyRootParameters {
    "@type"?: "root";
    "inwarp": InputPathType;
    "outwarp": string;
    "n": number;
}
type GreedyRootParametersTagged = Required<Pick<GreedyRootParameters, '@type'>> & GreedyRootParameters;


interface GreedyJacobianParameters {
    "@type"?: "jacobian";
    "inwarp": InputPathType;
    "outjac": string;
}
type GreedyJacobianParametersTagged = Required<Pick<GreedyJacobianParameters, '@type'>> & GreedyJacobianParameters;


interface GreedyMetricParameters {
    "@type"?: "metric";
    "metric_type": "SSD" | "MI" | "NMI" | "NCC" | "MAHAL";
    "metric_param"?: number | null | undefined;
}
type GreedyMetricParametersTagged = Required<Pick<GreedyMetricParameters, '@type'>> & GreedyMetricParameters;


interface GreedyTjrParameters {
    "@type"?: "tjr";
    "mesh": InputPathType;
    "weight": number;
}
type GreedyTjrParametersTagged = Required<Pick<GreedyTjrParameters, '@type'>> & GreedyTjrParameters;


interface GreedySearchParameters {
    "@type"?: "search";
    "n": number;
    "rot": string;
    "tran": number;
}
type GreedySearchParametersTagged = Required<Pick<GreedySearchParameters, '@type'>> & GreedySearchParameters;


interface GreedyResliceMovingImageParameters {
    "@type"?: "reslice_moving_image";
    "moving": InputPathType;
    "output": string;
}
type GreedyResliceMovingImageParametersTagged = Required<Pick<GreedyResliceMovingImageParameters, '@type'>> & GreedyResliceMovingImageParameters;


interface GreedyResliceSurfaceParameters {
    "@type"?: "reslice_surface";
    "inmesh": InputPathType;
    "outmesh": string;
}
type GreedyResliceSurfaceParametersTagged = Required<Pick<GreedyResliceSurfaceParameters, '@type'>> & GreedyResliceSurfaceParameters;


interface GreedyNnParameters {
    "@type"?: "nn";
}
type GreedyNnParametersTagged = Required<Pick<GreedyNnParameters, '@type'>> & GreedyNnParameters;


interface GreedyLinearParameters {
    "@type"?: "linear";
}
type GreedyLinearParametersTagged = Required<Pick<GreedyLinearParameters, '@type'>> & GreedyLinearParameters;


interface GreedyLabelParameters {
    "@type"?: "label";
    "sigma_spec": string;
}
type GreedyLabelParametersTagged = Required<Pick<GreedyLabelParameters, '@type'>> & GreedyLabelParameters;


interface GreedyResliceSimplexJacobianParameters {
    "@type"?: "reslice_simplex_jacobian";
    "inmesh": InputPathType;
    "outmesh": string;
}
type GreedyResliceSimplexJacobianParametersTagged = Required<Pick<GreedyResliceSimplexJacobianParameters, '@type'>> & GreedyResliceSimplexJacobianParameters;


interface GreedyParameters {
    "@type"?: "greedy/greedy";
    "dimensions": number;
    "input_images"?: GreedyInputImagesParameters | null | undefined;
    "output"?: string | null | undefined;
    "affine": boolean;
    "brute"?: string | null | undefined;
    "moments"?: 1 | 2 | null | undefined;
    "reslice"?: Array<InputPathType> | null | undefined;
    "invert"?: GreedyInvertParameters | null | undefined;
    "root"?: GreedyRootParameters | null | undefined;
    "jacobian"?: GreedyJacobianParameters | null | undefined;
    "metric_mode": boolean;
    "defopt": boolean;
    "weight"?: number | null | undefined;
    "metric"?: GreedyMetricParameters | null | undefined;
    "step_size"?: string | null | undefined;
    "iterations"?: string | null | undefined;
    "threads"?: number | null | undefined;
    "fixed_mask"?: InputPathType | null | undefined;
    "gm_trim"?: number | null | undefined;
    "moving_mask"?: InputPathType | null | undefined;
    "wncc_mask_dilate": boolean;
    "reference_image"?: InputPathType | null | undefined;
    "ref_pad"?: number | null | undefined;
    "background"?: string | null | undefined;
    "input_transform"?: InputPathType | null | undefined;
    "zero_last_dimension": boolean;
    "time_step_mode"?: "CONST" | "SCALE" | "SCALEDOWN" | null | undefined;
    "smoothing"?: string | null | undefined;
    "inverse_warp"?: InputPathType | null | undefined;
    "root_warp"?: InputPathType | null | undefined;
    "warp_precision"?: number | null | undefined;
    "noise"?: number | null | undefined;
    "exponent"?: number | null | undefined;
    "svf_mode": boolean;
    "svlb": boolean;
    "sv_incompr": boolean;
    "initial_warp"?: InputPathType | null | undefined;
    "tjr"?: GreedyTjrParameters | null | undefined;
    "wr"?: number | null | undefined;
    "initial_affine"?: InputPathType | null | undefined;
    "ia_identity": boolean;
    "ia_voxel_grid": boolean;
    "ia_image_centers": boolean;
    "ia_image_side"?: string | null | undefined;
    "ia_moments"?: 1 | 2 | null | undefined;
    "affine_dof"?: 6 | 7 | 12 | null | undefined;
    "jitter"?: number | null | undefined;
    "search"?: GreedySearchParameters | null | undefined;
    "det"?: -1 | 1 | null | undefined;
    "cov_id": boolean;
    "fixed_reslicing_image"?: InputPathType | null | undefined;
    "reslice_moving_image"?: GreedyResliceMovingImageParameters | null | undefined;
    "reslice_surface"?: GreedyResliceSurfaceParameters | null | undefined;
    "interpolation"?: GreedyNnParametersTagged | GreedyLinearParametersTagged | GreedyLabelParametersTagged | null | undefined;
    "reslice_background"?: number | null | undefined;
    "reslice_datatype"?: "auto" | "double" | "float" | "uint" | "int" | "ushort" | "short" | "uchar" | "char" | null | undefined;
    "reslice_composite"?: InputPathType | null | undefined;
    "reslice_jacobian"?: InputPathType | null | undefined;
    "reslice_simplex_jacobian"?: GreedyResliceSimplexJacobianParameters | null | undefined;
    "reslice_mask"?: InputPathType | null | undefined;
    "metric_gradient"?: InputPathType | null | undefined;
    "debug_deriv": boolean;
    "debug_deriv_eps"?: number | null | undefined;
    "debug_aff_obj": boolean;
    "dump_pyramid": boolean;
    "dump_moving": boolean;
    "dump_frequency"?: number | null | undefined;
    "dump_prefix"?: string | null | undefined;
    "powell": boolean;
    "float": boolean;
    "version": boolean;
    "verbosity"?: 0 | 1 | 2 | null | undefined;
}
type GreedyParametersTagged = Required<Pick<GreedyParameters, '@type'>> & GreedyParameters;


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function greedy_interpolation_cargs_dyn_fn(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "nn": greedy_nn_cargs,
        "linear": greedy_linear_cargs,
        "label": greedy_label_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function greedy_interpolation_outputs_dyn_fn(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @param fixed The fixed image
 * @param moving The moving image
 *
 * @returns Parameter dictionary
 */
function greedy_input_images_params(
    fixed: InputPathType,
    moving: InputPathType,
): GreedyInputImagesParametersTagged {
    const params = {
        "@type": "input_images" as const,
        "fixed": fixed,
        "moving": moving,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_input_images_cargs(
    params: GreedyInputImagesParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["fixed"] ?? null)));
    cargs.push(execution.inputFile((params["moving"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `GreedyInvertParameters | null(...)`.
 *
 * @interface
 */
interface GreedyInvertOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The inverted warp file
     */
    inverted_warp: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inwarp The input warp to be inverted
 * @param outwarp The filename for the inverted warp output
 *
 * @returns Parameter dictionary
 */
function greedy_invert_params(
    inwarp: InputPathType,
    outwarp: string,
): GreedyInvertParametersTagged {
    const params = {
        "@type": "invert" as const,
        "inwarp": inwarp,
        "outwarp": outwarp,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_invert_cargs(
    params: GreedyInvertParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inwarp"] ?? null)));
    cargs.push((params["outwarp"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_invert_outputs(
    params: GreedyInvertParameters,
    execution: Execution,
): GreedyInvertOutputs {
    const ret: GreedyInvertOutputs = {
        root: execution.outputFile("."),
        inverted_warp: execution.outputFile([(params["outwarp"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyRootParameters | null(...)`.
 *
 * @interface
 */
interface GreedyRootOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The 2^N-th root of the input warp
     */
    root_warp: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inwarp The input warp
 * @param outwarp The filename for the root warp output
 * @param n The value of N for 2^N-th root
 *
 * @returns Parameter dictionary
 */
function greedy_root_params(
    inwarp: InputPathType,
    outwarp: string,
    n: number,
): GreedyRootParametersTagged {
    const params = {
        "@type": "root" as const,
        "inwarp": inwarp,
        "outwarp": outwarp,
        "n": n,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_root_cargs(
    params: GreedyRootParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inwarp"] ?? null)));
    cargs.push((params["outwarp"] ?? null));
    cargs.push(String((params["n"] ?? null)));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_root_outputs(
    params: GreedyRootParameters,
    execution: Execution,
): GreedyRootOutputs {
    const ret: GreedyRootOutputs = {
        root: execution.outputFile("."),
        root_warp: execution.outputFile([(params["outwarp"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyJacobianParameters | null(...)`.
 *
 * @interface
 */
interface GreedyJacobianOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The Jacobian determinant of the warp
     */
    jacobian_determinant: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inwarp The input warp
 * @param outjac The filename for the Jacobian determinant output
 *
 * @returns Parameter dictionary
 */
function greedy_jacobian_params(
    inwarp: InputPathType,
    outjac: string,
): GreedyJacobianParametersTagged {
    const params = {
        "@type": "jacobian" as const,
        "inwarp": inwarp,
        "outjac": outjac,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_jacobian_cargs(
    params: GreedyJacobianParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inwarp"] ?? null)));
    cargs.push((params["outjac"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_jacobian_outputs(
    params: GreedyJacobianParameters,
    execution: Execution,
): GreedyJacobianOutputs {
    const ret: GreedyJacobianOutputs = {
        root: execution.outputFile("."),
        jacobian_determinant: execution.outputFile([(params["outjac"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @param metric_type Type of metric to use
 * @param metric_param Parameter for the metric (e.g., radius for NCC)
 *
 * @returns Parameter dictionary
 */
function greedy_metric_params(
    metric_type: "SSD" | "MI" | "NMI" | "NCC" | "MAHAL",
    metric_param: number | null = null,
): GreedyMetricParametersTagged {
    const params = {
        "@type": "metric" as const,
        "metric_type": metric_type,
    };
    if (metric_param !== null) {
        params["metric_param"] = metric_param;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_metric_cargs(
    params: GreedyMetricParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["metric_type"] ?? null));
    if ((params["metric_param"] ?? null) !== null) {
        cargs.push(String((params["metric_param"] ?? null)));
    }
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mesh The tetrahedral mesh file
 * @param weight The weight of the penalty term
 *
 * @returns Parameter dictionary
 */
function greedy_tjr_params(
    mesh: InputPathType,
    weight: number,
): GreedyTjrParametersTagged {
    const params = {
        "@type": "tjr" as const,
        "mesh": mesh,
        "weight": weight,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_tjr_cargs(
    params: GreedyTjrParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["mesh"] ?? null)));
    cargs.push(String((params["weight"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param n Number of iterations for random search
 * @param rot Standard deviation of random rotation angle (degrees) or 'any' or 'flip'
 * @param tran Standard deviation of random offset in physical units
 *
 * @returns Parameter dictionary
 */
function greedy_search_params(
    n: number,
    rot: string,
    tran: number,
): GreedySearchParametersTagged {
    const params = {
        "@type": "search" as const,
        "n": n,
        "rot": rot,
        "tran": tran,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_search_cargs(
    params: GreedySearchParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(String((params["n"] ?? null)));
    cargs.push((params["rot"] ?? null));
    cargs.push(String((params["tran"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `GreedyResliceMovingImageParameters | null(...)`.
 *
 * @interface
 */
interface GreedyResliceMovingImageOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The resliced output image
     */
    resliced_image: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param moving The moving image to be resliced
 * @param output The filename for the resliced output image
 *
 * @returns Parameter dictionary
 */
function greedy_reslice_moving_image_params(
    moving: InputPathType,
    output: string,
): GreedyResliceMovingImageParametersTagged {
    const params = {
        "@type": "reslice_moving_image" as const,
        "moving": moving,
        "output": output,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_reslice_moving_image_cargs(
    params: GreedyResliceMovingImageParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["moving"] ?? null)));
    cargs.push((params["output"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_reslice_moving_image_outputs(
    params: GreedyResliceMovingImageParameters,
    execution: Execution,
): GreedyResliceMovingImageOutputs {
    const ret: GreedyResliceMovingImageOutputs = {
        root: execution.outputFile("."),
        resliced_image: execution.outputFile([(params["output"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyResliceSurfaceParameters | null(...)`.
 *
 * @interface
 */
interface GreedyResliceSurfaceOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The warped output mesh
     */
    warped_mesh: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inmesh The input mesh file
 * @param outmesh The filename for the output warped mesh
 *
 * @returns Parameter dictionary
 */
function greedy_reslice_surface_params(
    inmesh: InputPathType,
    outmesh: string,
): GreedyResliceSurfaceParametersTagged {
    const params = {
        "@type": "reslice_surface" as const,
        "inmesh": inmesh,
        "outmesh": outmesh,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_reslice_surface_cargs(
    params: GreedyResliceSurfaceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inmesh"] ?? null)));
    cargs.push((params["outmesh"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_reslice_surface_outputs(
    params: GreedyResliceSurfaceParameters,
    execution: Execution,
): GreedyResliceSurfaceOutputs {
    const ret: GreedyResliceSurfaceOutputs = {
        root: execution.outputFile("."),
        warped_mesh: execution.outputFile([(params["outmesh"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function greedy_nn_params(
): GreedyNnParametersTagged {
    const params = {
        "@type": "nn" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_nn_cargs(
    params: GreedyNnParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("NN");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function greedy_linear_params(
): GreedyLinearParametersTagged {
    const params = {
        "@type": "linear" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_linear_cargs(
    params: GreedyLinearParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("LINEAR");
    return cargs;
}


/**
 * Build parameters.
 *
 * @param sigma_spec The <sigma_spec> parameter to the -ri LABEL command specifies the standard deviation of the Gaussian kernel used to smooth the labels. It can be provided in voxel units (e.g., 0.2vox) or millimeter units (e.g., 0.2mm). Value of 0.2vox works well in most situations
 *
 * @returns Parameter dictionary
 */
function greedy_label_params(
    sigma_spec: string,
): GreedyLabelParametersTagged {
    const params = {
        "@type": "label" as const,
        "sigma_spec": sigma_spec,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_label_cargs(
    params: GreedyLabelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("LABEL");
    cargs.push((params["sigma_spec"] ?? null));
    return cargs;
}


/**
 * Output object returned when calling `GreedyResliceSimplexJacobianParameters | null(...)`.
 *
 * @interface
 */
interface GreedyResliceSimplexJacobianOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output mesh with computed Jacobian determinants
     */
    jacobian_mesh: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inmesh The input simplex mesh file
 * @param outmesh The filename for the output mesh with Jacobian determinants
 *
 * @returns Parameter dictionary
 */
function greedy_reslice_simplex_jacobian_params(
    inmesh: InputPathType,
    outmesh: string,
): GreedyResliceSimplexJacobianParametersTagged {
    const params = {
        "@type": "reslice_simplex_jacobian" as const,
        "inmesh": inmesh,
        "outmesh": outmesh,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_reslice_simplex_jacobian_cargs(
    params: GreedyResliceSimplexJacobianParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inmesh"] ?? null)));
    cargs.push((params["outmesh"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_reslice_simplex_jacobian_outputs(
    params: GreedyResliceSimplexJacobianParameters,
    execution: Execution,
): GreedyResliceSimplexJacobianOutputs {
    const ret: GreedyResliceSimplexJacobianOutputs = {
        root: execution.outputFile("."),
        jacobian_mesh: execution.outputFile([(params["outmesh"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyParameters(...)`.
 *
 * @interface
 */
interface GreedyOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output file from affine or deformable registration
     */
    output_file: OutputPathType | null;
    /**
     * Outputs from `greedy_invert_outputs`.
     */
    invert: GreedyInvertOutputs | null;
    /**
     * Outputs from `greedy_root_outputs`.
     */
    root_: GreedyRootOutputs | null;
    /**
     * Outputs from `greedy_jacobian_outputs`.
     */
    jacobian: GreedyJacobianOutputs | null;
    /**
     * Outputs from `greedy_reslice_moving_image_outputs`.
     */
    reslice_moving_image: GreedyResliceMovingImageOutputs | null;
    /**
     * Outputs from `greedy_reslice_surface_outputs`.
     */
    reslice_surface: GreedyResliceSurfaceOutputs | null;
    /**
     * Outputs from `greedy_reslice_simplex_jacobian_outputs`.
     */
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianOutputs | null;
}


/**
 * Build parameters.
 *
 * @param dimensions Number of image dimensions
 * @param input_images Image pair (may be repeated)
 * @param output Output file (matrix in affine mode; image in deformable mode, metric computation mode; ignored in reslicing mode)
 * @param affine Perform affine registration and save to output (-o)
 * @param brute Perform a brute force search around each voxel
 * @param moments Perform moments of inertia rigid alignment of given order (1 or 2)
 * @param reslice Reslice images instead of doing registration
 * @param invert Invert previously computed warp
 * @param root Convert 2^N-th root of a warp
 * @param jacobian Compute the Jacobian determinant of the warp
 * @param metric_mode Compute metric between images
 * @param defopt Deformable optimization mode (experimental)
 * @param weight Weight of the next -i pair
 * @param metric Metric for the entire registration
 * @param step_size Step size for optimization (default = 1.0), may also be specified per level (e.g. 0.3x0.1)
 * @param iterations Number of iterations per level of multi-res
 * @param threads Number of allowed concurrent threads
 * @param fixed_mask Fixed image mask (metric gradients computed only over the mask)
 * @param gm_trim Generate the fixed image mask by trimming the extent of the fixed image by given radius
 * @param moving_mask Moving image mask (pixels outside are excluded from metric computation)
 * @param wncc_mask_dilate Specifies that fixed and moving masks should be dilated by the radius of the WNCC metric during registration
 * @param reference_image Use supplied image, rather than fixed image to define the reference space
 * @param ref_pad Define the reference space by padding the fixed image by radius
 * @param background Value to fill missing values when mapping fixed and moving images to reference space
 * @param input_transform Specify transforms (matrices, warps) that map moving image to reference space
 * @param zero_last_dimension Sets sigmas and NCC radius to zero in the last dimension for 2D/3D registration
 * @param time_step_mode Time step behavior mode
 * @param smoothing Smoothing for the greedy update step (e.g., '1.732vox 0.7071vox')
 * @param inverse_warp Compute and write the inverse of the warp field
 * @param root_warp Compute and write the (2^N-th) root of the warp field
 * @param warp_precision Saved warp precision in voxels (default=0.1; 0 for no compression)
 * @param noise Standard deviation of white noise added to moving/fixed images when using NCC metric
 * @param exponent The exponent used for warp inversion, root computation, and in stationary velocity field mode
 * @param svf_mode Perform registration using the stationary velocity model
 * @param svlb Use more accurate but expensive update of v in stationary velocity field mode
 * @param sv_incompr Incompressibility mode, implements Mansi et al. 2011 iLogDemons
 * @param initial_warp Specifies the initial warp to start iteration from
 * @param tjr Apply a regularization penalty based on the Jacobian of a tetrahedral mesh
 * @param wr Weight of SVF smoothness regularization term (default: 1000)
 * @param initial_affine Initial affine matrix for optimization
 * @param ia_identity Initialize affine matrix based on NIFTI headers
 * @param ia_voxel_grid Initialize affine matrix so that voxels with corresponding indices align
 * @param ia_image_centers Initialize affine matrix based on matching image centers
 * @param ia_image_side Initialize affine matrix based on matching center of one image side
 * @param ia_moments Initialize affine matrix based on matching moments of inertia
 * @param affine_dof Degrees of freedom for affine registration. 6=rigid, 7=similarity, 12=affine
 * @param jitter Jitter (in voxel units) applied to sample points (default: 0.5)
 * @param search Random search over rigid transforms before starting optimization
 * @param det Force the determinant of transform to be either 1 (no flip) or -1 (flip)
 * @param cov_id Assume identity covariance (match centers and do flips only, no rotation)
 * @param fixed_reslicing_image Fixed image for reslicing
 * @param reslice_moving_image Moving/output image pair for reslicing
 * @param reslice_surface Fixed/output surface pair (vertices are warped from fixed space to moving)
 * @param interpolation Interpolation for the next pair (NN, LINEAR*, LABEL sigma)
 * @param reslice_background Background (i.e. outside) intensity for the next pair (default 0)
 * @param reslice_datatype Data type for the next pair
 * @param reslice_composite Write composed transforms to outwarp
 * @param reslice_jacobian Write Jacobian determinant image to outjacobian
 * @param reslice_simplex_jacobian Compute Jacobian determinant for a simplex mesh in fixed space
 * @param reslice_mask A binary mask for the fixed image; zero values will be overwritten with background
 * @param metric_gradient Write the gradient of the metric to file
 * @param debug_deriv Enable periodic checks of derivatives (debug)
 * @param debug_deriv_eps Epsilon for derivative debugging
 * @param debug_aff_obj Plot affine objective in neighborhood of -ia matrix
 * @param dump_pyramid Dump the image pyramid at the start of the registration
 * @param dump_moving Dump moving image at each iter
 * @param dump_frequency Dump frequency
 * @param dump_prefix Prefix for dump files (may be a path)
 * @param powell Use Powell's method instead of LGBFS
 * @param float Use single precision floating point (off by default)
 * @param version Print version info
 * @param verbosity Verbosity level (0: none, 1: default, 2: verbose)
 *
 * @returns Parameter dictionary
 */
function greedy_params(
    dimensions: number,
    input_images: GreedyInputImagesParameters | null = null,
    output: string | null = null,
    affine: boolean = false,
    brute: string | null = null,
    moments: 1 | 2 | null = null,
    reslice: Array<InputPathType> | null = null,
    invert: GreedyInvertParameters | null = null,
    root: GreedyRootParameters | null = null,
    jacobian: GreedyJacobianParameters | null = null,
    metric_mode: boolean = false,
    defopt: boolean = false,
    weight: number | null = null,
    metric: GreedyMetricParameters | null = null,
    step_size: string | null = null,
    iterations: string | null = null,
    threads: number | null = null,
    fixed_mask: InputPathType | null = null,
    gm_trim: number | null = null,
    moving_mask: InputPathType | null = null,
    wncc_mask_dilate: boolean = false,
    reference_image: InputPathType | null = null,
    ref_pad: number | null = null,
    background: string | null = null,
    input_transform: InputPathType | null = null,
    zero_last_dimension: boolean = false,
    time_step_mode: "CONST" | "SCALE" | "SCALEDOWN" | null = null,
    smoothing: string | null = null,
    inverse_warp: InputPathType | null = null,
    root_warp: InputPathType | null = null,
    warp_precision: number | null = null,
    noise: number | null = null,
    exponent: number | null = null,
    svf_mode: boolean = false,
    svlb: boolean = false,
    sv_incompr: boolean = false,
    initial_warp: InputPathType | null = null,
    tjr: GreedyTjrParameters | null = null,
    wr: number | null = null,
    initial_affine: InputPathType | null = null,
    ia_identity: boolean = false,
    ia_voxel_grid: boolean = false,
    ia_image_centers: boolean = false,
    ia_image_side: string | null = null,
    ia_moments: 1 | 2 | null = null,
    affine_dof: 6 | 7 | 12 | null = null,
    jitter: number | null = null,
    search: GreedySearchParameters | null = null,
    det: -1 | 1 | null = null,
    cov_id: boolean = false,
    fixed_reslicing_image: InputPathType | null = null,
    reslice_moving_image: GreedyResliceMovingImageParameters | null = null,
    reslice_surface: GreedyResliceSurfaceParameters | null = null,
    interpolation: GreedyNnParametersTagged | GreedyLinearParametersTagged | GreedyLabelParametersTagged | null = null,
    reslice_background: number | null = null,
    reslice_datatype: "auto" | "double" | "float" | "uint" | "int" | "ushort" | "short" | "uchar" | "char" | null = null,
    reslice_composite: InputPathType | null = null,
    reslice_jacobian: InputPathType | null = null,
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianParameters | null = null,
    reslice_mask: InputPathType | null = null,
    metric_gradient: InputPathType | null = null,
    debug_deriv: boolean = false,
    debug_deriv_eps: number | null = null,
    debug_aff_obj: boolean = false,
    dump_pyramid: boolean = false,
    dump_moving: boolean = false,
    dump_frequency: number | null = null,
    dump_prefix: string | null = null,
    powell: boolean = false,
    float: boolean = false,
    version: boolean = false,
    verbosity: 0 | 1 | 2 | null = null,
): GreedyParametersTagged {
    const params = {
        "@type": "greedy/greedy" as const,
        "dimensions": dimensions,
        "affine": affine,
        "metric_mode": metric_mode,
        "defopt": defopt,
        "wncc_mask_dilate": wncc_mask_dilate,
        "zero_last_dimension": zero_last_dimension,
        "svf_mode": svf_mode,
        "svlb": svlb,
        "sv_incompr": sv_incompr,
        "ia_identity": ia_identity,
        "ia_voxel_grid": ia_voxel_grid,
        "ia_image_centers": ia_image_centers,
        "cov_id": cov_id,
        "debug_deriv": debug_deriv,
        "debug_aff_obj": debug_aff_obj,
        "dump_pyramid": dump_pyramid,
        "dump_moving": dump_moving,
        "powell": powell,
        "float": float,
        "version": version,
    };
    if (input_images !== null) {
        params["input_images"] = input_images;
    }
    if (output !== null) {
        params["output"] = output;
    }
    if (brute !== null) {
        params["brute"] = brute;
    }
    if (moments !== null) {
        params["moments"] = moments;
    }
    if (reslice !== null) {
        params["reslice"] = reslice;
    }
    if (invert !== null) {
        params["invert"] = invert;
    }
    if (root !== null) {
        params["root"] = root;
    }
    if (jacobian !== null) {
        params["jacobian"] = jacobian;
    }
    if (weight !== null) {
        params["weight"] = weight;
    }
    if (metric !== null) {
        params["metric"] = metric;
    }
    if (step_size !== null) {
        params["step_size"] = step_size;
    }
    if (iterations !== null) {
        params["iterations"] = iterations;
    }
    if (threads !== null) {
        params["threads"] = threads;
    }
    if (fixed_mask !== null) {
        params["fixed_mask"] = fixed_mask;
    }
    if (gm_trim !== null) {
        params["gm_trim"] = gm_trim;
    }
    if (moving_mask !== null) {
        params["moving_mask"] = moving_mask;
    }
    if (reference_image !== null) {
        params["reference_image"] = reference_image;
    }
    if (ref_pad !== null) {
        params["ref_pad"] = ref_pad;
    }
    if (background !== null) {
        params["background"] = background;
    }
    if (input_transform !== null) {
        params["input_transform"] = input_transform;
    }
    if (time_step_mode !== null) {
        params["time_step_mode"] = time_step_mode;
    }
    if (smoothing !== null) {
        params["smoothing"] = smoothing;
    }
    if (inverse_warp !== null) {
        params["inverse_warp"] = inverse_warp;
    }
    if (root_warp !== null) {
        params["root_warp"] = root_warp;
    }
    if (warp_precision !== null) {
        params["warp_precision"] = warp_precision;
    }
    if (noise !== null) {
        params["noise"] = noise;
    }
    if (exponent !== null) {
        params["exponent"] = exponent;
    }
    if (initial_warp !== null) {
        params["initial_warp"] = initial_warp;
    }
    if (tjr !== null) {
        params["tjr"] = tjr;
    }
    if (wr !== null) {
        params["wr"] = wr;
    }
    if (initial_affine !== null) {
        params["initial_affine"] = initial_affine;
    }
    if (ia_image_side !== null) {
        params["ia_image_side"] = ia_image_side;
    }
    if (ia_moments !== null) {
        params["ia_moments"] = ia_moments;
    }
    if (affine_dof !== null) {
        params["affine_dof"] = affine_dof;
    }
    if (jitter !== null) {
        params["jitter"] = jitter;
    }
    if (search !== null) {
        params["search"] = search;
    }
    if (det !== null) {
        params["det"] = det;
    }
    if (fixed_reslicing_image !== null) {
        params["fixed_reslicing_image"] = fixed_reslicing_image;
    }
    if (reslice_moving_image !== null) {
        params["reslice_moving_image"] = reslice_moving_image;
    }
    if (reslice_surface !== null) {
        params["reslice_surface"] = reslice_surface;
    }
    if (interpolation !== null) {
        params["interpolation"] = interpolation;
    }
    if (reslice_background !== null) {
        params["reslice_background"] = reslice_background;
    }
    if (reslice_datatype !== null) {
        params["reslice_datatype"] = reslice_datatype;
    }
    if (reslice_composite !== null) {
        params["reslice_composite"] = reslice_composite;
    }
    if (reslice_jacobian !== null) {
        params["reslice_jacobian"] = reslice_jacobian;
    }
    if (reslice_simplex_jacobian !== null) {
        params["reslice_simplex_jacobian"] = reslice_simplex_jacobian;
    }
    if (reslice_mask !== null) {
        params["reslice_mask"] = reslice_mask;
    }
    if (metric_gradient !== null) {
        params["metric_gradient"] = metric_gradient;
    }
    if (debug_deriv_eps !== null) {
        params["debug_deriv_eps"] = debug_deriv_eps;
    }
    if (dump_frequency !== null) {
        params["dump_frequency"] = dump_frequency;
    }
    if (dump_prefix !== null) {
        params["dump_prefix"] = dump_prefix;
    }
    if (verbosity !== null) {
        params["verbosity"] = verbosity;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_cargs(
    params: GreedyParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("greedy");
    cargs.push(
        "-d",
        String((params["dimensions"] ?? null))
    );
    if ((params["input_images"] ?? null) !== null) {
        cargs.push(
            "-i",
            ...greedy_input_images_cargs((params["input_images"] ?? null), execution)
        );
    }
    if ((params["output"] ?? null) !== null) {
        cargs.push(
            "-o",
            (params["output"] ?? null)
        );
    }
    if ((params["affine"] ?? false)) {
        cargs.push("-a");
    }
    if ((params["brute"] ?? null) !== null) {
        cargs.push(
            "-brute",
            (params["brute"] ?? null)
        );
    }
    if ((params["moments"] ?? null) !== null) {
        cargs.push(
            "-moments",
            String((params["moments"] ?? null))
        );
    }
    if ((params["reslice"] ?? null) !== null) {
        cargs.push(
            "-r",
            ...(params["reslice"] ?? null).map(f => execution.inputFile(f))
        );
    }
    if ((params["invert"] ?? null) !== null) {
        cargs.push(
            "-iw",
            ...greedy_invert_cargs((params["invert"] ?? null), execution)
        );
    }
    if ((params["root"] ?? null) !== null) {
        cargs.push(
            "-root",
            ...greedy_root_cargs((params["root"] ?? null), execution)
        );
    }
    if ((params["jacobian"] ?? null) !== null) {
        cargs.push(
            "-jac",
            ...greedy_jacobian_cargs((params["jacobian"] ?? null), execution)
        );
    }
    if ((params["metric_mode"] ?? false)) {
        cargs.push("-metric");
    }
    if ((params["defopt"] ?? false)) {
        cargs.push("-defopt");
    }
    if ((params["weight"] ?? null) !== null) {
        cargs.push(
            "-w",
            String((params["weight"] ?? null))
        );
    }
    if ((params["metric"] ?? null) !== null) {
        cargs.push(
            "-m",
            ...greedy_metric_cargs((params["metric"] ?? null), execution)
        );
    }
    if ((params["step_size"] ?? null) !== null) {
        cargs.push(
            "-e",
            (params["step_size"] ?? null)
        );
    }
    if ((params["iterations"] ?? null) !== null) {
        cargs.push(
            "-n",
            (params["iterations"] ?? null)
        );
    }
    if ((params["threads"] ?? null) !== null) {
        cargs.push(
            "-threads",
            String((params["threads"] ?? null))
        );
    }
    if ((params["fixed_mask"] ?? null) !== null) {
        cargs.push(
            "-gm",
            execution.inputFile((params["fixed_mask"] ?? null))
        );
    }
    if ((params["gm_trim"] ?? null) !== null) {
        cargs.push(
            "-gm-trim",
            String((params["gm_trim"] ?? null))
        );
    }
    if ((params["moving_mask"] ?? null) !== null) {
        cargs.push(
            "-mm",
            execution.inputFile((params["moving_mask"] ?? null))
        );
    }
    if ((params["wncc_mask_dilate"] ?? false)) {
        cargs.push("-wncc-mask-dilate");
    }
    if ((params["reference_image"] ?? null) !== null) {
        cargs.push(
            "-ref",
            execution.inputFile((params["reference_image"] ?? null))
        );
    }
    if ((params["ref_pad"] ?? null) !== null) {
        cargs.push(
            "-ref-pad",
            String((params["ref_pad"] ?? null))
        );
    }
    if ((params["background"] ?? null) !== null) {
        cargs.push(
            "-bg",
            (params["background"] ?? null)
        );
    }
    if ((params["input_transform"] ?? null) !== null) {
        cargs.push(
            "-it",
            execution.inputFile((params["input_transform"] ?? null))
        );
    }
    if ((params["zero_last_dimension"] ?? false)) {
        cargs.push("-z");
    }
    if ((params["time_step_mode"] ?? null) !== null) {
        cargs.push(
            "-tscale",
            (params["time_step_mode"] ?? null)
        );
    }
    if ((params["smoothing"] ?? null) !== null) {
        cargs.push(
            "-s",
            (params["smoothing"] ?? null)
        );
    }
    if ((params["inverse_warp"] ?? null) !== null) {
        cargs.push(
            "-oinv",
            execution.inputFile((params["inverse_warp"] ?? null))
        );
    }
    if ((params["root_warp"] ?? null) !== null) {
        cargs.push(
            "-oroot",
            execution.inputFile((params["root_warp"] ?? null))
        );
    }
    if ((params["warp_precision"] ?? null) !== null) {
        cargs.push(
            "-wp",
            String((params["warp_precision"] ?? null))
        );
    }
    if ((params["noise"] ?? null) !== null) {
        cargs.push(
            "-noise",
            String((params["noise"] ?? null))
        );
    }
    if ((params["exponent"] ?? null) !== null) {
        cargs.push(
            "-exp",
            String((params["exponent"] ?? null))
        );
    }
    if ((params["svf_mode"] ?? false)) {
        cargs.push("-sv");
    }
    if ((params["svlb"] ?? false)) {
        cargs.push("-svlb");
    }
    if ((params["sv_incompr"] ?? false)) {
        cargs.push("-sv-incompr");
    }
    if ((params["initial_warp"] ?? null) !== null) {
        cargs.push(
            "-id",
            execution.inputFile((params["initial_warp"] ?? null))
        );
    }
    if ((params["tjr"] ?? null) !== null) {
        cargs.push(
            "-tjr",
            ...greedy_tjr_cargs((params["tjr"] ?? null), execution)
        );
    }
    if ((params["wr"] ?? null) !== null) {
        cargs.push(
            "-wr",
            String((params["wr"] ?? null))
        );
    }
    if ((params["initial_affine"] ?? null) !== null) {
        cargs.push(
            "-ia",
            execution.inputFile((params["initial_affine"] ?? null))
        );
    }
    if ((params["ia_identity"] ?? false)) {
        cargs.push("-ia-identity");
    }
    if ((params["ia_voxel_grid"] ?? false)) {
        cargs.push("-ia-voxel-grid");
    }
    if ((params["ia_image_centers"] ?? false)) {
        cargs.push("-ia-image-centers");
    }
    if ((params["ia_image_side"] ?? null) !== null) {
        cargs.push(
            "-ia-image-side",
            (params["ia_image_side"] ?? null)
        );
    }
    if ((params["ia_moments"] ?? null) !== null) {
        cargs.push(
            "-ia-moments",
            String((params["ia_moments"] ?? null))
        );
    }
    if ((params["affine_dof"] ?? null) !== null) {
        cargs.push(
            "-dof",
            String((params["affine_dof"] ?? null))
        );
    }
    if ((params["jitter"] ?? null) !== null) {
        cargs.push(
            "-jitter",
            String((params["jitter"] ?? null))
        );
    }
    if ((params["search"] ?? null) !== null) {
        cargs.push(
            "-search",
            ...greedy_search_cargs((params["search"] ?? null), execution)
        );
    }
    if ((params["det"] ?? null) !== null) {
        cargs.push(
            "-det",
            String((params["det"] ?? null))
        );
    }
    if ((params["cov_id"] ?? false)) {
        cargs.push("-cov-id");
    }
    if ((params["fixed_reslicing_image"] ?? null) !== null) {
        cargs.push(
            "-rf",
            execution.inputFile((params["fixed_reslicing_image"] ?? null))
        );
    }
    if ((params["reslice_moving_image"] ?? null) !== null) {
        cargs.push(
            "-rm",
            ...greedy_reslice_moving_image_cargs((params["reslice_moving_image"] ?? null), execution)
        );
    }
    if ((params["reslice_surface"] ?? null) !== null) {
        cargs.push(
            "-rs",
            ...greedy_reslice_surface_cargs((params["reslice_surface"] ?? null), execution)
        );
    }
    if ((params["interpolation"] ?? null) !== null) {
        cargs.push(
            "-ri",
            ...greedy_interpolation_cargs_dyn_fn((params["interpolation"] ?? null)["@type"])((params["interpolation"] ?? null), execution)
        );
    }
    if ((params["reslice_background"] ?? null) !== null) {
        cargs.push(
            "-rb",
            String((params["reslice_background"] ?? null))
        );
    }
    if ((params["reslice_datatype"] ?? null) !== null) {
        cargs.push(
            "-rt",
            (params["reslice_datatype"] ?? null)
        );
    }
    if ((params["reslice_composite"] ?? null) !== null) {
        cargs.push(
            "-rc",
            execution.inputFile((params["reslice_composite"] ?? null))
        );
    }
    if ((params["reslice_jacobian"] ?? null) !== null) {
        cargs.push(
            "-rj",
            execution.inputFile((params["reslice_jacobian"] ?? null))
        );
    }
    if ((params["reslice_simplex_jacobian"] ?? null) !== null) {
        cargs.push(
            "-rsj",
            ...greedy_reslice_simplex_jacobian_cargs((params["reslice_simplex_jacobian"] ?? null), execution)
        );
    }
    if ((params["reslice_mask"] ?? null) !== null) {
        cargs.push(
            "-rk",
            execution.inputFile((params["reslice_mask"] ?? null))
        );
    }
    if ((params["metric_gradient"] ?? null) !== null) {
        cargs.push(
            "-og",
            execution.inputFile((params["metric_gradient"] ?? null))
        );
    }
    if ((params["debug_deriv"] ?? false)) {
        cargs.push("-debug-deriv");
    }
    if ((params["debug_deriv_eps"] ?? null) !== null) {
        cargs.push(
            "-debug-deriv-eps",
            String((params["debug_deriv_eps"] ?? null))
        );
    }
    if ((params["debug_aff_obj"] ?? false)) {
        cargs.push("-debug-aff-obj");
    }
    if ((params["dump_pyramid"] ?? false)) {
        cargs.push("-dump-pyramid");
    }
    if ((params["dump_moving"] ?? false)) {
        cargs.push("-dump-moving");
    }
    if ((params["dump_frequency"] ?? null) !== null) {
        cargs.push(
            "-dump-freq",
            String((params["dump_frequency"] ?? null))
        );
    }
    if ((params["dump_prefix"] ?? null) !== null) {
        cargs.push(
            "-dump-prefix",
            (params["dump_prefix"] ?? null)
        );
    }
    if ((params["powell"] ?? false)) {
        cargs.push("-powell");
    }
    if ((params["float"] ?? false)) {
        cargs.push("-float");
    }
    if ((params["version"] ?? false)) {
        cargs.push("-version");
    }
    if ((params["verbosity"] ?? null) !== null) {
        cargs.push(
            "-V",
            String((params["verbosity"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_outputs(
    params: GreedyParameters,
    execution: Execution,
): GreedyOutputs {
    const ret: GreedyOutputs = {
        root: execution.outputFile("."),
        output_file: ((params["output"] ?? null) !== null) ? execution.outputFile([(params["output"] ?? null)].join('')) : null,
        invert: (params["invert"] ?? null) ? (greedy_invert_outputs((params["invert"] ?? null), execution) ?? null) : null,
        root_: (params["root"] ?? null) ? (greedy_root_outputs((params["root"] ?? null), execution) ?? null) : null,
        jacobian: (params["jacobian"] ?? null) ? (greedy_jacobian_outputs((params["jacobian"] ?? null), execution) ?? null) : null,
        reslice_moving_image: (params["reslice_moving_image"] ?? null) ? (greedy_reslice_moving_image_outputs((params["reslice_moving_image"] ?? null), execution) ?? null) : null,
        reslice_surface: (params["reslice_surface"] ?? null) ? (greedy_reslice_surface_outputs((params["reslice_surface"] ?? null), execution) ?? null) : null,
        reslice_simplex_jacobian: (params["reslice_simplex_jacobian"] ?? null) ? (greedy_reslice_simplex_jacobian_outputs((params["reslice_simplex_jacobian"] ?? null), execution) ?? null) : null,
    };
    return ret;
}


/**
 * greedy
 *
 * Paul's greedy diffeomorphic registration implementation.
 *
 * Author: Greedy Developers
 *
 * URL: https://sites.google.com/view/greedyreg/about
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `GreedyOutputs`).
 */
function greedy_execute(
    params: GreedyParameters,
    runner: Runner | null = null,
): GreedyOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(GREEDY_METADATA);
    params = execution.params(params)
    const cargs = greedy_cargs(params, execution)
    const ret = greedy_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * greedy
 *
 * Paul's greedy diffeomorphic registration implementation.
 *
 * Author: Greedy Developers
 *
 * URL: https://sites.google.com/view/greedyreg/about
 *
 * @param dimensions Number of image dimensions
 * @param input_images Image pair (may be repeated)
 * @param output Output file (matrix in affine mode; image in deformable mode, metric computation mode; ignored in reslicing mode)
 * @param affine Perform affine registration and save to output (-o)
 * @param brute Perform a brute force search around each voxel
 * @param moments Perform moments of inertia rigid alignment of given order (1 or 2)
 * @param reslice Reslice images instead of doing registration
 * @param invert Invert previously computed warp
 * @param root Convert 2^N-th root of a warp
 * @param jacobian Compute the Jacobian determinant of the warp
 * @param metric_mode Compute metric between images
 * @param defopt Deformable optimization mode (experimental)
 * @param weight Weight of the next -i pair
 * @param metric Metric for the entire registration
 * @param step_size Step size for optimization (default = 1.0), may also be specified per level (e.g. 0.3x0.1)
 * @param iterations Number of iterations per level of multi-res
 * @param threads Number of allowed concurrent threads
 * @param fixed_mask Fixed image mask (metric gradients computed only over the mask)
 * @param gm_trim Generate the fixed image mask by trimming the extent of the fixed image by given radius
 * @param moving_mask Moving image mask (pixels outside are excluded from metric computation)
 * @param wncc_mask_dilate Specifies that fixed and moving masks should be dilated by the radius of the WNCC metric during registration
 * @param reference_image Use supplied image, rather than fixed image to define the reference space
 * @param ref_pad Define the reference space by padding the fixed image by radius
 * @param background Value to fill missing values when mapping fixed and moving images to reference space
 * @param input_transform Specify transforms (matrices, warps) that map moving image to reference space
 * @param zero_last_dimension Sets sigmas and NCC radius to zero in the last dimension for 2D/3D registration
 * @param time_step_mode Time step behavior mode
 * @param smoothing Smoothing for the greedy update step (e.g., '1.732vox 0.7071vox')
 * @param inverse_warp Compute and write the inverse of the warp field
 * @param root_warp Compute and write the (2^N-th) root of the warp field
 * @param warp_precision Saved warp precision in voxels (default=0.1; 0 for no compression)
 * @param noise Standard deviation of white noise added to moving/fixed images when using NCC metric
 * @param exponent The exponent used for warp inversion, root computation, and in stationary velocity field mode
 * @param svf_mode Perform registration using the stationary velocity model
 * @param svlb Use more accurate but expensive update of v in stationary velocity field mode
 * @param sv_incompr Incompressibility mode, implements Mansi et al. 2011 iLogDemons
 * @param initial_warp Specifies the initial warp to start iteration from
 * @param tjr Apply a regularization penalty based on the Jacobian of a tetrahedral mesh
 * @param wr Weight of SVF smoothness regularization term (default: 1000)
 * @param initial_affine Initial affine matrix for optimization
 * @param ia_identity Initialize affine matrix based on NIFTI headers
 * @param ia_voxel_grid Initialize affine matrix so that voxels with corresponding indices align
 * @param ia_image_centers Initialize affine matrix based on matching image centers
 * @param ia_image_side Initialize affine matrix based on matching center of one image side
 * @param ia_moments Initialize affine matrix based on matching moments of inertia
 * @param affine_dof Degrees of freedom for affine registration. 6=rigid, 7=similarity, 12=affine
 * @param jitter Jitter (in voxel units) applied to sample points (default: 0.5)
 * @param search Random search over rigid transforms before starting optimization
 * @param det Force the determinant of transform to be either 1 (no flip) or -1 (flip)
 * @param cov_id Assume identity covariance (match centers and do flips only, no rotation)
 * @param fixed_reslicing_image Fixed image for reslicing
 * @param reslice_moving_image Moving/output image pair for reslicing
 * @param reslice_surface Fixed/output surface pair (vertices are warped from fixed space to moving)
 * @param interpolation Interpolation for the next pair (NN, LINEAR*, LABEL sigma)
 * @param reslice_background Background (i.e. outside) intensity for the next pair (default 0)
 * @param reslice_datatype Data type for the next pair
 * @param reslice_composite Write composed transforms to outwarp
 * @param reslice_jacobian Write Jacobian determinant image to outjacobian
 * @param reslice_simplex_jacobian Compute Jacobian determinant for a simplex mesh in fixed space
 * @param reslice_mask A binary mask for the fixed image; zero values will be overwritten with background
 * @param metric_gradient Write the gradient of the metric to file
 * @param debug_deriv Enable periodic checks of derivatives (debug)
 * @param debug_deriv_eps Epsilon for derivative debugging
 * @param debug_aff_obj Plot affine objective in neighborhood of -ia matrix
 * @param dump_pyramid Dump the image pyramid at the start of the registration
 * @param dump_moving Dump moving image at each iter
 * @param dump_frequency Dump frequency
 * @param dump_prefix Prefix for dump files (may be a path)
 * @param powell Use Powell's method instead of LGBFS
 * @param float Use single precision floating point (off by default)
 * @param version Print version info
 * @param verbosity Verbosity level (0: none, 1: default, 2: verbose)
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `GreedyOutputs`).
 */
function greedy_(
    dimensions: number,
    input_images: GreedyInputImagesParameters | null = null,
    output: string | null = null,
    affine: boolean = false,
    brute: string | null = null,
    moments: 1 | 2 | null = null,
    reslice: Array<InputPathType> | null = null,
    invert: GreedyInvertParameters | null = null,
    root: GreedyRootParameters | null = null,
    jacobian: GreedyJacobianParameters | null = null,
    metric_mode: boolean = false,
    defopt: boolean = false,
    weight: number | null = null,
    metric: GreedyMetricParameters | null = null,
    step_size: string | null = null,
    iterations: string | null = null,
    threads: number | null = null,
    fixed_mask: InputPathType | null = null,
    gm_trim: number | null = null,
    moving_mask: InputPathType | null = null,
    wncc_mask_dilate: boolean = false,
    reference_image: InputPathType | null = null,
    ref_pad: number | null = null,
    background: string | null = null,
    input_transform: InputPathType | null = null,
    zero_last_dimension: boolean = false,
    time_step_mode: "CONST" | "SCALE" | "SCALEDOWN" | null = null,
    smoothing: string | null = null,
    inverse_warp: InputPathType | null = null,
    root_warp: InputPathType | null = null,
    warp_precision: number | null = null,
    noise: number | null = null,
    exponent: number | null = null,
    svf_mode: boolean = false,
    svlb: boolean = false,
    sv_incompr: boolean = false,
    initial_warp: InputPathType | null = null,
    tjr: GreedyTjrParameters | null = null,
    wr: number | null = null,
    initial_affine: InputPathType | null = null,
    ia_identity: boolean = false,
    ia_voxel_grid: boolean = false,
    ia_image_centers: boolean = false,
    ia_image_side: string | null = null,
    ia_moments: 1 | 2 | null = null,
    affine_dof: 6 | 7 | 12 | null = null,
    jitter: number | null = null,
    search: GreedySearchParameters | null = null,
    det: -1 | 1 | null = null,
    cov_id: boolean = false,
    fixed_reslicing_image: InputPathType | null = null,
    reslice_moving_image: GreedyResliceMovingImageParameters | null = null,
    reslice_surface: GreedyResliceSurfaceParameters | null = null,
    interpolation: GreedyNnParametersTagged | GreedyLinearParametersTagged | GreedyLabelParametersTagged | null = null,
    reslice_background: number | null = null,
    reslice_datatype: "auto" | "double" | "float" | "uint" | "int" | "ushort" | "short" | "uchar" | "char" | null = null,
    reslice_composite: InputPathType | null = null,
    reslice_jacobian: InputPathType | null = null,
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianParameters | null = null,
    reslice_mask: InputPathType | null = null,
    metric_gradient: InputPathType | null = null,
    debug_deriv: boolean = false,
    debug_deriv_eps: number | null = null,
    debug_aff_obj: boolean = false,
    dump_pyramid: boolean = false,
    dump_moving: boolean = false,
    dump_frequency: number | null = null,
    dump_prefix: string | null = null,
    powell: boolean = false,
    float: boolean = false,
    version: boolean = false,
    verbosity: 0 | 1 | 2 | null = null,
    runner: Runner | null = null,
): GreedyOutputs {
    const params = greedy_params(dimensions, input_images, output, affine, brute, moments, reslice, invert, root, jacobian, metric_mode, defopt, weight, metric, step_size, iterations, threads, fixed_mask, gm_trim, moving_mask, wncc_mask_dilate, reference_image, ref_pad, background, input_transform, zero_last_dimension, time_step_mode, smoothing, inverse_warp, root_warp, warp_precision, noise, exponent, svf_mode, svlb, sv_incompr, initial_warp, tjr, wr, initial_affine, ia_identity, ia_voxel_grid, ia_image_centers, ia_image_side, ia_moments, affine_dof, jitter, search, det, cov_id, fixed_reslicing_image, reslice_moving_image, reslice_surface, interpolation, reslice_background, reslice_datatype, reslice_composite, reslice_jacobian, reslice_simplex_jacobian, reslice_mask, metric_gradient, debug_deriv, debug_deriv_eps, debug_aff_obj, dump_pyramid, dump_moving, dump_frequency, dump_prefix, powell, float, version, verbosity)
    return greedy_execute(params, runner);
}


export {
      GREEDY_METADATA,
      GreedyInvertOutputs,
      GreedyJacobianOutputs,
      GreedyOutputs,
      GreedyResliceMovingImageOutputs,
      GreedyResliceSimplexJacobianOutputs,
      GreedyResliceSurfaceOutputs,
      GreedyRootOutputs,
      greedy_,
      greedy_execute,
      greedy_input_images_params,
      greedy_invert_params,
      greedy_jacobian_params,
      greedy_label_params,
      greedy_linear_params,
      greedy_metric_params,
      greedy_nn_params,
      greedy_params,
      greedy_reslice_moving_image_params,
      greedy_reslice_simplex_jacobian_params,
      greedy_reslice_surface_params,
      greedy_root_params,
      greedy_search_params,
      greedy_tjr_params,
};
