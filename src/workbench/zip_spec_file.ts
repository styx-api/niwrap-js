// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ZIP_SPEC_FILE_METADATA: Metadata = {
    id: "06edf7f38703ef83935a1b2ad9fc02acb523add6.workbench",
    name: "zip-spec-file",
    package: "workbench",
    container_image_tag: "nx10x/workbench:2.1.0",
};


interface ZipSpecFileParamsDict {
    "@type"?: "workbench/zip-spec-file";
    "directory"?: string | null | undefined;
    "skip-missing": boolean;
    "spec-file": string;
    "extract-folder": string;
    "zip-file": string;
}
type ZipSpecFileParamsDictTagged = Required<Pick<ZipSpecFileParamsDict, '@type'>> & ZipSpecFileParamsDict;


/**
 * Output object returned when calling `ZipSpecFileParamsDict(...)`.
 *
 * @interface
 */
interface ZipSpecFileOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param spec_file the specification file to add to zip file
 * @param extract_folder the name of the folder created when the zip file is unzipped
 * @param zip_file out - the zip file that will be created
 * @param directory specify a directory that all data files are somewhere within, this will become the root of the zipfile's directory structure

the directory
 * @param skip_missing any missing files will generate only warnings, and the zip file will be created anyway
 *
 * @returns Parameter dictionary
 */
function zip_spec_file_params(
    spec_file: string,
    extract_folder: string,
    zip_file: string,
    directory: string | null = null,
    skip_missing: boolean = false,
): ZipSpecFileParamsDictTagged {
    const params = {
        "@type": "workbench/zip-spec-file" as const,
        "skip-missing": skip_missing,
        "spec-file": spec_file,
        "extract-folder": extract_folder,
        "zip-file": zip_file,
    };
    if (directory !== null) {
        params["directory"] = directory;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function zip_spec_file_cargs(
    params: ZipSpecFileParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["directory"] ?? null) !== null || (params["skip-missing"] ?? false)) {
        cargs.push(
            "wb_command",
            "-zip-spec-file",
            "-base-dir",
            (((params["directory"] ?? null) !== null) ? (params["directory"] ?? null) : ""),
            (((params["skip-missing"] ?? false)) ? "-skip-missing" : "")
        );
    }
    cargs.push((params["spec-file"] ?? null));
    cargs.push((params["extract-folder"] ?? null));
    cargs.push((params["zip-file"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function zip_spec_file_outputs(
    params: ZipSpecFileParamsDict,
    execution: Execution,
): ZipSpecFileOutputs {
    const ret: ZipSpecFileOutputs = {
        root: execution.outputFile("."),
    };
    return ret;
}


/**
 * ZIP A SPEC FILE AND ITS DATA FILES.
 *
 * If zip-file already exists, it will be overwritten.  If -base-dir is not specified, the directory containing the spec file is used for the base directory.  The spec file must contain only relative paths, and no data files may be outside the base directory.  Scene files inside spec files are not checked for what files they reference, ensure that all data files referenced by the scene files are also referenced by the spec file.
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ZipSpecFileOutputs`).
 */
function zip_spec_file_execute(
    params: ZipSpecFileParamsDict,
    runner: Runner | null = null,
): ZipSpecFileOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ZIP_SPEC_FILE_METADATA);
    params = execution.params(params)
    const cargs = zip_spec_file_cargs(params, execution)
    const ret = zip_spec_file_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * ZIP A SPEC FILE AND ITS DATA FILES.
 *
 * If zip-file already exists, it will be overwritten.  If -base-dir is not specified, the directory containing the spec file is used for the base directory.  The spec file must contain only relative paths, and no data files may be outside the base directory.  Scene files inside spec files are not checked for what files they reference, ensure that all data files referenced by the scene files are also referenced by the spec file.
 *
 * @param spec_file the specification file to add to zip file
 * @param extract_folder the name of the folder created when the zip file is unzipped
 * @param zip_file out - the zip file that will be created
 * @param directory specify a directory that all data files are somewhere within, this will become the root of the zipfile's directory structure

the directory
 * @param skip_missing any missing files will generate only warnings, and the zip file will be created anyway
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ZipSpecFileOutputs`).
 */
function zip_spec_file(
    spec_file: string,
    extract_folder: string,
    zip_file: string,
    directory: string | null = null,
    skip_missing: boolean = false,
    runner: Runner | null = null,
): ZipSpecFileOutputs {
    const params = zip_spec_file_params(spec_file, extract_folder, zip_file, directory, skip_missing)
    return zip_spec_file_execute(params, runner);
}


export {
      ZIP_SPEC_FILE_METADATA,
      ZipSpecFileOutputs,
      ZipSpecFileParamsDict,
      ZipSpecFileParamsDictTagged,
      zip_spec_file,
      zip_spec_file_execute,
      zip_spec_file_params,
};
