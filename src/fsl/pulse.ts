// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const PULSE_METADATA: Metadata = {
    id: "0912bfc18a05bdaa4deb097213d2029cbae7c791.boutiques",
    name: "pulse",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface PulseParameters {
    "@type"?: "fsl/pulse";
    "input_file": InputPathType;
    "output_base": string;
    "seq"?: string | null | undefined;
    "angle"?: number | null | undefined;
    "te"?: number | null | undefined;
    "tr"?: number | null | undefined;
    "trslc"?: number | null | undefined;
    "nx"?: number | null | undefined;
    "ny"?: number | null | undefined;
    "dx"?: number | null | undefined;
    "dy"?: number | null | undefined;
    "maxG"?: number | null | undefined;
    "riset"?: number | null | undefined;
    "bw"?: number | null | undefined;
    "numvol"?: number | null | undefined;
    "numslc"?: number | null | undefined;
    "slcthk"?: number | null | undefined;
    "gap"?: number | null | undefined;
    "zstart"?: number | null | undefined;
    "slcdir"?: string | null | undefined;
    "phasedir"?: string | null | undefined;
    "readdir"?: string | null | undefined;
    "verbose_flag": boolean;
    "kcoord_flag": boolean;
    "cover"?: number | null | undefined;
}
type PulseParametersTagged = Required<Pick<PulseParameters, '@type'>> & PulseParameters;


/**
 * Output object returned when calling `PulseParameters(...)`.
 *
 * @interface
 */
interface PulseOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Pulse sequence matrix output
     */
    output_pulse_sequence_matrix: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param input_file 4D digital brain, resolution can be any.
 * @param output_base Output base name
 * @param seq Type of pulse sequence; default=epi (epi OR ge)
 * @param angle Flip angle in degrees; default=90
 * @param te The time from the first RF to the first echo; default=0.03s
 * @param tr The time between the two RF pulses applied on the same part of the object; default=3s
 * @param trslc The time that takes for the acquisition of one slice; default=0.12s
 * @param nx Resolution in x of the output image; default=64
 * @param ny Resolution in y of the output image; default=64
 * @param dx Image voxel x-dimension; default=0.004m
 * @param dy Image voxel y-dimension; default=0.004m
 * @param max_g Maximum gradient strength; default=0.055 T/m
 * @param riset Time it takes for the gradient to reach its max value; default=0.00022s
 * @param bw Receiving bandwidth; default=100000Hz
 * @param numvol Number of volumes; default=1
 * @param numslc Number of slices; default=1
 * @param slcthk Slice thickness; default=0.006m
 * @param gap Gap between the slices in meters; default=0m
 * @param zstart The lowest position in the slice direction in meters; default=0m
 * @param slcdir Slice acquisition direction/orientation; default=z- (x+,x-, y+,y- or z+,or z-)
 * @param phasedir Phase encode direction/orientation; default=y+ (x+,x-, y+,y- or z+,or z-)
 * @param readdir Read-out direction/orientation; default=x+ (x+,x-, y+,y- or z+,or z-)
 * @param verbose_flag Switch on diagnostic messages
 * @param kcoord_flag Save k-space coordinates; default=no
 * @param cover Phase partial Fourier coverage in percentage; default=100 (min=50, max=100)
 *
 * @returns Parameter dictionary
 */
function pulse_params(
    input_file: InputPathType,
    output_base: string,
    seq: string | null = null,
    angle: number | null = null,
    te: number | null = null,
    tr: number | null = null,
    trslc: number | null = null,
    nx: number | null = null,
    ny: number | null = null,
    dx: number | null = null,
    dy: number | null = null,
    max_g: number | null = null,
    riset: number | null = null,
    bw: number | null = null,
    numvol: number | null = null,
    numslc: number | null = null,
    slcthk: number | null = null,
    gap: number | null = null,
    zstart: number | null = null,
    slcdir: string | null = null,
    phasedir: string | null = null,
    readdir: string | null = null,
    verbose_flag: boolean = false,
    kcoord_flag: boolean = false,
    cover: number | null = null,
): PulseParametersTagged {
    const params = {
        "@type": "fsl/pulse" as const,
        "input_file": input_file,
        "output_base": output_base,
        "verbose_flag": verbose_flag,
        "kcoord_flag": kcoord_flag,
    };
    if (seq !== null) {
        params["seq"] = seq;
    }
    if (angle !== null) {
        params["angle"] = angle;
    }
    if (te !== null) {
        params["te"] = te;
    }
    if (tr !== null) {
        params["tr"] = tr;
    }
    if (trslc !== null) {
        params["trslc"] = trslc;
    }
    if (nx !== null) {
        params["nx"] = nx;
    }
    if (ny !== null) {
        params["ny"] = ny;
    }
    if (dx !== null) {
        params["dx"] = dx;
    }
    if (dy !== null) {
        params["dy"] = dy;
    }
    if (max_g !== null) {
        params["maxG"] = max_g;
    }
    if (riset !== null) {
        params["riset"] = riset;
    }
    if (bw !== null) {
        params["bw"] = bw;
    }
    if (numvol !== null) {
        params["numvol"] = numvol;
    }
    if (numslc !== null) {
        params["numslc"] = numslc;
    }
    if (slcthk !== null) {
        params["slcthk"] = slcthk;
    }
    if (gap !== null) {
        params["gap"] = gap;
    }
    if (zstart !== null) {
        params["zstart"] = zstart;
    }
    if (slcdir !== null) {
        params["slcdir"] = slcdir;
    }
    if (phasedir !== null) {
        params["phasedir"] = phasedir;
    }
    if (readdir !== null) {
        params["readdir"] = readdir;
    }
    if (cover !== null) {
        params["cover"] = cover;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function pulse_cargs(
    params: PulseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("pulse");
    cargs.push(
        "-i",
        execution.inputFile((params["input_file"] ?? null))
    );
    cargs.push(
        "-o",
        (params["output_base"] ?? null)
    );
    if ((params["seq"] ?? null) !== null) {
        cargs.push(
            "--seq",
            (params["seq"] ?? null)
        );
    }
    if ((params["angle"] ?? null) !== null) {
        cargs.push(
            "--angle",
            String((params["angle"] ?? null))
        );
    }
    if ((params["te"] ?? null) !== null) {
        cargs.push(
            "--te",
            String((params["te"] ?? null))
        );
    }
    if ((params["tr"] ?? null) !== null) {
        cargs.push(
            "--tr",
            String((params["tr"] ?? null))
        );
    }
    if ((params["trslc"] ?? null) !== null) {
        cargs.push(
            "--trslc",
            String((params["trslc"] ?? null))
        );
    }
    if ((params["nx"] ?? null) !== null) {
        cargs.push(
            "--nx",
            String((params["nx"] ?? null))
        );
    }
    if ((params["ny"] ?? null) !== null) {
        cargs.push(
            "--ny",
            String((params["ny"] ?? null))
        );
    }
    if ((params["dx"] ?? null) !== null) {
        cargs.push(
            "--dx",
            String((params["dx"] ?? null))
        );
    }
    if ((params["dy"] ?? null) !== null) {
        cargs.push(
            "--dy",
            String((params["dy"] ?? null))
        );
    }
    if ((params["maxG"] ?? null) !== null) {
        cargs.push(
            "--maxG",
            String((params["maxG"] ?? null))
        );
    }
    if ((params["riset"] ?? null) !== null) {
        cargs.push(
            "--riset",
            String((params["riset"] ?? null))
        );
    }
    if ((params["bw"] ?? null) !== null) {
        cargs.push(
            "--bw",
            String((params["bw"] ?? null))
        );
    }
    if ((params["numvol"] ?? null) !== null) {
        cargs.push(
            "--numvol",
            String((params["numvol"] ?? null))
        );
    }
    if ((params["numslc"] ?? null) !== null) {
        cargs.push(
            "--numslc",
            String((params["numslc"] ?? null))
        );
    }
    if ((params["slcthk"] ?? null) !== null) {
        cargs.push(
            "--slcthk",
            String((params["slcthk"] ?? null))
        );
    }
    if ((params["gap"] ?? null) !== null) {
        cargs.push(
            "--gap",
            String((params["gap"] ?? null))
        );
    }
    if ((params["zstart"] ?? null) !== null) {
        cargs.push(
            "--zstart",
            String((params["zstart"] ?? null))
        );
    }
    if ((params["slcdir"] ?? null) !== null) {
        cargs.push(
            "--slcdir",
            (params["slcdir"] ?? null)
        );
    }
    if ((params["phasedir"] ?? null) !== null) {
        cargs.push(
            "--phasedir",
            (params["phasedir"] ?? null)
        );
    }
    if ((params["readdir"] ?? null) !== null) {
        cargs.push(
            "--readdir",
            (params["readdir"] ?? null)
        );
    }
    if ((params["verbose_flag"] ?? false)) {
        cargs.push("-v");
    }
    if ((params["kcoord_flag"] ?? false)) {
        cargs.push("-k");
    }
    if ((params["cover"] ?? null) !== null) {
        cargs.push(
            "--cover",
            String((params["cover"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function pulse_outputs(
    params: PulseParameters,
    execution: Execution,
): PulseOutputs {
    const ret: PulseOutputs = {
        root: execution.outputFile("."),
        output_pulse_sequence_matrix: execution.outputFile([(params["output_base"] ?? null), "_pulsesequence_matrix"].join('')),
    };
    return ret;
}


/**
 * pulse
 *
 * Generates a pulse sequence matrix for a given digital brain image.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `PulseOutputs`).
 */
function pulse_execute(
    params: PulseParameters,
    runner: Runner | null = null,
): PulseOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(PULSE_METADATA);
    params = execution.params(params)
    const cargs = pulse_cargs(params, execution)
    const ret = pulse_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * pulse
 *
 * Generates a pulse sequence matrix for a given digital brain image.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param input_file 4D digital brain, resolution can be any.
 * @param output_base Output base name
 * @param seq Type of pulse sequence; default=epi (epi OR ge)
 * @param angle Flip angle in degrees; default=90
 * @param te The time from the first RF to the first echo; default=0.03s
 * @param tr The time between the two RF pulses applied on the same part of the object; default=3s
 * @param trslc The time that takes for the acquisition of one slice; default=0.12s
 * @param nx Resolution in x of the output image; default=64
 * @param ny Resolution in y of the output image; default=64
 * @param dx Image voxel x-dimension; default=0.004m
 * @param dy Image voxel y-dimension; default=0.004m
 * @param max_g Maximum gradient strength; default=0.055 T/m
 * @param riset Time it takes for the gradient to reach its max value; default=0.00022s
 * @param bw Receiving bandwidth; default=100000Hz
 * @param numvol Number of volumes; default=1
 * @param numslc Number of slices; default=1
 * @param slcthk Slice thickness; default=0.006m
 * @param gap Gap between the slices in meters; default=0m
 * @param zstart The lowest position in the slice direction in meters; default=0m
 * @param slcdir Slice acquisition direction/orientation; default=z- (x+,x-, y+,y- or z+,or z-)
 * @param phasedir Phase encode direction/orientation; default=y+ (x+,x-, y+,y- or z+,or z-)
 * @param readdir Read-out direction/orientation; default=x+ (x+,x-, y+,y- or z+,or z-)
 * @param verbose_flag Switch on diagnostic messages
 * @param kcoord_flag Save k-space coordinates; default=no
 * @param cover Phase partial Fourier coverage in percentage; default=100 (min=50, max=100)
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `PulseOutputs`).
 */
function pulse(
    input_file: InputPathType,
    output_base: string,
    seq: string | null = null,
    angle: number | null = null,
    te: number | null = null,
    tr: number | null = null,
    trslc: number | null = null,
    nx: number | null = null,
    ny: number | null = null,
    dx: number | null = null,
    dy: number | null = null,
    max_g: number | null = null,
    riset: number | null = null,
    bw: number | null = null,
    numvol: number | null = null,
    numslc: number | null = null,
    slcthk: number | null = null,
    gap: number | null = null,
    zstart: number | null = null,
    slcdir: string | null = null,
    phasedir: string | null = null,
    readdir: string | null = null,
    verbose_flag: boolean = false,
    kcoord_flag: boolean = false,
    cover: number | null = null,
    runner: Runner | null = null,
): PulseOutputs {
    const params = pulse_params(input_file, output_base, seq, angle, te, tr, trslc, nx, ny, dx, dy, max_g, riset, bw, numvol, numslc, slcthk, gap, zstart, slcdir, phasedir, readdir, verbose_flag, kcoord_flag, cover)
    return pulse_execute(params, runner);
}


export {
      PULSE_METADATA,
      PulseOutputs,
      pulse,
      pulse_execute,
      pulse_params,
};
