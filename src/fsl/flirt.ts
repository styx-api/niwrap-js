// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const FLIRT_METADATA: Metadata = {
    id: "c1e04fa70c0e223bd30966b0bf0fa3ed5c379486.boutiques",
    name: "flirt",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface FlirtParameters {
    "@type"?: "fsl/flirt";
    "in_file": InputPathType;
    "reference": InputPathType;
    "out_file": string;
    "out_matrix_file": string;
    "angle_rep"?: "quaternion" | "euler" | null | undefined;
    "apply_isoxfm"?: number | null | undefined;
    "apply_xfm": boolean;
    "bbrslope"?: number | null | undefined;
    "bbrtype"?: "signed" | "global_abs" | "local_abs" | null | undefined;
    "bgvalue"?: number | null | undefined;
    "bins"?: number | null | undefined;
    "coarse_search"?: number | null | undefined;
    "cost"?: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | "bbr" | null | undefined;
    "cost_func"?: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | "bbr" | null | undefined;
    "datatype"?: "char" | "short" | "int" | "float" | "double" | null | undefined;
    "display_init": boolean;
    "dof"?: number | null | undefined;
    "echospacing"?: number | null | undefined;
    "fieldmap"?: InputPathType | null | undefined;
    "fieldmapmask"?: InputPathType | null | undefined;
    "fine_search"?: number | null | undefined;
    "force_scaling": boolean;
    "in_matrix_file"?: InputPathType | null | undefined;
    "in_weight"?: InputPathType | null | undefined;
    "interp"?: "trilinear" | "nearestneighbour" | "sinc" | "spline" | null | undefined;
    "min_sampling"?: number | null | undefined;
    "no_clamp": boolean;
    "no_resample": boolean;
    "no_resample_blur": boolean;
    "no_search": boolean;
    "padding_size"?: number | null | undefined;
    "pedir"?: number | null | undefined;
    "ref_weight"?: InputPathType | null | undefined;
    "rigid2D": boolean;
    "schedule"?: InputPathType | null | undefined;
    "searchr_x"?: Array<number> | null | undefined;
    "searchr_y"?: Array<number> | null | undefined;
    "searchr_z"?: Array<number> | null | undefined;
    "sinc_width"?: number | null | undefined;
    "sinc_window"?: "rectangular" | "hanning" | "blackman" | null | undefined;
    "uses_qform": boolean;
    "verbose"?: number | null | undefined;
    "wm_seg"?: InputPathType | null | undefined;
    "wmcoords"?: InputPathType | null | undefined;
    "wmnorms"?: InputPathType | null | undefined;
}
type FlirtParametersTagged = Required<Pick<FlirtParameters, '@type'>> & FlirtParameters;


/**
 * Output object returned when calling `FlirtParameters(...)`.
 *
 * @interface
 */
interface FlirtOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Registered output file.
     */
    out_file: OutputPathType;
    /**
     * Output affine matrix in 4x4 asciii format.
     */
    out_matrix_file: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param in_file Input file.
 * @param reference Reference file.
 * @param out_file Registered output file.
 * @param out_matrix_file Output affine matrix in 4x4 asciii format.
 * @param angle_rep 'quaternion' or 'euler'. Representation of rotation angles.
 * @param apply_isoxfm As applyxfm but forces isotropic resampling.
 * @param apply_xfm Apply transformation supplied by in_matrix_file or uses_qform to use the affine matrix stored in the reference header.
 * @param bbrslope Value of bbr slope.
 * @param bbrtype 'signed' or 'global_abs' or 'local_abs'. Type of bbr cost function: signed [default], global_abs, local_abs.
 * @param bgvalue Use specified background value for points outside fov.
 * @param bins Number of histogram bins.
 * @param coarse_search Coarse search delta angle.
 * @param cost 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or 'leastsq' or 'labeldiff' or 'bbr'. Cost function.
 * @param cost_func 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or 'leastsq' or 'labeldiff' or 'bbr'. Cost function.
 * @param datatype 'char' or 'short' or 'int' or 'float' or 'double'. Force output data type.
 * @param display_init Display initial matrix.
 * @param dof Number of transform degrees of freedom.
 * @param echospacing Value of epi echo spacing - units of seconds.
 * @param fieldmap Fieldmap image in rads/s - must be already registered to the reference image.
 * @param fieldmapmask Mask for fieldmap image.
 * @param fine_search Fine search delta angle.
 * @param force_scaling Force rescaling even for low-res images.
 * @param in_matrix_file Input 4x4 affine matrix.
 * @param in_weight File for input weighting volume.
 * @param interp 'trilinear' or 'nearestneighbour' or 'sinc' or 'spline'. Final interpolation method used in reslicing.
 * @param min_sampling Set minimum voxel dimension for sampling.
 * @param no_clamp Do not use intensity clamping.
 * @param no_resample Do not change input sampling.
 * @param no_resample_blur Do not use blurring on downsampling.
 * @param no_search Set all angular searches to ranges 0 to 0.
 * @param padding_size For applyxfm: interpolates outside image by size.
 * @param pedir Phase encode direction of epi - 1/2/3=x/y/z & -1/-2/-3=-x/-y/-z.
 * @param ref_weight File for reference weighting volume.
 * @param rigid2_d Use 2d rigid body mode - ignores dof.
 * @param schedule Replaces default schedule.
 * @param searchr_x Search angles along x-axis, in degrees.
 * @param searchr_y Search angles along y-axis, in degrees.
 * @param searchr_z Search angles along z-axis, in degrees.
 * @param sinc_width Full-width in voxels.
 * @param sinc_window 'rectangular' or 'hanning' or 'blackman'. Sinc window.
 * @param uses_qform Initialize using sform or qform.
 * @param verbose Verbose mode, 0 is least.
 * @param wm_seg White matter segmentation volume needed by bbr cost function.
 * @param wmcoords White matter boundary coordinates for bbr cost function.
 * @param wmnorms White matter boundary normals for bbr cost function.
 *
 * @returns Parameter dictionary
 */
function flirt_params(
    in_file: InputPathType,
    reference: InputPathType,
    out_file: string,
    out_matrix_file: string,
    angle_rep: "quaternion" | "euler" | null = null,
    apply_isoxfm: number | null = null,
    apply_xfm: boolean = false,
    bbrslope: number | null = null,
    bbrtype: "signed" | "global_abs" | "local_abs" | null = null,
    bgvalue: number | null = null,
    bins: number | null = null,
    coarse_search: number | null = null,
    cost: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | "bbr" | null = null,
    cost_func: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | "bbr" | null = null,
    datatype: "char" | "short" | "int" | "float" | "double" | null = null,
    display_init: boolean = false,
    dof: number | null = null,
    echospacing: number | null = null,
    fieldmap: InputPathType | null = null,
    fieldmapmask: InputPathType | null = null,
    fine_search: number | null = null,
    force_scaling: boolean = false,
    in_matrix_file: InputPathType | null = null,
    in_weight: InputPathType | null = null,
    interp: "trilinear" | "nearestneighbour" | "sinc" | "spline" | null = null,
    min_sampling: number | null = null,
    no_clamp: boolean = false,
    no_resample: boolean = false,
    no_resample_blur: boolean = false,
    no_search: boolean = false,
    padding_size: number | null = null,
    pedir: number | null = null,
    ref_weight: InputPathType | null = null,
    rigid2_d: boolean = false,
    schedule: InputPathType | null = null,
    searchr_x: Array<number> | null = null,
    searchr_y: Array<number> | null = null,
    searchr_z: Array<number> | null = null,
    sinc_width: number | null = null,
    sinc_window: "rectangular" | "hanning" | "blackman" | null = null,
    uses_qform: boolean = false,
    verbose: number | null = null,
    wm_seg: InputPathType | null = null,
    wmcoords: InputPathType | null = null,
    wmnorms: InputPathType | null = null,
): FlirtParametersTagged {
    const params = {
        "@type": "fsl/flirt" as const,
        "in_file": in_file,
        "reference": reference,
        "out_file": out_file,
        "out_matrix_file": out_matrix_file,
        "apply_xfm": apply_xfm,
        "display_init": display_init,
        "force_scaling": force_scaling,
        "no_clamp": no_clamp,
        "no_resample": no_resample,
        "no_resample_blur": no_resample_blur,
        "no_search": no_search,
        "rigid2D": rigid2_d,
        "uses_qform": uses_qform,
    };
    if (angle_rep !== null) {
        params["angle_rep"] = angle_rep;
    }
    if (apply_isoxfm !== null) {
        params["apply_isoxfm"] = apply_isoxfm;
    }
    if (bbrslope !== null) {
        params["bbrslope"] = bbrslope;
    }
    if (bbrtype !== null) {
        params["bbrtype"] = bbrtype;
    }
    if (bgvalue !== null) {
        params["bgvalue"] = bgvalue;
    }
    if (bins !== null) {
        params["bins"] = bins;
    }
    if (coarse_search !== null) {
        params["coarse_search"] = coarse_search;
    }
    if (cost !== null) {
        params["cost"] = cost;
    }
    if (cost_func !== null) {
        params["cost_func"] = cost_func;
    }
    if (datatype !== null) {
        params["datatype"] = datatype;
    }
    if (dof !== null) {
        params["dof"] = dof;
    }
    if (echospacing !== null) {
        params["echospacing"] = echospacing;
    }
    if (fieldmap !== null) {
        params["fieldmap"] = fieldmap;
    }
    if (fieldmapmask !== null) {
        params["fieldmapmask"] = fieldmapmask;
    }
    if (fine_search !== null) {
        params["fine_search"] = fine_search;
    }
    if (in_matrix_file !== null) {
        params["in_matrix_file"] = in_matrix_file;
    }
    if (in_weight !== null) {
        params["in_weight"] = in_weight;
    }
    if (interp !== null) {
        params["interp"] = interp;
    }
    if (min_sampling !== null) {
        params["min_sampling"] = min_sampling;
    }
    if (padding_size !== null) {
        params["padding_size"] = padding_size;
    }
    if (pedir !== null) {
        params["pedir"] = pedir;
    }
    if (ref_weight !== null) {
        params["ref_weight"] = ref_weight;
    }
    if (schedule !== null) {
        params["schedule"] = schedule;
    }
    if (searchr_x !== null) {
        params["searchr_x"] = searchr_x;
    }
    if (searchr_y !== null) {
        params["searchr_y"] = searchr_y;
    }
    if (searchr_z !== null) {
        params["searchr_z"] = searchr_z;
    }
    if (sinc_width !== null) {
        params["sinc_width"] = sinc_width;
    }
    if (sinc_window !== null) {
        params["sinc_window"] = sinc_window;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    if (wm_seg !== null) {
        params["wm_seg"] = wm_seg;
    }
    if (wmcoords !== null) {
        params["wmcoords"] = wmcoords;
    }
    if (wmnorms !== null) {
        params["wmnorms"] = wmnorms;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function flirt_cargs(
    params: FlirtParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("flirt");
    cargs.push(
        "-in",
        execution.inputFile((params["in_file"] ?? null))
    );
    cargs.push(
        "-ref",
        execution.inputFile((params["reference"] ?? null))
    );
    cargs.push(
        "-out",
        (params["out_file"] ?? null)
    );
    cargs.push(
        "-omat",
        (params["out_matrix_file"] ?? null)
    );
    if ((params["angle_rep"] ?? null) !== null) {
        cargs.push(
            "-anglerep",
            (params["angle_rep"] ?? null)
        );
    }
    if ((params["apply_isoxfm"] ?? null) !== null) {
        cargs.push(
            "-applyisoxfm",
            String((params["apply_isoxfm"] ?? null))
        );
    }
    if ((params["apply_xfm"] ?? false)) {
        cargs.push("-applyxfm");
    }
    if ((params["bbrslope"] ?? null) !== null) {
        cargs.push(
            "-bbrslope",
            String((params["bbrslope"] ?? null))
        );
    }
    if ((params["bbrtype"] ?? null) !== null) {
        cargs.push(
            "-bbrtype",
            (params["bbrtype"] ?? null)
        );
    }
    if ((params["bgvalue"] ?? null) !== null) {
        cargs.push(
            "-setbackground",
            String((params["bgvalue"] ?? null))
        );
    }
    if ((params["bins"] ?? null) !== null) {
        cargs.push(
            "-bins",
            String((params["bins"] ?? null))
        );
    }
    if ((params["coarse_search"] ?? null) !== null) {
        cargs.push(
            "-coarsesearch",
            String((params["coarse_search"] ?? null))
        );
    }
    if ((params["cost"] ?? null) !== null) {
        cargs.push(
            "-cost",
            (params["cost"] ?? null)
        );
    }
    if ((params["cost_func"] ?? null) !== null) {
        cargs.push(
            "-searchcost",
            (params["cost_func"] ?? null)
        );
    }
    if ((params["datatype"] ?? null) !== null) {
        cargs.push(
            "-datatype",
            (params["datatype"] ?? null)
        );
    }
    if ((params["display_init"] ?? false)) {
        cargs.push("-displayinit");
    }
    if ((params["dof"] ?? null) !== null) {
        cargs.push(
            "-dof",
            String((params["dof"] ?? null))
        );
    }
    if ((params["echospacing"] ?? null) !== null) {
        cargs.push(
            "-echospacing",
            String((params["echospacing"] ?? null))
        );
    }
    if ((params["fieldmap"] ?? null) !== null) {
        cargs.push(
            "-fieldmap",
            execution.inputFile((params["fieldmap"] ?? null))
        );
    }
    if ((params["fieldmapmask"] ?? null) !== null) {
        cargs.push(
            "-fieldmapmask",
            execution.inputFile((params["fieldmapmask"] ?? null))
        );
    }
    if ((params["fine_search"] ?? null) !== null) {
        cargs.push(
            "-finesearch",
            String((params["fine_search"] ?? null))
        );
    }
    if ((params["force_scaling"] ?? false)) {
        cargs.push("-forcescaling");
    }
    if ((params["in_matrix_file"] ?? null) !== null) {
        cargs.push(
            "-init",
            execution.inputFile((params["in_matrix_file"] ?? null))
        );
    }
    if ((params["in_weight"] ?? null) !== null) {
        cargs.push(
            "-inweight",
            execution.inputFile((params["in_weight"] ?? null))
        );
    }
    if ((params["interp"] ?? null) !== null) {
        cargs.push(
            "-interp",
            (params["interp"] ?? null)
        );
    }
    if ((params["min_sampling"] ?? null) !== null) {
        cargs.push(
            "-minsampling",
            String((params["min_sampling"] ?? null))
        );
    }
    if ((params["no_clamp"] ?? false)) {
        cargs.push("-noclamp");
    }
    if ((params["no_resample"] ?? false)) {
        cargs.push("-noresample");
    }
    if ((params["no_resample_blur"] ?? false)) {
        cargs.push("-noresampblur");
    }
    if ((params["no_search"] ?? false)) {
        cargs.push("-nosearch");
    }
    if ((params["padding_size"] ?? null) !== null) {
        cargs.push(
            "-paddingsize",
            String((params["padding_size"] ?? null))
        );
    }
    if ((params["pedir"] ?? null) !== null) {
        cargs.push(
            "-pedir",
            String((params["pedir"] ?? null))
        );
    }
    if ((params["ref_weight"] ?? null) !== null) {
        cargs.push(
            "-refweight",
            execution.inputFile((params["ref_weight"] ?? null))
        );
    }
    if ((params["rigid2D"] ?? false)) {
        cargs.push("-2D");
    }
    if ((params["schedule"] ?? null) !== null) {
        cargs.push(
            "-schedule",
            execution.inputFile((params["schedule"] ?? null))
        );
    }
    if ((params["searchr_x"] ?? null) !== null) {
        cargs.push(
            "-searchrx",
            ...(params["searchr_x"] ?? null).map(String)
        );
    }
    if ((params["searchr_y"] ?? null) !== null) {
        cargs.push(
            "-searchry",
            ...(params["searchr_y"] ?? null).map(String)
        );
    }
    if ((params["searchr_z"] ?? null) !== null) {
        cargs.push(
            "-searchrz",
            ...(params["searchr_z"] ?? null).map(String)
        );
    }
    if ((params["sinc_width"] ?? null) !== null) {
        cargs.push(
            "-sincwidth",
            String((params["sinc_width"] ?? null))
        );
    }
    if ((params["sinc_window"] ?? null) !== null) {
        cargs.push(
            "-sincwindow",
            (params["sinc_window"] ?? null)
        );
    }
    if ((params["uses_qform"] ?? false)) {
        cargs.push("-usesqform");
    }
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "-verbose",
            String((params["verbose"] ?? null))
        );
    }
    if ((params["wm_seg"] ?? null) !== null) {
        cargs.push(
            "-wmseg",
            execution.inputFile((params["wm_seg"] ?? null))
        );
    }
    if ((params["wmcoords"] ?? null) !== null) {
        cargs.push(
            "-wmcoords",
            execution.inputFile((params["wmcoords"] ?? null))
        );
    }
    if ((params["wmnorms"] ?? null) !== null) {
        cargs.push(
            "-wmnorms",
            execution.inputFile((params["wmnorms"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function flirt_outputs(
    params: FlirtParameters,
    execution: Execution,
): FlirtOutputs {
    const ret: FlirtOutputs = {
        root: execution.outputFile("."),
        out_file: execution.outputFile([(params["out_file"] ?? null)].join('')),
        out_matrix_file: execution.outputFile([(params["out_matrix_file"] ?? null)].join('')),
    };
    return ret;
}


/**
 * flirt
 *
 * FLIRT (FMRIB's Linear Image Registration Tool) is a fully automated robust and accurate tool for linear (affine) intra- and inter-modal brain image registration.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FlirtOutputs`).
 */
function flirt_execute(
    params: FlirtParameters,
    runner: Runner | null = null,
): FlirtOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(FLIRT_METADATA);
    params = execution.params(params)
    const cargs = flirt_cargs(params, execution)
    const ret = flirt_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * flirt
 *
 * FLIRT (FMRIB's Linear Image Registration Tool) is a fully automated robust and accurate tool for linear (affine) intra- and inter-modal brain image registration.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param in_file Input file.
 * @param reference Reference file.
 * @param out_file Registered output file.
 * @param out_matrix_file Output affine matrix in 4x4 asciii format.
 * @param angle_rep 'quaternion' or 'euler'. Representation of rotation angles.
 * @param apply_isoxfm As applyxfm but forces isotropic resampling.
 * @param apply_xfm Apply transformation supplied by in_matrix_file or uses_qform to use the affine matrix stored in the reference header.
 * @param bbrslope Value of bbr slope.
 * @param bbrtype 'signed' or 'global_abs' or 'local_abs'. Type of bbr cost function: signed [default], global_abs, local_abs.
 * @param bgvalue Use specified background value for points outside fov.
 * @param bins Number of histogram bins.
 * @param coarse_search Coarse search delta angle.
 * @param cost 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or 'leastsq' or 'labeldiff' or 'bbr'. Cost function.
 * @param cost_func 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or 'leastsq' or 'labeldiff' or 'bbr'. Cost function.
 * @param datatype 'char' or 'short' or 'int' or 'float' or 'double'. Force output data type.
 * @param display_init Display initial matrix.
 * @param dof Number of transform degrees of freedom.
 * @param echospacing Value of epi echo spacing - units of seconds.
 * @param fieldmap Fieldmap image in rads/s - must be already registered to the reference image.
 * @param fieldmapmask Mask for fieldmap image.
 * @param fine_search Fine search delta angle.
 * @param force_scaling Force rescaling even for low-res images.
 * @param in_matrix_file Input 4x4 affine matrix.
 * @param in_weight File for input weighting volume.
 * @param interp 'trilinear' or 'nearestneighbour' or 'sinc' or 'spline'. Final interpolation method used in reslicing.
 * @param min_sampling Set minimum voxel dimension for sampling.
 * @param no_clamp Do not use intensity clamping.
 * @param no_resample Do not change input sampling.
 * @param no_resample_blur Do not use blurring on downsampling.
 * @param no_search Set all angular searches to ranges 0 to 0.
 * @param padding_size For applyxfm: interpolates outside image by size.
 * @param pedir Phase encode direction of epi - 1/2/3=x/y/z & -1/-2/-3=-x/-y/-z.
 * @param ref_weight File for reference weighting volume.
 * @param rigid2_d Use 2d rigid body mode - ignores dof.
 * @param schedule Replaces default schedule.
 * @param searchr_x Search angles along x-axis, in degrees.
 * @param searchr_y Search angles along y-axis, in degrees.
 * @param searchr_z Search angles along z-axis, in degrees.
 * @param sinc_width Full-width in voxels.
 * @param sinc_window 'rectangular' or 'hanning' or 'blackman'. Sinc window.
 * @param uses_qform Initialize using sform or qform.
 * @param verbose Verbose mode, 0 is least.
 * @param wm_seg White matter segmentation volume needed by bbr cost function.
 * @param wmcoords White matter boundary coordinates for bbr cost function.
 * @param wmnorms White matter boundary normals for bbr cost function.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FlirtOutputs`).
 */
function flirt(
    in_file: InputPathType,
    reference: InputPathType,
    out_file: string,
    out_matrix_file: string,
    angle_rep: "quaternion" | "euler" | null = null,
    apply_isoxfm: number | null = null,
    apply_xfm: boolean = false,
    bbrslope: number | null = null,
    bbrtype: "signed" | "global_abs" | "local_abs" | null = null,
    bgvalue: number | null = null,
    bins: number | null = null,
    coarse_search: number | null = null,
    cost: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | "bbr" | null = null,
    cost_func: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | "bbr" | null = null,
    datatype: "char" | "short" | "int" | "float" | "double" | null = null,
    display_init: boolean = false,
    dof: number | null = null,
    echospacing: number | null = null,
    fieldmap: InputPathType | null = null,
    fieldmapmask: InputPathType | null = null,
    fine_search: number | null = null,
    force_scaling: boolean = false,
    in_matrix_file: InputPathType | null = null,
    in_weight: InputPathType | null = null,
    interp: "trilinear" | "nearestneighbour" | "sinc" | "spline" | null = null,
    min_sampling: number | null = null,
    no_clamp: boolean = false,
    no_resample: boolean = false,
    no_resample_blur: boolean = false,
    no_search: boolean = false,
    padding_size: number | null = null,
    pedir: number | null = null,
    ref_weight: InputPathType | null = null,
    rigid2_d: boolean = false,
    schedule: InputPathType | null = null,
    searchr_x: Array<number> | null = null,
    searchr_y: Array<number> | null = null,
    searchr_z: Array<number> | null = null,
    sinc_width: number | null = null,
    sinc_window: "rectangular" | "hanning" | "blackman" | null = null,
    uses_qform: boolean = false,
    verbose: number | null = null,
    wm_seg: InputPathType | null = null,
    wmcoords: InputPathType | null = null,
    wmnorms: InputPathType | null = null,
    runner: Runner | null = null,
): FlirtOutputs {
    const params = flirt_params(in_file, reference, out_file, out_matrix_file, angle_rep, apply_isoxfm, apply_xfm, bbrslope, bbrtype, bgvalue, bins, coarse_search, cost, cost_func, datatype, display_init, dof, echospacing, fieldmap, fieldmapmask, fine_search, force_scaling, in_matrix_file, in_weight, interp, min_sampling, no_clamp, no_resample, no_resample_blur, no_search, padding_size, pedir, ref_weight, rigid2_d, schedule, searchr_x, searchr_y, searchr_z, sinc_width, sinc_window, uses_qform, verbose, wm_seg, wmcoords, wmnorms)
    return flirt_execute(params, runner);
}


export {
      FLIRT_METADATA,
      FlirtOutputs,
      flirt,
      flirt_execute,
      flirt_params,
};
