// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const SIGNED_DISTANCE_TO_SURFACE_METADATA: Metadata = {
    id: "1796554a2d94421b2b6c260e929d7ad272d3242f.boutiques",
    name: "signed-distance-to-surface",
    package: "workbench",
    container_image_tag: "brainlife/connectome_workbench:1.5.0-freesurfer-update",
};


interface SignedDistanceToSurfaceParameters {
    "@type": "workbench.signed-distance-to-surface";
    "surface_comp": InputPathType;
    "surface_ref": InputPathType;
    "metric": string;
    "opt_winding_method"?: string | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "workbench.signed-distance-to-surface": signed_distance_to_surface_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "workbench.signed-distance-to-surface": signed_distance_to_surface_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `signed_distance_to_surface(...)`.
 *
 * @interface
 */
interface SignedDistanceToSurfaceOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output metric
     */
    metric: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param surface_comp the comparison surface to measure the signed distance on
 * @param surface_ref the reference surface that defines the signed distance function
 * @param metric the output metric
 * @param opt_winding_method winding method for point inside surface test: name of the method (default EVEN_ODD)
 *
 * @returns Parameter dictionary
 */
function signed_distance_to_surface_params(
    surface_comp: InputPathType,
    surface_ref: InputPathType,
    metric: string,
    opt_winding_method: string | null = null,
): SignedDistanceToSurfaceParameters {
    const params = {
        "@type": "workbench.signed-distance-to-surface" as const,
        "surface_comp": surface_comp,
        "surface_ref": surface_ref,
        "metric": metric,
    };
    if (opt_winding_method !== null) {
        params["opt_winding_method"] = opt_winding_method;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function signed_distance_to_surface_cargs(
    params: SignedDistanceToSurfaceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("wb_command");
    cargs.push("-signed-distance-to-surface");
    cargs.push(execution.inputFile((params["surface_comp"] ?? null)));
    cargs.push(execution.inputFile((params["surface_ref"] ?? null)));
    cargs.push((params["metric"] ?? null));
    if ((params["opt_winding_method"] ?? null) !== null) {
        cargs.push(
            "-winding",
            (params["opt_winding_method"] ?? null)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function signed_distance_to_surface_outputs(
    params: SignedDistanceToSurfaceParameters,
    execution: Execution,
): SignedDistanceToSurfaceOutputs {
    const ret: SignedDistanceToSurfaceOutputs = {
        root: execution.outputFile("."),
        metric: execution.outputFile([(params["metric"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Compute signed distance from one surface to another.
 *
 * Compute the signed distance function of the reference surface at every vertex on the comparison surface.  NOTE: this relation is NOT symmetric, the line from a vertex to the closest point on the 'ref' surface (the one that defines the signed distance function) will only align with the normal of the 'ref' surface.  Valid specifiers for winding methods are as follows:
 *
 * EVEN_ODD (default)
 * NEGATIVE
 * NONZERO
 * NORMALS
 *
 * The NORMALS method uses the normals of triangles and edges, or the closest triangle hit by a ray from the point.  This method may be slightly faster, but is only reliable for a closed surface that does not cross through itself.  All other methods count entry (positive) and exit (negative) crossings of a vertical ray from the point, then counts as inside if the total is odd, negative, or nonzero, respectively.
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param params The parameters.
 * @param execution The execution object.
 *
 * @returns NamedTuple of outputs (described in `SignedDistanceToSurfaceOutputs`).
 */
function signed_distance_to_surface_execute(
    params: SignedDistanceToSurfaceParameters,
    execution: Execution,
): SignedDistanceToSurfaceOutputs {
    params = execution.params(params)
    const cargs = signed_distance_to_surface_cargs(params, execution)
    const ret = signed_distance_to_surface_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * Compute signed distance from one surface to another.
 *
 * Compute the signed distance function of the reference surface at every vertex on the comparison surface.  NOTE: this relation is NOT symmetric, the line from a vertex to the closest point on the 'ref' surface (the one that defines the signed distance function) will only align with the normal of the 'ref' surface.  Valid specifiers for winding methods are as follows:
 *
 * EVEN_ODD (default)
 * NEGATIVE
 * NONZERO
 * NORMALS
 *
 * The NORMALS method uses the normals of triangles and edges, or the closest triangle hit by a ray from the point.  This method may be slightly faster, but is only reliable for a closed surface that does not cross through itself.  All other methods count entry (positive) and exit (negative) crossings of a vertical ray from the point, then counts as inside if the total is odd, negative, or nonzero, respectively.
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param surface_comp the comparison surface to measure the signed distance on
 * @param surface_ref the reference surface that defines the signed distance function
 * @param metric the output metric
 * @param opt_winding_method winding method for point inside surface test: name of the method (default EVEN_ODD)
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `SignedDistanceToSurfaceOutputs`).
 */
function signed_distance_to_surface(
    surface_comp: InputPathType,
    surface_ref: InputPathType,
    metric: string,
    opt_winding_method: string | null = null,
    runner: Runner | null = null,
): SignedDistanceToSurfaceOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(SIGNED_DISTANCE_TO_SURFACE_METADATA);
    const params = signed_distance_to_surface_params(surface_comp, surface_ref, metric, opt_winding_method)
    return signed_distance_to_surface_execute(params, execution);
}


export {
      SIGNED_DISTANCE_TO_SURFACE_METADATA,
      SignedDistanceToSurfaceOutputs,
      SignedDistanceToSurfaceParameters,
      signed_distance_to_surface,
      signed_distance_to_surface_cargs,
      signed_distance_to_surface_execute,
      signed_distance_to_surface_outputs,
      signed_distance_to_surface_params,
};
