// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_3DEDGEDOG_METADATA: Metadata = {
    id: "1c3d8f0c9e39b26a708590d37d0905a6facb7f27.boutiques",
    name: "3dedgedog",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V3dedgedogParameters {
    "@type"?: "afni/3dedgedog";
    "input": InputPathType;
    "prefix": string;
    "mask"?: InputPathType | null | undefined;
    "automask"?: string | null | undefined;
    "sigma_rad"?: number | null | undefined;
    "sigma_nvox"?: number | null | undefined;
    "ratio_sigma"?: number | null | undefined;
    "output_intermed": boolean;
    "edge_bnd_nn"?: number | null | undefined;
    "edge_bnd_side"?: string | null | undefined;
    "edge_bnd_scale": boolean;
    "only2d"?: string | null | undefined;
}
type V3dedgedogParametersTagged = Required<Pick<V3dedgedogParameters, '@type'>> & V3dedgedogParameters;


/**
 * Output object returned when calling `V3dedgedogParameters(...)`.
 *
 * @interface
 */
interface V3dedgedogOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output edge dataset
     */
    out_edge: OutputPathType;
    /**
     * Output difference of Gaussian dataset
     */
    out_dog: OutputPathType;
    /**
     * Output Euclidean Distance Transform squared dataset
     */
    out_edt2: OutputPathType;
    /**
     * Output inner Gaussian blurred dataset
     */
    out_blur_inner: OutputPathType;
    /**
     * Output outer Gaussian blurred dataset
     */
    out_blur_outer: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param input Input dataset
 * @param prefix Output prefix name
 * @param mask Mask dataset applied after Euclidean Distance Transform calculation
 * @param automask Calculate mask automatically. Optionally, you can provide an integer X to dilate the initial automask X times (e.g., -automask+X)
 * @param sigma_rad Radius for 'inner' Gaussian, in mm; must be greater than 0 (default: 1.40)
 * @param sigma_nvox Define radius for 'inner' Gaussian by providing a multiplicative factor for voxel edge length greater than 0 (default: use sigma_rad)
 * @param ratio_sigma Ratio of inner and outer Gaussian sigma values (default: 1.40)
 * @param output_intermed Output intermediate datasets: DOG, EDT2, BLURS (default: not output)
 * @param edge_bnd_nn Nearest neighbor (NN) value for connectedness of boundaries; must be 1 (face only), 2 (face+edge), or 3 (face+edge+node) (default: 1)
 * @param edge_bnd_side Specify boundary layer to use: NEG, POS, BOTH, BOTH_SIGN (default: NEG)
 * @param edge_bnd_scale Scale edge values to have relative magnitude between 0 and 100 (default: edge locations have value=1)
 * @param only2d Calculate edges in 2D per plane specified by SLI: 'axi', 'cor', 'sag'
 *
 * @returns Parameter dictionary
 */
function v_3dedgedog_params(
    input: InputPathType,
    prefix: string,
    mask: InputPathType | null = null,
    automask: string | null = null,
    sigma_rad: number | null = null,
    sigma_nvox: number | null = null,
    ratio_sigma: number | null = null,
    output_intermed: boolean = false,
    edge_bnd_nn: number | null = null,
    edge_bnd_side: string | null = null,
    edge_bnd_scale: boolean = false,
    only2d: string | null = null,
): V3dedgedogParametersTagged {
    const params = {
        "@type": "afni/3dedgedog" as const,
        "input": input,
        "prefix": prefix,
        "output_intermed": output_intermed,
        "edge_bnd_scale": edge_bnd_scale,
    };
    if (mask !== null) {
        params["mask"] = mask;
    }
    if (automask !== null) {
        params["automask"] = automask;
    }
    if (sigma_rad !== null) {
        params["sigma_rad"] = sigma_rad;
    }
    if (sigma_nvox !== null) {
        params["sigma_nvox"] = sigma_nvox;
    }
    if (ratio_sigma !== null) {
        params["ratio_sigma"] = ratio_sigma;
    }
    if (edge_bnd_nn !== null) {
        params["edge_bnd_nn"] = edge_bnd_nn;
    }
    if (edge_bnd_side !== null) {
        params["edge_bnd_side"] = edge_bnd_side;
    }
    if (only2d !== null) {
        params["only2d"] = only2d;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function v_3dedgedog_cargs(
    params: V3dedgedogParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("3dedgedog");
    cargs.push(execution.inputFile((params["input"] ?? null)));
    cargs.push((params["prefix"] ?? null));
    if ((params["mask"] ?? null) !== null) {
        cargs.push(
            "-mask",
            execution.inputFile((params["mask"] ?? null))
        );
    }
    if ((params["automask"] ?? null) !== null) {
        cargs.push(
            "-automask",
            (params["automask"] ?? null)
        );
    }
    if ((params["sigma_rad"] ?? null) !== null) {
        cargs.push(
            "-sigma_rad",
            String((params["sigma_rad"] ?? null))
        );
    }
    if ((params["sigma_nvox"] ?? null) !== null) {
        cargs.push(
            "-sigma_nvox",
            String((params["sigma_nvox"] ?? null))
        );
    }
    if ((params["ratio_sigma"] ?? null) !== null) {
        cargs.push(
            "-ratio_sigma",
            String((params["ratio_sigma"] ?? null))
        );
    }
    if ((params["output_intermed"] ?? false)) {
        cargs.push("-output_intermed");
    }
    if ((params["edge_bnd_nn"] ?? null) !== null) {
        cargs.push(
            "-edge_bnd_NN",
            String((params["edge_bnd_nn"] ?? null))
        );
    }
    if ((params["edge_bnd_side"] ?? null) !== null) {
        cargs.push(
            "-edge_bnd_side",
            (params["edge_bnd_side"] ?? null)
        );
    }
    if ((params["edge_bnd_scale"] ?? false)) {
        cargs.push("-edge_bnd_scale");
    }
    if ((params["only2d"] ?? null) !== null) {
        cargs.push(
            "-only2D",
            (params["only2d"] ?? null)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function v_3dedgedog_outputs(
    params: V3dedgedogParameters,
    execution: Execution,
): V3dedgedogOutputs {
    const ret: V3dedgedogOutputs = {
        root: execution.outputFile("."),
        out_edge: execution.outputFile([(params["prefix"] ?? null), "_edge.nii.gz"].join('')),
        out_dog: execution.outputFile([(params["prefix"] ?? null), "_dog.nii.gz"].join('')),
        out_edt2: execution.outputFile([(params["prefix"] ?? null), "_edt2.nii.gz"].join('')),
        out_blur_inner: execution.outputFile([(params["prefix"] ?? null), "_blur_inner.nii.gz"].join('')),
        out_blur_outer: execution.outputFile([(params["prefix"] ?? null), "_blur_outer.nii.gz"].join('')),
    };
    return ret;
}


/**
 * 3dedgedog
 *
 * Calculate edges in an image using the Difference of Gaussians (DOG) method with extensions/tweaks of the Marr-Hildreth algorithm.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dedgedogOutputs`).
 */
function v_3dedgedog_execute(
    params: V3dedgedogParameters,
    runner: Runner | null = null,
): V3dedgedogOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_3DEDGEDOG_METADATA);
    params = execution.params(params)
    const cargs = v_3dedgedog_cargs(params, execution)
    const ret = v_3dedgedog_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * 3dedgedog
 *
 * Calculate edges in an image using the Difference of Gaussians (DOG) method with extensions/tweaks of the Marr-Hildreth algorithm.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param input Input dataset
 * @param prefix Output prefix name
 * @param mask Mask dataset applied after Euclidean Distance Transform calculation
 * @param automask Calculate mask automatically. Optionally, you can provide an integer X to dilate the initial automask X times (e.g., -automask+X)
 * @param sigma_rad Radius for 'inner' Gaussian, in mm; must be greater than 0 (default: 1.40)
 * @param sigma_nvox Define radius for 'inner' Gaussian by providing a multiplicative factor for voxel edge length greater than 0 (default: use sigma_rad)
 * @param ratio_sigma Ratio of inner and outer Gaussian sigma values (default: 1.40)
 * @param output_intermed Output intermediate datasets: DOG, EDT2, BLURS (default: not output)
 * @param edge_bnd_nn Nearest neighbor (NN) value for connectedness of boundaries; must be 1 (face only), 2 (face+edge), or 3 (face+edge+node) (default: 1)
 * @param edge_bnd_side Specify boundary layer to use: NEG, POS, BOTH, BOTH_SIGN (default: NEG)
 * @param edge_bnd_scale Scale edge values to have relative magnitude between 0 and 100 (default: edge locations have value=1)
 * @param only2d Calculate edges in 2D per plane specified by SLI: 'axi', 'cor', 'sag'
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dedgedogOutputs`).
 */
function v_3dedgedog(
    input: InputPathType,
    prefix: string,
    mask: InputPathType | null = null,
    automask: string | null = null,
    sigma_rad: number | null = null,
    sigma_nvox: number | null = null,
    ratio_sigma: number | null = null,
    output_intermed: boolean = false,
    edge_bnd_nn: number | null = null,
    edge_bnd_side: string | null = null,
    edge_bnd_scale: boolean = false,
    only2d: string | null = null,
    runner: Runner | null = null,
): V3dedgedogOutputs {
    const params = v_3dedgedog_params(input, prefix, mask, automask, sigma_rad, sigma_nvox, ratio_sigma, output_intermed, edge_bnd_nn, edge_bnd_side, edge_bnd_scale, only2d)
    return v_3dedgedog_execute(params, runner);
}


export {
      V3dedgedogOutputs,
      V_3DEDGEDOG_METADATA,
      v_3dedgedog,
      v_3dedgedog_execute,
      v_3dedgedog_params,
};
