// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ANTS_APPLY_TRANSFORMS_METADATA: Metadata = {
    id: "8209354b35fca6222f53525ec72fc9f4429a7c4a.boutiques",
    name: "antsApplyTransforms",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface AntsApplyTransformsWarpedOutputParameters {
    "__STYXTYPE__": "warpedOutput";
    "warpedOutputFileName": string;
}


interface AntsApplyTransformsCompositeDisplacementFieldOutputParameters {
    "__STYXTYPE__": "compositeDisplacementFieldOutput";
    "compositeDisplacementField": string;
    "printOutCompositeWarpFile"?: 0 | 1 | null | undefined;
}


interface AntsApplyTransformsGenericAffineTransformOutputParameters {
    "__STYXTYPE__": "genericAffineTransformOutput";
    "genericAffineTransformFile": string;
    "calculateInverse"?: 0 | 1 | null | undefined;
}


interface AntsApplyTransformsLinearParameters {
    "__STYXTYPE__": "linear";
}


interface AntsApplyTransformsNearestNeighborParameters {
    "__STYXTYPE__": "nearestNeighbor";
}


interface AntsApplyTransformsMultiLabelnoparamsParameters {
    "__STYXTYPE__": "multiLabelnoparams";
}


interface AntsApplyTransformsSigmaParameters {
    "__STYXTYPE__": "sigma";
    "sigma": number;
}


interface AntsApplyTransformsAlphaParameters {
    "__STYXTYPE__": "alpha";
    "alpha": number;
}


interface AntsApplyTransformsParamParameters {
    "__STYXTYPE__": "param";
    "params": Array<AntsApplyTransformsSigmaParameters | AntsApplyTransformsAlphaParameters>;
}


interface AntsApplyTransformsMultiLabelParameters {
    "__STYXTYPE__": "multiLabel";
    "params": AntsApplyTransformsParamParameters;
}


interface AntsApplyTransformsGaussianParameters {
    "__STYXTYPE__": "gaussian";
    "sigma"?: number | null | undefined;
    "alpha"?: number | null | undefined;
}


interface AntsApplyTransformsBsplineParameters {
    "__STYXTYPE__": "bspline";
    "order"?: number | null | undefined;
}


interface AntsApplyTransformsCosineWindowedSincParameters {
    "__STYXTYPE__": "cosineWindowedSinc";
}


interface AntsApplyTransformsWelchWindowedSincParameters {
    "__STYXTYPE__": "welchWindowedSinc";
}


interface AntsApplyTransformsHammingWindowedSincParameters {
    "__STYXTYPE__": "hammingWindowedSinc";
}


interface AntsApplyTransformsLanczosWindowedSincParameters {
    "__STYXTYPE__": "lanczosWindowedSinc";
}


interface AntsApplyTransformsGenericLabelParameters {
    "__STYXTYPE__": "genericLabel";
    "interpolator"?: string | null | undefined;
}


interface AntsApplyTransformsTransformFileNameParameters {
    "__STYXTYPE__": "transformFileName";
    "transformFileName": InputPathType;
}


interface AntsApplyTransformsUseInverseParameters {
    "__STYXTYPE__": "useInverse";
    "transformFileName": InputPathType;
}


interface AntsApplyTransformsParameters {
    "__STYXTYPE__": "antsApplyTransforms";
    "dimensionality"?: 2 | 3 | 4 | null | undefined;
    "input_image_type"?: 0 | 1 | 2 | 3 | 4 | 5 | null | undefined;
    "input_image": InputPathType;
    "reference_image": InputPathType;
    "output": AntsApplyTransformsWarpedOutputParameters | AntsApplyTransformsCompositeDisplacementFieldOutputParameters | AntsApplyTransformsGenericAffineTransformOutputParameters;
    "interpolation"?: AntsApplyTransformsLinearParameters | AntsApplyTransformsNearestNeighborParameters | AntsApplyTransformsMultiLabelnoparamsParameters | AntsApplyTransformsMultiLabelParameters | AntsApplyTransformsGaussianParameters | AntsApplyTransformsBsplineParameters | AntsApplyTransformsCosineWindowedSincParameters | AntsApplyTransformsWelchWindowedSincParameters | AntsApplyTransformsHammingWindowedSincParameters | AntsApplyTransformsLanczosWindowedSincParameters | AntsApplyTransformsGenericLabelParameters | null | undefined;
    "output_data_type"?: "char" | "uchar" | "short" | "int" | "float" | "double" | "default" | null | undefined;
    "transform"?: Array<AntsApplyTransformsTransformFileNameParameters | AntsApplyTransformsUseInverseParameters> | null | undefined;
    "default_value"?: number | null | undefined;
    "static_cast_for_R"?: string | null | undefined;
    "float"?: 0 | 1 | null | undefined;
    "verbose"?: 0 | 1 | null | undefined;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "antsApplyTransforms": ants_apply_transforms_cargs,
        "warpedOutput": ants_apply_transforms_warped_output_cargs,
        "compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_cargs,
        "genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_cargs,
        "linear": ants_apply_transforms_linear_cargs,
        "nearestNeighbor": ants_apply_transforms_nearest_neighbor_cargs,
        "multiLabelnoparams": ants_apply_transforms_multi_labelnoparams_cargs,
        "multiLabel": ants_apply_transforms_multi_label_cargs,
        "param": ants_apply_transforms_param_cargs,
        "sigma": ants_apply_transforms_sigma_cargs,
        "alpha": ants_apply_transforms_alpha_cargs,
        "gaussian": ants_apply_transforms_gaussian_cargs,
        "bspline": ants_apply_transforms_bspline_cargs,
        "cosineWindowedSinc": ants_apply_transforms_cosine_windowed_sinc_cargs,
        "welchWindowedSinc": ants_apply_transforms_welch_windowed_sinc_cargs,
        "hammingWindowedSinc": ants_apply_transforms_hamming_windowed_sinc_cargs,
        "lanczosWindowedSinc": ants_apply_transforms_lanczos_windowed_sinc_cargs,
        "genericLabel": ants_apply_transforms_generic_label_cargs,
        "transformFileName": ants_apply_transforms_transform_file_name_cargs,
        "useInverse": ants_apply_transforms_use_inverse_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "antsApplyTransforms": ants_apply_transforms_outputs,
        "warpedOutput": ants_apply_transforms_warped_output_outputs,
        "compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_outputs,
        "genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `AntsApplyTransformsWarpedOutputParameters(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsWarpedOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Warped image.
     */
    output_image_outfile: OutputPathType;
}


function ants_apply_transforms_warped_output_params(
    warped_output_file_name: string,
): AntsApplyTransformsWarpedOutputParameters {
    /**
     * Build parameters.
    
     * @param warped_output_file_name Output file name.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "warpedOutput" as const,
        "warpedOutputFileName": warped_output_file_name,
    };
    return params;
}


function ants_apply_transforms_warped_output_cargs(
    params: AntsApplyTransformsWarpedOutputParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push((params["warpedOutputFileName"] ?? null));
    return cargs;
}


function ants_apply_transforms_warped_output_outputs(
    params: AntsApplyTransformsWarpedOutputParameters,
    execution: Execution,
): AntsApplyTransformsWarpedOutputOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: AntsApplyTransformsWarpedOutputOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["warpedOutputFileName"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `AntsApplyTransformsCompositeDisplacementFieldOutputParameters(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsCompositeDisplacementFieldOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Warped image.
     */
    output_image_outfile: OutputPathType;
}


function ants_apply_transforms_composite_displacement_field_output_params(
    composite_displacement_field: string,
    print_out_composite_warp_file: 0 | 1 | null = null,
): AntsApplyTransformsCompositeDisplacementFieldOutputParameters {
    /**
     * Build parameters.
    
     * @param composite_displacement_field Output file name.
     * @param print_out_composite_warp_file Output a composite warp file instead of a transformed image.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "compositeDisplacementFieldOutput" as const,
        "compositeDisplacementField": composite_displacement_field,
    };
    if (print_out_composite_warp_file !== null) {
        params["printOutCompositeWarpFile"] = print_out_composite_warp_file;
    }
    return params;
}


function ants_apply_transforms_composite_displacement_field_output_cargs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    if ((params["printOutCompositeWarpFile"] ?? null) !== null) {
        cargs.push(["[", (params["compositeDisplacementField"] ?? null), ",printOutCompositeWarpFile=", String((params["printOutCompositeWarpFile"] ?? null)), "]"].join(''));
    }
    return cargs;
}


function ants_apply_transforms_composite_displacement_field_output_outputs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
    execution: Execution,
): AntsApplyTransformsCompositeDisplacementFieldOutputOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: AntsApplyTransformsCompositeDisplacementFieldOutputOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["compositeDisplacementField"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `AntsApplyTransformsGenericAffineTransformOutputParameters(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsGenericAffineTransformOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Warped image.
     */
    output_image_outfile: OutputPathType;
}


function ants_apply_transforms_generic_affine_transform_output_params(
    generic_affine_transform_file: string,
    calculate_inverse: 0 | 1 | null = null,
): AntsApplyTransformsGenericAffineTransformOutputParameters {
    /**
     * Build parameters.
    
     * @param generic_affine_transform_file Output file name.
     * @param calculate_inverse Calculate the inverse of the affine transform.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "genericAffineTransformOutput" as const,
        "genericAffineTransformFile": generic_affine_transform_file,
    };
    if (calculate_inverse !== null) {
        params["calculateInverse"] = calculate_inverse;
    }
    return params;
}


function ants_apply_transforms_generic_affine_transform_output_cargs(
    params: AntsApplyTransformsGenericAffineTransformOutputParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    if ((params["calculateInverse"] ?? null) !== null) {
        cargs.push(["Linear[", (params["genericAffineTransformFile"] ?? null), ",calculateInverse=", String((params["calculateInverse"] ?? null)), "]"].join(''));
    }
    return cargs;
}


function ants_apply_transforms_generic_affine_transform_output_outputs(
    params: AntsApplyTransformsGenericAffineTransformOutputParameters,
    execution: Execution,
): AntsApplyTransformsGenericAffineTransformOutputOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: AntsApplyTransformsGenericAffineTransformOutputOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["genericAffineTransformFile"] ?? null)].join('')),
    };
    return ret;
}


function ants_apply_transforms_linear_params(
): AntsApplyTransformsLinearParameters {
    /**
     * Build parameters.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "linear" as const,
    };
    return params;
}


function ants_apply_transforms_linear_cargs(
    params: AntsApplyTransformsLinearParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("Linear");
    return cargs;
}


function ants_apply_transforms_nearest_neighbor_params(
): AntsApplyTransformsNearestNeighborParameters {
    /**
     * Build parameters.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "nearestNeighbor" as const,
    };
    return params;
}


function ants_apply_transforms_nearest_neighbor_cargs(
    params: AntsApplyTransformsNearestNeighborParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("NearestNeighbor");
    return cargs;
}


function ants_apply_transforms_multi_labelnoparams_params(
): AntsApplyTransformsMultiLabelnoparamsParameters {
    /**
     * Build parameters.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "multiLabelnoparams" as const,
    };
    return params;
}


function ants_apply_transforms_multi_labelnoparams_cargs(
    params: AntsApplyTransformsMultiLabelnoparamsParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("MultiLabel");
    return cargs;
}


function ants_apply_transforms_sigma_params(
    sigma: number,
): AntsApplyTransformsSigmaParameters {
    /**
     * Build parameters.
    
     * @param sigma Sigma value.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "sigma" as const,
        "sigma": sigma,
    };
    return params;
}


function ants_apply_transforms_sigma_cargs(
    params: AntsApplyTransformsSigmaParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push(["sigma=", String((params["sigma"] ?? null))].join(''));
    return cargs;
}


function ants_apply_transforms_alpha_params(
    alpha: number,
): AntsApplyTransformsAlphaParameters {
    /**
     * Build parameters.
    
     * @param alpha Alpha value.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "alpha" as const,
        "alpha": alpha,
    };
    return params;
}


function ants_apply_transforms_alpha_cargs(
    params: AntsApplyTransformsAlphaParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push(["alpha=", String((params["alpha"] ?? null))].join(''));
    return cargs;
}


function ants_apply_transforms_param_params(
    params_: Array<AntsApplyTransformsSigmaParameters | AntsApplyTransformsAlphaParameters>,
): AntsApplyTransformsParamParameters {
    /**
     * Build parameters.
    
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "param" as const,
        "params": params_,
    };
    return params;
}


function ants_apply_transforms_param_cargs(
    params: AntsApplyTransformsParamParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push(["[", (params["params"] ?? null).map(s => dynCargs(s.__STYXTYPE__)(s, execution)).flat().join(","), "]"].join(''));
    return cargs;
}


function ants_apply_transforms_multi_label_params(
    params_: AntsApplyTransformsParamParameters,
): AntsApplyTransformsMultiLabelParameters {
    /**
     * Build parameters.
    
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "multiLabel" as const,
        "params": params_,
    };
    return params;
}


function ants_apply_transforms_multi_label_cargs(
    params: AntsApplyTransformsMultiLabelParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push(["MultiLabel", dynCargs((params["params"] ?? null).__STYXTYPE__)((params["params"] ?? null), execution).join("")].join(''));
    return cargs;
}


function ants_apply_transforms_gaussian_params(
    sigma: number | null = null,
    alpha: number | null = null,
): AntsApplyTransformsGaussianParameters {
    /**
     * Build parameters.
    
     * @param sigma Sigma value.
     * @param alpha Alpha value.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "gaussian" as const,
    };
    if (sigma !== null) {
        params["sigma"] = sigma;
    }
    if (alpha !== null) {
        params["alpha"] = alpha;
    }
    return params;
}


function ants_apply_transforms_gaussian_cargs(
    params: AntsApplyTransformsGaussianParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    if ((params["sigma"] ?? null) !== null || (params["alpha"] ?? null) !== null) {
        cargs.push(["Gaussian[sigma=", (((params["sigma"] ?? null) !== null) ? String((params["sigma"] ?? null)) : ""), ",alpha=", (((params["alpha"] ?? null) !== null) ? String((params["alpha"] ?? null)) : ""), "]"].join(''));
    }
    return cargs;
}


function ants_apply_transforms_bspline_params(
    order: number | null = null,
): AntsApplyTransformsBsplineParameters {
    /**
     * Build parameters.
    
     * @param order Order value.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "bspline" as const,
    };
    if (order !== null) {
        params["order"] = order;
    }
    return params;
}


function ants_apply_transforms_bspline_cargs(
    params: AntsApplyTransformsBsplineParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    if ((params["order"] ?? null) !== null) {
        cargs.push(["BSpline[order=", String((params["order"] ?? null)), "]"].join(''));
    }
    return cargs;
}


function ants_apply_transforms_cosine_windowed_sinc_params(
): AntsApplyTransformsCosineWindowedSincParameters {
    /**
     * Build parameters.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "cosineWindowedSinc" as const,
    };
    return params;
}


function ants_apply_transforms_cosine_windowed_sinc_cargs(
    params: AntsApplyTransformsCosineWindowedSincParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("CosineWindowedSinc");
    return cargs;
}


function ants_apply_transforms_welch_windowed_sinc_params(
): AntsApplyTransformsWelchWindowedSincParameters {
    /**
     * Build parameters.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "welchWindowedSinc" as const,
    };
    return params;
}


function ants_apply_transforms_welch_windowed_sinc_cargs(
    params: AntsApplyTransformsWelchWindowedSincParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("WelchWindowedSinc");
    return cargs;
}


function ants_apply_transforms_hamming_windowed_sinc_params(
): AntsApplyTransformsHammingWindowedSincParameters {
    /**
     * Build parameters.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "hammingWindowedSinc" as const,
    };
    return params;
}


function ants_apply_transforms_hamming_windowed_sinc_cargs(
    params: AntsApplyTransformsHammingWindowedSincParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("HammingWindowedSinc");
    return cargs;
}


function ants_apply_transforms_lanczos_windowed_sinc_params(
): AntsApplyTransformsLanczosWindowedSincParameters {
    /**
     * Build parameters.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "lanczosWindowedSinc" as const,
    };
    return params;
}


function ants_apply_transforms_lanczos_windowed_sinc_cargs(
    params: AntsApplyTransformsLanczosWindowedSincParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("LanczosWindowedSinc");
    return cargs;
}


function ants_apply_transforms_generic_label_params(
    interpolator: string | null = null,
): AntsApplyTransformsGenericLabelParameters {
    /**
     * Build parameters.
    
     * @param interpolator Interpolator value.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "genericLabel" as const,
    };
    if (interpolator !== null) {
        params["interpolator"] = interpolator;
    }
    return params;
}


function ants_apply_transforms_generic_label_cargs(
    params: AntsApplyTransformsGenericLabelParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    if ((params["interpolator"] ?? null) !== null) {
        cargs.push(["GenericLabel[interpolator=", (params["interpolator"] ?? null), "]"].join(''));
    }
    return cargs;
}


function ants_apply_transforms_transform_file_name_params(
    transform_file_name: InputPathType,
): AntsApplyTransformsTransformFileNameParameters {
    /**
     * Build parameters.
    
     * @param transform_file_name Transform file name.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "transformFileName" as const,
        "transformFileName": transform_file_name,
    };
    return params;
}


function ants_apply_transforms_transform_file_name_cargs(
    params: AntsApplyTransformsTransformFileNameParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["transformFileName"] ?? null)));
    return cargs;
}


function ants_apply_transforms_use_inverse_params(
    transform_file_name: InputPathType,
): AntsApplyTransformsUseInverseParameters {
    /**
     * Build parameters.
    
     * @param transform_file_name Transform file name.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "useInverse" as const,
        "transformFileName": transform_file_name,
    };
    return params;
}


function ants_apply_transforms_use_inverse_cargs(
    params: AntsApplyTransformsUseInverseParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push(["[", execution.inputFile((params["transformFileName"] ?? null)), ",useInverse]"].join(''));
    return cargs;
}


/**
 * Output object returned when calling `ants_apply_transforms(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Outputs from `AntsApplyTransformsWarpedOutputParameters` or `AntsApplyTransformsCompositeDisplacementFieldOutputParameters` or `AntsApplyTransformsGenericAffineTransformOutputParameters`.
     */
    output: AntsApplyTransformsWarpedOutputOutputs | AntsApplyTransformsCompositeDisplacementFieldOutputOutputs | AntsApplyTransformsGenericAffineTransformOutputOutputs;
}


function ants_apply_transforms_params(
    input_image: InputPathType,
    reference_image: InputPathType,
    output: AntsApplyTransformsWarpedOutputParameters | AntsApplyTransformsCompositeDisplacementFieldOutputParameters | AntsApplyTransformsGenericAffineTransformOutputParameters,
    dimensionality: 2 | 3 | 4 | null = null,
    input_image_type: 0 | 1 | 2 | 3 | 4 | 5 | null = null,
    interpolation: AntsApplyTransformsLinearParameters | AntsApplyTransformsNearestNeighborParameters | AntsApplyTransformsMultiLabelnoparamsParameters | AntsApplyTransformsMultiLabelParameters | AntsApplyTransformsGaussianParameters | AntsApplyTransformsBsplineParameters | AntsApplyTransformsCosineWindowedSincParameters | AntsApplyTransformsWelchWindowedSincParameters | AntsApplyTransformsHammingWindowedSincParameters | AntsApplyTransformsLanczosWindowedSincParameters | AntsApplyTransformsGenericLabelParameters | null = null,
    output_data_type: "char" | "uchar" | "short" | "int" | "float" | "double" | "default" | null = null,
    transform: Array<AntsApplyTransformsTransformFileNameParameters | AntsApplyTransformsUseInverseParameters> | null = null,
    default_value: number | null = null,
    static_cast_for_r: string | null = null,
    float: 0 | 1 | null = null,
    verbose: 0 | 1 | null = null,
): AntsApplyTransformsParameters {
    /**
     * Build parameters.
    
     * @param input_image Currently, the only input objects supported are image objects. However, the current framework allows for warping of other objects such as meshes and point sets.
     * @param reference_image For warping input images, the reference image defines the spacing, origin, size, and direction of the output warped image.
     * @param output One can either output the warped image or, if the boolean is set, one can print out the displacement field based on the composite transform and the reference image. A third option is to compose all affine transforms and (if boolean is set) calculate its inverse which is then written to an ITK file.
     * @param dimensionality This option forces the image to be treated as a specified-dimensional image. if not specified, antswarp tries to infer the dimensionality from the input image.
     * @param input_image_type Option specifying the input image type of scalar (default), vector, tensor, time series, or multi-channel. A time series image is a scalar image defined by an additional dimension for the time component whereas a multi-channel image is a vector image with only spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
     * @param interpolation Several interpolation options are available in ITK. These have all been made available.
     * @param output_data_type Output image data type. This is a direct typecast; output values are not rescaled. Default is to use the internal data type (float or double). uchar is unsigned char; others are signed. WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values exceed the range allowed by your choice. Note that some pixel types are not supported by some image formats. e.g. int is not supported by jpg.
     * @param transform Several transform options are supported including all those defined in the ITK library in addition to a deformation field transform. The ordering of the transformations follows the ordering specified on the command line. An identity transform is pushed onto the transformation stack. Each new transform encountered on the command line is also pushed onto the transformation stack. Then, to warp the input object, each point comprising the input object is warped first according to the last transform pushed onto the stack followed by the second to last transform, etc. until the last transform encountered which is the identity transform. Also, it should be noted that the inverse transform can be accommodated with the usual caveat that such an inverse must be defined by the specified transform class.
     * @param default_value Default voxel value to be used with input images only. Specifies the voxel value when the input point maps outside the output domain. With tensor input images, specifies the default voxel eigenvalues.
     * @param static_cast_for_r Forces static cast in ReadTransform (for R).
     * @param float Use float instead of double for computations.
     * @param verbose Verbose output.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "antsApplyTransforms" as const,
        "input_image": input_image,
        "reference_image": reference_image,
        "output": output,
    };
    if (dimensionality !== null) {
        params["dimensionality"] = dimensionality;
    }
    if (input_image_type !== null) {
        params["input_image_type"] = input_image_type;
    }
    if (interpolation !== null) {
        params["interpolation"] = interpolation;
    }
    if (output_data_type !== null) {
        params["output_data_type"] = output_data_type;
    }
    if (transform !== null) {
        params["transform"] = transform;
    }
    if (default_value !== null) {
        params["default_value"] = default_value;
    }
    if (static_cast_for_r !== null) {
        params["static_cast_for_R"] = static_cast_for_r;
    }
    if (float !== null) {
        params["float"] = float;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    return params;
}


function ants_apply_transforms_cargs(
    params: AntsApplyTransformsParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("antsApplyTransforms");
    if ((params["dimensionality"] ?? null) !== null) {
        cargs.push(
            "--dimensionality",
            String((params["dimensionality"] ?? null))
        );
    }
    if ((params["input_image_type"] ?? null) !== null) {
        cargs.push(
            "--input-image-type",
            String((params["input_image_type"] ?? null))
        );
    }
    cargs.push(
        "--input",
        execution.inputFile((params["input_image"] ?? null))
    );
    cargs.push(
        "--reference-image",
        execution.inputFile((params["reference_image"] ?? null))
    );
    cargs.push(
        "--output",
        ...dynCargs((params["output"] ?? null).__STYXTYPE__)((params["output"] ?? null), execution)
    );
    if ((params["interpolation"] ?? null) !== null) {
        cargs.push(
            "--interpolation",
            ...dynCargs((params["interpolation"] ?? null).__STYXTYPE__)((params["interpolation"] ?? null), execution)
        );
    }
    if ((params["output_data_type"] ?? null) !== null) {
        cargs.push(
            "--output-data-type",
            (params["output_data_type"] ?? null)
        );
    }
    if ((params["transform"] ?? null) !== null) {
        cargs.push(
            "--transform",
            ...(params["transform"] ?? null).map(s => dynCargs(s.__STYXTYPE__)(s, execution)).flat()
        );
    }
    if ((params["default_value"] ?? null) !== null) {
        cargs.push(
            "--default-value",
            String((params["default_value"] ?? null))
        );
    }
    if ((params["static_cast_for_R"] ?? null) !== null) {
        cargs.push(
            "--static-cast-for-R",
            (params["static_cast_for_R"] ?? null)
        );
    }
    if ((params["float"] ?? null) !== null) {
        cargs.push(
            "--float",
            String((params["float"] ?? null))
        );
    }
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "--verbose",
            String((params["verbose"] ?? null))
        );
    }
    return cargs;
}


function ants_apply_transforms_outputs(
    params: AntsApplyTransformsParameters,
    execution: Execution,
): AntsApplyTransformsOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: AntsApplyTransformsOutputs = {
        root: execution.outputFile("."),
        output: dynOutputs((params["output"] ?? null).__STYXTYPE__)?.((params["output"] ?? null), execution),
    };
    return ret;
}


function ants_apply_transforms_execute(
    params: AntsApplyTransformsParameters,
    execution: Execution,
): AntsApplyTransformsOutputs {
    /**
     * antsApplyTransforms, applied to an input image, transforms it according to a reference image and a transform (or a set of transforms).
     * 
     * Author: ANTs Developers
     * 
     * URL: https://github.com/ANTsX/ANTs
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
     */
    params = execution.params(params)
    const cargs = ants_apply_transforms_cargs(params, execution)
    const ret = ants_apply_transforms_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function ants_apply_transforms(
    input_image: InputPathType,
    reference_image: InputPathType,
    output: AntsApplyTransformsWarpedOutputParameters | AntsApplyTransformsCompositeDisplacementFieldOutputParameters | AntsApplyTransformsGenericAffineTransformOutputParameters,
    dimensionality: 2 | 3 | 4 | null = null,
    input_image_type: 0 | 1 | 2 | 3 | 4 | 5 | null = null,
    interpolation: AntsApplyTransformsLinearParameters | AntsApplyTransformsNearestNeighborParameters | AntsApplyTransformsMultiLabelnoparamsParameters | AntsApplyTransformsMultiLabelParameters | AntsApplyTransformsGaussianParameters | AntsApplyTransformsBsplineParameters | AntsApplyTransformsCosineWindowedSincParameters | AntsApplyTransformsWelchWindowedSincParameters | AntsApplyTransformsHammingWindowedSincParameters | AntsApplyTransformsLanczosWindowedSincParameters | AntsApplyTransformsGenericLabelParameters | null = null,
    output_data_type: "char" | "uchar" | "short" | "int" | "float" | "double" | "default" | null = null,
    transform: Array<AntsApplyTransformsTransformFileNameParameters | AntsApplyTransformsUseInverseParameters> | null = null,
    default_value: number | null = null,
    static_cast_for_r: string | null = null,
    float: 0 | 1 | null = null,
    verbose: 0 | 1 | null = null,
    runner: Runner | null = null,
): AntsApplyTransformsOutputs {
    /**
     * antsApplyTransforms, applied to an input image, transforms it according to a reference image and a transform (or a set of transforms).
     * 
     * Author: ANTs Developers
     * 
     * URL: https://github.com/ANTsX/ANTs
    
     * @param input_image Currently, the only input objects supported are image objects. However, the current framework allows for warping of other objects such as meshes and point sets.
     * @param reference_image For warping input images, the reference image defines the spacing, origin, size, and direction of the output warped image.
     * @param output One can either output the warped image or, if the boolean is set, one can print out the displacement field based on the composite transform and the reference image. A third option is to compose all affine transforms and (if boolean is set) calculate its inverse which is then written to an ITK file.
     * @param dimensionality This option forces the image to be treated as a specified-dimensional image. if not specified, antswarp tries to infer the dimensionality from the input image.
     * @param input_image_type Option specifying the input image type of scalar (default), vector, tensor, time series, or multi-channel. A time series image is a scalar image defined by an additional dimension for the time component whereas a multi-channel image is a vector image with only spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
     * @param interpolation Several interpolation options are available in ITK. These have all been made available.
     * @param output_data_type Output image data type. This is a direct typecast; output values are not rescaled. Default is to use the internal data type (float or double). uchar is unsigned char; others are signed. WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values exceed the range allowed by your choice. Note that some pixel types are not supported by some image formats. e.g. int is not supported by jpg.
     * @param transform Several transform options are supported including all those defined in the ITK library in addition to a deformation field transform. The ordering of the transformations follows the ordering specified on the command line. An identity transform is pushed onto the transformation stack. Each new transform encountered on the command line is also pushed onto the transformation stack. Then, to warp the input object, each point comprising the input object is warped first according to the last transform pushed onto the stack followed by the second to last transform, etc. until the last transform encountered which is the identity transform. Also, it should be noted that the inverse transform can be accommodated with the usual caveat that such an inverse must be defined by the specified transform class.
     * @param default_value Default voxel value to be used with input images only. Specifies the voxel value when the input point maps outside the output domain. With tensor input images, specifies the default voxel eigenvalues.
     * @param static_cast_for_r Forces static cast in ReadTransform (for R).
     * @param float Use float instead of double for computations.
     * @param verbose Verbose output.
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ANTS_APPLY_TRANSFORMS_METADATA);
    const params = ants_apply_transforms_params(input_image, reference_image, output, dimensionality, input_image_type, interpolation, output_data_type, transform, default_value, static_cast_for_r, float, verbose)
    return ants_apply_transforms_execute(params, execution);
}


export {
      ANTS_APPLY_TRANSFORMS_METADATA,
      AntsApplyTransformsAlphaParameters,
      AntsApplyTransformsBsplineParameters,
      AntsApplyTransformsCompositeDisplacementFieldOutputOutputs,
      AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
      AntsApplyTransformsCosineWindowedSincParameters,
      AntsApplyTransformsGaussianParameters,
      AntsApplyTransformsGenericAffineTransformOutputOutputs,
      AntsApplyTransformsGenericAffineTransformOutputParameters,
      AntsApplyTransformsGenericLabelParameters,
      AntsApplyTransformsHammingWindowedSincParameters,
      AntsApplyTransformsLanczosWindowedSincParameters,
      AntsApplyTransformsLinearParameters,
      AntsApplyTransformsMultiLabelParameters,
      AntsApplyTransformsMultiLabelnoparamsParameters,
      AntsApplyTransformsNearestNeighborParameters,
      AntsApplyTransformsOutputs,
      AntsApplyTransformsParamParameters,
      AntsApplyTransformsParameters,
      AntsApplyTransformsSigmaParameters,
      AntsApplyTransformsTransformFileNameParameters,
      AntsApplyTransformsUseInverseParameters,
      AntsApplyTransformsWarpedOutputOutputs,
      AntsApplyTransformsWarpedOutputParameters,
      AntsApplyTransformsWelchWindowedSincParameters,
      ants_apply_transforms,
      ants_apply_transforms_alpha_params,
      ants_apply_transforms_bspline_params,
      ants_apply_transforms_composite_displacement_field_output_params,
      ants_apply_transforms_cosine_windowed_sinc_params,
      ants_apply_transforms_gaussian_params,
      ants_apply_transforms_generic_affine_transform_output_params,
      ants_apply_transforms_generic_label_params,
      ants_apply_transforms_hamming_windowed_sinc_params,
      ants_apply_transforms_lanczos_windowed_sinc_params,
      ants_apply_transforms_linear_params,
      ants_apply_transforms_multi_label_params,
      ants_apply_transforms_multi_labelnoparams_params,
      ants_apply_transforms_nearest_neighbor_params,
      ants_apply_transforms_param_params,
      ants_apply_transforms_params,
      ants_apply_transforms_sigma_params,
      ants_apply_transforms_transform_file_name_params,
      ants_apply_transforms_use_inverse_params,
      ants_apply_transforms_warped_output_params,
      ants_apply_transforms_welch_windowed_sinc_params,
};
