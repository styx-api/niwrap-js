// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const GREEDY_METADATA: Metadata = {
    id: "8773061e4151d52c79dfd7c67e140eb0646f36ba.boutiques",
    name: "greedy",
    package: "greedy",
    container_image_tag: "pyushkevich/itksnap:v3.8.2",
};


interface GreedyInputImagesParameters {
    "@type": "greedy.greedy.input_images";
    "fixed": InputPathType;
    "moving": InputPathType;
}


interface GreedyInvertParameters {
    "@type": "greedy.greedy.invert";
    "inwarp": InputPathType;
    "outwarp": string;
}


interface GreedyRootParameters {
    "@type": "greedy.greedy.root";
    "inwarp": InputPathType;
    "outwarp": string;
    "n": number;
}


interface GreedyJacobianParameters {
    "@type": "greedy.greedy.jacobian";
    "inwarp": InputPathType;
    "outjac": string;
}


interface GreedyMetricParameters {
    "@type": "greedy.greedy.metric";
    "metric_type": "SSD" | "MI" | "NMI" | "NCC" | "MAHAL";
    "metric_param"?: number | null | undefined;
}


interface GreedyTjrParameters {
    "@type": "greedy.greedy.tjr";
    "mesh": InputPathType;
    "weight": number;
}


interface GreedySearchParameters {
    "@type": "greedy.greedy.search";
    "n": number;
    "rot": string;
    "tran": number;
}


interface GreedyResliceMovingImageParameters {
    "@type": "greedy.greedy.reslice_moving_image";
    "moving": InputPathType;
    "output": string;
}


interface GreedyResliceSurfaceParameters {
    "@type": "greedy.greedy.reslice_surface";
    "inmesh": InputPathType;
    "outmesh": string;
}


interface GreedyResliceSimplexJacobianParameters {
    "@type": "greedy.greedy.reslice_simplex_jacobian";
    "inmesh": InputPathType;
    "outmesh": string;
}


interface GreedyParameters {
    "@type": "greedy.greedy";
    "dimensions": number;
    "input_images"?: GreedyInputImagesParameters | null | undefined;
    "output"?: string | null | undefined;
    "affine": boolean;
    "brute"?: string | null | undefined;
    "moments"?: 1 | 2 | null | undefined;
    "reslice"?: Array<InputPathType> | null | undefined;
    "invert"?: GreedyInvertParameters | null | undefined;
    "root"?: GreedyRootParameters | null | undefined;
    "jacobian"?: GreedyJacobianParameters | null | undefined;
    "metric_mode": boolean;
    "defopt": boolean;
    "weight"?: number | null | undefined;
    "metric"?: GreedyMetricParameters | null | undefined;
    "step_size"?: string | null | undefined;
    "iterations"?: string | null | undefined;
    "threads"?: number | null | undefined;
    "fixed_mask"?: InputPathType | null | undefined;
    "gm_trim"?: number | null | undefined;
    "moving_mask"?: InputPathType | null | undefined;
    "wncc_mask_dilate": boolean;
    "reference_image"?: InputPathType | null | undefined;
    "ref_pad"?: number | null | undefined;
    "background"?: string | null | undefined;
    "input_transform"?: InputPathType | null | undefined;
    "zero_last_dimension": boolean;
    "time_step_mode"?: "CONST" | "SCALE" | "SCALEDOWN" | null | undefined;
    "smoothing"?: string | null | undefined;
    "inverse_warp"?: InputPathType | null | undefined;
    "root_warp"?: InputPathType | null | undefined;
    "warp_precision"?: number | null | undefined;
    "noise"?: number | null | undefined;
    "exponent"?: number | null | undefined;
    "svf_mode": boolean;
    "svlb": boolean;
    "sv_incompr": boolean;
    "initial_warp"?: InputPathType | null | undefined;
    "tjr"?: GreedyTjrParameters | null | undefined;
    "wr"?: number | null | undefined;
    "initial_affine"?: InputPathType | null | undefined;
    "ia_identity": boolean;
    "ia_voxel_grid": boolean;
    "ia_image_centers": boolean;
    "ia_image_side"?: string | null | undefined;
    "ia_moments"?: 1 | 2 | null | undefined;
    "affine_dof"?: 6 | 7 | 12 | null | undefined;
    "jitter"?: number | null | undefined;
    "search"?: GreedySearchParameters | null | undefined;
    "det"?: -1 | 1 | null | undefined;
    "cov_id": boolean;
    "fixed_reslicing_image"?: InputPathType | null | undefined;
    "reslice_moving_image"?: GreedyResliceMovingImageParameters | null | undefined;
    "reslice_surface"?: GreedyResliceSurfaceParameters | null | undefined;
    "interpolation"?: "NN" | "LINEAR" | "LABEL" | null | undefined;
    "reslice_background"?: number | null | undefined;
    "reslice_datatype"?: "auto" | "double" | "float" | "uint" | "int" | "ushort" | "short" | "uchar" | "char" | null | undefined;
    "reslice_composite"?: InputPathType | null | undefined;
    "reslice_jacobian"?: InputPathType | null | undefined;
    "reslice_simplex_jacobian"?: GreedyResliceSimplexJacobianParameters | null | undefined;
    "reslice_mask"?: InputPathType | null | undefined;
    "metric_gradient"?: InputPathType | null | undefined;
    "debug_deriv": boolean;
    "debug_deriv_eps"?: number | null | undefined;
    "debug_aff_obj": boolean;
    "dump_pyramid": boolean;
    "dump_moving": boolean;
    "dump_frequency"?: number | null | undefined;
    "dump_prefix"?: string | null | undefined;
    "powell": boolean;
    "float": boolean;
    "version": boolean;
    "verbosity"?: 0 | 1 | 2 | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "greedy.greedy": greedy_cargs,
        "greedy.greedy.input_images": greedy_input_images_cargs,
        "greedy.greedy.invert": greedy_invert_cargs,
        "greedy.greedy.root": greedy_root_cargs,
        "greedy.greedy.jacobian": greedy_jacobian_cargs,
        "greedy.greedy.metric": greedy_metric_cargs,
        "greedy.greedy.tjr": greedy_tjr_cargs,
        "greedy.greedy.search": greedy_search_cargs,
        "greedy.greedy.reslice_moving_image": greedy_reslice_moving_image_cargs,
        "greedy.greedy.reslice_surface": greedy_reslice_surface_cargs,
        "greedy.greedy.reslice_simplex_jacobian": greedy_reslice_simplex_jacobian_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "greedy.greedy": greedy_outputs,
        "greedy.greedy.invert": greedy_invert_outputs,
        "greedy.greedy.root": greedy_root_outputs,
        "greedy.greedy.jacobian": greedy_jacobian_outputs,
        "greedy.greedy.reslice_moving_image": greedy_reslice_moving_image_outputs,
        "greedy.greedy.reslice_surface": greedy_reslice_surface_outputs,
        "greedy.greedy.reslice_simplex_jacobian": greedy_reslice_simplex_jacobian_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @param fixed The fixed image
 * @param moving The moving image
 *
 * @returns Parameter dictionary
 */
function greedy_input_images_params(
    fixed: InputPathType,
    moving: InputPathType,
): GreedyInputImagesParameters {
    const params = {
        "@type": "greedy.greedy.input_images" as const,
        "fixed": fixed,
        "moving": moving,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_input_images_cargs(
    params: GreedyInputImagesParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["fixed"] ?? null)));
    cargs.push(execution.inputFile((params["moving"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `GreedyInvertParameters | null(...)`.
 *
 * @interface
 */
interface GreedyInvertOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The inverted warp file
     */
    inverted_warp: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inwarp The input warp to be inverted
 * @param outwarp The filename for the inverted warp output
 *
 * @returns Parameter dictionary
 */
function greedy_invert_params(
    inwarp: InputPathType,
    outwarp: string,
): GreedyInvertParameters {
    const params = {
        "@type": "greedy.greedy.invert" as const,
        "inwarp": inwarp,
        "outwarp": outwarp,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_invert_cargs(
    params: GreedyInvertParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inwarp"] ?? null)));
    cargs.push((params["outwarp"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_invert_outputs(
    params: GreedyInvertParameters,
    execution: Execution,
): GreedyInvertOutputs {
    const ret: GreedyInvertOutputs = {
        root: execution.outputFile("."),
        inverted_warp: execution.outputFile([(params["outwarp"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyRootParameters | null(...)`.
 *
 * @interface
 */
interface GreedyRootOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The 2^N-th root of the input warp
     */
    root_warp: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inwarp The input warp
 * @param outwarp The filename for the root warp output
 * @param n The value of N for 2^N-th root
 *
 * @returns Parameter dictionary
 */
function greedy_root_params(
    inwarp: InputPathType,
    outwarp: string,
    n: number,
): GreedyRootParameters {
    const params = {
        "@type": "greedy.greedy.root" as const,
        "inwarp": inwarp,
        "outwarp": outwarp,
        "n": n,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_root_cargs(
    params: GreedyRootParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inwarp"] ?? null)));
    cargs.push((params["outwarp"] ?? null));
    cargs.push(String((params["n"] ?? null)));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_root_outputs(
    params: GreedyRootParameters,
    execution: Execution,
): GreedyRootOutputs {
    const ret: GreedyRootOutputs = {
        root: execution.outputFile("."),
        root_warp: execution.outputFile([(params["outwarp"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyJacobianParameters | null(...)`.
 *
 * @interface
 */
interface GreedyJacobianOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The Jacobian determinant of the warp
     */
    jacobian_determinant: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inwarp The input warp
 * @param outjac The filename for the Jacobian determinant output
 *
 * @returns Parameter dictionary
 */
function greedy_jacobian_params(
    inwarp: InputPathType,
    outjac: string,
): GreedyJacobianParameters {
    const params = {
        "@type": "greedy.greedy.jacobian" as const,
        "inwarp": inwarp,
        "outjac": outjac,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_jacobian_cargs(
    params: GreedyJacobianParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inwarp"] ?? null)));
    cargs.push((params["outjac"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_jacobian_outputs(
    params: GreedyJacobianParameters,
    execution: Execution,
): GreedyJacobianOutputs {
    const ret: GreedyJacobianOutputs = {
        root: execution.outputFile("."),
        jacobian_determinant: execution.outputFile([(params["outjac"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @param metric_type Type of metric to use
 * @param metric_param Parameter for the metric (e.g., radius for NCC)
 *
 * @returns Parameter dictionary
 */
function greedy_metric_params(
    metric_type: "SSD" | "MI" | "NMI" | "NCC" | "MAHAL",
    metric_param: number | null = null,
): GreedyMetricParameters {
    const params = {
        "@type": "greedy.greedy.metric" as const,
        "metric_type": metric_type,
    };
    if (metric_param !== null) {
        params["metric_param"] = metric_param;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_metric_cargs(
    params: GreedyMetricParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["metric_type"] ?? null));
    if ((params["metric_param"] ?? null) !== null) {
        cargs.push(String((params["metric_param"] ?? null)));
    }
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mesh The tetrahedral mesh file
 * @param weight The weight of the penalty term
 *
 * @returns Parameter dictionary
 */
function greedy_tjr_params(
    mesh: InputPathType,
    weight: number,
): GreedyTjrParameters {
    const params = {
        "@type": "greedy.greedy.tjr" as const,
        "mesh": mesh,
        "weight": weight,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_tjr_cargs(
    params: GreedyTjrParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["mesh"] ?? null)));
    cargs.push(String((params["weight"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param n Number of iterations for random search
 * @param rot Standard deviation of random rotation angle (degrees) or 'any' or 'flip'
 * @param tran Standard deviation of random offset in physical units
 *
 * @returns Parameter dictionary
 */
function greedy_search_params(
    n: number,
    rot: string,
    tran: number,
): GreedySearchParameters {
    const params = {
        "@type": "greedy.greedy.search" as const,
        "n": n,
        "rot": rot,
        "tran": tran,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_search_cargs(
    params: GreedySearchParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(String((params["n"] ?? null)));
    cargs.push((params["rot"] ?? null));
    cargs.push(String((params["tran"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `GreedyResliceMovingImageParameters | null(...)`.
 *
 * @interface
 */
interface GreedyResliceMovingImageOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The resliced output image
     */
    resliced_image: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param moving The moving image to be resliced
 * @param output The filename for the resliced output image
 *
 * @returns Parameter dictionary
 */
function greedy_reslice_moving_image_params(
    moving: InputPathType,
    output: string,
): GreedyResliceMovingImageParameters {
    const params = {
        "@type": "greedy.greedy.reslice_moving_image" as const,
        "moving": moving,
        "output": output,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_reslice_moving_image_cargs(
    params: GreedyResliceMovingImageParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["moving"] ?? null)));
    cargs.push((params["output"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_reslice_moving_image_outputs(
    params: GreedyResliceMovingImageParameters,
    execution: Execution,
): GreedyResliceMovingImageOutputs {
    const ret: GreedyResliceMovingImageOutputs = {
        root: execution.outputFile("."),
        resliced_image: execution.outputFile([(params["output"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyResliceSurfaceParameters | null(...)`.
 *
 * @interface
 */
interface GreedyResliceSurfaceOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The warped output mesh
     */
    warped_mesh: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inmesh The input mesh file
 * @param outmesh The filename for the output warped mesh
 *
 * @returns Parameter dictionary
 */
function greedy_reslice_surface_params(
    inmesh: InputPathType,
    outmesh: string,
): GreedyResliceSurfaceParameters {
    const params = {
        "@type": "greedy.greedy.reslice_surface" as const,
        "inmesh": inmesh,
        "outmesh": outmesh,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_reslice_surface_cargs(
    params: GreedyResliceSurfaceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inmesh"] ?? null)));
    cargs.push((params["outmesh"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_reslice_surface_outputs(
    params: GreedyResliceSurfaceParameters,
    execution: Execution,
): GreedyResliceSurfaceOutputs {
    const ret: GreedyResliceSurfaceOutputs = {
        root: execution.outputFile("."),
        warped_mesh: execution.outputFile([(params["outmesh"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `GreedyResliceSimplexJacobianParameters | null(...)`.
 *
 * @interface
 */
interface GreedyResliceSimplexJacobianOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output mesh with computed Jacobian determinants
     */
    jacobian_mesh: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param inmesh The input simplex mesh file
 * @param outmesh The filename for the output mesh with Jacobian determinants
 *
 * @returns Parameter dictionary
 */
function greedy_reslice_simplex_jacobian_params(
    inmesh: InputPathType,
    outmesh: string,
): GreedyResliceSimplexJacobianParameters {
    const params = {
        "@type": "greedy.greedy.reslice_simplex_jacobian" as const,
        "inmesh": inmesh,
        "outmesh": outmesh,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_reslice_simplex_jacobian_cargs(
    params: GreedyResliceSimplexJacobianParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["inmesh"] ?? null)));
    cargs.push((params["outmesh"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_reslice_simplex_jacobian_outputs(
    params: GreedyResliceSimplexJacobianParameters,
    execution: Execution,
): GreedyResliceSimplexJacobianOutputs {
    const ret: GreedyResliceSimplexJacobianOutputs = {
        root: execution.outputFile("."),
        jacobian_mesh: execution.outputFile([(params["outmesh"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `greedy_(...)`.
 *
 * @interface
 */
interface GreedyOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output file from affine or deformable registration
     */
    output_file: OutputPathType | null;
    /**
     * Outputs from `greedy_invert_outputs`.
     */
    invert: GreedyInvertOutputs | null;
    /**
     * Outputs from `greedy_root_outputs`.
     */
    root_: GreedyRootOutputs | null;
    /**
     * Outputs from `greedy_jacobian_outputs`.
     */
    jacobian: GreedyJacobianOutputs | null;
    /**
     * Outputs from `greedy_reslice_moving_image_outputs`.
     */
    reslice_moving_image: GreedyResliceMovingImageOutputs | null;
    /**
     * Outputs from `greedy_reslice_surface_outputs`.
     */
    reslice_surface: GreedyResliceSurfaceOutputs | null;
    /**
     * Outputs from `greedy_reslice_simplex_jacobian_outputs`.
     */
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianOutputs | null;
}


/**
 * Build parameters.
 *
 * @param dimensions Number of image dimensions
 * @param input_images Image pair (may be repeated)
 * @param output Output file (matrix in affine mode; image in deformable mode, metric computation mode; ignored in reslicing mode)
 * @param affine Perform affine registration and save to output (-o)
 * @param brute Perform a brute force search around each voxel
 * @param moments Perform moments of inertia rigid alignment of given order (1 or 2)
 * @param reslice Reslice images instead of doing registration
 * @param invert Invert previously computed warp
 * @param root Convert 2^N-th root of a warp
 * @param jacobian Compute the Jacobian determinant of the warp
 * @param metric_mode Compute metric between images
 * @param defopt Deformable optimization mode (experimental)
 * @param weight Weight of the next -i pair
 * @param metric Metric for the entire registration
 * @param step_size Step size for optimization (default = 1.0), may also be specified per level (e.g. 0.3x0.1)
 * @param iterations Number of iterations per level of multi-res
 * @param threads Number of allowed concurrent threads
 * @param fixed_mask Fixed image mask (metric gradients computed only over the mask)
 * @param gm_trim Generate the fixed image mask by trimming the extent of the fixed image by given radius
 * @param moving_mask Moving image mask (pixels outside are excluded from metric computation)
 * @param wncc_mask_dilate Specifies that fixed and moving masks should be dilated by the radius of the WNCC metric during registration
 * @param reference_image Use supplied image, rather than fixed image to define the reference space
 * @param ref_pad Define the reference space by padding the fixed image by radius
 * @param background Value to fill missing values when mapping fixed and moving images to reference space
 * @param input_transform Specify transforms (matrices, warps) that map moving image to reference space
 * @param zero_last_dimension Sets sigmas and NCC radius to zero in the last dimension for 2D/3D registration
 * @param time_step_mode Time step behavior mode
 * @param smoothing Smoothing for the greedy update step (e.g., '1.732vox 0.7071vox')
 * @param inverse_warp Compute and write the inverse of the warp field
 * @param root_warp Compute and write the (2^N-th) root of the warp field
 * @param warp_precision Saved warp precision in voxels (default=0.1; 0 for no compression)
 * @param noise Standard deviation of white noise added to moving/fixed images when using NCC metric
 * @param exponent The exponent used for warp inversion, root computation, and in stationary velocity field mode
 * @param svf_mode Perform registration using the stationary velocity model
 * @param svlb Use more accurate but expensive update of v in stationary velocity field mode
 * @param sv_incompr Incompressibility mode, implements Mansi et al. 2011 iLogDemons
 * @param initial_warp Specifies the initial warp to start iteration from
 * @param tjr Apply a regularization penalty based on the Jacobian of a tetrahedral mesh
 * @param wr Weight of SVF smoothness regularization term (default: 1000)
 * @param initial_affine Initial affine matrix for optimization
 * @param ia_identity Initialize affine matrix based on NIFTI headers
 * @param ia_voxel_grid Initialize affine matrix so that voxels with corresponding indices align
 * @param ia_image_centers Initialize affine matrix based on matching image centers
 * @param ia_image_side Initialize affine matrix based on matching center of one image side
 * @param ia_moments Initialize affine matrix based on matching moments of inertia
 * @param affine_dof Degrees of freedom for affine registration. 6=rigid, 7=similarity, 12=affine
 * @param jitter Jitter (in voxel units) applied to sample points (default: 0.5)
 * @param search Random search over rigid transforms before starting optimization
 * @param det Force the determinant of transform to be either 1 (no flip) or -1 (flip)
 * @param cov_id Assume identity covariance (match centers and do flips only, no rotation)
 * @param fixed_reslicing_image Fixed image for reslicing
 * @param reslice_moving_image Moving/output image pair for reslicing
 * @param reslice_surface Fixed/output surface pair (vertices are warped from fixed space to moving)
 * @param interpolation Interpolation for the next pair (NN, LINEAR*, LABEL sigma)
 * @param reslice_background Background (i.e. outside) intensity for the next pair (default 0)
 * @param reslice_datatype Data type for the next pair
 * @param reslice_composite Write composed transforms to outwarp
 * @param reslice_jacobian Write Jacobian determinant image to outjacobian
 * @param reslice_simplex_jacobian Compute Jacobian determinant for a simplex mesh in fixed space
 * @param reslice_mask A binary mask for the fixed image; zero values will be overwritten with background
 * @param metric_gradient Write the gradient of the metric to file
 * @param debug_deriv Enable periodic checks of derivatives (debug)
 * @param debug_deriv_eps Epsilon for derivative debugging
 * @param debug_aff_obj Plot affine objective in neighborhood of -ia matrix
 * @param dump_pyramid Dump the image pyramid at the start of the registration
 * @param dump_moving Dump moving image at each iter
 * @param dump_frequency Dump frequency
 * @param dump_prefix Prefix for dump files (may be a path)
 * @param powell Use Powell's method instead of LGBFS
 * @param float Use single precision floating point (off by default)
 * @param version Print version info
 * @param verbosity Verbosity level (0: none, 1: default, 2: verbose)
 *
 * @returns Parameter dictionary
 */
function greedy_params(
    dimensions: number,
    input_images: GreedyInputImagesParameters | null = null,
    output: string | null = null,
    affine: boolean = false,
    brute: string | null = null,
    moments: 1 | 2 | null = null,
    reslice: Array<InputPathType> | null = null,
    invert: GreedyInvertParameters | null = null,
    root: GreedyRootParameters | null = null,
    jacobian: GreedyJacobianParameters | null = null,
    metric_mode: boolean = false,
    defopt: boolean = false,
    weight: number | null = null,
    metric: GreedyMetricParameters | null = null,
    step_size: string | null = null,
    iterations: string | null = null,
    threads: number | null = null,
    fixed_mask: InputPathType | null = null,
    gm_trim: number | null = null,
    moving_mask: InputPathType | null = null,
    wncc_mask_dilate: boolean = false,
    reference_image: InputPathType | null = null,
    ref_pad: number | null = null,
    background: string | null = null,
    input_transform: InputPathType | null = null,
    zero_last_dimension: boolean = false,
    time_step_mode: "CONST" | "SCALE" | "SCALEDOWN" | null = null,
    smoothing: string | null = null,
    inverse_warp: InputPathType | null = null,
    root_warp: InputPathType | null = null,
    warp_precision: number | null = null,
    noise: number | null = null,
    exponent: number | null = null,
    svf_mode: boolean = false,
    svlb: boolean = false,
    sv_incompr: boolean = false,
    initial_warp: InputPathType | null = null,
    tjr: GreedyTjrParameters | null = null,
    wr: number | null = null,
    initial_affine: InputPathType | null = null,
    ia_identity: boolean = false,
    ia_voxel_grid: boolean = false,
    ia_image_centers: boolean = false,
    ia_image_side: string | null = null,
    ia_moments: 1 | 2 | null = null,
    affine_dof: 6 | 7 | 12 | null = null,
    jitter: number | null = null,
    search: GreedySearchParameters | null = null,
    det: -1 | 1 | null = null,
    cov_id: boolean = false,
    fixed_reslicing_image: InputPathType | null = null,
    reslice_moving_image: GreedyResliceMovingImageParameters | null = null,
    reslice_surface: GreedyResliceSurfaceParameters | null = null,
    interpolation: "NN" | "LINEAR" | "LABEL" | null = null,
    reslice_background: number | null = null,
    reslice_datatype: "auto" | "double" | "float" | "uint" | "int" | "ushort" | "short" | "uchar" | "char" | null = null,
    reslice_composite: InputPathType | null = null,
    reslice_jacobian: InputPathType | null = null,
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianParameters | null = null,
    reslice_mask: InputPathType | null = null,
    metric_gradient: InputPathType | null = null,
    debug_deriv: boolean = false,
    debug_deriv_eps: number | null = null,
    debug_aff_obj: boolean = false,
    dump_pyramid: boolean = false,
    dump_moving: boolean = false,
    dump_frequency: number | null = null,
    dump_prefix: string | null = null,
    powell: boolean = false,
    float: boolean = false,
    version: boolean = false,
    verbosity: 0 | 1 | 2 | null = null,
): GreedyParameters {
    const params = {
        "@type": "greedy.greedy" as const,
        "dimensions": dimensions,
        "affine": affine,
        "metric_mode": metric_mode,
        "defopt": defopt,
        "wncc_mask_dilate": wncc_mask_dilate,
        "zero_last_dimension": zero_last_dimension,
        "svf_mode": svf_mode,
        "svlb": svlb,
        "sv_incompr": sv_incompr,
        "ia_identity": ia_identity,
        "ia_voxel_grid": ia_voxel_grid,
        "ia_image_centers": ia_image_centers,
        "cov_id": cov_id,
        "debug_deriv": debug_deriv,
        "debug_aff_obj": debug_aff_obj,
        "dump_pyramid": dump_pyramid,
        "dump_moving": dump_moving,
        "powell": powell,
        "float": float,
        "version": version,
    };
    if (input_images !== null) {
        params["input_images"] = input_images;
    }
    if (output !== null) {
        params["output"] = output;
    }
    if (brute !== null) {
        params["brute"] = brute;
    }
    if (moments !== null) {
        params["moments"] = moments;
    }
    if (reslice !== null) {
        params["reslice"] = reslice;
    }
    if (invert !== null) {
        params["invert"] = invert;
    }
    if (root !== null) {
        params["root"] = root;
    }
    if (jacobian !== null) {
        params["jacobian"] = jacobian;
    }
    if (weight !== null) {
        params["weight"] = weight;
    }
    if (metric !== null) {
        params["metric"] = metric;
    }
    if (step_size !== null) {
        params["step_size"] = step_size;
    }
    if (iterations !== null) {
        params["iterations"] = iterations;
    }
    if (threads !== null) {
        params["threads"] = threads;
    }
    if (fixed_mask !== null) {
        params["fixed_mask"] = fixed_mask;
    }
    if (gm_trim !== null) {
        params["gm_trim"] = gm_trim;
    }
    if (moving_mask !== null) {
        params["moving_mask"] = moving_mask;
    }
    if (reference_image !== null) {
        params["reference_image"] = reference_image;
    }
    if (ref_pad !== null) {
        params["ref_pad"] = ref_pad;
    }
    if (background !== null) {
        params["background"] = background;
    }
    if (input_transform !== null) {
        params["input_transform"] = input_transform;
    }
    if (time_step_mode !== null) {
        params["time_step_mode"] = time_step_mode;
    }
    if (smoothing !== null) {
        params["smoothing"] = smoothing;
    }
    if (inverse_warp !== null) {
        params["inverse_warp"] = inverse_warp;
    }
    if (root_warp !== null) {
        params["root_warp"] = root_warp;
    }
    if (warp_precision !== null) {
        params["warp_precision"] = warp_precision;
    }
    if (noise !== null) {
        params["noise"] = noise;
    }
    if (exponent !== null) {
        params["exponent"] = exponent;
    }
    if (initial_warp !== null) {
        params["initial_warp"] = initial_warp;
    }
    if (tjr !== null) {
        params["tjr"] = tjr;
    }
    if (wr !== null) {
        params["wr"] = wr;
    }
    if (initial_affine !== null) {
        params["initial_affine"] = initial_affine;
    }
    if (ia_image_side !== null) {
        params["ia_image_side"] = ia_image_side;
    }
    if (ia_moments !== null) {
        params["ia_moments"] = ia_moments;
    }
    if (affine_dof !== null) {
        params["affine_dof"] = affine_dof;
    }
    if (jitter !== null) {
        params["jitter"] = jitter;
    }
    if (search !== null) {
        params["search"] = search;
    }
    if (det !== null) {
        params["det"] = det;
    }
    if (fixed_reslicing_image !== null) {
        params["fixed_reslicing_image"] = fixed_reslicing_image;
    }
    if (reslice_moving_image !== null) {
        params["reslice_moving_image"] = reslice_moving_image;
    }
    if (reslice_surface !== null) {
        params["reslice_surface"] = reslice_surface;
    }
    if (interpolation !== null) {
        params["interpolation"] = interpolation;
    }
    if (reslice_background !== null) {
        params["reslice_background"] = reslice_background;
    }
    if (reslice_datatype !== null) {
        params["reslice_datatype"] = reslice_datatype;
    }
    if (reslice_composite !== null) {
        params["reslice_composite"] = reslice_composite;
    }
    if (reslice_jacobian !== null) {
        params["reslice_jacobian"] = reslice_jacobian;
    }
    if (reslice_simplex_jacobian !== null) {
        params["reslice_simplex_jacobian"] = reslice_simplex_jacobian;
    }
    if (reslice_mask !== null) {
        params["reslice_mask"] = reslice_mask;
    }
    if (metric_gradient !== null) {
        params["metric_gradient"] = metric_gradient;
    }
    if (debug_deriv_eps !== null) {
        params["debug_deriv_eps"] = debug_deriv_eps;
    }
    if (dump_frequency !== null) {
        params["dump_frequency"] = dump_frequency;
    }
    if (dump_prefix !== null) {
        params["dump_prefix"] = dump_prefix;
    }
    if (verbosity !== null) {
        params["verbosity"] = verbosity;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function greedy_cargs(
    params: GreedyParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("greedy");
    cargs.push(
        "-d",
        String((params["dimensions"] ?? null))
    );
    if ((params["input_images"] ?? null) !== null) {
        cargs.push(
            "-i",
            ...dynCargs((params["input_images"] ?? null)["@type"])((params["input_images"] ?? null), execution)
        );
    }
    if ((params["output"] ?? null) !== null) {
        cargs.push(
            "-o",
            (params["output"] ?? null)
        );
    }
    if ((params["affine"] ?? null)) {
        cargs.push("-a");
    }
    if ((params["brute"] ?? null) !== null) {
        cargs.push(
            "-brute",
            (params["brute"] ?? null)
        );
    }
    if ((params["moments"] ?? null) !== null) {
        cargs.push(
            "-moments",
            String((params["moments"] ?? null))
        );
    }
    if ((params["reslice"] ?? null) !== null) {
        cargs.push(
            "-r",
            ...(params["reslice"] ?? null).map(f => execution.inputFile(f))
        );
    }
    if ((params["invert"] ?? null) !== null) {
        cargs.push(
            "-iw",
            ...dynCargs((params["invert"] ?? null)["@type"])((params["invert"] ?? null), execution)
        );
    }
    if ((params["root"] ?? null) !== null) {
        cargs.push(
            "-root",
            ...dynCargs((params["root"] ?? null)["@type"])((params["root"] ?? null), execution)
        );
    }
    if ((params["jacobian"] ?? null) !== null) {
        cargs.push(
            "-jac",
            ...dynCargs((params["jacobian"] ?? null)["@type"])((params["jacobian"] ?? null), execution)
        );
    }
    if ((params["metric_mode"] ?? null)) {
        cargs.push("-metric");
    }
    if ((params["defopt"] ?? null)) {
        cargs.push("-defopt");
    }
    if ((params["weight"] ?? null) !== null) {
        cargs.push(
            "-w",
            String((params["weight"] ?? null))
        );
    }
    if ((params["metric"] ?? null) !== null) {
        cargs.push(
            "-m",
            ...dynCargs((params["metric"] ?? null)["@type"])((params["metric"] ?? null), execution)
        );
    }
    if ((params["step_size"] ?? null) !== null) {
        cargs.push(
            "-e",
            (params["step_size"] ?? null)
        );
    }
    if ((params["iterations"] ?? null) !== null) {
        cargs.push(
            "-n",
            (params["iterations"] ?? null)
        );
    }
    if ((params["threads"] ?? null) !== null) {
        cargs.push(
            "-threads",
            String((params["threads"] ?? null))
        );
    }
    if ((params["fixed_mask"] ?? null) !== null) {
        cargs.push(
            "-gm",
            execution.inputFile((params["fixed_mask"] ?? null))
        );
    }
    if ((params["gm_trim"] ?? null) !== null) {
        cargs.push(
            "-gm-trim",
            String((params["gm_trim"] ?? null))
        );
    }
    if ((params["moving_mask"] ?? null) !== null) {
        cargs.push(
            "-mm",
            execution.inputFile((params["moving_mask"] ?? null))
        );
    }
    if ((params["wncc_mask_dilate"] ?? null)) {
        cargs.push("-wncc-mask-dilate");
    }
    if ((params["reference_image"] ?? null) !== null) {
        cargs.push(
            "-ref",
            execution.inputFile((params["reference_image"] ?? null))
        );
    }
    if ((params["ref_pad"] ?? null) !== null) {
        cargs.push(
            "-ref-pad",
            String((params["ref_pad"] ?? null))
        );
    }
    if ((params["background"] ?? null) !== null) {
        cargs.push(
            "-bg",
            (params["background"] ?? null)
        );
    }
    if ((params["input_transform"] ?? null) !== null) {
        cargs.push(
            "-it",
            execution.inputFile((params["input_transform"] ?? null))
        );
    }
    if ((params["zero_last_dimension"] ?? null)) {
        cargs.push("-z");
    }
    if ((params["time_step_mode"] ?? null) !== null) {
        cargs.push(
            "-tscale",
            (params["time_step_mode"] ?? null)
        );
    }
    if ((params["smoothing"] ?? null) !== null) {
        cargs.push(
            "-s",
            (params["smoothing"] ?? null)
        );
    }
    if ((params["inverse_warp"] ?? null) !== null) {
        cargs.push(
            "-oinv",
            execution.inputFile((params["inverse_warp"] ?? null))
        );
    }
    if ((params["root_warp"] ?? null) !== null) {
        cargs.push(
            "-oroot",
            execution.inputFile((params["root_warp"] ?? null))
        );
    }
    if ((params["warp_precision"] ?? null) !== null) {
        cargs.push(
            "-wp",
            String((params["warp_precision"] ?? null))
        );
    }
    if ((params["noise"] ?? null) !== null) {
        cargs.push(
            "-noise",
            String((params["noise"] ?? null))
        );
    }
    if ((params["exponent"] ?? null) !== null) {
        cargs.push(
            "-exp",
            String((params["exponent"] ?? null))
        );
    }
    if ((params["svf_mode"] ?? null)) {
        cargs.push("-sv");
    }
    if ((params["svlb"] ?? null)) {
        cargs.push("-svlb");
    }
    if ((params["sv_incompr"] ?? null)) {
        cargs.push("-sv-incompr");
    }
    if ((params["initial_warp"] ?? null) !== null) {
        cargs.push(
            "-id",
            execution.inputFile((params["initial_warp"] ?? null))
        );
    }
    if ((params["tjr"] ?? null) !== null) {
        cargs.push(
            "-tjr",
            ...dynCargs((params["tjr"] ?? null)["@type"])((params["tjr"] ?? null), execution)
        );
    }
    if ((params["wr"] ?? null) !== null) {
        cargs.push(
            "-wr",
            String((params["wr"] ?? null))
        );
    }
    if ((params["initial_affine"] ?? null) !== null) {
        cargs.push(
            "-ia",
            execution.inputFile((params["initial_affine"] ?? null))
        );
    }
    if ((params["ia_identity"] ?? null)) {
        cargs.push("-ia-identity");
    }
    if ((params["ia_voxel_grid"] ?? null)) {
        cargs.push("-ia-voxel-grid");
    }
    if ((params["ia_image_centers"] ?? null)) {
        cargs.push("-ia-image-centers");
    }
    if ((params["ia_image_side"] ?? null) !== null) {
        cargs.push(
            "-ia-image-side",
            (params["ia_image_side"] ?? null)
        );
    }
    if ((params["ia_moments"] ?? null) !== null) {
        cargs.push(
            "-ia-moments",
            String((params["ia_moments"] ?? null))
        );
    }
    if ((params["affine_dof"] ?? null) !== null) {
        cargs.push(
            "-dof",
            String((params["affine_dof"] ?? null))
        );
    }
    if ((params["jitter"] ?? null) !== null) {
        cargs.push(
            "-jitter",
            String((params["jitter"] ?? null))
        );
    }
    if ((params["search"] ?? null) !== null) {
        cargs.push(
            "-search",
            ...dynCargs((params["search"] ?? null)["@type"])((params["search"] ?? null), execution)
        );
    }
    if ((params["det"] ?? null) !== null) {
        cargs.push(
            "-det",
            String((params["det"] ?? null))
        );
    }
    if ((params["cov_id"] ?? null)) {
        cargs.push("-cov-id");
    }
    if ((params["fixed_reslicing_image"] ?? null) !== null) {
        cargs.push(
            "-rf",
            execution.inputFile((params["fixed_reslicing_image"] ?? null))
        );
    }
    if ((params["reslice_moving_image"] ?? null) !== null) {
        cargs.push(
            "-rm",
            ...dynCargs((params["reslice_moving_image"] ?? null)["@type"])((params["reslice_moving_image"] ?? null), execution)
        );
    }
    if ((params["reslice_surface"] ?? null) !== null) {
        cargs.push(
            "-rs",
            ...dynCargs((params["reslice_surface"] ?? null)["@type"])((params["reslice_surface"] ?? null), execution)
        );
    }
    if ((params["interpolation"] ?? null) !== null) {
        cargs.push(
            "-ri",
            (params["interpolation"] ?? null)
        );
    }
    if ((params["reslice_background"] ?? null) !== null) {
        cargs.push(
            "-rb",
            String((params["reslice_background"] ?? null))
        );
    }
    if ((params["reslice_datatype"] ?? null) !== null) {
        cargs.push(
            "-rt",
            (params["reslice_datatype"] ?? null)
        );
    }
    if ((params["reslice_composite"] ?? null) !== null) {
        cargs.push(
            "-rc",
            execution.inputFile((params["reslice_composite"] ?? null))
        );
    }
    if ((params["reslice_jacobian"] ?? null) !== null) {
        cargs.push(
            "-rj",
            execution.inputFile((params["reslice_jacobian"] ?? null))
        );
    }
    if ((params["reslice_simplex_jacobian"] ?? null) !== null) {
        cargs.push(
            "-rsj",
            ...dynCargs((params["reslice_simplex_jacobian"] ?? null)["@type"])((params["reslice_simplex_jacobian"] ?? null), execution)
        );
    }
    if ((params["reslice_mask"] ?? null) !== null) {
        cargs.push(
            "-rk",
            execution.inputFile((params["reslice_mask"] ?? null))
        );
    }
    if ((params["metric_gradient"] ?? null) !== null) {
        cargs.push(
            "-og",
            execution.inputFile((params["metric_gradient"] ?? null))
        );
    }
    if ((params["debug_deriv"] ?? null)) {
        cargs.push("-debug-deriv");
    }
    if ((params["debug_deriv_eps"] ?? null) !== null) {
        cargs.push(
            "-debug-deriv-eps",
            String((params["debug_deriv_eps"] ?? null))
        );
    }
    if ((params["debug_aff_obj"] ?? null)) {
        cargs.push("-debug-aff-obj");
    }
    if ((params["dump_pyramid"] ?? null)) {
        cargs.push("-dump-pyramid");
    }
    if ((params["dump_moving"] ?? null)) {
        cargs.push("-dump-moving");
    }
    if ((params["dump_frequency"] ?? null) !== null) {
        cargs.push(
            "-dump-freq",
            String((params["dump_frequency"] ?? null))
        );
    }
    if ((params["dump_prefix"] ?? null) !== null) {
        cargs.push(
            "-dump-prefix",
            (params["dump_prefix"] ?? null)
        );
    }
    if ((params["powell"] ?? null)) {
        cargs.push("-powell");
    }
    if ((params["float"] ?? null)) {
        cargs.push("-float");
    }
    if ((params["version"] ?? null)) {
        cargs.push("-version");
    }
    if ((params["verbosity"] ?? null) !== null) {
        cargs.push(
            "-V",
            String((params["verbosity"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function greedy_outputs(
    params: GreedyParameters,
    execution: Execution,
): GreedyOutputs {
    const ret: GreedyOutputs = {
        root: execution.outputFile("."),
        output_file: ((params["output"] ?? null) !== null) ? execution.outputFile([(params["output"] ?? null)].join('')) : null,
        invert: (dynOutputs((params["invert"] ?? null)["@type"])?.((params["invert"] ?? null), execution) ?? null),
        root_: (dynOutputs((params["root"] ?? null)["@type"])?.((params["root"] ?? null), execution) ?? null),
        jacobian: (dynOutputs((params["jacobian"] ?? null)["@type"])?.((params["jacobian"] ?? null), execution) ?? null),
        reslice_moving_image: (dynOutputs((params["reslice_moving_image"] ?? null)["@type"])?.((params["reslice_moving_image"] ?? null), execution) ?? null),
        reslice_surface: (dynOutputs((params["reslice_surface"] ?? null)["@type"])?.((params["reslice_surface"] ?? null), execution) ?? null),
        reslice_simplex_jacobian: (dynOutputs((params["reslice_simplex_jacobian"] ?? null)["@type"])?.((params["reslice_simplex_jacobian"] ?? null), execution) ?? null),
    };
    return ret;
}


/**
 * greedy
 *
 * Paul's greedy diffeomorphic registration implementation.
 *
 * Author: Greedy Developers
 *
 * URL: https://sites.google.com/view/greedyreg/about
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `GreedyOutputs`).
 */
function greedy_execute(
    params: GreedyParameters,
    runner: Runner | null = null,
): GreedyOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(GREEDY_METADATA);
    params = execution.params(params)
    const cargs = greedy_cargs(params, execution)
    const ret = greedy_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * greedy
 *
 * Paul's greedy diffeomorphic registration implementation.
 *
 * Author: Greedy Developers
 *
 * URL: https://sites.google.com/view/greedyreg/about
 *
 * @param dimensions Number of image dimensions
 * @param input_images Image pair (may be repeated)
 * @param output Output file (matrix in affine mode; image in deformable mode, metric computation mode; ignored in reslicing mode)
 * @param affine Perform affine registration and save to output (-o)
 * @param brute Perform a brute force search around each voxel
 * @param moments Perform moments of inertia rigid alignment of given order (1 or 2)
 * @param reslice Reslice images instead of doing registration
 * @param invert Invert previously computed warp
 * @param root Convert 2^N-th root of a warp
 * @param jacobian Compute the Jacobian determinant of the warp
 * @param metric_mode Compute metric between images
 * @param defopt Deformable optimization mode (experimental)
 * @param weight Weight of the next -i pair
 * @param metric Metric for the entire registration
 * @param step_size Step size for optimization (default = 1.0), may also be specified per level (e.g. 0.3x0.1)
 * @param iterations Number of iterations per level of multi-res
 * @param threads Number of allowed concurrent threads
 * @param fixed_mask Fixed image mask (metric gradients computed only over the mask)
 * @param gm_trim Generate the fixed image mask by trimming the extent of the fixed image by given radius
 * @param moving_mask Moving image mask (pixels outside are excluded from metric computation)
 * @param wncc_mask_dilate Specifies that fixed and moving masks should be dilated by the radius of the WNCC metric during registration
 * @param reference_image Use supplied image, rather than fixed image to define the reference space
 * @param ref_pad Define the reference space by padding the fixed image by radius
 * @param background Value to fill missing values when mapping fixed and moving images to reference space
 * @param input_transform Specify transforms (matrices, warps) that map moving image to reference space
 * @param zero_last_dimension Sets sigmas and NCC radius to zero in the last dimension for 2D/3D registration
 * @param time_step_mode Time step behavior mode
 * @param smoothing Smoothing for the greedy update step (e.g., '1.732vox 0.7071vox')
 * @param inverse_warp Compute and write the inverse of the warp field
 * @param root_warp Compute and write the (2^N-th) root of the warp field
 * @param warp_precision Saved warp precision in voxels (default=0.1; 0 for no compression)
 * @param noise Standard deviation of white noise added to moving/fixed images when using NCC metric
 * @param exponent The exponent used for warp inversion, root computation, and in stationary velocity field mode
 * @param svf_mode Perform registration using the stationary velocity model
 * @param svlb Use more accurate but expensive update of v in stationary velocity field mode
 * @param sv_incompr Incompressibility mode, implements Mansi et al. 2011 iLogDemons
 * @param initial_warp Specifies the initial warp to start iteration from
 * @param tjr Apply a regularization penalty based on the Jacobian of a tetrahedral mesh
 * @param wr Weight of SVF smoothness regularization term (default: 1000)
 * @param initial_affine Initial affine matrix for optimization
 * @param ia_identity Initialize affine matrix based on NIFTI headers
 * @param ia_voxel_grid Initialize affine matrix so that voxels with corresponding indices align
 * @param ia_image_centers Initialize affine matrix based on matching image centers
 * @param ia_image_side Initialize affine matrix based on matching center of one image side
 * @param ia_moments Initialize affine matrix based on matching moments of inertia
 * @param affine_dof Degrees of freedom for affine registration. 6=rigid, 7=similarity, 12=affine
 * @param jitter Jitter (in voxel units) applied to sample points (default: 0.5)
 * @param search Random search over rigid transforms before starting optimization
 * @param det Force the determinant of transform to be either 1 (no flip) or -1 (flip)
 * @param cov_id Assume identity covariance (match centers and do flips only, no rotation)
 * @param fixed_reslicing_image Fixed image for reslicing
 * @param reslice_moving_image Moving/output image pair for reslicing
 * @param reslice_surface Fixed/output surface pair (vertices are warped from fixed space to moving)
 * @param interpolation Interpolation for the next pair (NN, LINEAR*, LABEL sigma)
 * @param reslice_background Background (i.e. outside) intensity for the next pair (default 0)
 * @param reslice_datatype Data type for the next pair
 * @param reslice_composite Write composed transforms to outwarp
 * @param reslice_jacobian Write Jacobian determinant image to outjacobian
 * @param reslice_simplex_jacobian Compute Jacobian determinant for a simplex mesh in fixed space
 * @param reslice_mask A binary mask for the fixed image; zero values will be overwritten with background
 * @param metric_gradient Write the gradient of the metric to file
 * @param debug_deriv Enable periodic checks of derivatives (debug)
 * @param debug_deriv_eps Epsilon for derivative debugging
 * @param debug_aff_obj Plot affine objective in neighborhood of -ia matrix
 * @param dump_pyramid Dump the image pyramid at the start of the registration
 * @param dump_moving Dump moving image at each iter
 * @param dump_frequency Dump frequency
 * @param dump_prefix Prefix for dump files (may be a path)
 * @param powell Use Powell's method instead of LGBFS
 * @param float Use single precision floating point (off by default)
 * @param version Print version info
 * @param verbosity Verbosity level (0: none, 1: default, 2: verbose)
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `GreedyOutputs`).
 */
function greedy_(
    dimensions: number,
    input_images: GreedyInputImagesParameters | null = null,
    output: string | null = null,
    affine: boolean = false,
    brute: string | null = null,
    moments: 1 | 2 | null = null,
    reslice: Array<InputPathType> | null = null,
    invert: GreedyInvertParameters | null = null,
    root: GreedyRootParameters | null = null,
    jacobian: GreedyJacobianParameters | null = null,
    metric_mode: boolean = false,
    defopt: boolean = false,
    weight: number | null = null,
    metric: GreedyMetricParameters | null = null,
    step_size: string | null = null,
    iterations: string | null = null,
    threads: number | null = null,
    fixed_mask: InputPathType | null = null,
    gm_trim: number | null = null,
    moving_mask: InputPathType | null = null,
    wncc_mask_dilate: boolean = false,
    reference_image: InputPathType | null = null,
    ref_pad: number | null = null,
    background: string | null = null,
    input_transform: InputPathType | null = null,
    zero_last_dimension: boolean = false,
    time_step_mode: "CONST" | "SCALE" | "SCALEDOWN" | null = null,
    smoothing: string | null = null,
    inverse_warp: InputPathType | null = null,
    root_warp: InputPathType | null = null,
    warp_precision: number | null = null,
    noise: number | null = null,
    exponent: number | null = null,
    svf_mode: boolean = false,
    svlb: boolean = false,
    sv_incompr: boolean = false,
    initial_warp: InputPathType | null = null,
    tjr: GreedyTjrParameters | null = null,
    wr: number | null = null,
    initial_affine: InputPathType | null = null,
    ia_identity: boolean = false,
    ia_voxel_grid: boolean = false,
    ia_image_centers: boolean = false,
    ia_image_side: string | null = null,
    ia_moments: 1 | 2 | null = null,
    affine_dof: 6 | 7 | 12 | null = null,
    jitter: number | null = null,
    search: GreedySearchParameters | null = null,
    det: -1 | 1 | null = null,
    cov_id: boolean = false,
    fixed_reslicing_image: InputPathType | null = null,
    reslice_moving_image: GreedyResliceMovingImageParameters | null = null,
    reslice_surface: GreedyResliceSurfaceParameters | null = null,
    interpolation: "NN" | "LINEAR" | "LABEL" | null = null,
    reslice_background: number | null = null,
    reslice_datatype: "auto" | "double" | "float" | "uint" | "int" | "ushort" | "short" | "uchar" | "char" | null = null,
    reslice_composite: InputPathType | null = null,
    reslice_jacobian: InputPathType | null = null,
    reslice_simplex_jacobian: GreedyResliceSimplexJacobianParameters | null = null,
    reslice_mask: InputPathType | null = null,
    metric_gradient: InputPathType | null = null,
    debug_deriv: boolean = false,
    debug_deriv_eps: number | null = null,
    debug_aff_obj: boolean = false,
    dump_pyramid: boolean = false,
    dump_moving: boolean = false,
    dump_frequency: number | null = null,
    dump_prefix: string | null = null,
    powell: boolean = false,
    float: boolean = false,
    version: boolean = false,
    verbosity: 0 | 1 | 2 | null = null,
    runner: Runner | null = null,
): GreedyOutputs {
    const params = greedy_params(dimensions, input_images, output, affine, brute, moments, reslice, invert, root, jacobian, metric_mode, defopt, weight, metric, step_size, iterations, threads, fixed_mask, gm_trim, moving_mask, wncc_mask_dilate, reference_image, ref_pad, background, input_transform, zero_last_dimension, time_step_mode, smoothing, inverse_warp, root_warp, warp_precision, noise, exponent, svf_mode, svlb, sv_incompr, initial_warp, tjr, wr, initial_affine, ia_identity, ia_voxel_grid, ia_image_centers, ia_image_side, ia_moments, affine_dof, jitter, search, det, cov_id, fixed_reslicing_image, reslice_moving_image, reslice_surface, interpolation, reslice_background, reslice_datatype, reslice_composite, reslice_jacobian, reslice_simplex_jacobian, reslice_mask, metric_gradient, debug_deriv, debug_deriv_eps, debug_aff_obj, dump_pyramid, dump_moving, dump_frequency, dump_prefix, powell, float, version, verbosity)
    return greedy_execute(params, runner);
}


export {
      GREEDY_METADATA,
      GreedyInputImagesParameters,
      GreedyInvertOutputs,
      GreedyInvertParameters,
      GreedyJacobianOutputs,
      GreedyJacobianParameters,
      GreedyMetricParameters,
      GreedyOutputs,
      GreedyParameters,
      GreedyResliceMovingImageOutputs,
      GreedyResliceMovingImageParameters,
      GreedyResliceSimplexJacobianOutputs,
      GreedyResliceSimplexJacobianParameters,
      GreedyResliceSurfaceOutputs,
      GreedyResliceSurfaceParameters,
      GreedyRootOutputs,
      GreedyRootParameters,
      GreedySearchParameters,
      GreedyTjrParameters,
      greedy_,
      greedy_execute,
      greedy_input_images_params,
      greedy_invert_params,
      greedy_jacobian_params,
      greedy_metric_params,
      greedy_params,
      greedy_reslice_moving_image_params,
      greedy_reslice_simplex_jacobian_params,
      greedy_reslice_surface_params,
      greedy_root_params,
      greedy_search_params,
      greedy_tjr_params,
};
