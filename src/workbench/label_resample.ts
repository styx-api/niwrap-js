// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const LABEL_RESAMPLE_METADATA: Metadata = {
    id: "c5578cc16cfdc8f6e4a75e75e6c10f719016d2e0.workbench",
    name: "label-resample",
    package: "workbench",
    container_image_tag: "nx10x/workbench:2.1.0",
};


interface LabelResampleAreaSurfsParamsDict {
    "@type"?: "area-surfs";
    "current-area": InputPathType;
    "new-area": InputPathType;
}
type LabelResampleAreaSurfsParamsDictTagged = Required<Pick<LabelResampleAreaSurfsParamsDict, '@type'>> & LabelResampleAreaSurfsParamsDict;


interface LabelResampleAreaMetricsParamsDict {
    "@type"?: "area-metrics";
    "current-area": InputPathType;
    "new-area": InputPathType;
}
type LabelResampleAreaMetricsParamsDictTagged = Required<Pick<LabelResampleAreaMetricsParamsDict, '@type'>> & LabelResampleAreaMetricsParamsDict;


interface LabelResampleValidRoiOutParamsDict {
    "@type"?: "valid-roi-out";
    "roi-out": string;
}
type LabelResampleValidRoiOutParamsDictTagged = Required<Pick<LabelResampleValidRoiOutParamsDict, '@type'>> & LabelResampleValidRoiOutParamsDict;


interface LabelResampleParamsDict {
    "@type"?: "workbench/label-resample";
    "label-in": InputPathType;
    "current-sphere": InputPathType;
    "new-sphere": InputPathType;
    "method": string;
    "label-out": string;
    "area-surfs"?: LabelResampleAreaSurfsParamsDict | null | undefined;
    "area-metrics"?: LabelResampleAreaMetricsParamsDict | null | undefined;
    "valid-roi-out"?: LabelResampleValidRoiOutParamsDict | null | undefined;
    "roi-metric"?: InputPathType | null | undefined;
    "bypass-sphere-check": boolean;
    "largest": boolean;
}
type LabelResampleParamsDictTagged = Required<Pick<LabelResampleParamsDict, '@type'>> & LabelResampleParamsDict;


/**
 * Build parameters.
 *
 * @param current_area a relevant anatomical surface with <current-sphere> mesh
 * @param new_area a relevant anatomical surface with <new-sphere> mesh
 *
 * @returns Parameter dictionary
 */
function label_resample_area_surfs(
    current_area: InputPathType,
    new_area: InputPathType,
): LabelResampleAreaSurfsParamsDictTagged {
    const params = {
        "@type": "area-surfs" as const,
        "current-area": current_area,
        "new-area": new_area,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function label_resample_area_surfs_cargs(
    params: LabelResampleAreaSurfsParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-area-surfs",
        execution.inputFile((params["current-area"] ?? null)),
        execution.inputFile((params["new-area"] ?? null))
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param current_area a metric file with vertex areas for <current-sphere> mesh
 * @param new_area a metric file with vertex areas for <new-sphere> mesh
 *
 * @returns Parameter dictionary
 */
function label_resample_area_metrics(
    current_area: InputPathType,
    new_area: InputPathType,
): LabelResampleAreaMetricsParamsDictTagged {
    const params = {
        "@type": "area-metrics" as const,
        "current-area": current_area,
        "new-area": new_area,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function label_resample_area_metrics_cargs(
    params: LabelResampleAreaMetricsParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-area-metrics",
        execution.inputFile((params["current-area"] ?? null)),
        execution.inputFile((params["new-area"] ?? null))
    );
    return cargs;
}


/**
 * Output object returned when calling `LabelResampleValidRoiOutParamsDict | null(...)`.
 *
 * @interface
 */
interface LabelResampleValidRoiOutOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output roi as a metric
     */
    roi_out: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param roi_out the output roi as a metric
 *
 * @returns Parameter dictionary
 */
function label_resample_valid_roi_out(
    roi_out: string,
): LabelResampleValidRoiOutParamsDictTagged {
    const params = {
        "@type": "valid-roi-out" as const,
        "roi-out": roi_out,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function label_resample_valid_roi_out_cargs(
    params: LabelResampleValidRoiOutParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-valid-roi-out",
        (params["roi-out"] ?? null)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function label_resample_valid_roi_out_outputs(
    params: LabelResampleValidRoiOutParamsDict,
    execution: Execution,
): LabelResampleValidRoiOutOutputs {
    const ret: LabelResampleValidRoiOutOutputs = {
        root: execution.outputFile("."),
        roi_out: execution.outputFile([(params["roi-out"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `LabelResampleParamsDict(...)`.
 *
 * @interface
 */
interface LabelResampleOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output label file
     */
    label_out: OutputPathType;
    /**
     * Outputs from `label_resample_valid_roi_out_outputs`.
     */
    valid_roi_out: LabelResampleValidRoiOutOutputs | null;
}


/**
 * Build parameters.
 *
 * @param label_in the label file to resample
 * @param current_sphere a sphere surface with the mesh that the label file is currently on
 * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
 * @param method the method name
 * @param label_out the output label file
 * @param area_surfs specify surfaces to do vertex area correction based on
 * @param area_metrics specify vertex area metrics to do area correction based on
 * @param valid_roi_out output the ROI of vertices that got data from valid source vertices
 * @param roi_metric use an input roi on the current mesh to exclude non-data vertices

the roi, as a metric file
 * @param bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
 * @param largest use only the label of the vertex with the largest weight
 *
 * @returns Parameter dictionary
 */
function label_resample_params(
    label_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    label_out: string,
    area_surfs: LabelResampleAreaSurfsParamsDict | null = null,
    area_metrics: LabelResampleAreaMetricsParamsDict | null = null,
    valid_roi_out: LabelResampleValidRoiOutParamsDict | null = null,
    roi_metric: InputPathType | null = null,
    bypass_sphere_check: boolean = false,
    largest: boolean = false,
): LabelResampleParamsDictTagged {
    const params = {
        "@type": "workbench/label-resample" as const,
        "label-in": label_in,
        "current-sphere": current_sphere,
        "new-sphere": new_sphere,
        "method": method,
        "label-out": label_out,
        "bypass-sphere-check": bypass_sphere_check,
        "largest": largest,
    };
    if (area_surfs !== null) {
        params["area-surfs"] = area_surfs;
    }
    if (area_metrics !== null) {
        params["area-metrics"] = area_metrics;
    }
    if (valid_roi_out !== null) {
        params["valid-roi-out"] = valid_roi_out;
    }
    if (roi_metric !== null) {
        params["roi-metric"] = roi_metric;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function label_resample_cargs(
    params: LabelResampleParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "wb_command",
        "-label-resample"
    );
    cargs.push(execution.inputFile((params["label-in"] ?? null)));
    cargs.push(execution.inputFile((params["current-sphere"] ?? null)));
    cargs.push(execution.inputFile((params["new-sphere"] ?? null)));
    cargs.push((params["method"] ?? null));
    cargs.push((params["label-out"] ?? null));
    if ((params["area-surfs"] ?? null) !== null || (params["area-metrics"] ?? null) !== null || (params["valid-roi-out"] ?? null) !== null) {
        cargs.push(
            ...(((params["area-surfs"] ?? null) !== null) ? label_resample_area_surfs_cargs((params["area-surfs"] ?? null), execution) : []),
            ...(((params["area-metrics"] ?? null) !== null) ? label_resample_area_metrics_cargs((params["area-metrics"] ?? null), execution) : []),
            ...(((params["valid-roi-out"] ?? null) !== null) ? label_resample_valid_roi_out_cargs((params["valid-roi-out"] ?? null), execution) : [])
        );
    }
    if ((params["roi-metric"] ?? null) !== null) {
        cargs.push(
            "-current-roi",
            execution.inputFile((params["roi-metric"] ?? null))
        );
    }
    if ((params["bypass-sphere-check"] ?? false)) {
        cargs.push("-bypass-sphere-check");
    }
    if ((params["largest"] ?? false)) {
        cargs.push("-largest");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function label_resample_outputs(
    params: LabelResampleParamsDict,
    execution: Execution,
): LabelResampleOutputs {
    const ret: LabelResampleOutputs = {
        root: execution.outputFile("."),
        label_out: execution.outputFile([(params["label-out"] ?? null)].join('')),
        valid_roi_out: (params["valid-roi-out"] ?? null) ? (label_resample_valid_roi_out_outputs((params["valid-roi-out"] ?? null), execution) ?? null) : null,
    };
    return ret;
}


/**
 * RESAMPLE A LABEL FILE TO A DIFFERENT MESH.
 *
 * Resamples a label file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
 *
 * The ADAP_BARY_AREA method is recommended for label data, because it should be better at resolving vertices that are near multiple labels, or in case of downsampling.  Midthickness surfaces are recommended for the vertex areas for most data.
 *
 * The -largest option results in nearest vertex behavior when used with BARYCENTRIC, as it uses the value of the source vertex that has the largest weight.
 *
 * When -largest is not specified, the vertex weights are summed according to which label they correspond to, and the label with the largest sum is used.
 *
 * The <method> argument must be one of the following:
 *
 * ADAP_BARY_AREA
 * BARYCENTRIC
 * .
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `LabelResampleOutputs`).
 */
function label_resample_execute(
    params: LabelResampleParamsDict,
    runner: Runner | null = null,
): LabelResampleOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(LABEL_RESAMPLE_METADATA);
    params = execution.params(params)
    const cargs = label_resample_cargs(params, execution)
    const ret = label_resample_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * RESAMPLE A LABEL FILE TO A DIFFERENT MESH.
 *
 * Resamples a label file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
 *
 * The ADAP_BARY_AREA method is recommended for label data, because it should be better at resolving vertices that are near multiple labels, or in case of downsampling.  Midthickness surfaces are recommended for the vertex areas for most data.
 *
 * The -largest option results in nearest vertex behavior when used with BARYCENTRIC, as it uses the value of the source vertex that has the largest weight.
 *
 * When -largest is not specified, the vertex weights are summed according to which label they correspond to, and the label with the largest sum is used.
 *
 * The <method> argument must be one of the following:
 *
 * ADAP_BARY_AREA
 * BARYCENTRIC
 * .
 *
 * @param label_in the label file to resample
 * @param current_sphere a sphere surface with the mesh that the label file is currently on
 * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
 * @param method the method name
 * @param label_out the output label file
 * @param area_surfs specify surfaces to do vertex area correction based on
 * @param area_metrics specify vertex area metrics to do area correction based on
 * @param valid_roi_out output the ROI of vertices that got data from valid source vertices
 * @param roi_metric use an input roi on the current mesh to exclude non-data vertices

the roi, as a metric file
 * @param bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
 * @param largest use only the label of the vertex with the largest weight
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `LabelResampleOutputs`).
 */
function label_resample(
    label_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    label_out: string,
    area_surfs: LabelResampleAreaSurfsParamsDict | null = null,
    area_metrics: LabelResampleAreaMetricsParamsDict | null = null,
    valid_roi_out: LabelResampleValidRoiOutParamsDict | null = null,
    roi_metric: InputPathType | null = null,
    bypass_sphere_check: boolean = false,
    largest: boolean = false,
    runner: Runner | null = null,
): LabelResampleOutputs {
    const params = label_resample_params(label_in, current_sphere, new_sphere, method, label_out, area_surfs, area_metrics, valid_roi_out, roi_metric, bypass_sphere_check, largest)
    return label_resample_execute(params, runner);
}


export {
      LABEL_RESAMPLE_METADATA,
      LabelResampleAreaMetricsParamsDict,
      LabelResampleAreaMetricsParamsDictTagged,
      LabelResampleAreaSurfsParamsDict,
      LabelResampleAreaSurfsParamsDictTagged,
      LabelResampleOutputs,
      LabelResampleParamsDict,
      LabelResampleParamsDictTagged,
      LabelResampleValidRoiOutOutputs,
      LabelResampleValidRoiOutParamsDict,
      LabelResampleValidRoiOutParamsDictTagged,
      label_resample,
      label_resample_area_metrics,
      label_resample_area_surfs,
      label_resample_execute,
      label_resample_params,
      label_resample_valid_roi_out,
};
