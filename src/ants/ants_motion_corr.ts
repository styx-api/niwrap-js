// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ANTS_MOTION_CORR_METADATA: Metadata = {
    id: "bad4ed9033e4ea6d613468b01cddbf59baf994a6.boutiques",
    name: "antsMotionCorr",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface AntsMotionCorrParameters {
    "@type"?: "ants/antsMotionCorr";
    "dimensionality"?: 2 | 3 | null | undefined;
    "n_images"?: number | null | undefined;
    "metric"?: string | null | undefined;
    "use_fixed_reference_image"?: 0 | 1 | null | undefined;
    "use_scales_estimator": boolean;
    "transform"?: string | null | undefined;
    "iterations"?: string | null | undefined;
    "smoothing_sigmas"?: string | null | undefined;
    "shrink_factors"?: string | null | undefined;
    "output"?: string | null | undefined;
    "average_image": boolean;
    "write_displacement": boolean;
    "use_histogram_matching"?: 0 | 1 | null | undefined;
    "random_seed"?: number | null | undefined;
    "interpolation"?: "Linear" | "NearestNeighbor" | "BSpline" | "BlackmanWindowedSinc" | "CosineWindowedSinc" | "WelchWindowedSinc" | "HammingWindowedSinc" | "LanczosWindowedSinc" | null | undefined;
    "verbose"?: 0 | 1 | null | undefined;
}
type AntsMotionCorrParametersTagged = Required<Pick<AntsMotionCorrParameters, '@type'>> & AntsMotionCorrParameters;


/**
 * Output object returned when calling `AntsMotionCorrParameters(...)`.
 *
 * @interface
 */
interface AntsMotionCorrOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output is the transformation matrix.
     */
    output_transform_prefix: OutputPathType;
    /**
     * The output is the warped moving image.
     */
    warped_image: OutputPathType;
    /**
     * The output is the averaged image of the input time series.
     */
    average_image_output: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, the program tries to infer the dimensionality from the input image.
 * @param n_images This option sets the number of images to use to construct the template image.
 * @param metric Metrics for registration: GC (global correlation), CC (ANTS neighborhood cross correlation), MI (Mutual information), and Demons.
 * @param use_fixed_reference_image Use a fixed reference image to correct all volumes, instead of correcting each image to the prior volume in the time series.
 * @param use_scales_estimator Use the scale estimator to control optimization.
 * @param transform Several transform options are available: Affine, Rigid, GaussianDisplacementField, SyN.
 * @param iterations Specify the number of iterations at each level.
 * @param smoothing_sigmas Specify the sigma for smoothing at each level. Smoothing may be specified in mm units or voxels with 'AxBxCmm' or 'AxBxCvox'. No units implies voxels.
 * @param shrink_factors Specify the shrink factor for the virtual domain (typically the fixed image) at each level.
 * @param output Specify the output transform prefix (output format is .nii.gz ). Optionally, one can choose to warp the moving image to the fixed space and, if the inverse transform exists, one can also output the warped fixed image.
 * @param average_image Average the input time series image.
 * @param write_displacement Write the low-dimensional 3D transforms to a 4D displacement field.
 * @param use_histogram_matching Histogram match the moving images to the reference image.
 * @param random_seed Use a fixed seed for random number generation.
 * @param interpolation Several interpolation options are available in ITK. The above are available (default Linear).
 * @param verbose Verbose output.
 *
 * @returns Parameter dictionary
 */
function ants_motion_corr_params(
    dimensionality: 2 | 3 | null = null,
    n_images: number | null = null,
    metric: string | null = null,
    use_fixed_reference_image: 0 | 1 | null = null,
    use_scales_estimator: boolean = false,
    transform: string | null = null,
    iterations: string | null = null,
    smoothing_sigmas: string | null = null,
    shrink_factors: string | null = null,
    output: string | null = null,
    average_image: boolean = false,
    write_displacement: boolean = false,
    use_histogram_matching: 0 | 1 | null = null,
    random_seed: number | null = null,
    interpolation: "Linear" | "NearestNeighbor" | "BSpline" | "BlackmanWindowedSinc" | "CosineWindowedSinc" | "WelchWindowedSinc" | "HammingWindowedSinc" | "LanczosWindowedSinc" | null = null,
    verbose: 0 | 1 | null = null,
): AntsMotionCorrParametersTagged {
    const params = {
        "@type": "ants/antsMotionCorr" as const,
        "use_scales_estimator": use_scales_estimator,
        "average_image": average_image,
        "write_displacement": write_displacement,
    };
    if (dimensionality !== null) {
        params["dimensionality"] = dimensionality;
    }
    if (n_images !== null) {
        params["n_images"] = n_images;
    }
    if (metric !== null) {
        params["metric"] = metric;
    }
    if (use_fixed_reference_image !== null) {
        params["use_fixed_reference_image"] = use_fixed_reference_image;
    }
    if (transform !== null) {
        params["transform"] = transform;
    }
    if (iterations !== null) {
        params["iterations"] = iterations;
    }
    if (smoothing_sigmas !== null) {
        params["smoothing_sigmas"] = smoothing_sigmas;
    }
    if (shrink_factors !== null) {
        params["shrink_factors"] = shrink_factors;
    }
    if (output !== null) {
        params["output"] = output;
    }
    if (use_histogram_matching !== null) {
        params["use_histogram_matching"] = use_histogram_matching;
    }
    if (random_seed !== null) {
        params["random_seed"] = random_seed;
    }
    if (interpolation !== null) {
        params["interpolation"] = interpolation;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_motion_corr_cargs(
    params: AntsMotionCorrParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("antsMotionCorr");
    if ((params["dimensionality"] ?? null) !== null) {
        cargs.push(
            "--dimensionality",
            String((params["dimensionality"] ?? null))
        );
    }
    if ((params["n_images"] ?? null) !== null) {
        cargs.push(
            "--n-images",
            String((params["n_images"] ?? null))
        );
    }
    if ((params["metric"] ?? null) !== null) {
        cargs.push(
            "--metric",
            (params["metric"] ?? null)
        );
    }
    if ((params["use_fixed_reference_image"] ?? null) !== null) {
        cargs.push(
            "--useFixedReferenceImage",
            String((params["use_fixed_reference_image"] ?? null))
        );
    }
    if ((params["use_scales_estimator"] ?? false)) {
        cargs.push("--useScalesEstimator");
    }
    if ((params["transform"] ?? null) !== null) {
        cargs.push(
            "--transform",
            (params["transform"] ?? null)
        );
    }
    if ((params["iterations"] ?? null) !== null) {
        cargs.push(
            "--iterations",
            (params["iterations"] ?? null)
        );
    }
    if ((params["smoothing_sigmas"] ?? null) !== null) {
        cargs.push(
            "--smoothingSigmas",
            (params["smoothing_sigmas"] ?? null)
        );
    }
    if ((params["shrink_factors"] ?? null) !== null) {
        cargs.push(
            "--shrinkFactors",
            (params["shrink_factors"] ?? null)
        );
    }
    if ((params["output"] ?? null) !== null) {
        cargs.push(
            "--output",
            (params["output"] ?? null)
        );
    }
    if ((params["average_image"] ?? false)) {
        cargs.push("--average-image");
    }
    if ((params["write_displacement"] ?? false)) {
        cargs.push("--write-displacement");
    }
    if ((params["use_histogram_matching"] ?? null) !== null) {
        cargs.push(
            "--use-histogram-matching",
            String((params["use_histogram_matching"] ?? null))
        );
    }
    if ((params["random_seed"] ?? null) !== null) {
        cargs.push(
            "--random-seed",
            String((params["random_seed"] ?? null))
        );
    }
    if ((params["interpolation"] ?? null) !== null) {
        cargs.push(
            "--interpolation",
            (params["interpolation"] ?? null)
        );
    }
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "--verbose",
            String((params["verbose"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ants_motion_corr_outputs(
    params: AntsMotionCorrParameters,
    execution: Execution,
): AntsMotionCorrOutputs {
    const ret: AntsMotionCorrOutputs = {
        root: execution.outputFile("."),
        output_transform_prefix: execution.outputFile(["[OUTPUT_TRANSFORM_PREFIX]Affine.mat"].join('')),
        warped_image: execution.outputFile(["[OUTPUT_TRANSFORM_PREFIX]Warped.nii.gz"].join('')),
        average_image_output: execution.outputFile(["[OUTPUT_TRANSFORM_PREFIX]Average.nii.gz"].join('')),
    };
    return ret;
}


/**
 * antsMotionCorr
 *
 * ANTS Motion Correction application to perform motion correction on 4D time series data.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsMotionCorrOutputs`).
 */
function ants_motion_corr_execute(
    params: AntsMotionCorrParameters,
    runner: Runner | null = null,
): AntsMotionCorrOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ANTS_MOTION_CORR_METADATA);
    params = execution.params(params)
    const cargs = ants_motion_corr_cargs(params, execution)
    const ret = ants_motion_corr_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * antsMotionCorr
 *
 * ANTS Motion Correction application to perform motion correction on 4D time series data.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, the program tries to infer the dimensionality from the input image.
 * @param n_images This option sets the number of images to use to construct the template image.
 * @param metric Metrics for registration: GC (global correlation), CC (ANTS neighborhood cross correlation), MI (Mutual information), and Demons.
 * @param use_fixed_reference_image Use a fixed reference image to correct all volumes, instead of correcting each image to the prior volume in the time series.
 * @param use_scales_estimator Use the scale estimator to control optimization.
 * @param transform Several transform options are available: Affine, Rigid, GaussianDisplacementField, SyN.
 * @param iterations Specify the number of iterations at each level.
 * @param smoothing_sigmas Specify the sigma for smoothing at each level. Smoothing may be specified in mm units or voxels with 'AxBxCmm' or 'AxBxCvox'. No units implies voxels.
 * @param shrink_factors Specify the shrink factor for the virtual domain (typically the fixed image) at each level.
 * @param output Specify the output transform prefix (output format is .nii.gz ). Optionally, one can choose to warp the moving image to the fixed space and, if the inverse transform exists, one can also output the warped fixed image.
 * @param average_image Average the input time series image.
 * @param write_displacement Write the low-dimensional 3D transforms to a 4D displacement field.
 * @param use_histogram_matching Histogram match the moving images to the reference image.
 * @param random_seed Use a fixed seed for random number generation.
 * @param interpolation Several interpolation options are available in ITK. The above are available (default Linear).
 * @param verbose Verbose output.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsMotionCorrOutputs`).
 */
function ants_motion_corr(
    dimensionality: 2 | 3 | null = null,
    n_images: number | null = null,
    metric: string | null = null,
    use_fixed_reference_image: 0 | 1 | null = null,
    use_scales_estimator: boolean = false,
    transform: string | null = null,
    iterations: string | null = null,
    smoothing_sigmas: string | null = null,
    shrink_factors: string | null = null,
    output: string | null = null,
    average_image: boolean = false,
    write_displacement: boolean = false,
    use_histogram_matching: 0 | 1 | null = null,
    random_seed: number | null = null,
    interpolation: "Linear" | "NearestNeighbor" | "BSpline" | "BlackmanWindowedSinc" | "CosineWindowedSinc" | "WelchWindowedSinc" | "HammingWindowedSinc" | "LanczosWindowedSinc" | null = null,
    verbose: 0 | 1 | null = null,
    runner: Runner | null = null,
): AntsMotionCorrOutputs {
    const params = ants_motion_corr_params(dimensionality, n_images, metric, use_fixed_reference_image, use_scales_estimator, transform, iterations, smoothing_sigmas, shrink_factors, output, average_image, write_displacement, use_histogram_matching, random_seed, interpolation, verbose)
    return ants_motion_corr_execute(params, runner);
}


export {
      ANTS_MOTION_CORR_METADATA,
      AntsMotionCorrOutputs,
      ants_motion_corr,
      ants_motion_corr_execute,
      ants_motion_corr_params,
};
