// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const FSL_DEFACE_METADATA: Metadata = {
    id: "aa385f8d356c96dd0d6919ea7f5354ddd42343d5.boutiques",
    name: "fsl_deface",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface FslDefaceParameters {
    "@type"?: "fsl/fsl_deface";
    "infile": InputPathType;
    "outfile": string;
    "cropped_defacing_flag": boolean;
    "defacing_mask"?: string | null | undefined;
    "cropped_struc"?: string | null | undefined;
    "orig_to_std_mat"?: string | null | undefined;
    "orig_to_cropped_mat"?: string | null | undefined;
    "cropped_to_std_mat"?: string | null | undefined;
    "shift_nud"?: Array<number> | null | undefined;
    "fractional_intensity"?: number | null | undefined;
    "bias_correct_flag": boolean;
    "center_of_gravity"?: Array<number> | null | undefined;
    "qc_images"?: string | null | undefined;
}
type FslDefaceParametersTagged = Required<Pick<FslDefaceParameters, '@type'>> & FslDefaceParameters;


/**
 * Output object returned when calling `FslDefaceParameters(...)`.
 *
 * @interface
 */
interface FslDefaceOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Defaced T1w image
     */
    outfile: OutputPathType;
    /**
     * Defacing mask file
     */
    out_defacing_mask: OutputPathType | null;
    /**
     * Cropped structural image file
     */
    out_cropped_struc: OutputPathType | null;
    /**
     * Affine matrix from original struct to std
     */
    out_orig_to_std_mat: OutputPathType | null;
    /**
     * Affine matrix from original struct to cropped struct
     */
    out_orig_to_cropped_mat: OutputPathType | null;
    /**
     * Affine matrix from cropped struct to std
     */
    out_cropped_to_std_mat: OutputPathType | null;
    /**
     * QC image for defacing (original)
     */
    qc_image_original: OutputPathType | null;
    /**
     * QC image for defacing (cropped)
     */
    qc_image_cropped: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param infile Input T1w image
 * @param outfile Output defaced T1w image
 * @param cropped_defacing_flag Apply the defacing to the cropped image instead of the original image
 * @param defacing_mask Filename to save the defacing mask
 * @param cropped_struc Filename to save the new cropped struct
 * @param orig_to_std_mat Filename to save affine matrix from original struct to std
 * @param orig_to_cropped_mat Filename to save affine matrix from original struct to cropped struct
 * @param cropped_to_std_mat Filename to save affine matrix from cropped struct to std
 * @param shift_nud Shift, in mm, x-, y- and z-directions, to shift face mask by (These matrices will only work if the input has been previously reoriented to std)
 * @param fractional_intensity Fractional intensity for bet (0->1); default=0.5
 * @param bias_correct_flag Bias-correct the input image (with fast)
 * @param center_of_gravity Center-of-gravity for bet (voxels, not mm)
 * @param qc_images Generate 2 pngs to show how the defacing worked for QC purposes
 *
 * @returns Parameter dictionary
 */
function fsl_deface_params(
    infile: InputPathType,
    outfile: string,
    cropped_defacing_flag: boolean = false,
    defacing_mask: string | null = null,
    cropped_struc: string | null = null,
    orig_to_std_mat: string | null = null,
    orig_to_cropped_mat: string | null = null,
    cropped_to_std_mat: string | null = null,
    shift_nud: Array<number> | null = null,
    fractional_intensity: number | null = null,
    bias_correct_flag: boolean = false,
    center_of_gravity: Array<number> | null = null,
    qc_images: string | null = null,
): FslDefaceParametersTagged {
    const params = {
        "@type": "fsl/fsl_deface" as const,
        "infile": infile,
        "outfile": outfile,
        "cropped_defacing_flag": cropped_defacing_flag,
        "bias_correct_flag": bias_correct_flag,
    };
    if (defacing_mask !== null) {
        params["defacing_mask"] = defacing_mask;
    }
    if (cropped_struc !== null) {
        params["cropped_struc"] = cropped_struc;
    }
    if (orig_to_std_mat !== null) {
        params["orig_to_std_mat"] = orig_to_std_mat;
    }
    if (orig_to_cropped_mat !== null) {
        params["orig_to_cropped_mat"] = orig_to_cropped_mat;
    }
    if (cropped_to_std_mat !== null) {
        params["cropped_to_std_mat"] = cropped_to_std_mat;
    }
    if (shift_nud !== null) {
        params["shift_nud"] = shift_nud;
    }
    if (fractional_intensity !== null) {
        params["fractional_intensity"] = fractional_intensity;
    }
    if (center_of_gravity !== null) {
        params["center_of_gravity"] = center_of_gravity;
    }
    if (qc_images !== null) {
        params["qc_images"] = qc_images;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function fsl_deface_cargs(
    params: FslDefaceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("fsl_deface");
    cargs.push(execution.inputFile((params["infile"] ?? null)));
    cargs.push((params["outfile"] ?? null));
    if ((params["cropped_defacing_flag"] ?? false)) {
        cargs.push("-k");
    }
    if ((params["defacing_mask"] ?? null) !== null) {
        cargs.push(
            "-d",
            (params["defacing_mask"] ?? null)
        );
    }
    if ((params["cropped_struc"] ?? null) !== null) {
        cargs.push(
            "-n",
            (params["cropped_struc"] ?? null)
        );
    }
    if ((params["orig_to_std_mat"] ?? null) !== null) {
        cargs.push(
            "-m13",
            (params["orig_to_std_mat"] ?? null)
        );
    }
    if ((params["orig_to_cropped_mat"] ?? null) !== null) {
        cargs.push(
            "-m12",
            (params["orig_to_cropped_mat"] ?? null)
        );
    }
    if ((params["cropped_to_std_mat"] ?? null) !== null) {
        cargs.push(
            "-m23",
            (params["cropped_to_std_mat"] ?? null)
        );
    }
    if ((params["shift_nud"] ?? null) !== null) {
        cargs.push(
            "-nud",
            ...(params["shift_nud"] ?? null).map(String)
        );
    }
    if ((params["fractional_intensity"] ?? null) !== null) {
        cargs.push(
            "-f",
            String((params["fractional_intensity"] ?? null))
        );
    }
    if ((params["bias_correct_flag"] ?? false)) {
        cargs.push("-B");
    }
    if ((params["center_of_gravity"] ?? null) !== null) {
        cargs.push(
            "-c",
            ...(params["center_of_gravity"] ?? null).map(String)
        );
    }
    if ((params["qc_images"] ?? null) !== null) {
        cargs.push(
            "-p",
            (params["qc_images"] ?? null)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function fsl_deface_outputs(
    params: FslDefaceParameters,
    execution: Execution,
): FslDefaceOutputs {
    const ret: FslDefaceOutputs = {
        root: execution.outputFile("."),
        outfile: execution.outputFile([(params["outfile"] ?? null), ".nii.gz"].join('')),
        out_defacing_mask: ((params["defacing_mask"] ?? null) !== null) ? execution.outputFile([(params["defacing_mask"] ?? null), ".nii.gz"].join('')) : null,
        out_cropped_struc: ((params["cropped_struc"] ?? null) !== null) ? execution.outputFile([(params["cropped_struc"] ?? null), ".nii.gz"].join('')) : null,
        out_orig_to_std_mat: ((params["orig_to_std_mat"] ?? null) !== null) ? execution.outputFile([(params["orig_to_std_mat"] ?? null), ".mat"].join('')) : null,
        out_orig_to_cropped_mat: ((params["orig_to_cropped_mat"] ?? null) !== null) ? execution.outputFile([(params["orig_to_cropped_mat"] ?? null), ".mat"].join('')) : null,
        out_cropped_to_std_mat: ((params["cropped_to_std_mat"] ?? null) !== null) ? execution.outputFile([(params["cropped_to_std_mat"] ?? null), ".mat"].join('')) : null,
        qc_image_original: ((params["qc_images"] ?? null) !== null) ? execution.outputFile([(params["qc_images"] ?? null), "_defaced_original.png"].join('')) : null,
        qc_image_cropped: ((params["qc_images"] ?? null) !== null) ? execution.outputFile([(params["qc_images"] ?? null), "_defaced_cropped.png"].join('')) : null,
    };
    return ret;
}


/**
 * fsl_deface
 *
 * Tool to deface a structural T1w image.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FslDefaceOutputs`).
 */
function fsl_deface_execute(
    params: FslDefaceParameters,
    runner: Runner | null = null,
): FslDefaceOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(FSL_DEFACE_METADATA);
    params = execution.params(params)
    const cargs = fsl_deface_cargs(params, execution)
    const ret = fsl_deface_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * fsl_deface
 *
 * Tool to deface a structural T1w image.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param infile Input T1w image
 * @param outfile Output defaced T1w image
 * @param cropped_defacing_flag Apply the defacing to the cropped image instead of the original image
 * @param defacing_mask Filename to save the defacing mask
 * @param cropped_struc Filename to save the new cropped struct
 * @param orig_to_std_mat Filename to save affine matrix from original struct to std
 * @param orig_to_cropped_mat Filename to save affine matrix from original struct to cropped struct
 * @param cropped_to_std_mat Filename to save affine matrix from cropped struct to std
 * @param shift_nud Shift, in mm, x-, y- and z-directions, to shift face mask by (These matrices will only work if the input has been previously reoriented to std)
 * @param fractional_intensity Fractional intensity for bet (0->1); default=0.5
 * @param bias_correct_flag Bias-correct the input image (with fast)
 * @param center_of_gravity Center-of-gravity for bet (voxels, not mm)
 * @param qc_images Generate 2 pngs to show how the defacing worked for QC purposes
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FslDefaceOutputs`).
 */
function fsl_deface(
    infile: InputPathType,
    outfile: string,
    cropped_defacing_flag: boolean = false,
    defacing_mask: string | null = null,
    cropped_struc: string | null = null,
    orig_to_std_mat: string | null = null,
    orig_to_cropped_mat: string | null = null,
    cropped_to_std_mat: string | null = null,
    shift_nud: Array<number> | null = null,
    fractional_intensity: number | null = null,
    bias_correct_flag: boolean = false,
    center_of_gravity: Array<number> | null = null,
    qc_images: string | null = null,
    runner: Runner | null = null,
): FslDefaceOutputs {
    const params = fsl_deface_params(infile, outfile, cropped_defacing_flag, defacing_mask, cropped_struc, orig_to_std_mat, orig_to_cropped_mat, cropped_to_std_mat, shift_nud, fractional_intensity, bias_correct_flag, center_of_gravity, qc_images)
    return fsl_deface_execute(params, runner);
}


export {
      FSL_DEFACE_METADATA,
      FslDefaceOutputs,
      fsl_deface,
      fsl_deface_execute,
      fsl_deface_params,
};
