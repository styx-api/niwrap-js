// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const IMCAT_METADATA: Metadata = {
    id: "6a0a0bce655557ed4d9e4948bfaf9cd151a149da.boutiques",
    name: "imcat",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface ImcatParameters {
    "@type"?: "afni/imcat";
    "input_files": Array<InputPathType>;
    "scale_image"?: InputPathType | null | undefined;
    "scale_pixels"?: InputPathType | null | undefined;
    "scale_intensity": boolean;
    "gscale"?: number | null | undefined;
    "rgb_out": boolean;
    "res_in"?: Array<number> | null | undefined;
    "respad_in"?: Array<number> | null | undefined;
    "pad_val"?: number | null | undefined;
    "crop"?: Array<number> | null | undefined;
    "autocrop_ctol"?: number | null | undefined;
    "autocrop_atol"?: number | null | undefined;
    "autocrop": boolean;
    "zero_wrap": boolean;
    "white_wrap": boolean;
    "gray_wrap"?: number | null | undefined;
    "image_wrap": boolean;
    "rand_wrap": boolean;
    "prefix"?: string | null | undefined;
    "matrix"?: Array<number> | null | undefined;
    "nx"?: number | null | undefined;
    "ny"?: number | null | undefined;
    "matrix_from_scale": boolean;
    "gap"?: number | null | undefined;
    "gap_col"?: Array<number> | null | undefined;
}
type ImcatParametersTagged = Required<Pick<ImcatParameters, '@type'>> & ImcatParameters;


/**
 * Output object returned when calling `ImcatParameters(...)`.
 *
 * @interface
 */
interface ImcatOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output image file
     */
    output_image_file: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param input_files Input image files
 * @param scale_image Multiply each image IM(i,j) in output image matrix IM by the color or intensity of the pixel (i,j) in SCALE_IMG.
 * @param scale_pixels Multiply each pixel (i,j) in output image by the color or intensity of the pixel (i,j) in SCALE_IMG. SCALE_IMG is automatically resized to the resolution of the output image.
 * @param scale_intensity Instead of multiplying by the color of pixel (i,j), use its intensity (average color).
 * @param gscale Apply FAC in addition to scaling of -scale_* options.
 * @param rgb_out Force output to be in RGB, even if input is bytes. This option is turned on automatically in certain cases.
 * @param res_in Set resolution of all input images to RX by RY pixels. Default is to make all input have the same resolution as the first image.
 * @param respad_in Like -res_in, but resample to the max while respecting the aspect ratio, and then pad to achieve desired pixel count.
 * @param pad_val Set the padding value, should it be needed by -respad_in to VAL. VAL is typecast to byte, default is 0, max is 255.
 * @param crop Crop images by L (Left), R (Right), T (Top), B (Bottom) pixels. Cutting is performed after any resolution change, if any, is to be done.
 * @param autocrop_ctol A line is eliminated if none of its R G B values differ by more than CTOL% from those of the corner pixel.
 * @param autocrop_atol A line is eliminated if none of its R G B values differ by more than ATOL% from those of line average.
 * @param autocrop This option is the same as using both of -autocrop_atol 20 and -autocrop_ctol 20
 * @param zero_wrap If number of images is not enough to fill matrix solid black images are used.
 * @param white_wrap If number of images is not enough to fill matrix solid white images are used.
 * @param gray_wrap If number of images is not enough to fill matrix, solid gray images are used. GRAY must be between 0 and 1.0.
 * @param image_wrap If number of images is not enough to fill matrix, images on command line are reused (default).
 * @param rand_wrap When reusing images to fill matrix, randomize the order in refill section only.
 * @param prefix Prefix the output files with string 'ppp'.
 * @param matrix Specify number of images in each row and column of IM at the same time.
 * @param nx Number of images in each row.
 * @param ny Number of images in each column.
 * @param matrix_from_scale Set NX and NY to be the same as the SCALE_IMG's dimensions. (needs -scale_image)
 * @param gap Put a line G pixels wide between images.
 * @param gap_col Set color of line to R G B values. Values range between 0 and 255.
 *
 * @returns Parameter dictionary
 */
function imcat_params(
    input_files: Array<InputPathType>,
    scale_image: InputPathType | null = null,
    scale_pixels: InputPathType | null = null,
    scale_intensity: boolean = false,
    gscale: number | null = null,
    rgb_out: boolean = false,
    res_in: Array<number> | null = null,
    respad_in: Array<number> | null = null,
    pad_val: number | null = null,
    crop: Array<number> | null = null,
    autocrop_ctol: number | null = null,
    autocrop_atol: number | null = null,
    autocrop: boolean = false,
    zero_wrap: boolean = false,
    white_wrap: boolean = false,
    gray_wrap: number | null = null,
    image_wrap: boolean = false,
    rand_wrap: boolean = false,
    prefix: string | null = null,
    matrix: Array<number> | null = null,
    nx: number | null = null,
    ny: number | null = null,
    matrix_from_scale: boolean = false,
    gap: number | null = null,
    gap_col: Array<number> | null = null,
): ImcatParametersTagged {
    const params = {
        "@type": "afni/imcat" as const,
        "input_files": input_files,
        "scale_intensity": scale_intensity,
        "rgb_out": rgb_out,
        "autocrop": autocrop,
        "zero_wrap": zero_wrap,
        "white_wrap": white_wrap,
        "image_wrap": image_wrap,
        "rand_wrap": rand_wrap,
        "matrix_from_scale": matrix_from_scale,
    };
    if (scale_image !== null) {
        params["scale_image"] = scale_image;
    }
    if (scale_pixels !== null) {
        params["scale_pixels"] = scale_pixels;
    }
    if (gscale !== null) {
        params["gscale"] = gscale;
    }
    if (res_in !== null) {
        params["res_in"] = res_in;
    }
    if (respad_in !== null) {
        params["respad_in"] = respad_in;
    }
    if (pad_val !== null) {
        params["pad_val"] = pad_val;
    }
    if (crop !== null) {
        params["crop"] = crop;
    }
    if (autocrop_ctol !== null) {
        params["autocrop_ctol"] = autocrop_ctol;
    }
    if (autocrop_atol !== null) {
        params["autocrop_atol"] = autocrop_atol;
    }
    if (gray_wrap !== null) {
        params["gray_wrap"] = gray_wrap;
    }
    if (prefix !== null) {
        params["prefix"] = prefix;
    }
    if (matrix !== null) {
        params["matrix"] = matrix;
    }
    if (nx !== null) {
        params["nx"] = nx;
    }
    if (ny !== null) {
        params["ny"] = ny;
    }
    if (gap !== null) {
        params["gap"] = gap;
    }
    if (gap_col !== null) {
        params["gap_col"] = gap_col;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function imcat_cargs(
    params: ImcatParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("imcat");
    cargs.push(...(params["input_files"] ?? null).map(f => execution.inputFile(f)));
    if ((params["scale_image"] ?? null) !== null) {
        cargs.push(
            "-scale_image",
            execution.inputFile((params["scale_image"] ?? null))
        );
    }
    if ((params["scale_pixels"] ?? null) !== null) {
        cargs.push(
            "-scale_pixels",
            execution.inputFile((params["scale_pixels"] ?? null))
        );
    }
    if ((params["scale_intensity"] ?? false)) {
        cargs.push("-scale_intensity");
    }
    if ((params["gscale"] ?? null) !== null) {
        cargs.push(
            "-gscale",
            String((params["gscale"] ?? null))
        );
    }
    if ((params["rgb_out"] ?? false)) {
        cargs.push("-rgb_out");
    }
    if ((params["res_in"] ?? null) !== null) {
        cargs.push(
            "-res_in",
            ...(params["res_in"] ?? null).map(String)
        );
    }
    if ((params["respad_in"] ?? null) !== null) {
        cargs.push(
            "-respad_in",
            ...(params["respad_in"] ?? null).map(String)
        );
    }
    if ((params["pad_val"] ?? null) !== null) {
        cargs.push(
            "-pad_val",
            String((params["pad_val"] ?? null))
        );
    }
    if ((params["crop"] ?? null) !== null) {
        cargs.push(
            "-crop",
            ...(params["crop"] ?? null).map(String)
        );
    }
    if ((params["autocrop_ctol"] ?? null) !== null) {
        cargs.push(
            "-autocrop_ctol",
            String((params["autocrop_ctol"] ?? null))
        );
    }
    if ((params["autocrop_atol"] ?? null) !== null) {
        cargs.push(
            "-autocrop_atol",
            String((params["autocrop_atol"] ?? null))
        );
    }
    if ((params["autocrop"] ?? false)) {
        cargs.push("-autocrop");
    }
    if ((params["zero_wrap"] ?? false)) {
        cargs.push("-zero_wrap");
    }
    if ((params["white_wrap"] ?? false)) {
        cargs.push("-white_wrap");
    }
    if ((params["gray_wrap"] ?? null) !== null) {
        cargs.push(
            "-gray_wrap",
            String((params["gray_wrap"] ?? null))
        );
    }
    if ((params["image_wrap"] ?? false)) {
        cargs.push("-image_wrap");
    }
    if ((params["rand_wrap"] ?? false)) {
        cargs.push("-rand_wrap");
    }
    if ((params["prefix"] ?? null) !== null) {
        cargs.push(
            "-prefix",
            (params["prefix"] ?? null)
        );
    }
    if ((params["matrix"] ?? null) !== null) {
        cargs.push(
            "-matrix",
            ...(params["matrix"] ?? null).map(String)
        );
    }
    if ((params["nx"] ?? null) !== null) {
        cargs.push(
            "-nx",
            String((params["nx"] ?? null))
        );
    }
    if ((params["ny"] ?? null) !== null) {
        cargs.push(
            "-ny",
            String((params["ny"] ?? null))
        );
    }
    if ((params["matrix_from_scale"] ?? false)) {
        cargs.push("-matrix_from_scale");
    }
    if ((params["gap"] ?? null) !== null) {
        cargs.push(
            "-gap",
            String((params["gap"] ?? null))
        );
    }
    if ((params["gap_col"] ?? null) !== null) {
        cargs.push(
            "-gap_col",
            ...(params["gap_col"] ?? null).map(String)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function imcat_outputs(
    params: ImcatParameters,
    execution: Execution,
): ImcatOutputs {
    const ret: ImcatOutputs = {
        root: execution.outputFile("."),
        output_image_file: ((params["prefix"] ?? null) !== null) ? execution.outputFile([(params["prefix"] ?? null), "output_image.[EXT]"].join('')) : null,
    };
    return ret;
}


/**
 * imcat
 *
 * Assembles a set of images into an image matrix (IM) montage of NX by NY images.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ImcatOutputs`).
 */
function imcat_execute(
    params: ImcatParameters,
    runner: Runner | null = null,
): ImcatOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(IMCAT_METADATA);
    params = execution.params(params)
    const cargs = imcat_cargs(params, execution)
    const ret = imcat_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * imcat
 *
 * Assembles a set of images into an image matrix (IM) montage of NX by NY images.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param input_files Input image files
 * @param scale_image Multiply each image IM(i,j) in output image matrix IM by the color or intensity of the pixel (i,j) in SCALE_IMG.
 * @param scale_pixels Multiply each pixel (i,j) in output image by the color or intensity of the pixel (i,j) in SCALE_IMG. SCALE_IMG is automatically resized to the resolution of the output image.
 * @param scale_intensity Instead of multiplying by the color of pixel (i,j), use its intensity (average color).
 * @param gscale Apply FAC in addition to scaling of -scale_* options.
 * @param rgb_out Force output to be in RGB, even if input is bytes. This option is turned on automatically in certain cases.
 * @param res_in Set resolution of all input images to RX by RY pixels. Default is to make all input have the same resolution as the first image.
 * @param respad_in Like -res_in, but resample to the max while respecting the aspect ratio, and then pad to achieve desired pixel count.
 * @param pad_val Set the padding value, should it be needed by -respad_in to VAL. VAL is typecast to byte, default is 0, max is 255.
 * @param crop Crop images by L (Left), R (Right), T (Top), B (Bottom) pixels. Cutting is performed after any resolution change, if any, is to be done.
 * @param autocrop_ctol A line is eliminated if none of its R G B values differ by more than CTOL% from those of the corner pixel.
 * @param autocrop_atol A line is eliminated if none of its R G B values differ by more than ATOL% from those of line average.
 * @param autocrop This option is the same as using both of -autocrop_atol 20 and -autocrop_ctol 20
 * @param zero_wrap If number of images is not enough to fill matrix solid black images are used.
 * @param white_wrap If number of images is not enough to fill matrix solid white images are used.
 * @param gray_wrap If number of images is not enough to fill matrix, solid gray images are used. GRAY must be between 0 and 1.0.
 * @param image_wrap If number of images is not enough to fill matrix, images on command line are reused (default).
 * @param rand_wrap When reusing images to fill matrix, randomize the order in refill section only.
 * @param prefix Prefix the output files with string 'ppp'.
 * @param matrix Specify number of images in each row and column of IM at the same time.
 * @param nx Number of images in each row.
 * @param ny Number of images in each column.
 * @param matrix_from_scale Set NX and NY to be the same as the SCALE_IMG's dimensions. (needs -scale_image)
 * @param gap Put a line G pixels wide between images.
 * @param gap_col Set color of line to R G B values. Values range between 0 and 255.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ImcatOutputs`).
 */
function imcat(
    input_files: Array<InputPathType>,
    scale_image: InputPathType | null = null,
    scale_pixels: InputPathType | null = null,
    scale_intensity: boolean = false,
    gscale: number | null = null,
    rgb_out: boolean = false,
    res_in: Array<number> | null = null,
    respad_in: Array<number> | null = null,
    pad_val: number | null = null,
    crop: Array<number> | null = null,
    autocrop_ctol: number | null = null,
    autocrop_atol: number | null = null,
    autocrop: boolean = false,
    zero_wrap: boolean = false,
    white_wrap: boolean = false,
    gray_wrap: number | null = null,
    image_wrap: boolean = false,
    rand_wrap: boolean = false,
    prefix: string | null = null,
    matrix: Array<number> | null = null,
    nx: number | null = null,
    ny: number | null = null,
    matrix_from_scale: boolean = false,
    gap: number | null = null,
    gap_col: Array<number> | null = null,
    runner: Runner | null = null,
): ImcatOutputs {
    const params = imcat_params(input_files, scale_image, scale_pixels, scale_intensity, gscale, rgb_out, res_in, respad_in, pad_val, crop, autocrop_ctol, autocrop_atol, autocrop, zero_wrap, white_wrap, gray_wrap, image_wrap, rand_wrap, prefix, matrix, nx, ny, matrix_from_scale, gap, gap_col)
    return imcat_execute(params, runner);
}


export {
      IMCAT_METADATA,
      ImcatOutputs,
      imcat,
      imcat_execute,
      imcat_params,
};
