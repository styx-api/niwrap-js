// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const C4D_METADATA: Metadata = {
    id: "b6dae542b7c7afb091071a6e55e8e03f16b1fcb9.boutiques",
    name: "c4d",
    package: "c3d",
    container_image_tag: "pyushkevich/itksnap:v3.8.2",
};


interface C4dAccumParameters {
    "@type"?: "accum";
    "accum": string;
}
type C4dAccumParametersTagged = Required<Pick<C4dAccumParameters, '@type'>> & C4dAccumParameters;


interface C4dAcosParameters {
    "@type"?: "acos";
    "acos": string;
}
type C4dAcosParametersTagged = Required<Pick<C4dAcosParameters, '@type'>> & C4dAcosParameters;


interface C4dAddParameters {
    "@type"?: "add";
    "add": string;
}
type C4dAddParametersTagged = Required<Pick<C4dAddParameters, '@type'>> & C4dAddParameters;


interface C4dAlignLandmarksParameters {
    "@type"?: "align_landmarks";
    "align_landmarks": string;
}
type C4dAlignLandmarksParametersTagged = Required<Pick<C4dAlignLandmarksParameters, '@type'>> & C4dAlignLandmarksParameters;


interface C4dAnisotropicDiffusionParameters {
    "@type"?: "anisotropic_diffusion";
    "anisotropic_diffusion": string;
}
type C4dAnisotropicDiffusionParametersTagged = Required<Pick<C4dAnisotropicDiffusionParameters, '@type'>> & C4dAnisotropicDiffusionParameters;


interface C4dAntialiasParameters {
    "@type"?: "antialias";
    "antialias": string;
}
type C4dAntialiasParametersTagged = Required<Pick<C4dAntialiasParameters, '@type'>> & C4dAntialiasParameters;


interface C4dSetParameters {
    "@type"?: "set";
    "set": string;
}
type C4dSetParametersTagged = Required<Pick<C4dSetParameters, '@type'>> & C4dSetParameters;


interface C4dAsinParameters {
    "@type"?: "asin";
    "asin": string;
}
type C4dAsinParametersTagged = Required<Pick<C4dAsinParameters, '@type'>> & C4dAsinParameters;


interface C4dAtan2Parameters {
    "@type"?: "atan2";
    "atan2": string;
}
type C4dAtan2ParametersTagged = Required<Pick<C4dAtan2Parameters, '@type'>> & C4dAtan2Parameters;


interface C4dBackgroundParameters {
    "@type"?: "background";
    "background": string;
}
type C4dBackgroundParametersTagged = Required<Pick<C4dBackgroundParameters, '@type'>> & C4dBackgroundParameters;


interface C4dN4BiasCorrectionParameters {
    "@type"?: "n4_bias_correction";
    "n4_bias_correction": string;
}
type C4dN4BiasCorrectionParametersTagged = Required<Pick<C4dN4BiasCorrectionParameters, '@type'>> & C4dN4BiasCorrectionParameters;


interface C4dBinarizeParameters {
    "@type"?: "binarize";
    "binarize": string;
}
type C4dBinarizeParametersTagged = Required<Pick<C4dBinarizeParameters, '@type'>> & C4dBinarizeParameters;


interface C4dCannyParameters {
    "@type"?: "canny";
    "canny": string;
}
type C4dCannyParametersTagged = Required<Pick<C4dCannyParameters, '@type'>> & C4dCannyParameters;


interface C4dCeilParameters {
    "@type"?: "ceil";
    "ceil": string;
}
type C4dCeilParametersTagged = Required<Pick<C4dCeilParameters, '@type'>> & C4dCeilParameters;


interface C4dCentroidParameters {
    "@type"?: "centroid";
    "centroid": string;
}
type C4dCentroidParametersTagged = Required<Pick<C4dCentroidParameters, '@type'>> & C4dCentroidParameters;


interface C4dCentroidMarkParameters {
    "@type"?: "centroid_mark";
    "centroid_mark": string;
}
type C4dCentroidMarkParametersTagged = Required<Pick<C4dCentroidMarkParameters, '@type'>> & C4dCentroidMarkParameters;


interface C4dConnectedComponentsParameters {
    "@type"?: "connected_components";
    "connected_components": string;
}
type C4dConnectedComponentsParametersTagged = Required<Pick<C4dConnectedComponentsParameters, '@type'>> & C4dConnectedComponentsParameters;


interface C4dClearParameters {
    "@type"?: "clear";
    "clear": string;
}
type C4dClearParametersTagged = Required<Pick<C4dClearParameters, '@type'>> & C4dClearParameters;


interface C4dClipParameters {
    "@type"?: "clip";
    "clip": string;
}
type C4dClipParametersTagged = Required<Pick<C4dClipParameters, '@type'>> & C4dClipParameters;


interface C4dColorMapParameters {
    "@type"?: "color_map";
    "color_map": string;
}
type C4dColorMapParametersTagged = Required<Pick<C4dColorMapParameters, '@type'>> & C4dColorMapParameters;


interface C4dCompressParameters {
    "@type"?: "compress";
    "compress": string;
}
type C4dCompressParametersTagged = Required<Pick<C4dCompressParameters, '@type'>> & C4dCompressParameters;


interface C4dNoCompressParameters {
    "@type"?: "no_compress";
    "no_compress": string;
}
type C4dNoCompressParametersTagged = Required<Pick<C4dNoCompressParameters, '@type'>> & C4dNoCompressParameters;


interface C4dConvParameters {
    "@type"?: "conv";
    "conv": string;
}
type C4dConvParametersTagged = Required<Pick<C4dConvParameters, '@type'>> & C4dConvParameters;


interface C4dCoordinateMapVoxelParameters {
    "@type"?: "coordinate_map_voxel";
    "coordinate_map_voxel": string;
}
type C4dCoordinateMapVoxelParametersTagged = Required<Pick<C4dCoordinateMapVoxelParameters, '@type'>> & C4dCoordinateMapVoxelParameters;


interface C4dCoordinateMapPhysicalParameters {
    "@type"?: "coordinate_map_physical";
    "coordinate_map_physical": string;
}
type C4dCoordinateMapPhysicalParametersTagged = Required<Pick<C4dCoordinateMapPhysicalParameters, '@type'>> & C4dCoordinateMapPhysicalParameters;


interface C4dCopyTransformParameters {
    "@type"?: "copy_transform";
    "copy_transform": string;
}
type C4dCopyTransformParametersTagged = Required<Pick<C4dCopyTransformParameters, '@type'>> & C4dCopyTransformParameters;


interface C4dCosParameters {
    "@type"?: "cos";
    "cos": string;
}
type C4dCosParametersTagged = Required<Pick<C4dCosParameters, '@type'>> & C4dCosParameters;


interface C4dCreateParameters {
    "@type"?: "create";
    "create": string;
}
type C4dCreateParametersTagged = Required<Pick<C4dCreateParameters, '@type'>> & C4dCreateParameters;


interface C4dDicomSeriesListParameters {
    "@type"?: "dicom_series_list";
    "dicom_series_list": string;
}
type C4dDicomSeriesListParametersTagged = Required<Pick<C4dDicomSeriesListParameters, '@type'>> & C4dDicomSeriesListParameters;


interface C4dDicomSeriesReadParameters {
    "@type"?: "dicom_series_read";
    "dicom_series_read": string;
}
type C4dDicomSeriesReadParametersTagged = Required<Pick<C4dDicomSeriesReadParameters, '@type'>> & C4dDicomSeriesReadParameters;


interface C4dDilateParameters {
    "@type"?: "dilate";
    "dilate": string;
}
type C4dDilateParametersTagged = Required<Pick<C4dDilateParameters, '@type'>> & C4dDilateParameters;


interface C4dDivideParameters {
    "@type"?: "divide";
    "divide": string;
}
type C4dDivideParametersTagged = Required<Pick<C4dDivideParameters, '@type'>> & C4dDivideParameters;


interface C4dDuplicateParameters {
    "@type"?: "duplicate";
    "duplicate": string;
}
type C4dDuplicateParametersTagged = Required<Pick<C4dDuplicateParameters, '@type'>> & C4dDuplicateParameters;


interface C4dEndaccumParameters {
    "@type"?: "endaccum";
    "endaccum": string;
}
type C4dEndaccumParametersTagged = Required<Pick<C4dEndaccumParameters, '@type'>> & C4dEndaccumParameters;


interface C4dEndforParameters {
    "@type"?: "endfor";
    "endfor": string;
}
type C4dEndforParametersTagged = Required<Pick<C4dEndforParameters, '@type'>> & C4dEndforParameters;


interface C4dErodeParameters {
    "@type"?: "erode";
    "erode": string;
}
type C4dErodeParametersTagged = Required<Pick<C4dErodeParameters, '@type'>> & C4dErodeParameters;


interface C4dErfParameters {
    "@type"?: "erf";
    "erf": string;
}
type C4dErfParametersTagged = Required<Pick<C4dErfParameters, '@type'>> & C4dErfParameters;


interface C4dExpParameters {
    "@type"?: "exp";
    "exp": string;
}
type C4dExpParametersTagged = Required<Pick<C4dExpParameters, '@type'>> & C4dExpParameters;


interface C4dExportPatchesParameters {
    "@type"?: "export_patches";
    "export_patches": string;
}
type C4dExportPatchesParametersTagged = Required<Pick<C4dExportPatchesParameters, '@type'>> & C4dExportPatchesParameters;


interface C4dExportPatchesAugParameters {
    "@type"?: "export_patches_aug";
    "export_patches_aug": string;
}
type C4dExportPatchesAugParametersTagged = Required<Pick<C4dExportPatchesAugParameters, '@type'>> & C4dExportPatchesAugParameters;


interface C4dExtrudeSegParameters {
    "@type"?: "extrude_seg";
    "extrude_seg": string;
}
type C4dExtrudeSegParametersTagged = Required<Pick<C4dExtrudeSegParameters, '@type'>> & C4dExtrudeSegParameters;


interface C4dFillBackgroundWithNoiseParameters {
    "@type"?: "fill_background_with_noise";
    "fill_background_with_noise": string;
}
type C4dFillBackgroundWithNoiseParametersTagged = Required<Pick<C4dFillBackgroundWithNoiseParameters, '@type'>> & C4dFillBackgroundWithNoiseParameters;


interface C4dFftParameters {
    "@type"?: "fft";
    "fft": string;
}
type C4dFftParametersTagged = Required<Pick<C4dFftParameters, '@type'>> & C4dFftParameters;


interface C4dFlipParameters {
    "@type"?: "flip";
    "flip": string;
}
type C4dFlipParametersTagged = Required<Pick<C4dFlipParameters, '@type'>> & C4dFlipParameters;


interface C4dFloorParameters {
    "@type"?: "floor";
    "floor": string;
}
type C4dFloorParametersTagged = Required<Pick<C4dFloorParameters, '@type'>> & C4dFloorParameters;


interface C4dForeachParameters {
    "@type"?: "foreach";
    "foreach": string;
}
type C4dForeachParametersTagged = Required<Pick<C4dForeachParameters, '@type'>> & C4dForeachParameters;


interface C4dForeachCompParameters {
    "@type"?: "foreach_comp";
    "foreach_comp": string;
}
type C4dForeachCompParametersTagged = Required<Pick<C4dForeachCompParameters, '@type'>> & C4dForeachCompParameters;


interface C4dGlmParameters {
    "@type"?: "glm";
    "glm": string;
}
type C4dGlmParametersTagged = Required<Pick<C4dGlmParameters, '@type'>> & C4dGlmParameters;


interface C4dGradientParameters {
    "@type"?: "gradient";
    "gradient": string;
}
type C4dGradientParametersTagged = Required<Pick<C4dGradientParameters, '@type'>> & C4dGradientParameters;


interface C4dHelpParameters {
    "@type"?: "_help";
    "_help": string;
}
type C4dHelpParametersTagged = Required<Pick<C4dHelpParameters, '@type'>> & C4dHelpParameters;


interface C4dHolefillParameters {
    "@type"?: "holefill";
    "holefill": string;
}
type C4dHolefillParametersTagged = Required<Pick<C4dHolefillParameters, '@type'>> & C4dHolefillParameters;


interface C4dHessianEigenvaluesParameters {
    "@type"?: "hessian_eigenvalues";
    "hessian_eigenvalues": string;
}
type C4dHessianEigenvaluesParametersTagged = Required<Pick<C4dHessianEigenvaluesParameters, '@type'>> & C4dHessianEigenvaluesParameters;


interface C4dHessianObjectnessParameters {
    "@type"?: "hessian_objectness";
    "hessian_objectness": string;
}
type C4dHessianObjectnessParametersTagged = Required<Pick<C4dHessianObjectnessParameters, '@type'>> & C4dHessianObjectnessParameters;


interface C4dHistogramMatchParameters {
    "@type"?: "histogram_match";
    "histogram_match": string;
}
type C4dHistogramMatchParametersTagged = Required<Pick<C4dHistogramMatchParameters, '@type'>> & C4dHistogramMatchParameters;


interface C4dInfoParameters {
    "@type"?: "info";
    "info": string;
}
type C4dInfoParametersTagged = Required<Pick<C4dInfoParameters, '@type'>> & C4dInfoParameters;


interface C4dInfoFullParameters {
    "@type"?: "info_full";
    "info_full": string;
}
type C4dInfoFullParametersTagged = Required<Pick<C4dInfoFullParameters, '@type'>> & C4dInfoFullParameters;


interface C4dInsertParameters {
    "@type"?: "insert";
    "insert": string;
}
type C4dInsertParametersTagged = Required<Pick<C4dInsertParameters, '@type'>> & C4dInsertParameters;


interface C4dInterpolationParameters {
    "@type"?: "interpolation";
    "interpolation": string;
}
type C4dInterpolationParametersTagged = Required<Pick<C4dInterpolationParameters, '@type'>> & C4dInterpolationParameters;


interface C4dIterationsParameters {
    "@type"?: "iterations";
    "iterations": string;
}
type C4dIterationsParametersTagged = Required<Pick<C4dIterationsParameters, '@type'>> & C4dIterationsParameters;


interface C4dLabelOverlapParameters {
    "@type"?: "label_overlap";
    "label_overlap": string;
}
type C4dLabelOverlapParametersTagged = Required<Pick<C4dLabelOverlapParameters, '@type'>> & C4dLabelOverlapParameters;


interface C4dLabelStatisticsParameters {
    "@type"?: "label_statistics";
    "label_statistics": string;
}
type C4dLabelStatisticsParametersTagged = Required<Pick<C4dLabelStatisticsParameters, '@type'>> & C4dLabelStatisticsParameters;


interface C4dLandmarksToSpheresParameters {
    "@type"?: "landmarks_to_spheres";
    "landmarks_to_spheres": string;
}
type C4dLandmarksToSpheresParametersTagged = Required<Pick<C4dLandmarksToSpheresParameters, '@type'>> & C4dLandmarksToSpheresParameters;


interface C4dLaplacianParameters {
    "@type"?: "laplacian";
    "laplacian": string;
}
type C4dLaplacianParametersTagged = Required<Pick<C4dLaplacianParameters, '@type'>> & C4dLaplacianParameters;


interface C4dLevelsetParameters {
    "@type"?: "levelset";
    "levelset": string;
}
type C4dLevelsetParametersTagged = Required<Pick<C4dLevelsetParameters, '@type'>> & C4dLevelsetParameters;


interface C4dLevelsetCurvatureParameters {
    "@type"?: "levelset_curvature";
    "levelset_curvature": string;
}
type C4dLevelsetCurvatureParametersTagged = Required<Pick<C4dLevelsetCurvatureParameters, '@type'>> & C4dLevelsetCurvatureParameters;


interface C4dLevelsetAdvectionParameters {
    "@type"?: "levelset_advection";
    "levelset_advection": string;
}
type C4dLevelsetAdvectionParametersTagged = Required<Pick<C4dLevelsetAdvectionParameters, '@type'>> & C4dLevelsetAdvectionParameters;


interface C4dLogParameters {
    "@type"?: "log";
    "log": string;
}
type C4dLogParametersTagged = Required<Pick<C4dLogParameters, '@type'>> & C4dLogParameters;


interface C4dLog10Parameters {
    "@type"?: "log10";
    "log10": string;
}
type C4dLog10ParametersTagged = Required<Pick<C4dLog10Parameters, '@type'>> & C4dLog10Parameters;


interface C4dManualParameters {
    "@type"?: "manual";
    "manual": string;
}
type C4dManualParametersTagged = Required<Pick<C4dManualParameters, '@type'>> & C4dManualParameters;


interface C4dMatchBoundingBoxParameters {
    "@type"?: "match_bounding_box";
    "match_bounding_box": string;
}
type C4dMatchBoundingBoxParametersTagged = Required<Pick<C4dMatchBoundingBoxParameters, '@type'>> & C4dMatchBoundingBoxParameters;


interface C4dMaximumParameters {
    "@type"?: "maximum";
    "maximum": string;
}
type C4dMaximumParametersTagged = Required<Pick<C4dMaximumParameters, '@type'>> & C4dMaximumParameters;


interface C4dMulticomponentSplitParameters {
    "@type"?: "multicomponent_split";
    "multicomponent_split": string;
}
type C4dMulticomponentSplitParametersTagged = Required<Pick<C4dMulticomponentSplitParameters, '@type'>> & C4dMulticomponentSplitParameters;


interface C4dMeanParameters {
    "@type"?: "mean";
    "mean": string;
}
type C4dMeanParametersTagged = Required<Pick<C4dMeanParameters, '@type'>> & C4dMeanParameters;


interface C4dMedianFilterParameters {
    "@type"?: "median_filter";
    "median_filter": string;
}
type C4dMedianFilterParametersTagged = Required<Pick<C4dMedianFilterParameters, '@type'>> & C4dMedianFilterParameters;


interface C4dMergeParameters {
    "@type"?: "merge";
    "merge": string;
}
type C4dMergeParametersTagged = Required<Pick<C4dMergeParameters, '@type'>> & C4dMergeParameters;


interface C4dMeanFilterParameters {
    "@type"?: "mean_filter";
    "mean_filter": string;
}
type C4dMeanFilterParametersTagged = Required<Pick<C4dMeanFilterParameters, '@type'>> & C4dMeanFilterParameters;


interface C4dMutualInfoParameters {
    "@type"?: "mutual_info";
    "mutual_info": string;
}
type C4dMutualInfoParametersTagged = Required<Pick<C4dMutualInfoParameters, '@type'>> & C4dMutualInfoParameters;


interface C4dMinimumParameters {
    "@type"?: "minimum";
    "minimum": string;
}
type C4dMinimumParametersTagged = Required<Pick<C4dMinimumParameters, '@type'>> & C4dMinimumParameters;


interface C4dMixtureModelParameters {
    "@type"?: "mixture_model";
    "mixture_model": string;
}
type C4dMixtureModelParametersTagged = Required<Pick<C4dMixtureModelParameters, '@type'>> & C4dMixtureModelParameters;


interface C4dMomentsParameters {
    "@type"?: "moments";
    "moments": string;
}
type C4dMomentsParametersTagged = Required<Pick<C4dMomentsParameters, '@type'>> & C4dMomentsParameters;


interface C4dMattesMutualInfoParameters {
    "@type"?: "mattes_mutual_info";
    "mattes_mutual_info": string;
}
type C4dMattesMutualInfoParametersTagged = Required<Pick<C4dMattesMutualInfoParameters, '@type'>> & C4dMattesMutualInfoParameters;


interface C4dMeanSquareParameters {
    "@type"?: "mean_square";
    "mean_square": string;
}
type C4dMeanSquareParametersTagged = Required<Pick<C4dMeanSquareParameters, '@type'>> & C4dMeanSquareParameters;


interface C4dMultiplyParameters {
    "@type"?: "multiply";
    "multiply": string;
}
type C4dMultiplyParametersTagged = Required<Pick<C4dMultiplyParameters, '@type'>> & C4dMultiplyParameters;


interface C4dNormalizedCrossCorrelationParameters {
    "@type"?: "normalized_cross_correlation";
    "normalized_cross_correlation": string;
}
type C4dNormalizedCrossCorrelationParametersTagged = Required<Pick<C4dNormalizedCrossCorrelationParameters, '@type'>> & C4dNormalizedCrossCorrelationParameters;


interface C4dNormalizedCorrelationParameters {
    "@type"?: "normalized_correlation";
    "normalized_correlation": string;
}
type C4dNormalizedCorrelationParametersTagged = Required<Pick<C4dNormalizedCorrelationParameters, '@type'>> & C4dNormalizedCorrelationParameters;


interface C4dNormalizedMutualInfoParameters {
    "@type"?: "normalized_mutual_info";
    "normalized_mutual_info": string;
}
type C4dNormalizedMutualInfoParametersTagged = Required<Pick<C4dNormalizedMutualInfoParameters, '@type'>> & C4dNormalizedMutualInfoParameters;


interface C4dNoiseGaussianParameters {
    "@type"?: "noise_gaussian";
    "noise_gaussian": string;
}
type C4dNoiseGaussianParametersTagged = Required<Pick<C4dNoiseGaussianParameters, '@type'>> & C4dNoiseGaussianParameters;


interface C4dNoisePoissonParameters {
    "@type"?: "noise_poisson";
    "noise_poisson": string;
}
type C4dNoisePoissonParametersTagged = Required<Pick<C4dNoisePoissonParameters, '@type'>> & C4dNoisePoissonParameters;


interface C4dNoiseSpeckleParameters {
    "@type"?: "noise_speckle";
    "noise_speckle": string;
}
type C4dNoiseSpeckleParametersTagged = Required<Pick<C4dNoiseSpeckleParameters, '@type'>> & C4dNoiseSpeckleParameters;


interface C4dNoiseSaltPepperParameters {
    "@type"?: "noise_salt_pepper";
    "noise_salt_pepper": string;
}
type C4dNoiseSaltPepperParametersTagged = Required<Pick<C4dNoiseSaltPepperParameters, '@type'>> & C4dNoiseSaltPepperParameters;


interface C4dNoMulticomponentSplitParameters {
    "@type"?: "no_multicomponent_split";
    "no_multicomponent_split": string;
}
type C4dNoMulticomponentSplitParametersTagged = Required<Pick<C4dNoMulticomponentSplitParameters, '@type'>> & C4dNoMulticomponentSplitParameters;


interface C4dNormalizeLocalWindowParameters {
    "@type"?: "normalize_local_window";
    "normalize_local_window": string;
}
type C4dNormalizeLocalWindowParametersTagged = Required<Pick<C4dNormalizeLocalWindowParameters, '@type'>> & C4dNormalizeLocalWindowParameters;


interface C4dNormpdfParameters {
    "@type"?: "normpdf";
    "normpdf": string;
}
type C4dNormpdfParametersTagged = Required<Pick<C4dNormpdfParameters, '@type'>> & C4dNormpdfParameters;


interface C4dNoroundParameters {
    "@type"?: "noround";
    "noround": string;
}
type C4dNoroundParametersTagged = Required<Pick<C4dNoroundParameters, '@type'>> & C4dNoroundParameters;


interface C4dNospmParameters {
    "@type"?: "nospm";
    "nospm": string;
}
type C4dNospmParametersTagged = Required<Pick<C4dNospmParameters, '@type'>> & C4dNospmParameters;


interface C4dOutputParameters {
    "@type"?: "output";
    "output": string;
}
type C4dOutputParametersTagged = Required<Pick<C4dOutputParameters, '@type'>> & C4dOutputParameters;


interface C4dOutputMulticomponentParameters {
    "@type"?: "output_multicomponent";
    "output_multicomponent": string;
}
type C4dOutputMulticomponentParametersTagged = Required<Pick<C4dOutputMulticomponentParameters, '@type'>> & C4dOutputMulticomponentParameters;


interface C4dOutputMultipleMulticomponentParameters {
    "@type"?: "output_multiple_multicomponent";
    "output_multiple_multicomponent": string;
}
type C4dOutputMultipleMulticomponentParametersTagged = Required<Pick<C4dOutputMultipleMulticomponentParameters, '@type'>> & C4dOutputMultipleMulticomponentParameters;


interface C4dOrientParameters {
    "@type"?: "orient";
    "orient": string;
}
type C4dOrientParametersTagged = Required<Pick<C4dOrientParameters, '@type'>> & C4dOrientParameters;


interface C4dOutputMultipleParameters {
    "@type"?: "output_multiple";
    "output_multiple": string;
}
type C4dOutputMultipleParametersTagged = Required<Pick<C4dOutputMultipleParameters, '@type'>> & C4dOutputMultipleParameters;


interface C4dOrient1Parameters {
    "@type"?: "orient_1";
    "orient": string;
}
type C4dOrient1ParametersTagged = Required<Pick<C4dOrient1Parameters, '@type'>> & C4dOrient1Parameters;


interface C4dOriginParameters {
    "@type"?: "origin";
    "origin": string;
}
type C4dOriginParametersTagged = Required<Pick<C4dOriginParameters, '@type'>> & C4dOriginParameters;


interface C4dOriginVoxelParameters {
    "@type"?: "origin_voxel";
    "origin_voxel": string;
}
type C4dOriginVoxelParametersTagged = Required<Pick<C4dOriginVoxelParameters, '@type'>> & C4dOriginVoxelParameters;


interface C4dOriginVoxelCoordParameters {
    "@type"?: "origin_voxel_coord";
    "origin_voxel_coord": string;
}
type C4dOriginVoxelCoordParametersTagged = Required<Pick<C4dOriginVoxelCoordParameters, '@type'>> & C4dOriginVoxelCoordParameters;


interface C4dOverlapParameters {
    "@type"?: "overlap";
    "overlap": string;
}
type C4dOverlapParametersTagged = Required<Pick<C4dOverlapParameters, '@type'>> & C4dOverlapParameters;


interface C4dOverlayLabelImageParameters {
    "@type"?: "overlay_label_image";
    "overlay_label_image": string;
}
type C4dOverlayLabelImageParametersTagged = Required<Pick<C4dOverlayLabelImageParameters, '@type'>> & C4dOverlayLabelImageParameters;


interface C4dPadParameters {
    "@type"?: "pad";
    "pad": string;
}
type C4dPadParametersTagged = Required<Pick<C4dPadParameters, '@type'>> & C4dPadParameters;


interface C4dPadToParameters {
    "@type"?: "pad_to";
    "pad_to": string;
}
type C4dPadToParametersTagged = Required<Pick<C4dPadToParameters, '@type'>> & C4dPadToParameters;


interface C4dPcaParameters {
    "@type"?: "pca";
    "pca": string;
}
type C4dPcaParametersTagged = Required<Pick<C4dPcaParameters, '@type'>> & C4dPcaParameters;


interface C4dPercentIntensityModeParameters {
    "@type"?: "percent_intensity_mode";
    "percent_intensity_mode": string;
}
type C4dPercentIntensityModeParametersTagged = Required<Pick<C4dPercentIntensityModeParameters, '@type'>> & C4dPercentIntensityModeParameters;


interface C4dPixelParameters {
    "@type"?: "pixel";
    "pixel": string;
}
type C4dPixelParametersTagged = Required<Pick<C4dPixelParameters, '@type'>> & C4dPixelParameters;


interface C4dPopParameters {
    "@type"?: "pop";
    "pop": string;
}
type C4dPopParametersTagged = Required<Pick<C4dPopParameters, '@type'>> & C4dPopParameters;


interface C4dPopasParameters {
    "@type"?: "popas";
    "popas": string;
}
type C4dPopasParametersTagged = Required<Pick<C4dPopasParameters, '@type'>> & C4dPopasParameters;


interface C4dProbeParameters {
    "@type"?: "probe";
    "probe": string;
}
type C4dProbeParametersTagged = Required<Pick<C4dProbeParameters, '@type'>> & C4dProbeParameters;


interface C4dPushParameters {
    "@type"?: "push";
    "push": string;
}
type C4dPushParametersTagged = Required<Pick<C4dPushParameters, '@type'>> & C4dPushParameters;


interface C4dRankParameters {
    "@type"?: "rank";
    "rank": string;
}
type C4dRankParametersTagged = Required<Pick<C4dRankParameters, '@type'>> & C4dRankParameters;


interface C4dReciprocalParameters {
    "@type"?: "reciprocal";
    "reciprocal": string;
}
type C4dReciprocalParametersTagged = Required<Pick<C4dReciprocalParameters, '@type'>> & C4dReciprocalParameters;


interface C4dRegionParameters {
    "@type"?: "region";
    "region": string;
}
type C4dRegionParametersTagged = Required<Pick<C4dRegionParameters, '@type'>> & C4dRegionParameters;


interface C4dReorderParameters {
    "@type"?: "reorder";
    "reorder": string;
}
type C4dReorderParametersTagged = Required<Pick<C4dReorderParameters, '@type'>> & C4dReorderParameters;


interface C4dRetainLabelsParameters {
    "@type"?: "retain_labels";
    "retain_labels": string;
}
type C4dRetainLabelsParametersTagged = Required<Pick<C4dRetainLabelsParameters, '@type'>> & C4dRetainLabelsParameters;


interface C4dRfApplyParameters {
    "@type"?: "rf_apply";
    "rf_apply": string;
}
type C4dRfApplyParametersTagged = Required<Pick<C4dRfApplyParameters, '@type'>> & C4dRfApplyParameters;


interface C4dRfTrainParameters {
    "@type"?: "rf_train";
    "rf_train": string;
}
type C4dRfTrainParametersTagged = Required<Pick<C4dRfTrainParameters, '@type'>> & C4dRfTrainParameters;


interface C4dRfParamPatchParameters {
    "@type"?: "rf_param_patch";
    "rf_param_patch": string;
}
type C4dRfParamPatchParametersTagged = Required<Pick<C4dRfParamPatchParameters, '@type'>> & C4dRfParamPatchParameters;


interface C4dRfParamUsexyzParameters {
    "@type"?: "rf_param_usexyz";
    "rf_param_usexyz": string;
}
type C4dRfParamUsexyzParametersTagged = Required<Pick<C4dRfParamUsexyzParameters, '@type'>> & C4dRfParamUsexyzParameters;


interface C4dRfParamNousexyzParameters {
    "@type"?: "rf_param_nousexyz";
    "rf_param_nousexyz": string;
}
type C4dRfParamNousexyzParametersTagged = Required<Pick<C4dRfParamNousexyzParameters, '@type'>> & C4dRfParamNousexyzParameters;


interface C4dRfParamNtreesParameters {
    "@type"?: "rf_param_ntrees";
    "rf_param_ntrees": string;
}
type C4dRfParamNtreesParametersTagged = Required<Pick<C4dRfParamNtreesParameters, '@type'>> & C4dRfParamNtreesParameters;


interface C4dRfParamTreedepthParameters {
    "@type"?: "rf_param_treedepth";
    "rf_param_treedepth": string;
}
type C4dRfParamTreedepthParametersTagged = Required<Pick<C4dRfParamTreedepthParameters, '@type'>> & C4dRfParamTreedepthParameters;


interface C4dSetSformParameters {
    "@type"?: "set_sform";
    "set_sform": string;
}
type C4dSetSformParametersTagged = Required<Pick<C4dSetSformParameters, '@type'>> & C4dSetSformParameters;


interface C4dReplaceParameters {
    "@type"?: "replace";
    "replace": string;
}
type C4dReplaceParametersTagged = Required<Pick<C4dReplaceParameters, '@type'>> & C4dReplaceParameters;


interface C4dResampleParameters {
    "@type"?: "resample";
    "resample": string;
}
type C4dResampleParametersTagged = Required<Pick<C4dResampleParameters, '@type'>> & C4dResampleParameters;


interface C4dResampleIsoParameters {
    "@type"?: "resample_iso";
    "resample_iso": string;
}
type C4dResampleIsoParametersTagged = Required<Pick<C4dResampleIsoParameters, '@type'>> & C4dResampleIsoParameters;


interface C4dResampleMmParameters {
    "@type"?: "resample_mm";
    "resample_mm": string;
}
type C4dResampleMmParametersTagged = Required<Pick<C4dResampleMmParameters, '@type'>> & C4dResampleMmParameters;


interface C4dResliceItkParameters {
    "@type"?: "reslice_itk";
    "reslice_itk": string;
}
type C4dResliceItkParametersTagged = Required<Pick<C4dResliceItkParameters, '@type'>> & C4dResliceItkParameters;


interface C4dResliceMatrixParameters {
    "@type"?: "reslice_matrix";
    "reslice_matrix": string;
}
type C4dResliceMatrixParametersTagged = Required<Pick<C4dResliceMatrixParameters, '@type'>> & C4dResliceMatrixParameters;


interface C4dResliceIdentityParameters {
    "@type"?: "reslice_identity";
    "reslice_identity": string;
}
type C4dResliceIdentityParametersTagged = Required<Pick<C4dResliceIdentityParameters, '@type'>> & C4dResliceIdentityParameters;


interface C4dRgb2hsvParameters {
    "@type"?: "rgb2hsv";
    "rgb2hsv": string;
}
type C4dRgb2hsvParametersTagged = Required<Pick<C4dRgb2hsvParameters, '@type'>> & C4dRgb2hsvParameters;


interface C4dRmsParameters {
    "@type"?: "rms";
    "rms": string;
}
type C4dRmsParametersTagged = Required<Pick<C4dRmsParameters, '@type'>> & C4dRmsParameters;


interface C4dRoundParameters {
    "@type"?: "round";
    "round": string;
}
type C4dRoundParametersTagged = Required<Pick<C4dRoundParameters, '@type'>> & C4dRoundParameters;


interface C4dScaleParameters {
    "@type"?: "scale";
    "scale": string;
}
type C4dScaleParametersTagged = Required<Pick<C4dScaleParameters, '@type'>> & C4dScaleParameters;


interface C4dSetSform1Parameters {
    "@type"?: "set_sform_1";
    "set_sform": string;
}
type C4dSetSform1ParametersTagged = Required<Pick<C4dSetSform1Parameters, '@type'>> & C4dSetSform1Parameters;


interface C4dSinParameters {
    "@type"?: "sin";
    "sin": string;
}
type C4dSinParametersTagged = Required<Pick<C4dSinParameters, '@type'>> & C4dSinParameters;


interface C4dSliceParameters {
    "@type"?: "slice";
    "slice": string;
}
type C4dSliceParametersTagged = Required<Pick<C4dSliceParameters, '@type'>> & C4dSliceParameters;


interface C4dSliceAllParameters {
    "@type"?: "slice_all";
    "slice_all": string;
}
type C4dSliceAllParametersTagged = Required<Pick<C4dSliceAllParameters, '@type'>> & C4dSliceAllParameters;


interface C4dSharpenParameters {
    "@type"?: "sharpen";
    "sharpen": string;
}
type C4dSharpenParametersTagged = Required<Pick<C4dSharpenParameters, '@type'>> & C4dSharpenParameters;


interface C4dShiftParameters {
    "@type"?: "shift";
    "shift": string;
}
type C4dShiftParametersTagged = Required<Pick<C4dShiftParameters, '@type'>> & C4dShiftParameters;


interface C4dSignedDistanceTransformParameters {
    "@type"?: "signed_distance_transform";
    "signed_distance_transform": string;
}
type C4dSignedDistanceTransformParametersTagged = Required<Pick<C4dSignedDistanceTransformParameters, '@type'>> & C4dSignedDistanceTransformParameters;


interface C4dSmoothParameters {
    "@type"?: "smooth";
    "smooth": string;
}
type C4dSmoothParametersTagged = Required<Pick<C4dSmoothParameters, '@type'>> & C4dSmoothParameters;


interface C4dSmoothFastParameters {
    "@type"?: "smooth_fast";
    "smooth_fast": string;
}
type C4dSmoothFastParametersTagged = Required<Pick<C4dSmoothFastParameters, '@type'>> & C4dSmoothFastParameters;


interface C4dSpacingParameters {
    "@type"?: "spacing";
    "spacing": string;
}
type C4dSpacingParametersTagged = Required<Pick<C4dSpacingParameters, '@type'>> & C4dSpacingParameters;


interface C4dSplitParameters {
    "@type"?: "split";
    "split": string;
}
type C4dSplitParametersTagged = Required<Pick<C4dSplitParameters, '@type'>> & C4dSplitParameters;


interface C4dSqrtParameters {
    "@type"?: "sqrt";
    "sqrt": string;
}
type C4dSqrtParametersTagged = Required<Pick<C4dSqrtParameters, '@type'>> & C4dSqrtParameters;


interface C4dStapleParameters {
    "@type"?: "staple";
    "staple": string;
}
type C4dStapleParametersTagged = Required<Pick<C4dStapleParameters, '@type'>> & C4dStapleParameters;


interface C4dStructureTensorEigenvaluesParameters {
    "@type"?: "structure_tensor_eigenvalues";
    "structure_tensor_eigenvalues": string;
}
type C4dStructureTensorEigenvaluesParametersTagged = Required<Pick<C4dStructureTensorEigenvaluesParameters, '@type'>> & C4dStructureTensorEigenvaluesParameters;


interface C4dSpmParameters {
    "@type"?: "spm";
    "spm": string;
}
type C4dSpmParametersTagged = Required<Pick<C4dSpmParameters, '@type'>> & C4dSpmParameters;


interface C4dSubtractParameters {
    "@type"?: "subtract";
    "subtract": string;
}
type C4dSubtractParametersTagged = Required<Pick<C4dSubtractParameters, '@type'>> & C4dSubtractParameters;


interface C4dSupervoxelParameters {
    "@type"?: "supervoxel";
    "supervoxel": string;
}
type C4dSupervoxelParametersTagged = Required<Pick<C4dSupervoxelParameters, '@type'>> & C4dSupervoxelParameters;


interface C4dStretchParameters {
    "@type"?: "stretch";
    "stretch": string;
}
type C4dStretchParametersTagged = Required<Pick<C4dStretchParameters, '@type'>> & C4dStretchParameters;


interface C4dSwapdimParameters {
    "@type"?: "swapdim";
    "swapdim": string;
}
type C4dSwapdimParametersTagged = Required<Pick<C4dSwapdimParameters, '@type'>> & C4dSwapdimParameters;


interface C4dTestImageParameters {
    "@type"?: "test_image";
    "test_image": string;
}
type C4dTestImageParametersTagged = Required<Pick<C4dTestImageParameters, '@type'>> & C4dTestImageParameters;


interface C4dTestProbeParameters {
    "@type"?: "test_probe";
    "test_probe": string;
}
type C4dTestProbeParametersTagged = Required<Pick<C4dTestProbeParameters, '@type'>> & C4dTestProbeParameters;


interface C4dThresholdParameters {
    "@type"?: "threshold";
    "threshold": string;
}
type C4dThresholdParametersTagged = Required<Pick<C4dThresholdParameters, '@type'>> & C4dThresholdParameters;


interface C4dTileParameters {
    "@type"?: "tile";
    "tile": string;
}
type C4dTileParametersTagged = Required<Pick<C4dTileParameters, '@type'>> & C4dTileParameters;


interface C4dTrimParameters {
    "@type"?: "trim";
    "trim": string;
}
type C4dTrimParametersTagged = Required<Pick<C4dTrimParameters, '@type'>> & C4dTrimParameters;


interface C4dTrimToSizeParameters {
    "@type"?: "trim_to_size";
    "trim_to_size": string;
}
type C4dTrimToSizeParametersTagged = Required<Pick<C4dTrimToSizeParameters, '@type'>> & C4dTrimToSizeParameters;


interface C4dTypeParameters {
    "@type"?: "type";
    "type": string;
}
type C4dTypeParametersTagged = Required<Pick<C4dTypeParameters, '@type'>> & C4dTypeParameters;


interface C4dVerboseParameters {
    "@type"?: "verbose";
    "verbose": string;
}
type C4dVerboseParametersTagged = Required<Pick<C4dVerboseParameters, '@type'>> & C4dVerboseParameters;


interface C4dNoverboseParameters {
    "@type"?: "noverbose";
    "noverbose": string;
}
type C4dNoverboseParametersTagged = Required<Pick<C4dNoverboseParameters, '@type'>> & C4dNoverboseParameters;


interface C4dVersionParameters {
    "@type"?: "version";
    "version": string;
}
type C4dVersionParametersTagged = Required<Pick<C4dVersionParameters, '@type'>> & C4dVersionParameters;


interface C4dVoteParameters {
    "@type"?: "vote";
    "vote": string;
}
type C4dVoteParametersTagged = Required<Pick<C4dVoteParameters, '@type'>> & C4dVoteParameters;


interface C4dVoteMrfParameters {
    "@type"?: "vote_mrf";
    "vote_mrf": string;
}
type C4dVoteMrfParametersTagged = Required<Pick<C4dVoteMrfParameters, '@type'>> & C4dVoteMrfParameters;


interface C4dVoteLabelParameters {
    "@type"?: "vote_label";
    "vote_label": string;
}
type C4dVoteLabelParametersTagged = Required<Pick<C4dVoteLabelParameters, '@type'>> & C4dVoteLabelParameters;


interface C4dVoxelSumParameters {
    "@type"?: "voxel_sum";
    "voxel_sum": string;
}
type C4dVoxelSumParametersTagged = Required<Pick<C4dVoxelSumParameters, '@type'>> & C4dVoxelSumParameters;


interface C4dVoxelIntegralParameters {
    "@type"?: "voxel_integral";
    "voxel_integral": string;
}
type C4dVoxelIntegralParametersTagged = Required<Pick<C4dVoxelIntegralParameters, '@type'>> & C4dVoxelIntegralParameters;


interface C4dVoxelwiseRegressionParameters {
    "@type"?: "voxelwise_regression";
    "voxelwise_regression": string;
}
type C4dVoxelwiseRegressionParametersTagged = Required<Pick<C4dVoxelwiseRegressionParameters, '@type'>> & C4dVoxelwiseRegressionParameters;


interface C4dWarpParameters {
    "@type"?: "warp";
    "warp": string;
}
type C4dWarpParametersTagged = Required<Pick<C4dWarpParameters, '@type'>> & C4dWarpParameters;


interface C4dWarpLabelParameters {
    "@type"?: "warp_label";
    "warp_label": string;
}
type C4dWarpLabelParametersTagged = Required<Pick<C4dWarpLabelParameters, '@type'>> & C4dWarpLabelParameters;


interface C4dWrapParameters {
    "@type"?: "wrap";
    "wrap": string;
}
type C4dWrapParametersTagged = Required<Pick<C4dWrapParameters, '@type'>> & C4dWrapParameters;


interface C4dWeightedSumParameters {
    "@type"?: "weighted_sum";
    "weighted_sum": string;
}
type C4dWeightedSumParametersTagged = Required<Pick<C4dWeightedSumParameters, '@type'>> & C4dWeightedSumParameters;


interface C4dWeightedSumVoxelwiseParameters {
    "@type"?: "weighted_sum_voxelwise";
    "weighted_sum_voxelwise": string;
}
type C4dWeightedSumVoxelwiseParametersTagged = Required<Pick<C4dWeightedSumVoxelwiseParameters, '@type'>> & C4dWeightedSumVoxelwiseParameters;


interface C4dParameters {
    "@type"?: "c3d/c4d";
    "input": Array<InputPathType>;
    "operations": Array<C4dAccumParametersTagged | C4dAcosParametersTagged | C4dAddParametersTagged | C4dAlignLandmarksParametersTagged | C4dAnisotropicDiffusionParametersTagged | C4dAntialiasParametersTagged | C4dSetParametersTagged | C4dAsinParametersTagged | C4dAtan2ParametersTagged | C4dBackgroundParametersTagged | C4dN4BiasCorrectionParametersTagged | C4dBinarizeParametersTagged | C4dCannyParametersTagged | C4dCeilParametersTagged | C4dCentroidParametersTagged | C4dCentroidMarkParametersTagged | C4dConnectedComponentsParametersTagged | C4dClearParametersTagged | C4dClipParametersTagged | C4dColorMapParametersTagged | C4dCompressParametersTagged | C4dNoCompressParametersTagged | C4dConvParametersTagged | C4dCoordinateMapVoxelParametersTagged | C4dCoordinateMapPhysicalParametersTagged | C4dCopyTransformParametersTagged | C4dCosParametersTagged | C4dCreateParametersTagged | C4dDicomSeriesListParametersTagged | C4dDicomSeriesReadParametersTagged | C4dDilateParametersTagged | C4dDivideParametersTagged | C4dDuplicateParametersTagged | C4dEndaccumParametersTagged | C4dEndforParametersTagged | C4dErodeParametersTagged | C4dErfParametersTagged | C4dExpParametersTagged | C4dExportPatchesParametersTagged | C4dExportPatchesAugParametersTagged | C4dExtrudeSegParametersTagged | C4dFillBackgroundWithNoiseParametersTagged | C4dFftParametersTagged | C4dFlipParametersTagged | C4dFloorParametersTagged | C4dForeachParametersTagged | C4dForeachCompParametersTagged | C4dGlmParametersTagged | C4dGradientParametersTagged | C4dHelpParametersTagged | C4dHolefillParametersTagged | C4dHessianEigenvaluesParametersTagged | C4dHessianObjectnessParametersTagged | C4dHistogramMatchParametersTagged | C4dInfoParametersTagged | C4dInfoFullParametersTagged | C4dInsertParametersTagged | C4dInterpolationParametersTagged | C4dIterationsParametersTagged | C4dLabelOverlapParametersTagged | C4dLabelStatisticsParametersTagged | C4dLandmarksToSpheresParametersTagged | C4dLaplacianParametersTagged | C4dLevelsetParametersTagged | C4dLevelsetCurvatureParametersTagged | C4dLevelsetAdvectionParametersTagged | C4dLogParametersTagged | C4dLog10ParametersTagged | C4dManualParametersTagged | C4dMatchBoundingBoxParametersTagged | C4dMaximumParametersTagged | C4dMulticomponentSplitParametersTagged | C4dMeanParametersTagged | C4dMedianFilterParametersTagged | C4dMergeParametersTagged | C4dMeanFilterParametersTagged | C4dMutualInfoParametersTagged | C4dMinimumParametersTagged | C4dMixtureModelParametersTagged | C4dMomentsParametersTagged | C4dMattesMutualInfoParametersTagged | C4dMeanSquareParametersTagged | C4dMultiplyParametersTagged | C4dNormalizedCrossCorrelationParametersTagged | C4dNormalizedCorrelationParametersTagged | C4dNormalizedMutualInfoParametersTagged | C4dNoiseGaussianParametersTagged | C4dNoisePoissonParametersTagged | C4dNoiseSpeckleParametersTagged | C4dNoiseSaltPepperParametersTagged | C4dNoMulticomponentSplitParametersTagged | C4dNormalizeLocalWindowParametersTagged | C4dNormpdfParametersTagged | C4dNoroundParametersTagged | C4dNospmParametersTagged | C4dOutputParametersTagged | C4dOutputMulticomponentParametersTagged | C4dOutputMultipleMulticomponentParametersTagged | C4dOrientParametersTagged | C4dOutputMultipleParametersTagged | C4dOrient1ParametersTagged | C4dOriginParametersTagged | C4dOriginVoxelParametersTagged | C4dOriginVoxelCoordParametersTagged | C4dOverlapParametersTagged | C4dOverlayLabelImageParametersTagged | C4dPadParametersTagged | C4dPadToParametersTagged | C4dPcaParametersTagged | C4dPercentIntensityModeParametersTagged | C4dPixelParametersTagged | C4dPopParametersTagged | C4dPopasParametersTagged | C4dProbeParametersTagged | C4dPushParametersTagged | C4dRankParametersTagged | C4dReciprocalParametersTagged | C4dRegionParametersTagged | C4dReorderParametersTagged | C4dRetainLabelsParametersTagged | C4dRfApplyParametersTagged | C4dRfTrainParametersTagged | C4dRfParamPatchParametersTagged | C4dRfParamUsexyzParametersTagged | C4dRfParamNousexyzParametersTagged | C4dRfParamNtreesParametersTagged | C4dRfParamTreedepthParametersTagged | C4dSetSformParametersTagged | C4dReplaceParametersTagged | C4dResampleParametersTagged | C4dResampleIsoParametersTagged | C4dResampleMmParametersTagged | C4dResliceItkParametersTagged | C4dResliceMatrixParametersTagged | C4dResliceIdentityParametersTagged | C4dRgb2hsvParametersTagged | C4dRmsParametersTagged | C4dRoundParametersTagged | C4dScaleParametersTagged | C4dSetSform1ParametersTagged | C4dSinParametersTagged | C4dSliceParametersTagged | C4dSliceAllParametersTagged | C4dSharpenParametersTagged | C4dShiftParametersTagged | C4dSignedDistanceTransformParametersTagged | C4dSmoothParametersTagged | C4dSmoothFastParametersTagged | C4dSpacingParametersTagged | C4dSplitParametersTagged | C4dSqrtParametersTagged | C4dStapleParametersTagged | C4dStructureTensorEigenvaluesParametersTagged | C4dSpmParametersTagged | C4dSubtractParametersTagged | C4dSupervoxelParametersTagged | C4dStretchParametersTagged | C4dSwapdimParametersTagged | C4dTestImageParametersTagged | C4dTestProbeParametersTagged | C4dThresholdParametersTagged | C4dTileParametersTagged | C4dTrimParametersTagged | C4dTrimToSizeParametersTagged | C4dTypeParametersTagged | C4dVerboseParametersTagged | C4dNoverboseParametersTagged | C4dVersionParametersTagged | C4dVoteParametersTagged | C4dVoteMrfParametersTagged | C4dVoteLabelParametersTagged | C4dVoxelSumParametersTagged | C4dVoxelIntegralParametersTagged | C4dVoxelwiseRegressionParametersTagged | C4dWarpParametersTagged | C4dWarpLabelParametersTagged | C4dWrapParametersTagged | C4dWeightedSumParametersTagged | C4dWeightedSumVoxelwiseParametersTagged>;
    "output": string;
}
type C4dParametersTagged = Required<Pick<C4dParameters, '@type'>> & C4dParameters;


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function c4d_operations_cargs_dyn_fn(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "accum": c4d_accum_cargs,
        "acos": c4d_acos_cargs,
        "add": c4d_add_cargs,
        "align_landmarks": c4d_align_landmarks_cargs,
        "anisotropic_diffusion": c4d_anisotropic_diffusion_cargs,
        "antialias": c4d_antialias_cargs,
        "set": c4d_set_cargs,
        "asin": c4d_asin_cargs,
        "atan2": c4d_atan2_cargs,
        "background": c4d_background_cargs,
        "n4_bias_correction": c4d_n4_bias_correction_cargs,
        "binarize": c4d_binarize_cargs,
        "canny": c4d_canny_cargs,
        "ceil": c4d_ceil_cargs,
        "centroid": c4d_centroid_cargs,
        "centroid_mark": c4d_centroid_mark_cargs,
        "connected_components": c4d_connected_components_cargs,
        "clear": c4d_clear_cargs,
        "clip": c4d_clip_cargs,
        "color_map": c4d_color_map_cargs,
        "compress": c4d_compress_cargs,
        "no_compress": c4d_no_compress_cargs,
        "conv": c4d_conv_cargs,
        "coordinate_map_voxel": c4d_coordinate_map_voxel_cargs,
        "coordinate_map_physical": c4d_coordinate_map_physical_cargs,
        "copy_transform": c4d_copy_transform_cargs,
        "cos": c4d_cos_cargs,
        "create": c4d_create_cargs,
        "dicom_series_list": c4d_dicom_series_list_cargs,
        "dicom_series_read": c4d_dicom_series_read_cargs,
        "dilate": c4d_dilate_cargs,
        "divide": c4d_divide_cargs,
        "duplicate": c4d_duplicate_cargs,
        "endaccum": c4d_endaccum_cargs,
        "endfor": c4d_endfor_cargs,
        "erode": c4d_erode_cargs,
        "erf": c4d_erf_cargs,
        "exp": c4d_exp_cargs,
        "export_patches": c4d_export_patches_cargs,
        "export_patches_aug": c4d_export_patches_aug_cargs,
        "extrude_seg": c4d_extrude_seg_cargs,
        "fill_background_with_noise": c4d_fill_background_with_noise_cargs,
        "fft": c4d_fft_cargs,
        "flip": c4d_flip_cargs,
        "floor": c4d_floor_cargs,
        "foreach": c4d_foreach_cargs,
        "foreach_comp": c4d_foreach_comp_cargs,
        "glm": c4d_glm_cargs,
        "gradient": c4d_gradient_cargs,
        "_help": c4d__help_cargs,
        "holefill": c4d_holefill_cargs,
        "hessian_eigenvalues": c4d_hessian_eigenvalues_cargs,
        "hessian_objectness": c4d_hessian_objectness_cargs,
        "histogram_match": c4d_histogram_match_cargs,
        "info": c4d_info_cargs,
        "info_full": c4d_info_full_cargs,
        "insert": c4d_insert_cargs,
        "interpolation": c4d_interpolation_cargs,
        "iterations": c4d_iterations_cargs,
        "label_overlap": c4d_label_overlap_cargs,
        "label_statistics": c4d_label_statistics_cargs,
        "landmarks_to_spheres": c4d_landmarks_to_spheres_cargs,
        "laplacian": c4d_laplacian_cargs,
        "levelset": c4d_levelset_cargs,
        "levelset_curvature": c4d_levelset_curvature_cargs,
        "levelset_advection": c4d_levelset_advection_cargs,
        "log": c4d_log_cargs,
        "log10": c4d_log10_cargs,
        "manual": c4d_manual_cargs,
        "match_bounding_box": c4d_match_bounding_box_cargs,
        "maximum": c4d_maximum_cargs,
        "multicomponent_split": c4d_multicomponent_split_cargs,
        "mean": c4d_mean_cargs,
        "median_filter": c4d_median_filter_cargs,
        "merge": c4d_merge_cargs,
        "mean_filter": c4d_mean_filter_cargs,
        "mutual_info": c4d_mutual_info_cargs,
        "minimum": c4d_minimum_cargs,
        "mixture_model": c4d_mixture_model_cargs,
        "moments": c4d_moments_cargs,
        "mattes_mutual_info": c4d_mattes_mutual_info_cargs,
        "mean_square": c4d_mean_square_cargs,
        "multiply": c4d_multiply_cargs,
        "normalized_cross_correlation": c4d_normalized_cross_correlation_cargs,
        "normalized_correlation": c4d_normalized_correlation_cargs,
        "normalized_mutual_info": c4d_normalized_mutual_info_cargs,
        "noise_gaussian": c4d_noise_gaussian_cargs,
        "noise_poisson": c4d_noise_poisson_cargs,
        "noise_speckle": c4d_noise_speckle_cargs,
        "noise_salt_pepper": c4d_noise_salt_pepper_cargs,
        "no_multicomponent_split": c4d_no_multicomponent_split_cargs,
        "normalize_local_window": c4d_normalize_local_window_cargs,
        "normpdf": c4d_normpdf_cargs,
        "noround": c4d_noround_cargs,
        "nospm": c4d_nospm_cargs,
        "output": c4d_output_cargs,
        "output_multicomponent": c4d_output_multicomponent_cargs,
        "output_multiple_multicomponent": c4d_output_multiple_multicomponent_cargs,
        "orient": c4d_orient_cargs,
        "output_multiple": c4d_output_multiple_cargs,
        "orient_1": c4d_orient_1_cargs,
        "origin": c4d_origin_cargs,
        "origin_voxel": c4d_origin_voxel_cargs,
        "origin_voxel_coord": c4d_origin_voxel_coord_cargs,
        "overlap": c4d_overlap_cargs,
        "overlay_label_image": c4d_overlay_label_image_cargs,
        "pad": c4d_pad_cargs,
        "pad_to": c4d_pad_to_cargs,
        "pca": c4d_pca_cargs,
        "percent_intensity_mode": c4d_percent_intensity_mode_cargs,
        "pixel": c4d_pixel_cargs,
        "pop": c4d_pop_cargs,
        "popas": c4d_popas_cargs,
        "probe": c4d_probe_cargs,
        "push": c4d_push_cargs,
        "rank": c4d_rank_cargs,
        "reciprocal": c4d_reciprocal_cargs,
        "region": c4d_region_cargs,
        "reorder": c4d_reorder_cargs,
        "retain_labels": c4d_retain_labels_cargs,
        "rf_apply": c4d_rf_apply_cargs,
        "rf_train": c4d_rf_train_cargs,
        "rf_param_patch": c4d_rf_param_patch_cargs,
        "rf_param_usexyz": c4d_rf_param_usexyz_cargs,
        "rf_param_nousexyz": c4d_rf_param_nousexyz_cargs,
        "rf_param_ntrees": c4d_rf_param_ntrees_cargs,
        "rf_param_treedepth": c4d_rf_param_treedepth_cargs,
        "set_sform": c4d_set_sform_cargs,
        "replace": c4d_replace_cargs,
        "resample": c4d_resample_cargs,
        "resample_iso": c4d_resample_iso_cargs,
        "resample_mm": c4d_resample_mm_cargs,
        "reslice_itk": c4d_reslice_itk_cargs,
        "reslice_matrix": c4d_reslice_matrix_cargs,
        "reslice_identity": c4d_reslice_identity_cargs,
        "rgb2hsv": c4d_rgb2hsv_cargs,
        "rms": c4d_rms_cargs,
        "round": c4d_round_cargs,
        "scale": c4d_scale_cargs,
        "set_sform_1": c4d_set_sform_1_cargs,
        "sin": c4d_sin_cargs,
        "slice": c4d_slice_cargs,
        "slice_all": c4d_slice_all_cargs,
        "sharpen": c4d_sharpen_cargs,
        "shift": c4d_shift_cargs,
        "signed_distance_transform": c4d_signed_distance_transform_cargs,
        "smooth": c4d_smooth_cargs,
        "smooth_fast": c4d_smooth_fast_cargs,
        "spacing": c4d_spacing_cargs,
        "split": c4d_split_cargs,
        "sqrt": c4d_sqrt_cargs,
        "staple": c4d_staple_cargs,
        "structure_tensor_eigenvalues": c4d_structure_tensor_eigenvalues_cargs,
        "spm": c4d_spm_cargs,
        "subtract": c4d_subtract_cargs,
        "supervoxel": c4d_supervoxel_cargs,
        "stretch": c4d_stretch_cargs,
        "swapdim": c4d_swapdim_cargs,
        "test_image": c4d_test_image_cargs,
        "test_probe": c4d_test_probe_cargs,
        "threshold": c4d_threshold_cargs,
        "tile": c4d_tile_cargs,
        "trim": c4d_trim_cargs,
        "trim_to_size": c4d_trim_to_size_cargs,
        "type": c4d_type_cargs,
        "verbose": c4d_verbose_cargs,
        "noverbose": c4d_noverbose_cargs,
        "version": c4d_version_cargs,
        "vote": c4d_vote_cargs,
        "vote_mrf": c4d_vote_mrf_cargs,
        "vote_label": c4d_vote_label_cargs,
        "voxel_sum": c4d_voxel_sum_cargs,
        "voxel_integral": c4d_voxel_integral_cargs,
        "voxelwise_regression": c4d_voxelwise_regression_cargs,
        "warp": c4d_warp_cargs,
        "warp_label": c4d_warp_label_cargs,
        "wrap": c4d_wrap_cargs,
        "weighted_sum": c4d_weighted_sum_cargs,
        "weighted_sum_voxelwise": c4d_weighted_sum_voxelwise_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function c4d_operations_outputs_dyn_fn(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "output": c4d_output_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @param accum -accum, -endaccum: Accumulate operations over all images

Syntax: `-accum command-list -endaccum`

Apply a binary operation (such as addition or multiplication) to all the images on the stack in a cumulative fashion. The command(s) will be applied to the last and second-to-last images on the stack, then to the result of this operation and the third-to-last image on the stack and so on. Below is the example of using the command to add multiple images. 

    c3d image*.nii -accum -add -endaccum -o sum.nii
 *
 * @returns Parameter dictionary
 */
function c4d_accum_params(
    accum: string,
): C4dAccumParametersTagged {
    const params = {
        "@type": "accum" as const,
        "accum": accum,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_accum_cargs(
    params: C4dAccumParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-accum",
        (params["accum"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param acos No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_acos_params(
    acos: string,
): C4dAcosParametersTagged {
    const params = {
        "@type": "acos" as const,
        "acos": acos,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_acos_cargs(
    params: C4dAcosParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-acos",
        (params["acos"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param add -add: Voxelwise image addition

Syntax: `-add`

Adds the last two images on the stack, and places the sum at the end of the stack.

    # Add two images: x = a + b
    c3d a.img b.img -add -o x.img

    # Add three images, x = (a + b) + c in the first example, x = a + (b + c) in the second
    c3d a.img b.img -add c.img -add -o x.img
    c3d a.img b.img c.img -add -add -o x.img

    # Subtract two images, using -scale command: x = a - b
    c3d a.img b.img -scale -1 -add -o x.img
 *
 * @returns Parameter dictionary
 */
function c4d_add_params(
    add: string,
): C4dAddParametersTagged {
    const params = {
        "@type": "add" as const,
        "add": add,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_add_cargs(
    params: C4dAddParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-add",
        (params["add"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param align_landmarks -alm, -align-landmarks: Align images based on landmark matching

Syntax: `-alm dof outfile`

Performs rigid or affine alignment between to sets of landmark images. A landmark image is an image where for every intensity value, the centroid of all voxels with that intensity represents a landmark. Landmarks can be created using the paintbrush tool in ITK-SNAP (they can be spheres, cubes, etc). The first image on the stack is the target/fixed/reference image, and the second is the moving image. The parameters are the degrees of freedom, which is a number (6 for rigid, 7 for rigid+scale, 12 for affine) and the output matrix file. In this example, we have images **fixed.nii* and **moving.nii** with corresponding landmark images. We use landmarks to align the moving image to the fixed:

    c3d fixed_landmarks.nii moving_landmarks.nii -alm 6 rigid.mat
    c3d fixed.nii moving.nii -reslice-matrix rigid.mat -o moving_resliced_to_fixed.nii
 *
 * @returns Parameter dictionary
 */
function c4d_align_landmarks_params(
    align_landmarks: string,
): C4dAlignLandmarksParametersTagged {
    const params = {
        "@type": "align_landmarks" as const,
        "align_landmarks": align_landmarks,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_align_landmarks_cargs(
    params: C4dAlignLandmarksParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-align-landmarks",
        (params["align_landmarks"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param anisotropic_diffusion -add: Voxelwise image addition

Syntax: `-add`

Adds the last two images on the stack, and places the sum at the end of the stack.

    # Add two images: x = a + b
    c3d a.img b.img -add -o x.img

    # Add three images, x = (a + b) + c in the first example, x = a + (b + c) in the second
    c3d a.img b.img -add c.img -add -o x.img
    c3d a.img b.img c.img -add -add -o x.img

    # Subtract two images, using -scale command: x = a - b
    c3d a.img b.img -scale -1 -add -o x.img
 *
 * @returns Parameter dictionary
 */
function c4d_anisotropic_diffusion_params(
    anisotropic_diffusion: string,
): C4dAnisotropicDiffusionParametersTagged {
    const params = {
        "@type": "anisotropic_diffusion" as const,
        "anisotropic_diffusion": anisotropic_diffusion,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_anisotropic_diffusion_cargs(
    params: C4dAnisotropicDiffusionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-anisotropic-diffusion",
        (params["anisotropic_diffusion"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param antialias No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_antialias_params(
    antialias: string,
): C4dAntialiasParametersTagged {
    const params = {
        "@type": "antialias" as const,
        "antialias": antialias,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_antialias_cargs(
    params: C4dAntialiasParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-antialias",
        (params["antialias"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param set_ -as: Assign image at the end of the stack to a variable

Syntax: `-as var`

Associates the image currently at the end of the stack with variable name 'var'. This allows you to retrieve the image later on the command line using the **-push** command. The **-as** and **-push** commands are useful when you need to use a certain image more than once during a convert3d operation. For example, if you want to compute the distance transform of a binary image and mask it so that the values outside of the binary image region have value 0, you would use the following command: 

    c3d binary.img -as A -sdt -push A -times -o masked_distance.img
 *
 * @returns Parameter dictionary
 */
function c4d_set_params(
    set_: string,
): C4dSetParametersTagged {
    const params = {
        "@type": "set" as const,
        "set": set_,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_set_cargs(
    params: C4dSetParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-as",
        (params["set"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param asin No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_asin_params(
    asin: string,
): C4dAsinParametersTagged {
    const params = {
        "@type": "asin" as const,
        "asin": asin,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_asin_cargs(
    params: C4dAsinParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-asin",
        (params["asin"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param atan2 -atan2: Voxelwise angle from sine and cosine

Syntax: `-atan2`

Computes the angle in radians from images containing sine and cosine. This is a voxel-wise operation. It requires two images on the stack (sine followed by cosine): 

    c3d sin_theta.nii.gz cos_theta.nii.gz -atan2 -o theta.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_atan2_params(
    atan2: string,
): C4dAtan2ParametersTagged {
    const params = {
        "@type": "atan2" as const,
        "atan2": atan2,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_atan2_cargs(
    params: C4dAtan2Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-atan2",
        (params["atan2"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param background -background: Specify background intensity

Syntax: `-background <value> `

Sets the background intensity for interpolation and other operations where some default background value is needed. Default is 0.
 *
 * @returns Parameter dictionary
 */
function c4d_background_params(
    background: string,
): C4dBackgroundParametersTagged {
    const params = {
        "@type": "background" as const,
        "background": background,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_background_cargs(
    params: C4dBackgroundParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-background",
        (params["background"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param n4_bias_correction -biascorr: Automatic MRI bias field correction

Syntax: `-biascorr`

Performs automatic bias field correction for MRI images. This feature uses the [N3 implementation in ITK by Dr. Tustison][4], based on the N3 algorithm by Sled et al. 

    c3d mri.nii.gz -biascorr -o mricorr.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_n4_bias_correction_params(
    n4_bias_correction: string,
): C4dN4BiasCorrectionParametersTagged {
    const params = {
        "@type": "n4_bias_correction" as const,
        "n4_bias_correction": n4_bias_correction,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_n4_bias_correction_cargs(
    params: C4dN4BiasCorrectionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-biascorr",
        (params["n4_bias_correction"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param binarize -binarize: Convert image to binary

Syntax: `-binarize`

Converts an image to binary by mapping all background values (the background is 0 by default and can be changed by the option **-background**) to 0 and all non-background values to 1. The **-binarize** command is shorthand for the **-threshold** command. 

    c3d test.img -binarize -o binary.img 
    c3d -background 10 -binarize -o binary.img
    c3d test.img -threshold 10 10 0 1              // equivalent to above command
 *
 * @returns Parameter dictionary
 */
function c4d_binarize_params(
    binarize: string,
): C4dBinarizeParametersTagged {
    const params = {
        "@type": "binarize" as const,
        "binarize": binarize,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_binarize_cargs(
    params: C4dBinarizeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-binarize",
        (params["binarize"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param canny -canny: Canny edge detector

Syntax: `-canny <sigma_vector> <t_lower> <t_upper>`

Performs edge detection on the last image on the stack using the Canny filter. The parameters are a vector of standard deviations defining the scale of the edges detected and lower and upper thresholds for edge selection. See documentation on the [ITK Canny Filter][14].
 *
 * @returns Parameter dictionary
 */
function c4d_canny_params(
    canny: string,
): C4dCannyParametersTagged {
    const params = {
        "@type": "canny" as const,
        "canny": canny,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_canny_cargs(
    params: C4dCannyParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-canny",
        (params["canny"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param ceil -ceil: Round up image intensities

Syntax: `-ceil `

Each image intensity is replaced by the smallest integer larger or equal to it

    c3d input.img -ceil -o output.img
 *
 * @returns Parameter dictionary
 */
function c4d_ceil_params(
    ceil: string,
): C4dCeilParametersTagged {
    const params = {
        "@type": "ceil" as const,
        "ceil": ceil,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_ceil_cargs(
    params: C4dCeilParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-ceil",
        (params["ceil"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param centroid -centroid: Report centroid of foreground voxels

Syntax: `-centroid`

Reports the centroid, in physical coordinates, of all foreground voxels in the image. 

    c3d binaryimage.img -centroid                         // centroid of all non-0 voxels
    c3d grayimage.img -thresh 1000 7000 1 0 -centroid 1   // centroid of all voxels in range 1000-7000
    c3d labelimage.img -thresh 5 5 1 0 -centroid          // centroid of all voxels with label 5
    c3d labelimage.img -split -foreach -centroid -endfor  // centroids of all labels (including 0)
 *
 * @returns Parameter dictionary
 */
function c4d_centroid_params(
    centroid: string,
): C4dCentroidParametersTagged {
    const params = {
        "@type": "centroid" as const,
        "centroid": centroid,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_centroid_cargs(
    params: C4dCentroidParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-centroid",
        (params["centroid"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param centroid_mark -centroid-mark: Mark the centroid of foreground voxels

Syntax: `-centroid-mark <label>`

Marks the centroid of the foreground voxels in an image. Unlike **-centroid**, this command does not print the centroid location, but marks the closest voxel in the image with the intensity **label**. The remaining voxels are assigned 0 intensity. Combined with -dilate, this can be used to mark centers of regions with spheres.

    c3d binaryimage.nii -centroid-mark -dilate 1 3x3x3
    c3d labelimage.nii -split -foreach -centroid-mark -endfor -merge -o centers.nii
 *
 * @returns Parameter dictionary
 */
function c4d_centroid_mark_params(
    centroid_mark: string,
): C4dCentroidMarkParametersTagged {
    const params = {
        "@type": "centroid_mark" as const,
        "centroid_mark": centroid_mark,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_centroid_mark_cargs(
    params: C4dCentroidMarkParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-centroid-mark",
        (params["centroid_mark"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param connected_components -comp, -connected-components: Compute connected components

Syntax: `-comp`

Computes the connected components of a binary image. Each connected component is assigned an integer index. Indices are ordered by the size of the component, so the component assigned index 1 is the largest. The background is assigned index 0. To select the largest connected component, combine the call to **-comp** with a call to **-threshold**. 

    c3d binary.img -comp -o comp.img
    c3d binary.img -comp -threshold 1 1 1 0 -o largest_comp.img
 *
 * @returns Parameter dictionary
 */
function c4d_connected_components_params(
    connected_components: string,
): C4dConnectedComponentsParametersTagged {
    const params = {
        "@type": "connected_components" as const,
        "connected_components": connected_components,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_connected_components_cargs(
    params: C4dConnectedComponentsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-connected-components",
        (params["connected_components"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param clear -clear: Clear the image stack

Syntax: `-clear` 

Clears the image stack. Images assigned a name with the **-as** command will remain in memory.
 *
 * @returns Parameter dictionary
 */
function c4d_clear_params(
    clear: string,
): C4dClearParametersTagged {
    const params = {
        "@type": "clear" as const,
        "clear": clear,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_clear_cargs(
    params: C4dClearParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-clear",
        (params["clear"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param clip -clip: Clip image intensity to range

Syntax: `-clip iMin iMax`

Clips image intensities, so that the values below *iMin* are converted to *iMin* and values greater than *iMax* are converted to *iMax*. This is useful for eliminating hyperintensities in images. Values *iMin* and *iMax* are intensity specifications (see below). 

    c3d mri.img -clip 1000 8000 -o mriclip01.img          // Clips below and above
    c3d mri.img -clip -inf 8000 -o mriclip02.img          // Clips above only
    c3d mri.img -clip -inf 95% -o mriclip03.img           // Clips at 95th percentile
 *
 * @returns Parameter dictionary
 */
function c4d_clip_params(
    clip: string,
): C4dClipParametersTagged {
    const params = {
        "@type": "clip" as const,
        "clip": clip,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_clip_cargs(
    params: C4dClipParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-clip",
        (params["clip"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param color_map -color-map, -colormap: Convert scalar image to RGB using color map    

Syntax: `-color-map <ColormapName> [min max]`

Converts a scalar image to a color (RGB) image using a specified color map. The output of the command are three images, containing the red, green and blue channels of the RGB image. The mapping uses the range of the input image, e.g., using the **jet** color map, the lowest intensity pixel in the image will be mapped to blue, and the highest intesnity pixel will be mapped to red. The admissible color maps are **hot,cool,spring,summer,autumn,winter,copper,jet,hsv,red,green,blue,grey,overunder**. The command can be used with the -omc command to write RGB images. The example below generates a PNG image from a slice in a scalar image. 

    c3d scalar.nii.gz -slice z 50% -flip y -color-map jet -type uchar -omc colorslice.png

By default the full image intensity range is mapped. The optional **min** and **max** parameters can be used to set the range of the color map. 

    c3d scalar.nii.gz -slice z 50% -flip y -color-map jet 0 1 -type uchar -omc colorslice.png
 *
 * @returns Parameter dictionary
 */
function c4d_color_map_params(
    color_map: string,
): C4dColorMapParametersTagged {
    const params = {
        "@type": "color_map" as const,
        "color_map": color_map,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_color_map_cargs(
    params: C4dColorMapParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-colormap",
        (params["color_map"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param compress -compress, -no-compress: Enable/disable compression for some image files

Syntax: `-compress` or `-no-compress`

Turns on compressing for image file formats that support it. For some file formats, like NIFTI (.nii), compression is enabled automatically when the filename includes the **.gz** extension. For other formats, like MetaImage, you need to specify **-compress** to enable compression. The following two commands save the image as compressed NIFTI and MetaImage files:

    c3d input.nii -o output.nii.gz
    c3d input.nii -compress -o output.mha
 *
 * @returns Parameter dictionary
 */
function c4d_compress_params(
    compress: string,
): C4dCompressParametersTagged {
    const params = {
        "@type": "compress" as const,
        "compress": compress,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_compress_cargs(
    params: C4dCompressParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-compress",
        (params["compress"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param no_compress -compress, -no-compress: Enable/disable compression for some image files

Syntax: `-compress` or `-no-compress`

Turns on compressing for image file formats that support it. For some file formats, like NIFTI (.nii), compression is enabled automatically when the filename includes the **.gz** extension. For other formats, like MetaImage, you need to specify **-compress** to enable compression. The following two commands save the image as compressed NIFTI and MetaImage files:

    c3d input.nii -o output.nii.gz
    c3d input.nii -compress -o output.mha
 *
 * @returns Parameter dictionary
 */
function c4d_no_compress_params(
    no_compress: string,
): C4dNoCompressParametersTagged {
    const params = {
        "@type": "no_compress" as const,
        "no_compress": no_compress,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_no_compress_cargs(
    params: C4dNoCompressParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-no-compress",
        (params["no_compress"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param conv -conv: Convolution

Syntax `-conv`

Performs convolution between the last two images on the stack. The convolution is performed using the Fourier transform. The result is an image of the same dimensions as the first image. For more details, see ["FFT Based Convolution" by Gaetan Lehmann][Lehmann].

    c3d image.nii kernel.nii -conv -o result.nii


[Lehmann]: https://hdl.handle.net/10380/3154
 *
 * @returns Parameter dictionary
 */
function c4d_conv_params(
    conv: string,
): C4dConvParametersTagged {
    const params = {
        "@type": "conv" as const,
        "conv": conv,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_conv_cargs(
    params: C4dConvParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-conv",
        (params["conv"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param coordinate_map_voxel -cmv, -coordinate-map-voxel: Generate voxel coordinate maps (voxel units)

Syntax: `-cmv`

For a *N*-dimensional image, replaces the last image on the stack with *N* images. The *k*-th output image at each voxel contains the $k$-th coordinate of that voxel, in voxel units.

    c3d image.nii -cmv -oo coordmap%d.nii.gz

One can use this command to split a brain segmentation image into a left hemisphere segmentation and a right hemisphere segmentation (assuming the X coordinate corresponds to the right-left axis)

    c3d seg.nii -as SEG -cmv -pop -pop  -thresh 50% inf 1 0 -as MASK \
        -push SEG -times -o seg_left.nii.gz \
        -push MASK -replace 1 0 0 1 \
        -push SEG -times -o seg_right.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_coordinate_map_voxel_params(
    coordinate_map_voxel: string,
): C4dCoordinateMapVoxelParametersTagged {
    const params = {
        "@type": "coordinate_map_voxel" as const,
        "coordinate_map_voxel": coordinate_map_voxel,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_coordinate_map_voxel_cargs(
    params: C4dCoordinateMapVoxelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-coordinate-map-voxel",
        (params["coordinate_map_voxel"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param coordinate_map_physical -cmp, -coordinate-map-physical: Generate voxel coordinate maps (voxel units)

Syntax: `-cmp`

This command is similar to **-cmv** (**-coordinate-map-voxel**), but the output will contain the physical coordinates of the voxels, in the NIFTI (RAS) coordinate frame.
 *
 * @returns Parameter dictionary
 */
function c4d_coordinate_map_physical_params(
    coordinate_map_physical: string,
): C4dCoordinateMapPhysicalParametersTagged {
    const params = {
        "@type": "coordinate_map_physical" as const,
        "coordinate_map_physical": coordinate_map_physical,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_coordinate_map_physical_cargs(
    params: C4dCoordinateMapPhysicalParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-coordinate-map-physical",
        (params["coordinate_map_physical"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param copy_transform -copy-transform: Copy header information 

Syntax: `-copy-transform`

Copies the image header, specifically the image to physical space transform (origin, spacing, direction cosines), from the first image (reference) to the second image (target). This is best done with NIFTI images, which store this information well. In the example below, *out.nii* will have the same header as *first.nii* and the same intensities as *second.nii*.

    c3d first.nii second.nii -copy-transform -o out.nii
 *
 * @returns Parameter dictionary
 */
function c4d_copy_transform_params(
    copy_transform: string,
): C4dCopyTransformParametersTagged {
    const params = {
        "@type": "copy_transform" as const,
        "copy_transform": copy_transform,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_copy_transform_cargs(
    params: C4dCopyTransformParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-copy-transform",
        (params["copy_transform"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param cos No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_cos_params(
    cos: string,
): C4dCosParametersTagged {
    const params = {
        "@type": "cos" as const,
        "cos": cos,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_cos_cargs(
    params: C4dCosParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-cos",
        (params["cos"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param create -create: Generate blank image

Syntax: `-create dimensions voxel_size`

Creates a new blank image with specified dimensions and voxel size, and places it at the end of the stack. The image is set to the current background value, which is 0 by default but can be overwritten with the **-background** command. The origin of the image can be changed with the **-origin** command. 

    c3d -create 256x256x160 1x1x1mm -o newimage.img
    c3d -background 128 -create 256x256x160 1x1x1mm -origin 128x128x80mm -o newimage.img
 *
 * @returns Parameter dictionary
 */
function c4d_create_params(
    create: string,
): C4dCreateParametersTagged {
    const params = {
        "@type": "create" as const,
        "create": create,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_create_cargs(
    params: C4dCreateParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-create",
        (params["create"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param dicom_series_list -dicom-series-list: List image series in a DICOM directory

Syntax: `-dicom-series-list <directory>

Prints out a table of DICOM series ids and corresponding image information to standard output.
 *
 * @returns Parameter dictionary
 */
function c4d_dicom_series_list_params(
    dicom_series_list: string,
): C4dDicomSeriesListParametersTagged {
    const params = {
        "@type": "dicom_series_list" as const,
        "dicom_series_list": dicom_series_list,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_dicom_series_list_cargs(
    params: C4dDicomSeriesListParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-dicom-series-list",
        (params["dicom_series_list"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param dicom_series_read -dicom-series-read: Read a DICOM image series

Syntax: `-dicom-series-read <directory> <series_id>`

Imports a specific DICOM image series from a directory containing DICOM files. The **directory** parameter may also point to one of the DICOM files in the directory.
The **seried_id** is a string identifier for the series that can be obtained by calling **-dicom-series-list**
 *
 * @returns Parameter dictionary
 */
function c4d_dicom_series_read_params(
    dicom_series_read: string,
): C4dDicomSeriesReadParametersTagged {
    const params = {
        "@type": "dicom_series_read" as const,
        "dicom_series_read": dicom_series_read,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_dicom_series_read_cargs(
    params: C4dDicomSeriesReadParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-dicom-series-read",
        (params["dicom_series_read"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param dilate -dilate: Binary dilation

Syntax: `-dilate <label> <radius_vector>`

Applies the dilation [mathematical morphology][5] operation to a binary image. The first parameter is the intensity value of the object that is to be dilated. The second is the radius of the dilation structuring element in 3D. 

    c3d binary.img -dilate 255 3x3x3vox -o newimage.img
 *
 * @returns Parameter dictionary
 */
function c4d_dilate_params(
    dilate: string,
): C4dDilateParametersTagged {
    const params = {
        "@type": "dilate" as const,
        "dilate": dilate,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_dilate_cargs(
    params: C4dDilateParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-dilate",
        (params["dilate"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param divide -divide: Voxelwise image division    

Syntax: `-divide`

Divides one image by another. For instance to compute C = A / B, use the command 

    c3d A.img B.img -divide -o C.img

Divison may generate infinite and not-a-number (NaN) values if B contains zeros. You can use **-replace** to get rid of these values

    c3d A.img B.img -divide -replace inf 1000 -inf -1000 NaN 0 -o C2.img
 *
 * @returns Parameter dictionary
 */
function c4d_divide_params(
    divide: string,
): C4dDivideParametersTagged {
    const params = {
        "@type": "divide" as const,
        "divide": divide,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_divide_cargs(
    params: C4dDivideParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-divide",
        (params["divide"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param duplicate -dup: Duplicate the last image on the stack

Syntax: `-dup` 

Duplicates the image at the end of the stack. This is equivalent to **-as var -push var**, but shorter. An example is when you want to pass an image as both arguments to a binary operator, e.g., computing the square of the image intensity: 

    c3d input.img -dup -times -o square.img

### Commands: Voxelwise Calculations
 *
 * @returns Parameter dictionary
 */
function c4d_duplicate_params(
    duplicate: string,
): C4dDuplicateParametersTagged {
    const params = {
        "@type": "duplicate" as const,
        "duplicate": duplicate,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_duplicate_cargs(
    params: C4dDuplicateParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-dup",
        (params["duplicate"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param endaccum -accum, -endaccum: Accumulate operations over all images

Syntax: `-accum command-list -endaccum`

Apply a binary operation (such as addition or multiplication) to all the images on the stack in a cumulative fashion. The command(s) will be applied to the last and second-to-last images on the stack, then to the result of this operation and the third-to-last image on the stack and so on. Below is the example of using the command to add multiple images. 

    c3d image*.nii -accum -add -endaccum -o sum.nii
 *
 * @returns Parameter dictionary
 */
function c4d_endaccum_params(
    endaccum: string,
): C4dEndaccumParametersTagged {
    const params = {
        "@type": "endaccum" as const,
        "endaccum": endaccum,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_endaccum_cargs(
    params: C4dEndaccumParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-endaccum",
        (params["endaccum"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param endfor -foreach, -endfor: Loop commands over all images on the stack

Syntax: `-foreach commands-list -endfor`

This command forces the commands between **-foreach** and **-endfor** to be applied to every image on the stack. The main use of this command is to automate processing of multiple datasets. For example, 

    c3d epi*.nii -foreach -smooth 3mm -endfor -oo epism%03d.nii
 *
 * @returns Parameter dictionary
 */
function c4d_endfor_params(
    endfor: string,
): C4dEndforParametersTagged {
    const params = {
        "@type": "endfor" as const,
        "endfor": endfor,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_endfor_cargs(
    params: C4dEndforParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-endfor",
        (params["endfor"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param erode -erode: Binary erosion

Syntax: `-erode <label> <radius_vector>`

Applies erosion [mathematical morphology][5] operation to a binary image. The first parameter is the intensity value of the object that is to be eroded. The second is the radius of the erosion structuring element in 3D. 

    c3d binary.img -erode 255 3x3x3vox -o newimage.img
 *
 * @returns Parameter dictionary
 */
function c4d_erode_params(
    erode: string,
): C4dErodeParametersTagged {
    const params = {
        "@type": "erode" as const,
        "erode": erode,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_erode_cargs(
    params: C4dErodeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-erode",
        (params["erode"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param erf -erf: Standard error function

Syntax: `-erf mu sigma`

Computes the standard error function. This is useful for applying soft thresholds. The function computes y = erf((x - mu)/sigma). 

    c3d input.img -erf 5 2 -o erf.img
 *
 * @returns Parameter dictionary
 */
function c4d_erf_params(
    erf: string,
): C4dErfParametersTagged {
    const params = {
        "@type": "erf" as const,
        "erf": erf,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_erf_cargs(
    params: C4dErfParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-erf",
        (params["erf"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param exp -exp: Voxelwise natural exponent

Syntax: `-exp`

Computes exponent of each voxel in the last image on the stack.

    c3d input.img -exp -o output.img
 *
 * @returns Parameter dictionary
 */
function c4d_exp_params(
    exp: string,
): C4dExpParametersTagged {
    const params = {
        "@type": "exp" as const,
        "exp": exp,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_exp_cargs(
    params: C4dExpParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-exp",
        (params["exp"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param export_patches -export-patches, -xp: Fixed size patch sampling from masked regions

Syntax: `-export-patches <outfile> <radius_vector> <frequency>`

See also: **-export-patches-aug (-xpa)** command, which provides data augmentation for deep learning.

This command samples patches from a region of a ND image and stores them into a data file that can be read easily in other software, for example, NumPy. This is useful for generating training data for machine learning projects. Multiple "channels" can be sampled.

    c3d chan1.nii chan2.nii chan3.nii mask.nii -xp samples.dat 4x4x4 100

This command will sample the three images chan1, chan2, chan3 at foreground voxels in the mask. Voxels in the mask foreground region are sampled randomly, following a uniform distribution. The value of 100 means that every 100-th voxel, on average, is sampled. The radius 4x4x4 means that patches of size 9x9x9 will be generated. For each sampled voxel, the sampled intensity data is represented as a 3x9x9x9 array in this example.

To read these samples in NumPy use the following code

    dims = (9,9,9)                          # Patch dimensions
    k = 3                                   # Number of channels
    bps = (4 * k * reduce(mul, dims, 1))    # Bytes per sample
    np = os.path.getsize(fname) // bps      # Number of samples
    arr = numpy.memmap(fname,'float32','r',shape=(np,k) + dims)

It is also possible to visualize the extracted samples in ITK-SNAP by reading them as a raw image, with dimensions equal to the dimensions of the patch, and the z-dimension multiplied by the number of samples.

The command can also be used to extract entire structures. For example, if we have a binary segmentation of a lesion of an approximately known size in an MRI scan, we can extract a patch of given size centered on this lesion, as follows:

    c3d mri.nii lesion_seg.nii -centroid-mark 1 -xp single_sample.dat 50x50x20 1

In the above example, **-centroid-mark** transforms the lesion segmentation into a single-voxel mask, from which the sample from the MRI is taken.
 *
 * @returns Parameter dictionary
 */
function c4d_export_patches_params(
    export_patches: string,
): C4dExportPatchesParametersTagged {
    const params = {
        "@type": "export_patches" as const,
        "export_patches": export_patches,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_export_patches_cargs(
    params: C4dExportPatchesParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-export-patches",
        (params["export_patches"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param export_patches_aug -export-patches-aug, -xpa: data augmentation for deep learning

Syntax `-export-patches-aug <N> <sigma_angle>`

This command must precede the `-export-patches (-xp)` command and instructs this command to not only sample patches along the image axes but to also sample **N** randomly rotated patches. Rotation is around a uniformly distributed axis with a rotation angle distributed normally with teh standard deviation **sigma_angle**, specified in degrees. This kind of sampling is useful for data augmentation for machine learning algorithms.

    c3d chan1.nii chan2.nii chan3.nii mask.nii -xpa 5 10 -xp samples.dat 4x4x4 100
 *
 * @returns Parameter dictionary
 */
function c4d_export_patches_aug_params(
    export_patches_aug: string,
): C4dExportPatchesAugParametersTagged {
    const params = {
        "@type": "export_patches_aug" as const,
        "export_patches_aug": export_patches_aug,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_export_patches_aug_cargs(
    params: C4dExportPatchesAugParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-export-patches-aug",
        (params["export_patches_aug"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param extrude_seg No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_extrude_seg_params(
    extrude_seg: string,
): C4dExtrudeSegParametersTagged {
    const params = {
        "@type": "extrude_seg" as const,
        "extrude_seg": extrude_seg,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_extrude_seg_cargs(
    params: C4dExtrudeSegParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-extrude-seg",
        (params["extrude_seg"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param fill_background_with_noise No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_fill_background_with_noise_params(
    fill_background_with_noise: string,
): C4dFillBackgroundWithNoiseParametersTagged {
    const params = {
        "@type": "fill_background_with_noise" as const,
        "fill_background_with_noise": fill_background_with_noise,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_fill_background_with_noise_cargs(
    params: C4dFillBackgroundWithNoiseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-fill-background-with-noise",
        (params["fill_background_with_noise"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param fft -fft: Fast Fourier transform

Syntax `-fft`

Computes the Fourier transform of a real-valued image at the end of the stack. The image is replaced by the real and imaginary components of the FFT. This command is only available if **convert3d** is compiled with the FFTW library support. 

    c3d image.nii -fft -oo real.nii imag.nii
 *
 * @returns Parameter dictionary
 */
function c4d_fft_params(
    fft: string,
): C4dFftParametersTagged {
    const params = {
        "@type": "fft" as const,
        "fft": fft,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_fft_cargs(
    params: C4dFftParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-fft",
        (params["fft"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param flip -flip: Flip image around an axis    

Syntax: `-flip axes`

Flips the image around specified axes. The parameter 'axes' may be any combination of characters 'x', 'y', and 'z'; the order does not matter. 

    c3d input.img -flip xy -o output.img
 *
 * @returns Parameter dictionary
 */
function c4d_flip_params(
    flip: string,
): C4dFlipParametersTagged {
    const params = {
        "@type": "flip" as const,
        "flip": flip,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_flip_cargs(
    params: C4dFlipParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-flip",
        (params["flip"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param floor -floor: Round down image intensities

Syntax: `-floor `

Each image intensity is replaced by the largest integer smaller or equal to it.

    c3d input.img -floor -o output.img

To round each intensity to the closest integer, use

    c3d input.img -shift 0.5 -floor
 *
 * @returns Parameter dictionary
 */
function c4d_floor_params(
    floor: string,
): C4dFloorParametersTagged {
    const params = {
        "@type": "floor" as const,
        "floor": floor,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_floor_cargs(
    params: C4dFloorParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-floor",
        (params["floor"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param foreach -foreach, -endfor: Loop commands over all images on the stack

Syntax: `-foreach commands-list -endfor`

This command forces the commands between **-foreach** and **-endfor** to be applied to every image on the stack. The main use of this command is to automate processing of multiple datasets. For example, 

    c3d epi*.nii -foreach -smooth 3mm -endfor -oo epism%03d.nii
 *
 * @returns Parameter dictionary
 */
function c4d_foreach_params(
    foreach: string,
): C4dForeachParametersTagged {
    const params = {
        "@type": "foreach" as const,
        "foreach": foreach,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_foreach_cargs(
    params: C4dForeachParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-foreach",
        (params["foreach"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param foreach_comp -foreach-comp, -endfor: Loop commands over components of a multi-component image 

Syntax `-foreach-comp <N> commands-list -endfor`

This command runs the list of commands separately for each component of a set of multi-component images loaded with -mcs. This makes it possible to perform component-wise operations on multi-component images. For example, it can be used to average several multi-component images. If the image stack contains images *x1* *y1* *z1* *x2* *y2* *z2*, then the operations will be run on *[x1,x2]*, *[y1,y2]*, *[z1,z2]*. For example, if multi_1.nii to multi_10.nii are three-component images, then the mean three-component image is given by

    c2d -mcs multi_*.nii -foreach-comp -mean -endfor -omc multi_mean.nii
 *
 * @returns Parameter dictionary
 */
function c4d_foreach_comp_params(
    foreach_comp: string,
): C4dForeachCompParametersTagged {
    const params = {
        "@type": "foreach_comp" as const,
        "foreach_comp": foreach_comp,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_foreach_comp_cargs(
    params: C4dForeachCompParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-foreach-comp",
        (params["foreach_comp"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param glm -glm: General linear model    

Syntax: `-glm design_matrix_file contrast_vector_file`

Applies voxel-wise general linear model to a set of images. More precisely, the general linear model solves the following system: $Y = X \beta + \epsilon$, where Y are the observations (a list of n images, where each voxel is treated as an independent observation); X is the $n x k$ design matrix, where $k$ is the number of factors; $\beta$ is a set of $k$ unknown images (factors) and $\epsilon$ is the error term. The command will compute the $\beta$ images and return a weighted sum of them, where the weights are specified in the contrast vector. The design matrix and the contrast vector are passed in as files. The file format is just a space-separated list of numbers. For a good explanation of the general linear model, see [S. Kiebel and A. Holmes, General Linear Model, in Ashburner, Friston, Holmes eds., *Human Brain Function, 2nd Edition*][6]. The example below computes the regression coefficient between a set of longitudinal images and subject's age: 

      echo "1 67.00" > design_mat.txt
      echo "1 75.00" >> design_mat.txt
      echo "1 80.00" >> design_mat.txt
      echo "1 83.00" >> design_mat.txt
      echo "0 1" >> contrast_vec.txt
      c3d time1.img time2.img time3.img time4.img -glm design_mat.txt contrast_vec.txt -o regress.img
 *
 * @returns Parameter dictionary
 */
function c4d_glm_params(
    glm: string,
): C4dGlmParametersTagged {
    const params = {
        "@type": "glm" as const,
        "glm": glm,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_glm_cargs(
    params: C4dGlmParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-glm",
        (params["glm"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param gradient -grad, -gradient: Image gradient

Syntax `-grad`

Computes the gradient of the image. Each component of the gradient is placed on the stack in order (x,y,z). The gradient is computed in physical RAS coordinates, taking into account image spacing and orientation. In other words, the gradient is the vector in physical space orthogonal to the isocontours of the image. No smoothing is performed, so it is a good idea to smooth the image first before computing the gradient.

    c3d myimage.nii -smooth 1.2vox -grad -oo grad_comp_%02d.nii
 *
 * @returns Parameter dictionary
 */
function c4d_gradient_params(
    gradient: string,
): C4dGradientParametersTagged {
    const params = {
        "@type": "gradient" as const,
        "gradient": gradient,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_gradient_cargs(
    params: C4dGradientParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-grad",
        (params["gradient"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param v__help -hesseig, -hessian-eigenvalues: Compute eigenvalues of the Hessian matrix

Syntax `-hesseig <scale>`

Computes the Hessian matrix at every pixel of an image and the eigenvalues of the Hessian. Images of the eigenvalues (sorted by value) are placed on the stack. These images are useful as texture features. See also the '''-steig''' command. The scale determines the amount of Gaussian smoothing applied for computing the partial derivatives in the Hessian, and is in physical (mm) units.

    c3d myimage.nii -hesseig 2.0 -oo eig%02d.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d__help_params(
    v__help: string,
): C4dHelpParametersTagged {
    const params = {
        "@type": "_help" as const,
        "_help": v__help,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d__help_cargs(
    params: C4dHelpParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-h",
        (params["_help"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param holefill -holefill: Fill holes in binary image

Syntax: `-holefill intensity_value [0|1] `

Apply the binary hole filling algorithm to a particular intensity value in the image. The input image is typically a binary image or a multi-label segmentation image. Holes (voxels not matching the specified intensity value that are completely contained by voxels matching this value) are filled. The second parameter specifies what type of topological connectivity is used to determine holes. The value 0 uses the default algorithm in ITK (face connectivity) and 1 uses the full connectivity variant (face, edge and vertex connectivity). For more details see the [ITK page for this algorithm][7]. 

    c3d segmentation.nii.gz -holefill 5 0 -type uchar -o filledlabel5.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_holefill_params(
    holefill: string,
): C4dHolefillParametersTagged {
    const params = {
        "@type": "holefill" as const,
        "holefill": holefill,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_holefill_cargs(
    params: C4dHolefillParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-hf",
        (params["holefill"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param hessian_eigenvalues -hesseig, -hessian-eigenvalues: Compute eigenvalues of the Hessian matrix

Syntax `-hesseig <scale>`

Computes the Hessian matrix at every pixel of an image and the eigenvalues of the Hessian. Images of the eigenvalues (sorted by value) are placed on the stack. These images are useful as texture features. See also the '''-steig''' command. The scale determines the amount of Gaussian smoothing applied for computing the partial derivatives in the Hessian, and is in physical (mm) units.

    c3d myimage.nii -hesseig 2.0 -oo eig%02d.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_hessian_eigenvalues_params(
    hessian_eigenvalues: string,
): C4dHessianEigenvaluesParametersTagged {
    const params = {
        "@type": "hessian_eigenvalues" as const,
        "hessian_eigenvalues": hessian_eigenvalues,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_hessian_eigenvalues_cargs(
    params: C4dHessianEigenvaluesParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-hesseig",
        (params["hessian_eigenvalues"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param hessian_objectness -hessobj, -hessian-objectness: Hessian objectness filter

Syntax: `-hessobj <dimension> <min_scale> <max_scale>`

Also known as the Frangi vesselness filter, this filter can be used to highlight tube-like, sheet-like and blob-like objects in the image. For details, see documentation to the [corresponging ITK class][HTOMIF]. 

Parameter `dimension` is an integer that determines the kind of features that are highlighed. Use 0 for blobs, 1 for tubes, 2 for pancakes, etc. The min and max scale parameters are floating point values, giving the scale of the features highlighted, in physical units. Typically, just one scale is used.

    # Detect vessel-like structures at scale 0.5mm
    c3d image.nii.gz -hessobj 1 0.5 0.5

 [HTOMIF] http://www.itk.org/Doxygen/html/classitk_1_1HessianToObjectnessMeasureImageFilter.html
 *
 * @returns Parameter dictionary
 */
function c4d_hessian_objectness_params(
    hessian_objectness: string,
): C4dHessianObjectnessParametersTagged {
    const params = {
        "@type": "hessian_objectness" as const,
        "hessian_objectness": hessian_objectness,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_hessian_objectness_cargs(
    params: C4dHessianObjectnessParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-hessobj",
        (params["hessian_objectness"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param histogram_match No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_histogram_match_params(
    histogram_match: string,
): C4dHistogramMatchParametersTagged {
    const params = {
        "@type": "histogram_match" as const,
        "histogram_match": histogram_match,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_histogram_match_cargs(
    params: C4dHistogramMatchParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-histmatch",
        (params["histogram_match"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param info -info: Display brief image information        

Syntax: `-info`

Prints brief information about the last image on the stack. Does not affect the stack.

    c3d image.hdr -info

Use with the **-foreach** command to get information on multiple images

    c3d images*.nii -foreach -info -endfor
 *
 * @returns Parameter dictionary
 */
function c4d_info_params(
    info: string,
): C4dInfoParametersTagged {
    const params = {
        "@type": "info" as const,
        "info": info,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_info_cargs(
    params: C4dInfoParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-info",
        (params["info"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param info_full -info-full: Display verbose image information        

Syntax: `-info-full`

Prints extended information about the last image on the stack, such as the metadata dictionary. For example, 

    c3d image.hdr -info-full
 *
 * @returns Parameter dictionary
 */
function c4d_info_full_params(
    info_full: string,
): C4dInfoFullParametersTagged {
    const params = {
        "@type": "info_full" as const,
        "info_full": info_full,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_info_full_cargs(
    params: C4dInfoFullParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-info-full",
        (params["info_full"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param insert -insert: Insert image anywhere in the stack

Syntax: `-insert var pos` 

This command is similar to **-push**, but allows you to insert the image associated with 'var' at any position in the stack, counting from the end. When 'pos' is 0, the image is placed at the end of the stack (same as **-push**). When pos is one, the image is placed at the next-to-end position, and so on.
 *
 * @returns Parameter dictionary
 */
function c4d_insert_params(
    insert: string,
): C4dInsertParametersTagged {
    const params = {
        "@type": "insert" as const,
        "insert": insert,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_insert_cargs(
    params: C4dInsertParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-insert",
        (params["insert"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param interpolation -interpolation: Set interpolation mode

Syntax: `-interpolation <NearestNeighbor|Linear|Cubic|Sinc|Gaussian> [param]`

Specifies the interpolation used with **-resample** and other commands. Default is **Linear**. Gaussian interpolation takes as the parameter the standard deviation of the Gaussian filter (e.g, 1mm). Gaussian interpolation is very similar in result to first smoothing an image with a Gaussian filter and then reslicing it with linear interpolation, but is more accurate and has less aliasing artifacts. It is also slower, and should only be used with small sigmas (a few voxels across). 

Shorthand 0 can be used for *NearestNeighbor*, 1 for *Linear* and 3 for *Cubic*. For example:

    c3d -int 3 test.nii -resample 200x200x200% -o cubic_supersample.nii
 *
 * @returns Parameter dictionary
 */
function c4d_interpolation_params(
    interpolation: string,
): C4dInterpolationParametersTagged {
    const params = {
        "@type": "interpolation" as const,
        "interpolation": interpolation,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_interpolation_cargs(
    params: C4dInterpolationParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-interpolation",
        (params["interpolation"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param iterations No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_iterations_params(
    iterations: string,
): C4dIterationsParametersTagged {
    const params = {
        "@type": "iterations" as const,
        "iterations": iterations,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_iterations_cargs(
    params: C4dIterationsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-iterations",
        (params["iterations"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param label_overlap No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_label_overlap_params(
    label_overlap: string,
): C4dLabelOverlapParametersTagged {
    const params = {
        "@type": "label_overlap" as const,
        "label_overlap": label_overlap,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_label_overlap_cargs(
    params: C4dLabelOverlapParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-label-overlap",
        (params["label_overlap"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param label_statistics -lstat, -label-statistics: Display segmentation volumes and intensity statistics

Syntax: `-lstat`

Given a grayscale image and a multilabel (or binary) image, this command computes the statistics for every label in the latter, including volumes, average grayscale intensity, etc. For instance, if image *mri.nii* is a medical image and *seg.nii* is a multilabel segmentation of the image with labels 0, 1 and 4, the following command can be used to print the statistics of the intensity of *mri.nii* for each of the labels 

    c3d mri.nii seg.nii -lstat

The output contains the mean, standard deviation, maximum intensity and minimum intensity for each label. If you just need volumes from a multi-label image, use **-dup** command as follows:

    c3d seg.nii -dup -lstat
 *
 * @returns Parameter dictionary
 */
function c4d_label_statistics_params(
    label_statistics: string,
): C4dLabelStatisticsParametersTagged {
    const params = {
        "@type": "label_statistics" as const,
        "label_statistics": label_statistics,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_label_statistics_cargs(
    params: C4dLabelStatisticsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-label-statistics",
        (params["label_statistics"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param landmarks_to_spheres No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_landmarks_to_spheres_params(
    landmarks_to_spheres: string,
): C4dLandmarksToSpheresParametersTagged {
    const params = {
        "@type": "landmarks_to_spheres" as const,
        "landmarks_to_spheres": landmarks_to_spheres,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_landmarks_to_spheres_cargs(
    params: C4dLandmarksToSpheresParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-landmarks-to-spheres",
        (params["landmarks_to_spheres"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param laplacian -laplacian, -laplace: Laplacian filter

Syntax: `-laplacian`

Applies the Laplacian filter to the image. Used to detect ridges of intensity. Typically, used with the **-smooth** option to obtain the equivalent of convolving the image with the *Laplacian of the Gaussian (LoG)* kernel: 

    c3d input.img -smooth 1.2vox -laplacian -o output.img
 *
 * @returns Parameter dictionary
 */
function c4d_laplacian_params(
    laplacian: string,
): C4dLaplacianParametersTagged {
    const params = {
        "@type": "laplacian" as const,
        "laplacian": laplacian,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_laplacian_cargs(
    params: C4dLaplacianParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-laplacian",
        (params["laplacian"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param levelset -levelset: Level set segmentation

Syntax: `-levelset n_iter `

Perform level set segmentation for *n\_iter* iterations, like in ITK-SNAP. The last image on the stack is treated as the initialization image and the next-to-last image on the stack is the speed image. Both images should be in the range between -1 and 1. Here is how the signs of the different images are interpreted 

|    | Speed Image   | Initialization Image | Output Image |
| -- | ------------- | -------------------- | ------------ |
| +1 | Foreground    | Outside              | Outside      |
| -1 | Background    | Inside               | Inside       | 

Here is an example where you have the speed and the initialization given: 

    c3d speed.img initial.img -levelset-curvature 0.5 -levelset 100 -o seg.img

Here is an example of segmenting the ventricles in an MRI image, where the ventricles and other CSF have intensity below 715. The image seg_bubbles.nii.gz in this example is a binary image of the initialization seeds (1 inside the seeds, 0 outside). 

    c3d brain.nii.gz -erf 715 100 -scale -1 seg_bubbles.nii.gz \
        -replace 0 1 1 -1 -levelset-curvature 0.2 -levelset 500 \
        -thresh -inf 0 1 0 -o segmentation.nii.gz

Another example of smoothing a binary image that is useful for cleaning up manual segmentations. Here the speed image is positive inside the binary object, and the initialization is negative inside the object. The command writes out both the level set image (whose 0-level set is the smoothed boundary of the binary object) and the smoothed binary object 

    c3d binary.img -threshold 1 inf 1 -1 -binary.img 1 inf 1 -1 \
        -levelset-curvature 1.5 -levelset 100 -o levelset.img \
        -thresh -inf 0 1 0 -o smoothed_binary.img
 *
 * @returns Parameter dictionary
 */
function c4d_levelset_params(
    levelset: string,
): C4dLevelsetParametersTagged {
    const params = {
        "@type": "levelset" as const,
        "levelset": levelset,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_levelset_cargs(
    params: C4dLevelsetParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-levelset",
        (params["levelset"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param levelset_curvature No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_levelset_curvature_params(
    levelset_curvature: string,
): C4dLevelsetCurvatureParametersTagged {
    const params = {
        "@type": "levelset_curvature" as const,
        "levelset_curvature": levelset_curvature,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_levelset_curvature_cargs(
    params: C4dLevelsetCurvatureParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-levelset-curvature",
        (params["levelset_curvature"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param levelset_advection No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_levelset_advection_params(
    levelset_advection: string,
): C4dLevelsetAdvectionParametersTagged {
    const params = {
        "@type": "levelset_advection" as const,
        "levelset_advection": levelset_advection,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_levelset_advection_cargs(
    params: C4dLevelsetAdvectionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-levelset-advection",
        (params["levelset_advection"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param log -log, -ln: Voxelwise natural logarithm

Syntax: `-log`

Computes natural logarithm of each voxel in the last image on the stack.
 *
 * @returns Parameter dictionary
 */
function c4d_log_params(
    log: string,
): C4dLogParametersTagged {
    const params = {
        "@type": "log" as const,
        "log": log,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_log_cargs(
    params: C4dLogParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-ln",
        (params["log"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param log10 -log10: Voxelwise base 10 logarithm

Syntax: `-log10`

Computes base 10 logarithm of each voxel in the last image on the stack.
 *
 * @returns Parameter dictionary
 */
function c4d_log10_params(
    log10: string,
): C4dLog10ParametersTagged {
    const params = {
        "@type": "log10" as const,
        "log10": log10,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_log10_cargs(
    params: C4dLog10Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-log10",
        (params["log10"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param manual No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_manual_params(
    manual: string,
): C4dManualParametersTagged {
    const params = {
        "@type": "manual" as const,
        "manual": manual,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_manual_cargs(
    params: C4dManualParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-manual",
        (params["manual"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param match_bounding_box -mbb, -match-bounding-box: Match bounding box of one image to another

Syntax: `-mbb`

Given two images on the stack (reference and target), sets the header of the target image so that the two images occupy the same physical space. The direction cosines of the target image are set to match the reference image.  This command is related to '-copy-transform' but supports images of different size.

    c3d reference.nii target.nii -mbb -o out.nii
 *
 * @returns Parameter dictionary
 */
function c4d_match_bounding_box_params(
    match_bounding_box: string,
): C4dMatchBoundingBoxParametersTagged {
    const params = {
        "@type": "match_bounding_box" as const,
        "match_bounding_box": match_bounding_box,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_match_bounding_box_cargs(
    params: C4dMatchBoundingBoxParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-match-bounding-box",
        (params["match_bounding_box"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param maximum -max: Voxel-wise maximum of two images

Syntax: `-max`

Computes the voxel-wise maximum of two images. Can be used with the **-accum** command to compute maximum of all images. 

    c3d i1.nii i2.nii -max -o max12.nii
    c3d i1.nii i2.nii i3.nii i4.nii -accum -max -endaccum -o max1234.nii
 *
 * @returns Parameter dictionary
 */
function c4d_maximum_params(
    maximum: string,
): C4dMaximumParametersTagged {
    const params = {
        "@type": "maximum" as const,
        "maximum": maximum,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_maximum_cargs(
    params: C4dMaximumParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-maximum",
        (params["maximum"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param multicomponent_split -mcs, -multicomponent-split: Enable splitting of multi-component images on read

Syntax: `-mcs`

Enable reading of multi-component images. By default, when a multi-component image is encountered, the components are combined into a single image. Setting the **-mcs** flag changes this behavior, and each of the components is loaded sequentially. See the section below on multi-component image support. 

    $ c3d -mcs rgb.mha -foreach -probe 110x110x80mm -endfor
    Interpolated image value at 110 110 80 is 1
    Interpolated image value at 110 110 80 is 66
    Interpolated image value at 110 110 80 is 29

    $ c3d rgb.mha -foreach -probe 110x110x80mm -endfor
    Interpolated image value at 110 110 80 is 49.5198
 *
 * @returns Parameter dictionary
 */
function c4d_multicomponent_split_params(
    multicomponent_split: string,
): C4dMulticomponentSplitParametersTagged {
    const params = {
        "@type": "multicomponent_split" as const,
        "multicomponent_split": multicomponent_split,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_multicomponent_split_cargs(
    params: C4dMulticomponentSplitParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-mcs",
        (params["multicomponent_split"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mean -mean: Mean of all images on the stack    

Syntax: `-mean `

Computes the mean of all the images on the stack. All images on the stack are replaced with the mean image.

    c3d image_*.nii -mean -o mean.nii
 *
 * @returns Parameter dictionary
 */
function c4d_mean_params(
    mean: string,
): C4dMeanParametersTagged {
    const params = {
        "@type": "mean" as const,
        "mean": mean,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_mean_cargs(
    params: C4dMeanParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-mean",
        (params["mean"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param median_filter -median, -median-filter: Median filter

Syntax: `-median <radius_vector>`

Applies the median filter: the intensity of each voxel is replaced by the median of the intensities in the neighborhood of size specified by the radius parameter. For example, the following code will apply the median filter with the 5x5x5 neighborhood. 

    c3d in.nii -median 2x2x2 -o median.nii
 *
 * @returns Parameter dictionary
 */
function c4d_median_filter_params(
    median_filter: string,
): C4dMedianFilterParametersTagged {
    const params = {
        "@type": "median_filter" as const,
        "median_filter": median_filter,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_median_filter_cargs(
    params: C4dMedianFilterParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-median",
        (params["median_filter"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param merge -merge: Merge images from previous split command   

Syntax: `-merge`

Works in conjunction with the **-split** command. Has similar behavior to **-vote**, except that label values are carried from the input to the **-split** command.
 *
 * @returns Parameter dictionary
 */
function c4d_merge_params(
    merge: string,
): C4dMergeParametersTagged {
    const params = {
        "@type": "merge" as const,
        "merge": merge,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_merge_cargs(
    params: C4dMergeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-merge",
        (params["merge"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mean_filter -mf, -mean-filter: Mean filter

Syntax: `-mf <radius_vector>`

Applies the mean filter: the intensity of each voxel is replaced by the mean of the intensities in the neighborhood of size specified by the radius parameter. For example, the following code will apply the mean filter with the 5x5x5 neighborhood. 

    c3d in.nii -mf 2x2x2 -o filtered.nii
 *
 * @returns Parameter dictionary
 */
function c4d_mean_filter_params(
    mean_filter: string,
): C4dMeanFilterParametersTagged {
    const params = {
        "@type": "mean_filter" as const,
        "mean_filter": mean_filter,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_mean_filter_cargs(
    params: C4dMeanFilterParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-mf",
        (params["mean_filter"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mutual_info -min: Voxel-wise minimum of two images

Syntax: `-min`

Computes the voxel-wise minimum of two images. Can be used with the **-accum** command to compute minimum of all images. 

    c3d i1.nii i2.nii -min -o min12.nii
    c3d i1.nii i2.nii i3.nii i4.nii -accum -min -endaccum -o min1234.nii
 *
 * @returns Parameter dictionary
 */
function c4d_mutual_info_params(
    mutual_info: string,
): C4dMutualInfoParametersTagged {
    const params = {
        "@type": "mutual_info" as const,
        "mutual_info": mutual_info,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_mutual_info_cargs(
    params: C4dMutualInfoParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-mi",
        (params["mutual_info"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param minimum -min: Voxel-wise minimum of two images

Syntax: `-min`

Computes the voxel-wise minimum of two images. Can be used with the **-accum** command to compute minimum of all images. 

    c3d i1.nii i2.nii -min -o min12.nii
    c3d i1.nii i2.nii i3.nii i4.nii -accum -min -endaccum -o min1234.nii
 *
 * @returns Parameter dictionary
 */
function c4d_minimum_params(
    minimum: string,
): C4dMinimumParametersTagged {
    const params = {
        "@type": "minimum" as const,
        "minimum": minimum,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_minimum_cargs(
    params: C4dMinimumParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-minimum",
        (params["minimum"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mixture_model No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_mixture_model_params(
    mixture_model: string,
): C4dMixtureModelParametersTagged {
    const params = {
        "@type": "mixture_model" as const,
        "mixture_model": mixture_model,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_mixture_model_cargs(
    params: C4dMixtureModelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-mixture",
        (params["mixture_model"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param moments No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_moments_params(
    moments: string,
): C4dMomentsParametersTagged {
    const params = {
        "@type": "moments" as const,
        "moments": moments,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_moments_cargs(
    params: C4dMomentsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-moments",
        (params["moments"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mattes_mutual_info No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_mattes_mutual_info_params(
    mattes_mutual_info: string,
): C4dMattesMutualInfoParametersTagged {
    const params = {
        "@type": "mattes_mutual_info" as const,
        "mattes_mutual_info": mattes_mutual_info,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_mattes_mutual_info_cargs(
    params: C4dMattesMutualInfoParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-mmi",
        (params["mattes_mutual_info"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param mean_square -msq, -mean-square: Compute mean square difference metric

Syntax: `-msq [movtransform.mat] [reftransform.mat]`

Compute the mean square difference metric between the last two images on the stack. If an optional *movtransform.mat* file is provided, the metric is computed by applying the transform to the moving image. If, in addition to *movtransform.mat*, the optional *reftransform.mat* file is also provided -- the moving transform is applied to the moving image, the ref transform is applied to the reference image, and the metric is computed in an image space that is physically halfway between the reference and moving images. This may be useful for unbiased metric computation if the two transforms are inverse of each other as both images undergo similar amount of interpolation. The definitions of reference and moving images and the transform file format are similar to the **-reslice-matrix** command. 

    # Compute metric between ref.nii and mov.nii
    c3d ref.nii mov.nii -msq

    # Compute metric between ref.nii and mov.nii after applying transform to mov.nii
    c3d ref.nii mov.nii -msq tmov.mat

    # Compute metric between ref.nii and mov.nii in a neutral space after applying transforms to both
    c3d ref.nii mov.nii -msq tmov.mat tref.mat
 *
 * @returns Parameter dictionary
 */
function c4d_mean_square_params(
    mean_square: string,
): C4dMeanSquareParametersTagged {
    const params = {
        "@type": "mean_square" as const,
        "mean_square": mean_square,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_mean_square_cargs(
    params: C4dMeanSquareParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-msq",
        (params["mean_square"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param multiply -multiply, -times: Multiply two images

Syntax: `-multiply`

Multiply two images voxel-by-voxel. The operation is applied to the last two images on the stack. 

    # Compute x = a * b
    c3d a.img b.img -multiply -o x.img

    # Compute x = a * (b + c) using add and -multiply
    c3d a.img b.img c.img -multiply -add -o x.img

Combine with the **-dup** command to compute voxelwise square of the image

    # Compute x = a^2
    c3d a.img -dup -multiply -o x.img
 *
 * @returns Parameter dictionary
 */
function c4d_multiply_params(
    multiply: string,
): C4dMultiplyParametersTagged {
    const params = {
        "@type": "multiply" as const,
        "multiply": multiply,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_multiply_cargs(
    params: C4dMultiplyParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-multiply",
        (params["multiply"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param normalized_cross_correlation -ncc, -normalized-cross-correlation: Compute normalized cross-correlation image

Syntax: `-ncc <radius_vector>`

Computes normalized cross-correlation between two images that occupy the same physical space. Each voxel in the resulting image is the cross-correlation of patches of given radius surrounding the voxel in the two input images. This is different from **-ncor**, which computes a global cross-correlation metric value.
 *
 * @returns Parameter dictionary
 */
function c4d_normalized_cross_correlation_params(
    normalized_cross_correlation: string,
): C4dNormalizedCrossCorrelationParametersTagged {
    const params = {
        "@type": "normalized_cross_correlation" as const,
        "normalized_cross_correlation": normalized_cross_correlation,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_normalized_cross_correlation_cargs(
    params: C4dNormalizedCrossCorrelationParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-ncc",
        (params["normalized_cross_correlation"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param normalized_correlation -ncor, -normalized-correlation: Compute normalized correlation metric

Syntax: `-ncor [movtransform.mat] [reftransform.mat]`

    :   Compute the normalized correlation metric between the last two images on the stack. See documentation for **-msq***.
 *
 * @returns Parameter dictionary
 */
function c4d_normalized_correlation_params(
    normalized_correlation: string,
): C4dNormalizedCorrelationParametersTagged {
    const params = {
        "@type": "normalized_correlation" as const,
        "normalized_correlation": normalized_correlation,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_normalized_correlation_cargs(
    params: C4dNormalizedCorrelationParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-ncor",
        (params["normalized_correlation"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param normalized_mutual_info -mmi, -mattes-mutual-info: Compute mutual informaiton metric

Syntax: `-nmi [movtransform.mat] [reftransform.mat]`

Compute the Mattes mutual information metric between the last two images on the stack. See documentation for **-msq**.
 *
 * @returns Parameter dictionary
 */
function c4d_normalized_mutual_info_params(
    normalized_mutual_info: string,
): C4dNormalizedMutualInfoParametersTagged {
    const params = {
        "@type": "normalized_mutual_info" as const,
        "normalized_mutual_info": normalized_mutual_info,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_normalized_mutual_info_cargs(
    params: C4dNormalizedMutualInfoParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-nmi",
        (params["normalized_mutual_info"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param noise_gaussian -noise-gaussian, -noise: Apply additive Gaussian noise

Syntax: `-noise-gaussian <sigma>`

Adds Gaussian noise to an image with zero mean and standard deviation sigma. Please see [Noise simulation article][15] by G. Lehmann for details.

    c3d image.nii -noise-gaussian 5 -o noisy.nii
 *
 * @returns Parameter dictionary
 */
function c4d_noise_gaussian_params(
    noise_gaussian: string,
): C4dNoiseGaussianParametersTagged {
    const params = {
        "@type": "noise_gaussian" as const,
        "noise_gaussian": noise_gaussian,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_noise_gaussian_cargs(
    params: C4dNoiseGaussianParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-noise-gaussian",
        (params["noise_gaussian"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param noise_poisson -noise-poisson: Apply Poisson noise
Syntax: `-noise-poisson <scale>`

Applies Poisson (shot) noise to an image with given scale. Please see [Noise simulation article][15] by G. Lehmann for details.

    c3d image.nii -noise-poisson 5 -o noisy.nii
 *
 * @returns Parameter dictionary
 */
function c4d_noise_poisson_params(
    noise_poisson: string,
): C4dNoisePoissonParametersTagged {
    const params = {
        "@type": "noise_poisson" as const,
        "noise_poisson": noise_poisson,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_noise_poisson_cargs(
    params: C4dNoisePoissonParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-noise-poisson",
        (params["noise_poisson"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param noise_speckle -noise-speckle: Apply Poisson noise
Syntax: `-noise-speckle <sigma>`

Applies Speckle noise to an image with given standard deviation. Please see [Noise simulation article][15] by G. Lehmann for details.

    c3d image.nii -noise-speckle 5 -o noisy.nii
 *
 * @returns Parameter dictionary
 */
function c4d_noise_speckle_params(
    noise_speckle: string,
): C4dNoiseSpeckleParametersTagged {
    const params = {
        "@type": "noise_speckle" as const,
        "noise_speckle": noise_speckle,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_noise_speckle_cargs(
    params: C4dNoiseSpeckleParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-noise-speckle",
        (params["noise_speckle"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param noise_salt_pepper -noise-salt-pepper: Apply salt and pepper noise
Syntax: `-noise-salt-pepper <probability>`

Applies salt and pepper noise to an image with given probability. Please see [Noise simulation article][15] by G. Lehmann for details.

    c3d image.nii -noise-salt-pepper 0.1 -o noisy.nii
 *
 * @returns Parameter dictionary
 */
function c4d_noise_salt_pepper_params(
    noise_salt_pepper: string,
): C4dNoiseSaltPepperParametersTagged {
    const params = {
        "@type": "noise_salt_pepper" as const,
        "noise_salt_pepper": noise_salt_pepper,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_noise_salt_pepper_cargs(
    params: C4dNoiseSaltPepperParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-noise-salt-pepper",
        (params["noise_salt_pepper"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param no_multicomponent_split -nomcs, -no-multicomponent-split: Disable splitting of multi-component images on read

Syntax: `-nomcs`

Used to reverse the effect of previous **-mcs** command.
 *
 * @returns Parameter dictionary
 */
function c4d_no_multicomponent_split_params(
    no_multicomponent_split: string,
): C4dNoMulticomponentSplitParametersTagged {
    const params = {
        "@type": "no_multicomponent_split" as const,
        "no_multicomponent_split": no_multicomponent_split,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_no_multicomponent_split_cargs(
    params: C4dNoMulticomponentSplitParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-nomcs",
        (params["no_multicomponent_split"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param normalize_local_window -nlw, -normalize-local-window: Standardize image intensity using local neighborhood

Syntax: `-nlw <radius>`

This command takes as inputs an image and a mask image. At each voxel, the mean of the local neighborhood is subtracted, and the result is divided by the standard deviation of the neighborhood. The mean and standard deviation are computed only over the masked region. You might also want to multiply by the mask.

    c3d gray.nii.gz mask.nii.gz -nlw 10x10x10 -o residual.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_normalize_local_window_params(
    normalize_local_window: string,
): C4dNormalizeLocalWindowParametersTagged {
    const params = {
        "@type": "normalize_local_window" as const,
        "normalize_local_window": normalize_local_window,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_normalize_local_window_cargs(
    params: C4dNormalizeLocalWindowParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-nlw",
        (params["normalize_local_window"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param normpdf No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_normpdf_params(
    normpdf: string,
): C4dNormpdfParametersTagged {
    const params = {
        "@type": "normpdf" as const,
        "normpdf": normpdf,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_normpdf_cargs(
    params: C4dNormpdfParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-normpdf",
        (params["normpdf"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param noround -noround, -round: Floating point rounding behavior

Syntax: `-noround` or `-round `

By default, **convert3d** will round floating point values when converting to an integer, short or byte image. This command specifies that rounding should not be used. Rounding is used to avoid numerical errors stemming from the internal floating point representation. 

    c3d image1.img -type short -noround image2.img
 *
 * @returns Parameter dictionary
 */
function c4d_noround_params(
    noround: string,
): C4dNoroundParametersTagged {
    const params = {
        "@type": "noround" as const,
        "noround": noround,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_noround_cargs(
    params: C4dNoroundParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-noround",
        (params["noround"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param nospm -spm, -nospm: SPM compatibility in Analyze output

Syntax: `-spm` or `-nospm `

These options specify whether use the SPM extension to the Analyze (.hdr,.img) format. When this option is on, the origin field stored by SPM in the Analyze header will be correctly interpreted. When saving analyze files, the origin will be set correctly. The default is equivalent to the **-nospm** option. Best to avoid this issue altogether by using NIFTI and SPM5 or later.

    c3d -spm in.hdr out.img.gz
 *
 * @returns Parameter dictionary
 */
function c4d_nospm_params(
    nospm: string,
): C4dNospmParametersTagged {
    const params = {
        "@type": "nospm" as const,
        "nospm": nospm,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_nospm_cargs(
    params: C4dNospmParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-nospm",
        (params["nospm"] ?? null)
    );
    return cargs;
}


/**
 * Output object returned when calling `C4dOutputParameters(...)`.
 *
 * @interface
 */
interface C4dOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output
     */
    output: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param output -o: Output (write) last image on the stack to image file    

Syntax: `-o filename`

Write image, overriding an existing image. Without the **-o** option, **convert3d** will write an image only if it does not exist. The **-o** options protects input images from being accidentally deleted. Here we copy an image, changing format:

    c3d image1.mha -o image2.nii

The **-o** option can also be used to save an intermediate image in the stack: 

    c3d image1.img -threshold 1 10 1 0 -o thresh.img -resample 50% -o final.img
 *
 * @returns Parameter dictionary
 */
function c4d_output_params(
    output: string,
): C4dOutputParametersTagged {
    const params = {
        "@type": "output" as const,
        "output": output,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_output_cargs(
    params: C4dOutputParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-o",
        (params["output"] ?? null)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function c4d_output_outputs(
    params: C4dOutputParameters,
    execution: Execution,
): C4dOutputOutputs {
    const ret: C4dOutputOutputs = {
        root: execution.outputFile("."),
        output: execution.outputFile([(params["output"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @param output_multicomponent -omc, -output-multicomponent: Output multiple images to single file

Syntax: `-omc [number] filename`

Write multiple images on the **Convert3d** stack as a single multi-component image file. If the optional number *n* is specified, only the last *n* images on the stack will be used. Not all file formats support multi-component output. NIFTI is the safest bet.

    c3d red.nii green.nii blue.nii -omc rgb.mha

For 2D images, this command can be used to generate color PNG files:

    c3d image.nii -slice z 50% -colormap jet -type uchar -omc colorslice.png
 *
 * @returns Parameter dictionary
 */
function c4d_output_multicomponent_params(
    output_multicomponent: string,
): C4dOutputMulticomponentParametersTagged {
    const params = {
        "@type": "output_multicomponent" as const,
        "output_multicomponent": output_multicomponent,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_output_multicomponent_cargs(
    params: C4dOutputMulticomponentParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-omc",
        (params["output_multicomponent"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param output_multiple_multicomponent -oomc: Output multiple multi-component images to multiple files

Syntax: `-oomc n_comp image_list` or `-oomc n_comp image_spec`

Write all images on the **convert3d** stack as multiple multi-component image files. The command is a mixture of the **-omc** and **-oo** commands. There must be a multiple of 'n_comp' images on the stack. Every consecutive 'n_comp' images on the stack will be written to a separate multi-component image.

### Commands: Stack Manipulation and Flow Control

These commands are used to manipulate the **convert3d** stack. The stack is a linear array of images. Every time an image is specified on the command line, it is loaded and placed at the end of the stack. Most operations take one image from the end of the stack, apply some operation to it, and place the result on the end of the stack. Certain commands like **-levelset** and **-reslice-matrix** take two images from the end of the stack as the input and replace them with a single output. Some other commands, like **-mean** and **-vote** take all images on the stack and replace them with a single output. 

Sometimes, for complex operations, it is useful to change the order of the images on the stack, to duplicate images, or to execute the same command multiple times. The stack manipulation and flow control commands allow you to complete complex tasks without saving intermediate images to the disk.
 *
 * @returns Parameter dictionary
 */
function c4d_output_multiple_multicomponent_params(
    output_multiple_multicomponent: string,
): C4dOutputMultipleMulticomponentParametersTagged {
    const params = {
        "@type": "output_multiple_multicomponent" as const,
        "output_multiple_multicomponent": output_multiple_multicomponent,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_output_multiple_multicomponent_cargs(
    params: C4dOutputMultipleMulticomponentParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-oomc",
        (params["output_multiple_multicomponent"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param orient -orient: Change image orientation

Syntax: `-orient CODE`

Set the orientation of the image using one of 48 canonical orientations. The orientation describes the mapping from the voxel coordinate system (i,j,k) to the physical coordinate system (x,y,z). In the voxel coordinate system, i runs along columns of voxels, j runs along rows of voxels, and k runs along slices of voxels. It is assumed (by the NIFTI convention) that the axes of the physical coordinate system run as follows: x from (L)eft to (R)ight, y from (P)osterior to (A)nterior, z from (I)nferior to (S)uperior. 

The CODE passed in is a three-letter code consisting of letters RLAPSI. Each letter describes the anatomical direction corresponding to the voxel coordinates (i,j,k). For example, code RAI means that i runs from Right to Left, j from Anterior to Posterior, and k from Inferior to Superior. 

    c3d input.img -orient RAI -o output.img
    c3d input.img -orient SAL -o output.img

This command has the same behavior as the 'Reorient Image' menu option in ITK-SNAP.
 *
 * @returns Parameter dictionary
 */
function c4d_orient_params(
    orient: string,
): C4dOrientParametersTagged {
    const params = {
        "@type": "orient" as const,
        "orient": orient,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_orient_cargs(
    params: C4dOrientParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-orient",
        (params["orient"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param output_multiple -oo: Output multiple images to multiple files 

Syntax: `-oo image_list` or `-oo image_spec`

Write all images on the **convert3d** stack as multiple files. There are two ways to use this command. The first is to supply a list of file names, separated by spaces: 

    c3d labelimage.nii -split -oo labelA.nii labelB.nii labelC.nii

In the above example, the image at the end of the stack will be saved as *labelC.nii*, the image next to the end of the stack will be saved as *labelB.nii* and so on. 

The second way to use the **-oo** command is to supply a pattern for the output filenames. In this case, all the images on the stack will be written. The format for the pattern is the same as for the [C++ printf command][8]. For example, the following command 

    c3d labelimage.nii -split -oo label%02d.nii

will generate images *label00.nii*, *label01.nii*, *label02.nii* and so on. The image at the end of the stack will have the highest number, and the image at the beginning of the stack will have number 00.
 *
 * @returns Parameter dictionary
 */
function c4d_output_multiple_params(
    output_multiple: string,
): C4dOutputMultipleParametersTagged {
    const params = {
        "@type": "output_multiple" as const,
        "output_multiple": output_multiple,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_output_multiple_cargs(
    params: C4dOutputMultipleParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-oo",
        (params["output_multiple"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param orient -orient: Change image orientation

Syntax: `-orient CODE`

Set the orientation of the image using one of 48 canonical orientations. The orientation describes the mapping from the voxel coordinate system (i,j,k) to the physical coordinate system (x,y,z). In the voxel coordinate system, i runs along columns of voxels, j runs along rows of voxels, and k runs along slices of voxels. It is assumed (by the NIFTI convention) that the axes of the physical coordinate system run as follows: x from (L)eft to (R)ight, y from (P)osterior to (A)nterior, z from (I)nferior to (S)uperior. 

The CODE passed in is a three-letter code consisting of letters RLAPSI. Each letter describes the anatomical direction corresponding to the voxel coordinates (i,j,k). For example, code RAI means that i runs from Right to Left, j from Anterior to Posterior, and k from Inferior to Superior. 

    c3d input.img -orient RAI -o output.img
    c3d input.img -orient SAL -o output.img

This command has the same behavior as the 'Reorient Image' menu option in ITK-SNAP.
 *
 * @returns Parameter dictionary
 */
function c4d_orient_1_params(
    orient: string,
): C4dOrient1ParametersTagged {
    const params = {
        "@type": "orient_1" as const,
        "orient": orient,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_orient_1_cargs(
    params: C4dOrient1Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-orient",
        (params["orient"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param origin -origin: Set image origin

Syntax: `-origin vector `

Set the origin of the image. The origin is the world coordinate (in NIfTI coordinate space) of the center of the voxel (0,0,0) in the image. The origin should be specified in millimeters. 

    c3d input.img -origin 100x100x100mm -o output.img
 *
 * @returns Parameter dictionary
 */
function c4d_origin_params(
    origin: string,
): C4dOriginParametersTagged {
    const params = {
        "@type": "origin" as const,
        "origin": origin,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_origin_cargs(
    params: C4dOriginParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-origin",
        (params["origin"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param origin_voxel -origin-voxel: Assign image origin to a voxel

Syntax: `-origin-voxel vector `

Set the origin of the image by specifying the voxel coordinates of the center of the patient (RAS) coordinate system. The vector should be specified in voxel units. 

    c3d input.img -origin-voxel 60x70x35 -o output.img
    c3d input.img -origin-voxel 50% -o output.img        # image centered around origin
 *
 * @returns Parameter dictionary
 */
function c4d_origin_voxel_params(
    origin_voxel: string,
): C4dOriginVoxelParametersTagged {
    const params = {
        "@type": "origin_voxel" as const,
        "origin_voxel": origin_voxel,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_origin_voxel_cargs(
    params: C4dOriginVoxelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-origin-voxel",
        (params["origin_voxel"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param origin_voxel_coord -origin-voxel-coord: Set coordinate of specified voxel

Syntax: `-origin-voxel-coord: <index> <vector>`

This command updates the origin of the image such that the specifed voxel has the specified coordinate. For example, you can use the command to set the world coordinate (in NIFTI coordinate space) of the center voxel of the image, as follows:

    c3d input.nii -origin-voxel-coord: 50% 10x10x5mm -o output.nii
 *
 * @returns Parameter dictionary
 */
function c4d_origin_voxel_coord_params(
    origin_voxel_coord: string,
): C4dOriginVoxelCoordParametersTagged {
    const params = {
        "@type": "origin_voxel_coord" as const,
        "origin_voxel_coord": origin_voxel_coord,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_origin_voxel_coord_cargs(
    params: C4dOriginVoxelCoordParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-origin-voxel-coord",
        (params["origin_voxel_coord"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param overlap -overlap: Compute relative overlap between binary images    

Syntax: `-overlap Z`

Compute relative overlap between labels in the last two images on the stack. Overlap is computed for a given label **Z**, i.e., the number of voxels that are equal to **Z** in both images is computed and divided by either the average number of voxels equal to **Z** in both images (to get Dice coefficient) or by the size of the region where at least one of the images is equal to **Z** (Jaccard coefficient). 

The command below computes overlap for label 255.

    c3d -verbose seg1.img seg2.img -overlap 255

The output of the command is in the following terse format, with the last two values giving Dice and Jaccard coefficients, respectively. 

    OVL: 1, 2383, 2474, 1807, 0.744081, 0.592459

Use the flag **-verbose** to get full information.

    Matching voxels in first image:  2383
    Matching voxels in second image: 2474
    Size of overlap region:          1807
    Dice similarity coefficient:     0.744081
    Intersection / ratio:            0.592459

This command does not alter the stack.
 *
 * @returns Parameter dictionary
 */
function c4d_overlap_params(
    overlap: string,
): C4dOverlapParametersTagged {
    const params = {
        "@type": "overlap" as const,
        "overlap": overlap,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_overlap_cargs(
    params: C4dOverlapParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-overlap",
        (params["overlap"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param overlay_label_image -oli, -overlay-label-image: Overlay segmentation image on grayscale image

Syntax: `-oli lookup_table_file opacity`

This command takes a grayscale image and a label image (i.e. image with a set of discrete values) and produces red, green and blue components of a color image. The resulting color image is an overlay of the labels over the grey image. The first parameter (*lookup\_table*) is a text file with entries in the format 

    label_value red green blue alpha 

Alpha values must be between 0 and 1. Red, green and blue values should be on the same order as the intensity of the grey image (typically 0-255). The text file is compatible with ITK-SNAP and can be generated using the ITK-SNAP `Segmentation->Save Label Descriptions` command. The second parameter (*opacity*) is between 0 and 1 and sets the overall opacity of the overlay. The output of this command is similar to the way ITK-SNAP presents segmentation data on top of grayscale images. 

    c3d gray.nii.gz -stretch 2% 98% 0 255 -clip 0 255 seg.nii.gz -oli labels.txt 0.5 -omc rgb.nii.gz

Note: this command does not interpolate between entries in the lookup table. It should not be used for images with a continuous intensity spectrum. 

Here is a more complex example, used to visualize a segmentation result. We do a few things in this command: trim grayscale and segmentation images to an ROI around the object of interest; map intensity range of the grayscale image to 0-255; extract slices through the middle of the cropped images; overlay segmentation on the grayscale image; and save as a color PNG file. 

    c3d seg.nii.gz -trim 20x20x0vox -as S gray.nii.gz -stretch 2% 98% 0 255 -clip 0 255 \\
        -reslice-identity -push S -foreach -slice z 50% -flip xy -endfor \\
        -oli labels.txt 0.5 -type uchar -omc ovl.png
 *
 * @returns Parameter dictionary
 */
function c4d_overlay_label_image_params(
    overlay_label_image: string,
): C4dOverlayLabelImageParametersTagged {
    const params = {
        "@type": "overlay_label_image" as const,
        "overlay_label_image": overlay_label_image,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_overlay_label_image_cargs(
    params: C4dOverlayLabelImageParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-overlay-label-image",
        (params["overlay_label_image"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param pad -pad: Pad image with constant value

Syntax: `-pad <padlower> <padupper> <value> `

Pads the image by a given percentage or number of voxels. The *padlower* dimension pads along the zero faces of the image, and the *padupper* dimension pads along the upper faces of the image. For example to add 1 voxel to the left side of an image, do 

    c3d img1.nii -pad 1x0x0vox 0x0x0vox 0 -o padded.nii

while 

    c3d img1.nii -pad 2x2x4vox 0% 0 -o padded.nii

adds two voxels padding to the left and posterior sides, and four slices to the bottom of the image. Note that the first argument changes the location of voxel (0,0,0) and thus the origin of the output image will be changed to maintain anatomical alignment between the padded and original images. 

Normally you will want to pad with zeros, but you can pad with any constant value, eg : 

    c3d img1.nii -pad 10% 10% 1 -o padded.nii

Adds 10% to all sides of the image, and fills the new voxels with the value 1.
 *
 * @returns Parameter dictionary
 */
function c4d_pad_params(
    pad: string,
): C4dPadParametersTagged {
    const params = {
        "@type": "pad" as const,
        "pad": pad,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_pad_cargs(
    params: C4dPadParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-pad",
        (params["pad"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param pad_to No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_pad_to_params(
    pad_to: string,
): C4dPadToParametersTagged {
    const params = {
        "@type": "pad_to" as const,
        "pad_to": pad_to,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_pad_to_cargs(
    params: C4dPadToParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-padto",
        (params["pad_to"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param pca -pca: Principal components analysis of foreground voxels

Syntax: `-pca`

Similar to the *-centroid* command, computes the centroid and prinicipal components of the foregrond voxels in the image. For example if the image is a binary image of an ellipsoid, this will report the center and the principal axes of the ellipsoid, in physical NIFTI coordinates.

    c3d binaryimage.img -pca                              // centroid of all non-0 voxels
    c3d labelimage.img -thresh 5 5 1 0 -pca               // centroid of all voxels with label 5
    c3d labelimage.img -split -foreach -pca -endfor       // centroids of all labels (including 0)
 *
 * @returns Parameter dictionary
 */
function c4d_pca_params(
    pca: string,
): C4dPcaParametersTagged {
    const params = {
        "@type": "pca" as const,
        "pca": pca,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_pca_cargs(
    params: C4dPcaParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-pca",
        (params["pca"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param percent_intensity_mode -pim, -percent-intensity-mode: Set behavior of % specifier

Syntax: `-pim Quantile | q | ForegroundQuantile | fq | Range | r`

This options changes how the percent sign (%) is interpreted when specifying intensity values. **Quantile (q)** means that `10%` describes the 10th percentile of all intensity values in the image (i.e., 10% of the voxels have lower intensity). **ForegroundQuantile (fq)** is similar, but voxels with background intensity (see **-background** option) are excluded from the percentile computation. **Range (r)** changes the meaning of percent sign from percentile to the range between the minimum and maximum of the image, and `0.1%` becomes equal to MIN + 0.1 (MAX - MIN). The default is **Quantile**. 

    $ c3d comp01.png -verbose -pim Quantile -verbose -threshold 75% inf 1 0 
    Quantile 0.75 maps to 18

    $ c3d comp01.png -verbose -pim ForegroundQuantile -verbose -threshold 75% inf 1 0 
    Foreground quantile 0.75 (over 37467 voxels) maps to 58

    $ c3d comp01.png -verbose -pim Range -verbose -threshold 75% inf 1 0 
    Intensity range spec 0.75 maps to 191.25
 *
 * @returns Parameter dictionary
 */
function c4d_percent_intensity_mode_params(
    percent_intensity_mode: string,
): C4dPercentIntensityModeParametersTagged {
    const params = {
        "@type": "percent_intensity_mode" as const,
        "percent_intensity_mode": percent_intensity_mode,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_percent_intensity_mode_cargs(
    params: C4dPercentIntensityModeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-percent-intensity-mode",
        (params["percent_intensity_mode"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param pixel No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_pixel_params(
    pixel: string,
): C4dPixelParametersTagged {
    const params = {
        "@type": "pixel" as const,
        "pixel": pixel,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_pixel_cargs(
    params: C4dPixelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-pixel",
        (params["pixel"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param pop -pop: Remove last image from the stack

Syntax: `-pop` 

Removes the last image from the image stack. Images assigned a name with the **-as** command will remain in memory.
 *
 * @returns Parameter dictionary
 */
function c4d_pop_params(
    pop: string,
): C4dPopParametersTagged {
    const params = {
        "@type": "pop" as const,
        "pop": pop,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_pop_cargs(
    params: C4dPopParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-pop",
        (params["pop"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param popas -popas: Remove last image from the stack and assign to variable

Syntax: `-popas var` 

Removes the last image from the stack, but also assigns it the name 'var', keeping the image in memory. Same as calling **-as** *var* followed by **-pop**.
 *
 * @returns Parameter dictionary
 */
function c4d_popas_params(
    popas: string,
): C4dPopasParametersTagged {
    const params = {
        "@type": "popas" as const,
        "popas": popas,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_popas_cargs(
    params: C4dPopasParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-popas",
        (params["popas"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param probe -probe: Report image intensity at a voxel

Syntax: `-probe <point_spec>`

Prints the value of the image at the position specified by the parameter `point_spec`, which may be in physical units or voxel units:

    c3d img1.img -probe 128x120x160vox
    c3d img1.img -interpolation NearestNeighbor -probe 60x60x60mm
    c3d img1.img -probe 50%
 *
 * @returns Parameter dictionary
 */
function c4d_probe_params(
    probe: string,
): C4dProbeParametersTagged {
    const params = {
        "@type": "probe" as const,
        "probe": probe,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_probe_cargs(
    params: C4dProbeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-probe",
        (params["probe"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param push -push: Place variable at the end of the stack

Syntax: `-push var`

Places the image associated with variable name 'var' on end of the image stack. Variable names are assigned using the **-as** command. The **-as** and **-push** commands are useful when you need to use a certain image more than once during a convert3d operation. For example, if you want to compute the distance transform of a binary image and mask it so that the values outside of the binary image region have value 0, you would use the following command: 

    c3d binary.img -as A -sdt -push A -times -o masked_distance.img
 *
 * @returns Parameter dictionary
 */
function c4d_push_params(
    push: string,
): C4dPushParametersTagged {
    const params = {
        "@type": "push" as const,
        "push": push,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_push_cargs(
    params: C4dPushParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-push",
        (params["push"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rank -rank: Voxelwise ranking of intensity values

Syntax: `-rank `

This command takes N images as the input (all the images on the stack are used). It also generates N images as the output. For voxel k in image j, it assigns it a label based on its rank among the values of voxel k in all N images. If the voxel has highest intensity in image j, then the j'th output will have value 1. 

    c3d img1.img img2.img ... imgN.img -rank -oo rank%d.img
 *
 * @returns Parameter dictionary
 */
function c4d_rank_params(
    rank: string,
): C4dRankParametersTagged {
    const params = {
        "@type": "rank" as const,
        "rank": rank,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rank_cargs(
    params: C4dRankParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rank",
        (params["rank"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param reciprocal -reciprocal: Image voxelwise reciprocal 

Syntax: `-reciprocal `

Computes the reciprocal of an image. For instance to compute B = 1 / A, use the command 

    c3d A.img -reciprocal -o B.img
 *
 * @returns Parameter dictionary
 */
function c4d_reciprocal_params(
    reciprocal: string,
): C4dReciprocalParametersTagged {
    const params = {
        "@type": "reciprocal" as const,
        "reciprocal": reciprocal,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_reciprocal_cargs(
    params: C4dReciprocalParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-reciprocal",
        (params["reciprocal"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param region -region: Extract region from image

Syntax: `-region vOrigin vSize `

Extract a rectangular region from the image. The first parameter is the position of the corner of the region, and the second is the size of the region. 

    c3d img1.img -region 20x20x20vox 50x60x70vox -o img2.img
    c3d img1.img -region 25% 50% -o img3.img
 *
 * @returns Parameter dictionary
 */
function c4d_region_params(
    region: string,
): C4dRegionParametersTagged {
    const params = {
        "@type": "region" as const,
        "region": region,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_region_cargs(
    params: C4dRegionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-region",
        (params["region"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param reorder -reorder: Rearrange images on the stack

Syntax: `-reorder k` or `-reorder fraction`

Rearranges images in the stack, such that images that are k positions apart become next to each other on the stack. In other words, if the original order of the images is 1, 2, ..., n, the new order of the images becomes 1, 1+k, 1+2k, ..., 2, 2+k, 2+2k, ..., k, 2k, ... n. Of course, n must be divisible by k. As an alternative to specifying k, you can specify a floating point number (i.e., **-reorder** 0.5), in which case k is obtained by multiplying n by the floating point number and rounding to the nearest integer. 

The following three commands are equivalent:

    c3d a1.nii a2.nii a3.nii a4.nii b1.nii b2.nii b3.nii b4.nii -reorder 4 ...
    c3d a1.nii a2.nii a3.nii a4.nii b1.nii b2.nii b3.nii b4.nii -reorder 0.5 ...
    c3d a1.nii b1.nii a2.nii b2.nii a3.nii b3.nii a4.nii b4.nii ...

The **-reorder** command us useful when you specify two sets of images using wildcards and then want to perform pairwise operations on the images. For example 

    c3d weight*.nii gray*.nii -reorder 0.5 -weighted-sum-voxelwise -o wsum.nii

is equivalent to the command

    c3d weight1.nii gray1.nii weight2.nii gray2.nii ... -weighted-sum-voxelwise -o wsum.nii
 *
 * @returns Parameter dictionary
 */
function c4d_reorder_params(
    reorder: string,
): C4dReorderParametersTagged {
    const params = {
        "@type": "reorder" as const,
        "reorder": reorder,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_reorder_cargs(
    params: C4dReorderParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-reorder",
        (params["reorder"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param retain_labels -retain-labels: Retain labels in a label image

Syntax: `-retain-labels I1 I2 ... IN`

Assuming that the input is a multi-label segmentation image, this command keeps all labels specifed in the list and replaces the remaining labels with the background value.

    c3d seg.nii -retain-labels 2 3 4 8 -o subseg.nii
 *
 * @returns Parameter dictionary
 */
function c4d_retain_labels_params(
    retain_labels: string,
): C4dRetainLabelsParametersTagged {
    const params = {
        "@type": "retain_labels" as const,
        "retain_labels": retain_labels,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_retain_labels_cargs(
    params: C4dRetainLabelsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-retain-labels",
        (params["retain_labels"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rf_apply -rf-apply: Apply Random Forest classifier 

Syntax: `-rf-apply <classifier_file>`

This command applies a classifier trained previously by **-rf-train**. The stack must contain the same number of feature images as when training. The images will be removed from the stack and replaced with a set of K probability images, where K is the number of classes during training. See examples under **-rf-train** for usage.
 *
 * @returns Parameter dictionary
 */
function c4d_rf_apply_params(
    rf_apply: string,
): C4dRfApplyParametersTagged {
    const params = {
        "@type": "rf_apply" as const,
        "rf_apply": rf_apply,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rf_apply_cargs(
    params: C4dRfApplyParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rf-apply",
        (params["rf_apply"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rf_train -rf-train: Train Random Forest classifier

Syntax: `-rf-train <classifier_file>`

This command trains a classifier using an implementation of the [Breyman et al. Random Forest Algorithm][Br2001], with modifications proposed by [Criminisi and Shotton][Cr2004]. The stack must contain one or more images of features (e.g., grayscale images), followed by a multi-label image. The latter must have at least two non-zero labels corresponding to different classes. The classifier is trained on a voxel by voxel basis. All voxels with label *L* are treated as the examples of class *L*. The classifier is output to a binary file that can later be used by the **-rf-apply** command. Multiple parameters can be specified with the **-rf-param-xxx** options before calling **-rf-train**. The stack is not modified by this command.

    # Training with two MRI modalities as features and default parameters
    c3d t1_mri.nii t2_mri.nii segmentation.nii -rf-train myforest1.rf

    # Training with patches as features (see docs for -rf-param-patch)
    c3d ultrasound.nii seg.nii -rf-param-patch 2x2x2 -rf-train myforest2.rf

    # Applying the classifier
    c3d ultrasound.nii -rf-apply myforest2.rf -omc class_prob.nii.gz

The commands are meant to replicate the "classification" pre-segmentation mode in ITK-SNAP, i.e., extending a rough example segmentation to the entire image domain. It is possible to also use the commands to train classifiers jointly on data from multiple subjects, each with its own segmentation, as long as the images from the different subjects occupy the same image space and can be stacked into a 4-dimensional image. For example:

    # Train using MRI and segmentations from N subjects
    c4d mri_subj*.nii -tile w -popas ALLMRI \
        seg_subj*.nii -tile w -popas ALLSEG \
        -rf-param-patch 2x2x2x0 \
        -push ALLMRI -push ALLSEG -rf-train myforest.rf

    # Apply using single MRI
    c4d mri_new.nii -rf-apply myforest.rf -omc classprob.nii

 [Br2001] Breiman, L. (2001). Random forests. Machine learning, 45(1), 5-32.
 [Cr2004] Criminisi, A., & Shotton, J. (2013). Decision forests for computer vision and medical image analysis. Springer Science & Business Media
 *
 * @returns Parameter dictionary
 */
function c4d_rf_train_params(
    rf_train: string,
): C4dRfTrainParametersTagged {
    const params = {
        "@type": "rf_train" as const,
        "rf_train": rf_train,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rf_train_cargs(
    params: C4dRfTrainParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rf-train",
        (params["rf_train"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rf_param_patch -rf-param-patch: Random Forest training patch size

Syntax: `-rf-param-patch <size_spec>`

Set the radius of the patch used to generate features for the RF classifier. By default this is zero, which means that just the intensity of each voxel is used as a feature. Setting this to non-zero values will result in neighboring intensities also being used as features, and can improve classification in presence of complex image texture. The patch size in each dimension is (2 * radius + 1). See **-rf-train** command for details.

    # Set patch size to 5x5x5 
    c3d ... -rf-param-patch 2x2x2 ... -rf-train myforest.rf
 *
 * @returns Parameter dictionary
 */
function c4d_rf_param_patch_params(
    rf_param_patch: string,
): C4dRfParamPatchParametersTagged {
    const params = {
        "@type": "rf_param_patch" as const,
        "rf_param_patch": rf_param_patch,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rf_param_patch_cargs(
    params: C4dRfParamPatchParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rf-param-patch",
        (params["rf_param_patch"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rf_param_usexyz -rf-param-usexyz: Random Forest coordinate features

Syntax: `-rf-param-usexyz`

Use the coordinates of voxels as additional features. This allows some geometric relations between different labels to be learned. Equivalent to the corresponding ITK-SNAP option.
 *
 * @returns Parameter dictionary
 */
function c4d_rf_param_usexyz_params(
    rf_param_usexyz: string,
): C4dRfParamUsexyzParametersTagged {
    const params = {
        "@type": "rf_param_usexyz" as const,
        "rf_param_usexyz": rf_param_usexyz,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rf_param_usexyz_cargs(
    params: C4dRfParamUsexyzParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rf-param-usexyz",
        (params["rf_param_usexyz"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rf_param_nousexyz No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_rf_param_nousexyz_params(
    rf_param_nousexyz: string,
): C4dRfParamNousexyzParametersTagged {
    const params = {
        "@type": "rf_param_nousexyz" as const,
        "rf_param_nousexyz": rf_param_nousexyz,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rf_param_nousexyz_cargs(
    params: C4dRfParamNousexyzParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rf-param-nousexyz",
        (params["rf_param_nousexyz"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rf_param_ntrees -rf-param-ntrees: Random Forest forest size

Syntax: `-rf-param-ntrees <integer>`

Sets the number of trees in the forest. Default value is 50. Larger forests are more robust but more time to train and apply.
 *
 * @returns Parameter dictionary
 */
function c4d_rf_param_ntrees_params(
    rf_param_ntrees: string,
): C4dRfParamNtreesParametersTagged {
    const params = {
        "@type": "rf_param_ntrees" as const,
        "rf_param_ntrees": rf_param_ntrees,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rf_param_ntrees_cargs(
    params: C4dRfParamNtreesParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rf-param-ntrees",
        (params["rf_param_ntrees"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rf_param_treedepth -rf-param-treedepth: Random Forest tree depth

Syntax: `-rf-param-treedepth <integer>`

Sets the depth of the trees in the classifier. Default value is 30. Deeper trees can learn on more complex data but require more time.
 *
 * @returns Parameter dictionary
 */
function c4d_rf_param_treedepth_params(
    rf_param_treedepth: string,
): C4dRfParamTreedepthParametersTagged {
    const params = {
        "@type": "rf_param_treedepth" as const,
        "rf_param_treedepth": rf_param_treedepth,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rf_param_treedepth_cargs(
    params: C4dRfParamTreedepthParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rf-param-treedepth",
        (params["rf_param_treedepth"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param set_sform -set-sform: Set the transform to physical space

Syntax: `-set-sform <sform.mat> `

Sets the Nifti sform of the last image on the stack to the 4x4 matrix provided.
 *
 * @returns Parameter dictionary
 */
function c4d_set_sform_params(
    set_sform: string,
): C4dSetSformParametersTagged {
    const params = {
        "@type": "set_sform" as const,
        "set_sform": set_sform,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_set_sform_cargs(
    params: C4dSetSformParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-set-sform",
        (params["set_sform"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param replace -replace: Replace intensities in image

Syntax: `-replace I1 J1 I2 J2 ... `

Replace intensity I1 by J1, I2 by J2 and so on. Allowed values of intensity include **nan**, **inf** and **-inf**. 

    c3d img1.img -replace 1 128 nan 0.0 -o img2.img
 *
 * @returns Parameter dictionary
 */
function c4d_replace_params(
    replace: string,
): C4dReplaceParametersTagged {
    const params = {
        "@type": "replace" as const,
        "replace": replace,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_replace_cargs(
    params: C4dReplaceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-replace",
        (params["replace"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param resample -resample: Resample image to new dimensions

Syntax: `-resample <dimensions> `

Resamples the image, keeping the bounding box the same, but changing the number of voxels in the image. The dimensions can be specified as a percentage, for example to double the number of voxels in each direction. The **-interpolation** flag affects how sampling is performed. 

    c3d img1.img -resample 123x142x200 -o img2.img 
    c3d img1.img -resample 200% -o img2.img 
    c3d img1.img -resample 100x100x200% -o img2.img 
    c3d img1.img -background 4.0 -interpolation Cubic -resample 123x142x200 -o img2.img
 *
 * @returns Parameter dictionary
 */
function c4d_resample_params(
    resample: string,
): C4dResampleParametersTagged {
    const params = {
        "@type": "resample" as const,
        "resample": resample,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_resample_cargs(
    params: C4dResampleParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-resample",
        (params["resample"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param resample_iso -resample-iso: Resample image to (approximately) isotropic resolution

Syntax: `-resample-iso <min|max>`

Resamples the image to have approximately isotropic resolution, either based on the smallest voxel dimension ('min' mode) or largest voxel dimension ('max' mode). This command calls **-resample** with appropriately calculated new image dimensions. The bounding box of the image in physical space is preserved. Therefore, since the image dimensions must be integer, the actual voxel dimensions after resampling may not be precisely isotropic. 

    c3d img1.img -resample-iso min -o img2.img
 *
 * @returns Parameter dictionary
 */
function c4d_resample_iso_params(
    resample_iso: string,
): C4dResampleIsoParametersTagged {
    const params = {
        "@type": "resample_iso" as const,
        "resample_iso": resample_iso,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_resample_iso_cargs(
    params: C4dResampleIsoParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-resample-iso",
        (params["resample_iso"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param resample_mm -resample-mm: Resample image to new resolution

Syntax: `-resample-mm <voxel_size> `

Resamples the image as in **-resample**, but the user specifies the new voxel size rather than dimensions. This may not be precise, so the bounding box of the image may change. A warning will be generated in that case. 

    c3d img1.img -resample-mm 1.0x1.5x1.5mm -o img2.img
 *
 * @returns Parameter dictionary
 */
function c4d_resample_mm_params(
    resample_mm: string,
): C4dResampleMmParametersTagged {
    const params = {
        "@type": "resample_mm" as const,
        "resample_mm": resample_mm,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_resample_mm_cargs(
    params: C4dResampleMmParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-resample-mm",
        (params["resample_mm"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param reslice_itk -reslice-itk: Resample image using affine transform

Syntax: `-reslice-itk <transform_file> `

Applies affine (or other) transform in ITK (ANTs) format to an image. See notes to **-reslice-matrix** for usage.
 *
 * @returns Parameter dictionary
 */
function c4d_reslice_itk_params(
    reslice_itk: string,
): C4dResliceItkParametersTagged {
    const params = {
        "@type": "reslice_itk" as const,
        "reslice_itk": reslice_itk,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_reslice_itk_cargs(
    params: C4dResliceItkParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-reslice-itk",
        (params["reslice_itk"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param reslice_matrix No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_reslice_matrix_params(
    reslice_matrix: string,
): C4dResliceMatrixParametersTagged {
    const params = {
        "@type": "reslice_matrix" as const,
        "reslice_matrix": reslice_matrix,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_reslice_matrix_cargs(
    params: C4dResliceMatrixParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-reslice-matrix",
        (params["reslice_matrix"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param reslice_identity -reslice-identity: Resample image using identity transform 

Syntax: `-reslice-identity `

Applies the **-reslice-matrix** command with the identity transform. This is useful when you have two scans of the same subject with different coordinate transformations to patient space and you want to resample one scan in the space of another scan. For example, if you have T1 and T2 images in different coordinate frames, and want to reslice the T2 image into the space of the T1 

    c3d t1.nii t2.nii -reslice-identity -o t2_in_t1_space.nii
 *
 * @returns Parameter dictionary
 */
function c4d_reslice_identity_params(
    reslice_identity: string,
): C4dResliceIdentityParametersTagged {
    const params = {
        "@type": "reslice_identity" as const,
        "reslice_identity": reslice_identity,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_reslice_identity_cargs(
    params: C4dResliceIdentityParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-reslice-identity",
        (params["reslice_identity"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rgb2hsv -rgb2hsv: Convert RGB image to HSV image

Syntax `-rgb2hsv`

Takes the last three images on the stack and treats them as red, green, and blue channels. Outputs three images corresponding to hue, saturation, value. To read color images you need the ***-msc*** command.

    c3d -mcs color.png -rgb2hsv -omc hsv.png
 *
 * @returns Parameter dictionary
 */
function c4d_rgb2hsv_params(
    rgb2hsv: string,
): C4dRgb2hsvParametersTagged {
    const params = {
        "@type": "rgb2hsv" as const,
        "rgb2hsv": rgb2hsv,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rgb2hsv_cargs(
    params: C4dRgb2hsvParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rgb2hsv",
        (params["rgb2hsv"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param rms -rms: Voxelwise vector norm

Syntax: `-rms`

Computes RMS (root mean square) of all images on the stack. The command takes the square of each image on the stack, adds all the squared images and takes the square root of the result. This is very useful for statistical operations. Images must have the same size. 

    c3d img1.img img2.img img3.img img4.img -rms -o rms.img

The equivalent of this command is

    c3d img1.img img2.img img3.img img4.img -foreach -dup -times -endfor \
        -accum -add -endaccum -sqrt -o rms.img
 *
 * @returns Parameter dictionary
 */
function c4d_rms_params(
    rms: string,
): C4dRmsParametersTagged {
    const params = {
        "@type": "rms" as const,
        "rms": rms,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_rms_cargs(
    params: C4dRmsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-rms",
        (params["rms"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param round -noround, -round: Floating point rounding behavior

Syntax: `-noround` or `-round `

By default, **convert3d** will round floating point values when converting to an integer, short or byte image. This command specifies that rounding should not be used. Rounding is used to avoid numerical errors stemming from the internal floating point representation. 

    c3d image1.img -type short -noround image2.img
 *
 * @returns Parameter dictionary
 */
function c4d_round_params(
    round: string,
): C4dRoundParametersTagged {
    const params = {
        "@type": "round" as const,
        "round": round,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_round_cargs(
    params: C4dRoundParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-round",
        (params["round"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param scale -scale: Scale intensity by constant factor

Syntax: `-scale <factor>`

Multiplies the intensity of each voxel in the last image on the stack by the given factor. 

    c3d img1.img -scale 0.5 -o img2.img
 *
 * @returns Parameter dictionary
 */
function c4d_scale_params(
    scale: string,
): C4dScaleParametersTagged {
    const params = {
        "@type": "scale" as const,
        "scale": scale,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_scale_cargs(
    params: C4dScaleParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-scale",
        (params["scale"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param set_sform -set-sform: Set the transform to physical space

Syntax: `-set-sform <sform.mat> `

Sets the Nifti sform of the last image on the stack to the 4x4 matrix provided.
 *
 * @returns Parameter dictionary
 */
function c4d_set_sform_1_params(
    set_sform: string,
): C4dSetSform1ParametersTagged {
    const params = {
        "@type": "set_sform_1" as const,
        "set_sform": set_sform,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_set_sform_1_cargs(
    params: C4dSetSform1Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-set-sform",
        (params["set_sform"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param sin -cos: Voxelwise cosine 

Syntax: `-sin`

Replaces the last image on the stack with the cosine trigonometric operation applied to all voxels. Input must be in radians.
 *
 * @returns Parameter dictionary
 */
function c4d_sin_params(
    sin: string,
): C4dSinParametersTagged {
    const params = {
        "@type": "sin" as const,
        "sin": sin,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_sin_cargs(
    params: C4dSinParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-sin",
        (params["sin"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param slice -slice: Extract slices from an image

Syntax: `-slice axis position_spec`

Extracts a slice along the specified axis (x,y or z). The position specifier **position_spec** can be a single slice or a range of slices. For a single slice, it can be specified as a number or a percentage. Numbering is zero-based, i.e, the first slice is slice 0, the last slice is N-1, where N is the number of slices. For a range, use MATLAB notation first:step:last. The slice is placed on the stack as an image with size 1 in the last dimension. You can save the slice as a 2D PNG image. 

    c3d input.img -slice x 128 -o myslice.nii.gz
    c3d input.img -slice y 50% myslice.nii.gz
    c3d input.img -slice z 25% -type uchar -stretch 0 2000 0 255 -o myslice.png
    c3d input.img -slice z 0:-1 -oo slice%0d.nii.gz 
    c3d input.img -slice z 20%:10%:80% -oo slice%0d.nii.gz 

With the new command **c4d**, the **-slice** command can be used to extract volumes from a 4D image. This can be useful to reformat a 4D NIFTI image as a 3D multi-component NIFTI image, using the command 

    c4d input4d.nii.gz -slice w 0:-1 -omc output3d_multicomp.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_slice_params(
    slice: string,
): C4dSliceParametersTagged {
    const params = {
        "@type": "slice" as const,
        "slice": slice,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_slice_cargs(
    params: C4dSliceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-slice",
        (params["slice"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param slice_all -slice-all: Extract slices from all images on the stack

Syntax `-slice-all axis position_spec`

This command behaves identical to the **-slice** command, but all images on the stack are sliced, and the slices are interleaved. This is useful for slicing multi-component images. For example, if you read a four-component image 'test4.nii.gz', you can extract and save the slices as follows:

    c3d test4.nii.gz -slice-all 20%:10%:80% -oomc 4 slice4_%03d.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_slice_all_params(
    slice_all: string,
): C4dSliceAllParametersTagged {
    const params = {
        "@type": "slice_all" as const,
        "slice_all": slice_all,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_slice_all_cargs(
    params: C4dSliceAllParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-slice-all",
        (params["slice_all"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param sharpen -sharpen: Sharpen edges in the image

Syntax: `-sharpen`

Applies the Laplacian sharpening filter from ITK, which accentuates the edges in the image.

    c3d input.nii.gz -sharpen -o output.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_sharpen_params(
    sharpen: string,
): C4dSharpenParametersTagged {
    const params = {
        "@type": "sharpen" as const,
        "sharpen": sharpen,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_sharpen_cargs(
    params: C4dSharpenParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-sharpen",
        (params["sharpen"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param shift -shift: Shift image intensity by constant

Syntax: `-shift <constant>`

Adds the given constant to every voxel.

    c3d img1.img -shift 100 -o img2.img
 *
 * @returns Parameter dictionary
 */
function c4d_shift_params(
    shift: string,
): C4dShiftParametersTagged {
    const params = {
        "@type": "shift" as const,
        "shift": shift,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_shift_cargs(
    params: C4dShiftParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-shift",
        (params["shift"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param signed_distance_transform -sdt, -signed-distance-transform: Signed distance transform of a binary image

Syntax: `-sdt`

Computes the signed distance transform of a binary image. Voxels where the binary image is non-zero will have negative values and voxels where the binary image is zero will have negative values. The magnitude of the value will be the approximate Euclidean distance to the boundary of the object represented by the binary image. 

    c3d binary.img -sdt -o dist.img
 *
 * @returns Parameter dictionary
 */
function c4d_signed_distance_transform_params(
    signed_distance_transform: string,
): C4dSignedDistanceTransformParametersTagged {
    const params = {
        "@type": "signed_distance_transform" as const,
        "signed_distance_transform": signed_distance_transform,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_signed_distance_transform_cargs(
    params: C4dSignedDistanceTransformParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-signed-distance-transform",
        (params["signed_distance_transform"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param smooth -smooth: Gaussian smoothing

Syntax: `-smooth <sigma_vector> `

Applies Gaussian smoothing to the image. The parameter vector specifies the standard deviation of the Gaussian kernel. Also see [Vector Format Specification][10] below. 

    c3d img1.img -smooth 2x1x1vox -o out.img
 *
 * @returns Parameter dictionary
 */
function c4d_smooth_params(
    smooth: string,
): C4dSmoothParametersTagged {
    const params = {
        "@type": "smooth" as const,
        "smooth": smooth,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_smooth_cargs(
    params: C4dSmoothParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-smooth",
        (params["smooth"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param smooth_fast -smooth-fast: Fast approximate Gaussian smoothing

Syntax: `-smooth-fast <sigma_vector> `

Applies Gaussian smoothing to the image using the fast [Deriche recursive smoothing algorithm][15].  The parameter vector specifies the standard deviation of the Gaussian kernel. Also see [Vector Format Specification][10] below. 

    c3d img1.img -smooth-fast 20x10x10vox -o out.img
 *
 * @returns Parameter dictionary
 */
function c4d_smooth_fast_params(
    smooth_fast: string,
): C4dSmoothFastParametersTagged {
    const params = {
        "@type": "smooth_fast" as const,
        "smooth_fast": smooth_fast,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_smooth_fast_cargs(
    params: C4dSmoothFastParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-smooth-fast",
        (params["smooth_fast"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param spacing -spacing: Set voxel spacing

Syntax: `-spacing <vector> `

Sets the voxel spacing of the image. This should always be a vector with positive components. For example, to set the spacing of the image to 1mm isotropic, use the command below. This command only changes the header of the image, not its contents. 

    c3d img.nii -spacing 1x1x1mm -o out.img
 *
 * @returns Parameter dictionary
 */
function c4d_spacing_params(
    spacing: string,
): C4dSpacingParametersTagged {
    const params = {
        "@type": "spacing" as const,
        "spacing": spacing,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_spacing_cargs(
    params: C4dSpacingParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-spacing",
        (params["spacing"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param split -split: Split multi-label image into binary images

Syntax: `-split`

This command takes a multilabel image (one with a small number of discrete intensity levels), and replaces it with a set of binary images, one for each of the levels. The images can later be recombined using the **-merge** command. The labels corresponding to each binary image are remembered by **convert3d** so that when **-merge** is called, the labels are faithfully reassigned. The **-merge** command treats each input as a probability image, and selects at each voxel the label that has highest probability. The example below smooths each label independently, then recombines using **-merge** 

    c3d multilabel.nii -split -foreach -smooth 3mm -endfor -merge -o ml_smooth.nii

Also of note is that the **-split** command will disregard infinite intensity values. So if you want to apply voting to a subset of the labels, you can replace labels you do not care about with *inf*, for example, using the **-thresh** command.
 *
 * @returns Parameter dictionary
 */
function c4d_split_params(
    split: string,
): C4dSplitParametersTagged {
    const params = {
        "@type": "split" as const,
        "split": split,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_split_cargs(
    params: C4dSplitParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-split",
        (params["split"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param sqrt -sqrt: Take square root of image

Syntax: `-sqrt `

Computes square root of each voxel in the image.

    c3d input.img -sqrt -o output.img
 *
 * @returns Parameter dictionary
 */
function c4d_sqrt_params(
    sqrt: string,
): C4dSqrtParametersTagged {
    const params = {
        "@type": "sqrt" as const,
        "sqrt": sqrt,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_sqrt_cargs(
    params: C4dSqrtParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-sqrt",
        (params["sqrt"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param staple -staple: STAPLE algorithm to combine segmentations

Syntax: `-staple <intensity_value> `

Runs the ITK implementation of the STAPLE algorithm ([See Paper][11]). STAPLE generates an estimate of the 'true' segmentation of a structure given a set of segmentations by different raters. This command treats all images on the stack as inputs. Each image is considered to be a segmentation by a different rater. The parameter *intensity_value* specifies the label in the segmentation images corresponding to the structure of interest (e.g., the segmentation image may have value 1 corresponding to the caudate and value 2 corresponding to the hippocampus. To run STAPLE on the hippocampus, pass in 2 as the *intensity_value*). The output of STAPLE is a real-valued image with voxels between 0 and 1, representing the probability of each voxel being in the 'true' segmentation. This image can be thresholded to get a binary consensus segmentation. Additional outputs (estimates of the sensitivity and specificity of each rater) are printed out if the **-verbose** command is used before the **-staple** command. 

    c3d -verbose rater1.img rater2.img rater3.img -staple 1 -o probmap.img
    c3d -verbose rater*.img -staple 1 -threshold 0.5 inf 1 0 -o bin_segm.img
 *
 * @returns Parameter dictionary
 */
function c4d_staple_params(
    staple: string,
): C4dStapleParametersTagged {
    const params = {
        "@type": "staple" as const,
        "staple": staple,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_staple_cargs(
    params: C4dStapleParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-staple",
        (params["staple"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param structure_tensor_eigenvalues -steig, -structure-tensor-eigenvalues: Compute eigenvalues of the structure tensor

Syntax `-steig <scale> <radius>`

Computes the Hessian matrix at every pixel of an image and the eigenvalues of the Hessian. Images of the eigenvalues (sorted by value) are placed on the stack. These images are useful as texture features. See also the '''-steig''' command. The scale determines the amount of Gaussian smoothing applied for computing the partial derivatives in the Hessian, and is in physical (mm) units.

    c3d myimage.nii -hesseig 2.0 -oo eig%02d.nii.gz
 *
 * @returns Parameter dictionary
 */
function c4d_structure_tensor_eigenvalues_params(
    structure_tensor_eigenvalues: string,
): C4dStructureTensorEigenvaluesParametersTagged {
    const params = {
        "@type": "structure_tensor_eigenvalues" as const,
        "structure_tensor_eigenvalues": structure_tensor_eigenvalues,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_structure_tensor_eigenvalues_cargs(
    params: C4dStructureTensorEigenvaluesParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-steig",
        (params["structure_tensor_eigenvalues"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param spm -spm, -nospm: SPM compatibility in Analyze output

Syntax: `-spm` or `-nospm `

These options specify whether use the SPM extension to the Analyze (.hdr,.img) format. When this option is on, the origin field stored by SPM in the Analyze header will be correctly interpreted. When saving analyze files, the origin will be set correctly. The default is equivalent to the **-nospm** option. Best to avoid this issue altogether by using NIFTI and SPM5 or later.

    c3d -spm in.hdr out.img.gz
 *
 * @returns Parameter dictionary
 */
function c4d_spm_params(
    spm: string,
): C4dSpmParametersTagged {
    const params = {
        "@type": "spm" as const,
        "spm": spm,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_spm_cargs(
    params: C4dSpmParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-spm",
        (params["spm"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param subtract No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_subtract_params(
    subtract: string,
): C4dSubtractParametersTagged {
    const params = {
        "@type": "subtract" as const,
        "subtract": subtract,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_subtract_cargs(
    params: C4dSubtractParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-subtract",
        (params["subtract"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param supervoxel No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_supervoxel_params(
    supervoxel: string,
): C4dSupervoxelParametersTagged {
    const params = {
        "@type": "supervoxel" as const,
        "supervoxel": supervoxel,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_supervoxel_cargs(
    params: C4dSupervoxelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-supervoxel",
        (params["supervoxel"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param stretch -stretch: Stretch image intensities linearly

Syntax: `-stretch <u1 u2 v1 v2> `

Stretches the intensities in the image linearly, such that u1 maps to v1 and u2 maps to v2. The linear transformation is applied to all intensities in the image, whether inside the range or not. For example, to map a floating point image with intensities in interval (0,1) to the full range of an unsigned short image, use 

    c3d input.img -stretch 0.0 1.0 0 65535 -type ushort -o output.img
 *
 * @returns Parameter dictionary
 */
function c4d_stretch_params(
    stretch: string,
): C4dStretchParametersTagged {
    const params = {
        "@type": "stretch" as const,
        "stretch": stretch,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_stretch_cargs(
    params: C4dStretchParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-stretch",
        (params["stretch"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param swapdim -swapdim: Reorder the coordinate axes of an image

Syntax `-swapdim <code>`

This command reorders the image axes (columns, rows, slices) to achieve a desired transformation between voxel space and physical space. The image remains exactly the same in physical space, but the encoding of the voxels in memory and on disk is changed to obtain the desired transformation. The transformation is specified as a three-letter 'RAI' code, as in the '''-orient''' command.

    c3d img.nii -swapdim ASL -info -o out.nii


### Commands: Image Processing

The following commands invoke an action that is applied to images. Unary commands apply the action to the last image on the stack, binary commands apply to the last two images and so on. Commands are affected by options, which are listed separately.
 *
 * @returns Parameter dictionary
 */
function c4d_swapdim_params(
    swapdim: string,
): C4dSwapdimParametersTagged {
    const params = {
        "@type": "swapdim" as const,
        "swapdim": swapdim,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_swapdim_cargs(
    params: C4dSwapdimParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-swapdim",
        (params["swapdim"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param test_image -test-image, -test-probe: Test condition

Syntax: `-test-image [tolerance]` and `-test-probe <vector> <value> [tolerance]`

These advanced commands (with more to come in the future) are primarily meant to allow testing of **c3d**. However, they can also be used for flow control in shell scripts (e.g., **bash** shell). The commands check a certain aspect of the **c3d** state and cause the program to exit with either return code 0 if the test succeeded or a non-zero return code if the test failed. 

**-test-image** tests if the last two images on the stack are identical (both in terms of data and header). Returns 0 if the images are identical. The optional tolerance parameter has default value 1e-8. 

    c3d input1.img input2.img -test-image

**-test-probe** is similar to the **-probe** command. It tests if the value of the last image on the stack at the position given by **vector** is equal to the **test_value**. An optional tolerance value may be specified, the default is 1e-8. 

    c3d input1.img -test-probe 40x40x20vox 1.0 1e-6
 *
 * @returns Parameter dictionary
 */
function c4d_test_image_params(
    test_image: string,
): C4dTestImageParametersTagged {
    const params = {
        "@type": "test_image" as const,
        "test_image": test_image,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_test_image_cargs(
    params: C4dTestImageParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-test-image",
        (params["test_image"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param test_probe -test-image, -test-probe: Test condition

Syntax: `-test-image [tolerance]` and `-test-probe <vector> <value> [tolerance]`

These advanced commands (with more to come in the future) are primarily meant to allow testing of **c3d**. However, they can also be used for flow control in shell scripts (e.g., **bash** shell). The commands check a certain aspect of the **c3d** state and cause the program to exit with either return code 0 if the test succeeded or a non-zero return code if the test failed. 

**-test-image** tests if the last two images on the stack are identical (both in terms of data and header). Returns 0 if the images are identical. The optional tolerance parameter has default value 1e-8. 

    c3d input1.img input2.img -test-image

**-test-probe** is similar to the **-probe** command. It tests if the value of the last image on the stack at the position given by **vector** is equal to the **test_value**. An optional tolerance value may be specified, the default is 1e-8. 

    c3d input1.img -test-probe 40x40x20vox 1.0 1e-6
 *
 * @returns Parameter dictionary
 */
function c4d_test_probe_params(
    test_probe: string,
): C4dTestProbeParametersTagged {
    const params = {
        "@type": "test_probe" as const,
        "test_probe": test_probe,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_test_probe_cargs(
    params: C4dTestProbeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-test-probe",
        (params["test_probe"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param threshold -thresh, -threshold: Binary thresholding

Syntax: `-thresh <u1 u2 vIn vOut> `

Thresholds the image, setting voxels whose intensity is in the range [u1,u2] to vIn and all other voxels to vOut. Values *u1* and *u2* are intensity specifications (see below). This means that you can supply values **inf** and **-inf** for u1 and u2 to construct a one-sided threshold. You can also specify *u1* and *u2* as percentiles. 
    c3d in.img -threshold -inf 128 1 0 -o out.img
    c3d in.img -threshold 64 128 1 0 -o out.img
    c3d in.img -threshold 20% 40% 1 0 -o out.img
 *
 * @returns Parameter dictionary
 */
function c4d_threshold_params(
    threshold: string,
): C4dThresholdParametersTagged {
    const params = {
        "@type": "threshold" as const,
        "threshold": threshold,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_threshold_cargs(
    params: C4dThresholdParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-threshold",
        (params["threshold"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param tile -tile: Tile and stack multiple images into one

Syntax: `-tile <tile_spec>`

Tiles multiple images into a single image -- including stacking slices into a 3D volume. The command takes all images on the stack and produces a single tiled image. The **tile_spec** parameter can either specify a coordinate axis (x, y, or z) along which to tile the images, or a layout vector (e.g., **4x4**) which specifies the tiling along each coordinate. Passing 0 for the last value in the layout vector determines the value based on the number of images currently loaded. For example, to create a 3D volume from a set of slices, we use 

    c3d slices*.png -tile z -o volume.nii.gz

And to arrange the same 2D slices into a 2D montage of 4 images per row, we would use the **c2d** command as follows: 

    c2d slices*.png -tile 4x0 -type uchar -o montage.png
 *
 * @returns Parameter dictionary
 */
function c4d_tile_params(
    tile: string,
): C4dTileParametersTagged {
    const params = {
        "@type": "tile" as const,
        "tile": tile,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_tile_cargs(
    params: C4dTileParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-tile",
        (params["tile"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param trim -trim: Trim background region of image

Syntax: `-trim <margin_vector>`

Use this command to trim background in an image. When most of the image is filled by background, this command will find the smallest rectangular region that contains all of the non-background voxels in the image. I will then expand this region by the margin of the size specified, and return the resulting region as the new image. For example, this command will trim an image, leaving a 5-voxel margin of background values on all sides

    c3d in.img -trim 5vox -o out.img
 *
 * @returns Parameter dictionary
 */
function c4d_trim_params(
    trim: string,
): C4dTrimParametersTagged {
    const params = {
        "@type": "trim" as const,
        "trim": trim,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_trim_cargs(
    params: C4dTrimParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-trim",
        (params["trim"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param trim_to_size -trim-to-size: Trim image to given size

Syntax: `-trim-to-size <size_vector>`

Like **-trim**, this command trims the background in an image. However, instead of **-trim**, you specify the target size of the output region. The actual region may be smaller if the specified region falls outside the boundaries of the input image. For example, if you want a 64x64x128 image containing all the foreground pixels in your image, call 

    c3d in.img -trim-to-size 64x64x128vox -o out.img
 *
 * @returns Parameter dictionary
 */
function c4d_trim_to_size_params(
    trim_to_size: string,
): C4dTrimToSizeParametersTagged {
    const params = {
        "@type": "trim_to_size" as const,
        "trim_to_size": trim_to_size,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_trim_to_size_cargs(
    params: C4dTrimToSizeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-trim-to-size",
        (params["trim_to_size"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param type_ -type: Specify pixel type for image output

Syntax: `-type < char | uchar | short | ushort | int | uint | float | double > `

Specifies the pixel type for the output image. By default, images are written in floating point (**float**) format. The type does not affect how images are processed, only how they are saved. 

    c3d image1.img -type short image2.img

Some images require data in certain types. For example, to save PNG images, uchar or ushort type must be specified.
 *
 * @returns Parameter dictionary
 */
function c4d_type_params(
    type_: string,
): C4dTypeParametersTagged {
    const params = {
        "@type": "type" as const,
        "type": type_,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_type_cargs(
    params: C4dTypeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-type",
        (params["type"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param verbose -verbose: Enable verbose output of commands

Syntax: `-verbose`

Commands entered after the **-verbose** command will print debugging information. This can be turned off with **-noverbose**.

### Parameter Specifications
 *
 * @returns Parameter dictionary
 */
function c4d_verbose_params(
    verbose: string,
): C4dVerboseParametersTagged {
    const params = {
        "@type": "verbose" as const,
        "verbose": verbose,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_verbose_cargs(
    params: C4dVerboseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-verbose",
        (params["verbose"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param noverbose No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_noverbose_params(
    noverbose: string,
): C4dNoverboseParametersTagged {
    const params = {
        "@type": "noverbose" as const,
        "noverbose": noverbose,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_noverbose_cargs(
    params: C4dNoverboseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-noverbose",
        (params["noverbose"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param version No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_version_params(
    version: string,
): C4dVersionParametersTagged {
    const params = {
        "@type": "version" as const,
        "version": version,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_version_cargs(
    params: C4dVersionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-version",
        (params["version"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param vote -vote: Vote among images on the stack

Syntax: `-vote `

This command takes all images on the stack as arguments and at each voxel *(i,j,k)* returns the index of the image for which the image value at *(i,j,k)* is the greatest. This is most useful when combining probability maps into a single label image. If images prob1.img, prob2.img, etc. give the probability of label 1, 2, etc. over the image domain, the **-vote** command will return the most probable label at each voxel. 

    c3d prob1.img prob2.img prob3.img -vote -type uchar -o label.img

The value assigned to each image is based on its position from the bottom of the stack, with zero indicating bottom-most image. In the example above, the output image has values 0 for voxels where prob1.img is highest, 1 for prob2.img and 2 for prob3.img. Also see the related commands **-split** and **-merge**.
 *
 * @returns Parameter dictionary
 */
function c4d_vote_params(
    vote: string,
): C4dVoteParametersTagged {
    const params = {
        "@type": "vote" as const,
        "vote": vote,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_vote_cargs(
    params: C4dVoteParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-vote",
        (params["vote"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param vote_mrf -vote-mrf: Vote with Markov Random Field regularlization

Syntax: `-vote-mrf <mode> <lambda>`

This command is similar to **-vote** but it performs regularlization using the Markov Random Field (MRF). This form of regularization penalizes the total surface area of the segments in the output. It results in more contiguous segments. 

The command takes all the images on the stack and assumes that they are likelihood images corresponding to labels 1, 2, ... N. This means that voxel **x** in image **k** holds the probability that voxel **x** has label **k**. Likelihood images must be between 0 and 1. Any values outside of the range are interpreted as the voxel being excluded from the voting. These voxels will be assigned label 0 in the output.

The problem is encoded in the form of energy minimization, consisting of a data term and a regularization term. The data term encodes the cost (penalty) associated with assigning the voxel **x** the label **k**. The parameter **mode** describes how likelihood images are mapped to the cost. 

* `VOTES_AGAINST` or `VA`. This mode is useful when the command is being used to combine several multi-label segmentations into a single one. Each likelihood image is assumed to be the proportion of segmentations that assign label *k* to voxel *x*. The data term equals to the error associated to assining the voxel *k* label *x*. This error is calculated as the sum of the likelihoods for all labels at *x* minus the likelihood for *k* at *x*. Note that the likelihoods do not have to add up to one, which may be interpreted as missing data for some voxels. 

* `LOG_LIKELIHOOD` or `LL`. The cost for label *k* at voxel *x* is the logarithm of the k-th likelihood image at *x*. This will assign infinite cost when the likelihood is zero. 

The regularlization term is encoded as **lambda** times the total number of neighboring voxels inside the mask (non-excluded region of the image) that have different labels. 

The optmization problem is solved using the Alpha-Expansion graph cut algorithm. Users of this functionality should cite the following papers. 

1. Yuri Boykov, Olga Veksler, Ramin Zabih, *Efficient Approximate Energy Minimization via Graph Cuts*, IEEE transactions on PAMI, vol. 20, no. 12, p. 1222-1239, 2001. 

2. Vladimir Kolmogorov and Ramin Zabih, *What Energy Functions can be Minimized via Graph Cuts?*, IEEE transactions on PAMI, vol. 26, no. 2, p. 147-159, 2004.

3. Yuri Boykov and Vladimir Kolmogorov, *An Experimental Comparison of Min-Cut/Max-Flow Algorithms for Energy Minimization in Vision*, IEEE transactions on PAMI, vol. 26, no. 9, p. 1124-1137, 2004. 

As noted in the open source implementation of the graph cuts algorithms distributed under the General Public License, "This software can be used only for research purposes, you should cite the aforementioned paper in any resulting publication.  If you wish to use this software (or the algorithms described in the aforementioned paper) for commercial purposes, you should be aware that there is a US patent: R. Zabih, Y. Boykov, O. Veksler, *System and method for fast approximate energy minimization via graph cuts*, United Stated Patent 6,744,923, June 1, 2004.

The example below illustrates applying **-vote-mrf** with a user-specified mask. Voxels outside of the mask are first remapped to NaN (not a number) and thus excluded from the MRF optimization and given 0 label.

    c3d lhood01.nii lhood02.nii lhood03.nii mask.nii -popas M \
        -foreach -push M -replace 0 NaN -times -endfor \
        -vote-mrf VA 0.2 -o result.nii
 *
 * @returns Parameter dictionary
 */
function c4d_vote_mrf_params(
    vote_mrf: string,
): C4dVoteMrfParametersTagged {
    const params = {
        "@type": "vote_mrf" as const,
        "vote_mrf": vote_mrf,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_vote_mrf_cargs(
    params: C4dVoteMrfParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-vote-mrf",
        (params["vote_mrf"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param vote_label No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_vote_label_params(
    vote_label: string,
): C4dVoteLabelParametersTagged {
    const params = {
        "@type": "vote_label" as const,
        "vote_label": vote_label,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_vote_label_cargs(
    params: C4dVoteLabelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-vote-label",
        (params["vote_label"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param voxel_sum -voxel-sum: Print sum of all voxel intensities

Syntax: `-voxel-sum `

Print the sum of all voxels in the image. 

    $ c3d image.img -voxel-sum 
    Voxel Sum: 200923123
 *
 * @returns Parameter dictionary
 */
function c4d_voxel_sum_params(
    voxel_sum: string,
): C4dVoxelSumParametersTagged {
    const params = {
        "@type": "voxel_sum" as const,
        "voxel_sum": voxel_sum,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_voxel_sum_cargs(
    params: C4dVoxelSumParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-voxel-sum",
        (params["voxel_sum"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param voxel_integral -voxel-integral: Print volume integral of all voxel intensities

Syntax: `-voxel-integral`

Like **-voxel-sum**, but multiplies the sum of voxel intensities by voxel volume. This is useful for computing volumes of objects represented by binary images. The result is in 'ml'. 

    $ c3d image.img -voxel-integral 
    Voxel Integral: 2341
 *
 * @returns Parameter dictionary
 */
function c4d_voxel_integral_params(
    voxel_integral: string,
): C4dVoxelIntegralParametersTagged {
    const params = {
        "@type": "voxel_integral" as const,
        "voxel_integral": voxel_integral,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_voxel_integral_cargs(
    params: C4dVoxelIntegralParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-voxel-integral",
        (params["voxel_integral"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param voxelwise_regression -voxreg, -voxelwise-regression: Regression between two images

Syntax: `-voxreg regression_order `

Perform regression between corresponding voxels in two images. This command takes two images as input, X and Y. This command finds parameters b\_0, b\_1, ..., b\_k, such that Y is best approximated by b\_0 + b\_1 * X + b\_2 * X^2 + ... + b_k * X^k. Here is an example of linear regression. 

    $ c3d Y.nii X.nii -voxreg 2 
    REGCOEFF[0] = 5.56935
    REGCOEFF[1] = 0.844024

    $ c3d Y.nii X.nii -scale 0.844024 -shift 5.56935 -voxreg 2
    REGCOEFF[0] = 0
    REGCOEFF[1] = 1
 *
 * @returns Parameter dictionary
 */
function c4d_voxelwise_regression_params(
    voxelwise_regression: string,
): C4dVoxelwiseRegressionParametersTagged {
    const params = {
        "@type": "voxelwise_regression" as const,
        "voxelwise_regression": voxelwise_regression,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_voxelwise_regression_cargs(
    params: C4dVoxelwiseRegressionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-voxelwise-regression",
        (params["voxelwise_regression"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param warp No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_warp_params(
    warp: string,
): C4dWarpParametersTagged {
    const params = {
        "@type": "warp" as const,
        "warp": warp,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_warp_cargs(
    params: C4dWarpParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-warp",
        (params["warp"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param warp_label No description found.
 *
 * @returns Parameter dictionary
 */
function c4d_warp_label_params(
    warp_label: string,
): C4dWarpLabelParametersTagged {
    const params = {
        "@type": "warp_label" as const,
        "warp_label": warp_label,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_warp_label_cargs(
    params: C4dWarpLabelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-warp-label",
        (params["warp_label"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param wrap -wrap: Wrap (rotate) image 

Syntax: `-wrap <vector> `

Wrap image around one or more voxel dimensions. Wrapping is typically used to correct for MRI wrap-around artifacts. The vector must have integer components, possibly negative. For example, 

    c3d badmri.nii.gz -wrap 0x20x0 -o fixedmri.nii.gz

will wrap the image in the second voxel dimension by 20 voxels (i.e., voxel at 10x40x20 will me moved to the position 10x20x20). 


### Commands: Options and Parameters

Options change the behavior of commands that *appear later on the command line*. This is very important. Specifying options after the command will have no effect.
 *
 * @returns Parameter dictionary
 */
function c4d_wrap_params(
    wrap: string,
): C4dWrapParametersTagged {
    const params = {
        "@type": "wrap" as const,
        "wrap": wrap,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_wrap_cargs(
    params: C4dWrapParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-wrap",
        (params["wrap"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param weighted_sum -wsum, -weighted-sum: Weighed sum of images with constant weights

Syntax: `-wsum weight1 weight2 ... weightN `

Computes weighted sum of the last N images on the stack. 

    c3d image1.nii image2.nii image3.nii -wsum 0.2 0.7 0.1 -o wsum.nii

This command is particularly useful for combining components in a multicomponent image. For example, for an RGB image, we can convert it to grayscale (using [ImageMagick][13] formula) as follows: 

    c3d -mcs rgb.nii -wsum 0.29900 0.58700 0.11400 -o gray.nii
 *
 * @returns Parameter dictionary
 */
function c4d_weighted_sum_params(
    weighted_sum: string,
): C4dWeightedSumParametersTagged {
    const params = {
        "@type": "weighted_sum" as const,
        "weighted_sum": weighted_sum,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_weighted_sum_cargs(
    params: C4dWeightedSumParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-weighted-sum",
        (params["weighted_sum"] ?? null)
    );
    return cargs;
}


/**
 * Build parameters.
 *
 * @param weighted_sum_voxelwise -wsv, -weighed-sum-voxelwise: Weighed sum of images with spatially varying weights

Syntax: `-wsv `

Computes weighted sum of N weight images and N scalar images. The images must be interleaved on the stack. All images on the stack are used.

    c3d weight1.nii image1.nii weight2.nii image2.nii weight3.nii image3.nii -wsv -o mysum.nii.gz

The **-reorder** command can simplify loading the images:

    c3d weight*.nii image*.nii -reorder 0.5 -wsv -o mysum.nii.gz

### Commands: Image Header Manipulation
 *
 * @returns Parameter dictionary
 */
function c4d_weighted_sum_voxelwise_params(
    weighted_sum_voxelwise: string,
): C4dWeightedSumVoxelwiseParametersTagged {
    const params = {
        "@type": "weighted_sum_voxelwise" as const,
        "weighted_sum_voxelwise": weighted_sum_voxelwise,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_weighted_sum_voxelwise_cargs(
    params: C4dWeightedSumVoxelwiseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "-weighted-sum-voxelwise",
        (params["weighted_sum_voxelwise"] ?? null)
    );
    return cargs;
}


/**
 * Output object returned when calling `C4dParameters(...)`.
 *
 * @interface
 */
interface C4dOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Outputs from `C4dOutputParameters`.This is a list of outputs with the same length and order as the inputs.
     */
    operations: Array<C4dOutputOutputs>;
}


/**
 * Build parameters.
 *
 * @param input The input image to process.
 * @param operations The operations to perform.
 * @param output The output image.
 *
 * @returns Parameter dictionary
 */
function c4d_params(
    input: Array<InputPathType>,
    operations: Array<C4dAccumParametersTagged | C4dAcosParametersTagged | C4dAddParametersTagged | C4dAlignLandmarksParametersTagged | C4dAnisotropicDiffusionParametersTagged | C4dAntialiasParametersTagged | C4dSetParametersTagged | C4dAsinParametersTagged | C4dAtan2ParametersTagged | C4dBackgroundParametersTagged | C4dN4BiasCorrectionParametersTagged | C4dBinarizeParametersTagged | C4dCannyParametersTagged | C4dCeilParametersTagged | C4dCentroidParametersTagged | C4dCentroidMarkParametersTagged | C4dConnectedComponentsParametersTagged | C4dClearParametersTagged | C4dClipParametersTagged | C4dColorMapParametersTagged | C4dCompressParametersTagged | C4dNoCompressParametersTagged | C4dConvParametersTagged | C4dCoordinateMapVoxelParametersTagged | C4dCoordinateMapPhysicalParametersTagged | C4dCopyTransformParametersTagged | C4dCosParametersTagged | C4dCreateParametersTagged | C4dDicomSeriesListParametersTagged | C4dDicomSeriesReadParametersTagged | C4dDilateParametersTagged | C4dDivideParametersTagged | C4dDuplicateParametersTagged | C4dEndaccumParametersTagged | C4dEndforParametersTagged | C4dErodeParametersTagged | C4dErfParametersTagged | C4dExpParametersTagged | C4dExportPatchesParametersTagged | C4dExportPatchesAugParametersTagged | C4dExtrudeSegParametersTagged | C4dFillBackgroundWithNoiseParametersTagged | C4dFftParametersTagged | C4dFlipParametersTagged | C4dFloorParametersTagged | C4dForeachParametersTagged | C4dForeachCompParametersTagged | C4dGlmParametersTagged | C4dGradientParametersTagged | C4dHelpParametersTagged | C4dHolefillParametersTagged | C4dHessianEigenvaluesParametersTagged | C4dHessianObjectnessParametersTagged | C4dHistogramMatchParametersTagged | C4dInfoParametersTagged | C4dInfoFullParametersTagged | C4dInsertParametersTagged | C4dInterpolationParametersTagged | C4dIterationsParametersTagged | C4dLabelOverlapParametersTagged | C4dLabelStatisticsParametersTagged | C4dLandmarksToSpheresParametersTagged | C4dLaplacianParametersTagged | C4dLevelsetParametersTagged | C4dLevelsetCurvatureParametersTagged | C4dLevelsetAdvectionParametersTagged | C4dLogParametersTagged | C4dLog10ParametersTagged | C4dManualParametersTagged | C4dMatchBoundingBoxParametersTagged | C4dMaximumParametersTagged | C4dMulticomponentSplitParametersTagged | C4dMeanParametersTagged | C4dMedianFilterParametersTagged | C4dMergeParametersTagged | C4dMeanFilterParametersTagged | C4dMutualInfoParametersTagged | C4dMinimumParametersTagged | C4dMixtureModelParametersTagged | C4dMomentsParametersTagged | C4dMattesMutualInfoParametersTagged | C4dMeanSquareParametersTagged | C4dMultiplyParametersTagged | C4dNormalizedCrossCorrelationParametersTagged | C4dNormalizedCorrelationParametersTagged | C4dNormalizedMutualInfoParametersTagged | C4dNoiseGaussianParametersTagged | C4dNoisePoissonParametersTagged | C4dNoiseSpeckleParametersTagged | C4dNoiseSaltPepperParametersTagged | C4dNoMulticomponentSplitParametersTagged | C4dNormalizeLocalWindowParametersTagged | C4dNormpdfParametersTagged | C4dNoroundParametersTagged | C4dNospmParametersTagged | C4dOutputParametersTagged | C4dOutputMulticomponentParametersTagged | C4dOutputMultipleMulticomponentParametersTagged | C4dOrientParametersTagged | C4dOutputMultipleParametersTagged | C4dOrient1ParametersTagged | C4dOriginParametersTagged | C4dOriginVoxelParametersTagged | C4dOriginVoxelCoordParametersTagged | C4dOverlapParametersTagged | C4dOverlayLabelImageParametersTagged | C4dPadParametersTagged | C4dPadToParametersTagged | C4dPcaParametersTagged | C4dPercentIntensityModeParametersTagged | C4dPixelParametersTagged | C4dPopParametersTagged | C4dPopasParametersTagged | C4dProbeParametersTagged | C4dPushParametersTagged | C4dRankParametersTagged | C4dReciprocalParametersTagged | C4dRegionParametersTagged | C4dReorderParametersTagged | C4dRetainLabelsParametersTagged | C4dRfApplyParametersTagged | C4dRfTrainParametersTagged | C4dRfParamPatchParametersTagged | C4dRfParamUsexyzParametersTagged | C4dRfParamNousexyzParametersTagged | C4dRfParamNtreesParametersTagged | C4dRfParamTreedepthParametersTagged | C4dSetSformParametersTagged | C4dReplaceParametersTagged | C4dResampleParametersTagged | C4dResampleIsoParametersTagged | C4dResampleMmParametersTagged | C4dResliceItkParametersTagged | C4dResliceMatrixParametersTagged | C4dResliceIdentityParametersTagged | C4dRgb2hsvParametersTagged | C4dRmsParametersTagged | C4dRoundParametersTagged | C4dScaleParametersTagged | C4dSetSform1ParametersTagged | C4dSinParametersTagged | C4dSliceParametersTagged | C4dSliceAllParametersTagged | C4dSharpenParametersTagged | C4dShiftParametersTagged | C4dSignedDistanceTransformParametersTagged | C4dSmoothParametersTagged | C4dSmoothFastParametersTagged | C4dSpacingParametersTagged | C4dSplitParametersTagged | C4dSqrtParametersTagged | C4dStapleParametersTagged | C4dStructureTensorEigenvaluesParametersTagged | C4dSpmParametersTagged | C4dSubtractParametersTagged | C4dSupervoxelParametersTagged | C4dStretchParametersTagged | C4dSwapdimParametersTagged | C4dTestImageParametersTagged | C4dTestProbeParametersTagged | C4dThresholdParametersTagged | C4dTileParametersTagged | C4dTrimParametersTagged | C4dTrimToSizeParametersTagged | C4dTypeParametersTagged | C4dVerboseParametersTagged | C4dNoverboseParametersTagged | C4dVersionParametersTagged | C4dVoteParametersTagged | C4dVoteMrfParametersTagged | C4dVoteLabelParametersTagged | C4dVoxelSumParametersTagged | C4dVoxelIntegralParametersTagged | C4dVoxelwiseRegressionParametersTagged | C4dWarpParametersTagged | C4dWarpLabelParametersTagged | C4dWrapParametersTagged | C4dWeightedSumParametersTagged | C4dWeightedSumVoxelwiseParametersTagged>,
    output: string,
): C4dParametersTagged {
    const params = {
        "@type": "c3d/c4d" as const,
        "input": input,
        "operations": operations,
        "output": output,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function c4d_cargs(
    params: C4dParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("c4d");
    cargs.push((params["input"] ?? null).map(f => execution.inputFile(f)).join(" "));
    cargs.push(...(params["operations"] ?? null).map(s => c4d_operations_cargs_dyn_fn(s["@type"])(s, execution)).flat());
    cargs.push(
        "-o",
        (params["output"] ?? null)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function c4d_outputs(
    params: C4dParameters,
    execution: Execution,
): C4dOutputs {
    const ret: C4dOutputs = {
        root: execution.outputFile("."),
        operations: (params["operations"] ?? null).map(i => c4d_operations_outputs_dyn_fn(i["@type"])?.(i, execution) ?? null),
    };
    return ret;
}


/**
 * c4d
 *
 * C4D is a command-line tool for medical image processing.
 *
 * Author: Convert3D Developers
 *
 * URL: http://www.itksnap.org/pmwiki/pmwiki.php?n=Convert3D.Convert3D
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `C4dOutputs`).
 */
function c4d_execute(
    params: C4dParameters,
    runner: Runner | null = null,
): C4dOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(C4D_METADATA);
    params = execution.params(params)
    const cargs = c4d_cargs(params, execution)
    const ret = c4d_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * c4d
 *
 * C4D is a command-line tool for medical image processing.
 *
 * Author: Convert3D Developers
 *
 * URL: http://www.itksnap.org/pmwiki/pmwiki.php?n=Convert3D.Convert3D
 *
 * @param input The input image to process.
 * @param operations The operations to perform.
 * @param output The output image.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `C4dOutputs`).
 */
function c4d(
    input: Array<InputPathType>,
    operations: Array<C4dAccumParametersTagged | C4dAcosParametersTagged | C4dAddParametersTagged | C4dAlignLandmarksParametersTagged | C4dAnisotropicDiffusionParametersTagged | C4dAntialiasParametersTagged | C4dSetParametersTagged | C4dAsinParametersTagged | C4dAtan2ParametersTagged | C4dBackgroundParametersTagged | C4dN4BiasCorrectionParametersTagged | C4dBinarizeParametersTagged | C4dCannyParametersTagged | C4dCeilParametersTagged | C4dCentroidParametersTagged | C4dCentroidMarkParametersTagged | C4dConnectedComponentsParametersTagged | C4dClearParametersTagged | C4dClipParametersTagged | C4dColorMapParametersTagged | C4dCompressParametersTagged | C4dNoCompressParametersTagged | C4dConvParametersTagged | C4dCoordinateMapVoxelParametersTagged | C4dCoordinateMapPhysicalParametersTagged | C4dCopyTransformParametersTagged | C4dCosParametersTagged | C4dCreateParametersTagged | C4dDicomSeriesListParametersTagged | C4dDicomSeriesReadParametersTagged | C4dDilateParametersTagged | C4dDivideParametersTagged | C4dDuplicateParametersTagged | C4dEndaccumParametersTagged | C4dEndforParametersTagged | C4dErodeParametersTagged | C4dErfParametersTagged | C4dExpParametersTagged | C4dExportPatchesParametersTagged | C4dExportPatchesAugParametersTagged | C4dExtrudeSegParametersTagged | C4dFillBackgroundWithNoiseParametersTagged | C4dFftParametersTagged | C4dFlipParametersTagged | C4dFloorParametersTagged | C4dForeachParametersTagged | C4dForeachCompParametersTagged | C4dGlmParametersTagged | C4dGradientParametersTagged | C4dHelpParametersTagged | C4dHolefillParametersTagged | C4dHessianEigenvaluesParametersTagged | C4dHessianObjectnessParametersTagged | C4dHistogramMatchParametersTagged | C4dInfoParametersTagged | C4dInfoFullParametersTagged | C4dInsertParametersTagged | C4dInterpolationParametersTagged | C4dIterationsParametersTagged | C4dLabelOverlapParametersTagged | C4dLabelStatisticsParametersTagged | C4dLandmarksToSpheresParametersTagged | C4dLaplacianParametersTagged | C4dLevelsetParametersTagged | C4dLevelsetCurvatureParametersTagged | C4dLevelsetAdvectionParametersTagged | C4dLogParametersTagged | C4dLog10ParametersTagged | C4dManualParametersTagged | C4dMatchBoundingBoxParametersTagged | C4dMaximumParametersTagged | C4dMulticomponentSplitParametersTagged | C4dMeanParametersTagged | C4dMedianFilterParametersTagged | C4dMergeParametersTagged | C4dMeanFilterParametersTagged | C4dMutualInfoParametersTagged | C4dMinimumParametersTagged | C4dMixtureModelParametersTagged | C4dMomentsParametersTagged | C4dMattesMutualInfoParametersTagged | C4dMeanSquareParametersTagged | C4dMultiplyParametersTagged | C4dNormalizedCrossCorrelationParametersTagged | C4dNormalizedCorrelationParametersTagged | C4dNormalizedMutualInfoParametersTagged | C4dNoiseGaussianParametersTagged | C4dNoisePoissonParametersTagged | C4dNoiseSpeckleParametersTagged | C4dNoiseSaltPepperParametersTagged | C4dNoMulticomponentSplitParametersTagged | C4dNormalizeLocalWindowParametersTagged | C4dNormpdfParametersTagged | C4dNoroundParametersTagged | C4dNospmParametersTagged | C4dOutputParametersTagged | C4dOutputMulticomponentParametersTagged | C4dOutputMultipleMulticomponentParametersTagged | C4dOrientParametersTagged | C4dOutputMultipleParametersTagged | C4dOrient1ParametersTagged | C4dOriginParametersTagged | C4dOriginVoxelParametersTagged | C4dOriginVoxelCoordParametersTagged | C4dOverlapParametersTagged | C4dOverlayLabelImageParametersTagged | C4dPadParametersTagged | C4dPadToParametersTagged | C4dPcaParametersTagged | C4dPercentIntensityModeParametersTagged | C4dPixelParametersTagged | C4dPopParametersTagged | C4dPopasParametersTagged | C4dProbeParametersTagged | C4dPushParametersTagged | C4dRankParametersTagged | C4dReciprocalParametersTagged | C4dRegionParametersTagged | C4dReorderParametersTagged | C4dRetainLabelsParametersTagged | C4dRfApplyParametersTagged | C4dRfTrainParametersTagged | C4dRfParamPatchParametersTagged | C4dRfParamUsexyzParametersTagged | C4dRfParamNousexyzParametersTagged | C4dRfParamNtreesParametersTagged | C4dRfParamTreedepthParametersTagged | C4dSetSformParametersTagged | C4dReplaceParametersTagged | C4dResampleParametersTagged | C4dResampleIsoParametersTagged | C4dResampleMmParametersTagged | C4dResliceItkParametersTagged | C4dResliceMatrixParametersTagged | C4dResliceIdentityParametersTagged | C4dRgb2hsvParametersTagged | C4dRmsParametersTagged | C4dRoundParametersTagged | C4dScaleParametersTagged | C4dSetSform1ParametersTagged | C4dSinParametersTagged | C4dSliceParametersTagged | C4dSliceAllParametersTagged | C4dSharpenParametersTagged | C4dShiftParametersTagged | C4dSignedDistanceTransformParametersTagged | C4dSmoothParametersTagged | C4dSmoothFastParametersTagged | C4dSpacingParametersTagged | C4dSplitParametersTagged | C4dSqrtParametersTagged | C4dStapleParametersTagged | C4dStructureTensorEigenvaluesParametersTagged | C4dSpmParametersTagged | C4dSubtractParametersTagged | C4dSupervoxelParametersTagged | C4dStretchParametersTagged | C4dSwapdimParametersTagged | C4dTestImageParametersTagged | C4dTestProbeParametersTagged | C4dThresholdParametersTagged | C4dTileParametersTagged | C4dTrimParametersTagged | C4dTrimToSizeParametersTagged | C4dTypeParametersTagged | C4dVerboseParametersTagged | C4dNoverboseParametersTagged | C4dVersionParametersTagged | C4dVoteParametersTagged | C4dVoteMrfParametersTagged | C4dVoteLabelParametersTagged | C4dVoxelSumParametersTagged | C4dVoxelIntegralParametersTagged | C4dVoxelwiseRegressionParametersTagged | C4dWarpParametersTagged | C4dWarpLabelParametersTagged | C4dWrapParametersTagged | C4dWeightedSumParametersTagged | C4dWeightedSumVoxelwiseParametersTagged>,
    output: string,
    runner: Runner | null = null,
): C4dOutputs {
    const params = c4d_params(input, operations, output)
    return c4d_execute(params, runner);
}


export {
      C4D_METADATA,
      C4dOutputOutputs,
      C4dOutputs,
      c4d,
      c4d__help_params,
      c4d_accum_params,
      c4d_acos_params,
      c4d_add_params,
      c4d_align_landmarks_params,
      c4d_anisotropic_diffusion_params,
      c4d_antialias_params,
      c4d_asin_params,
      c4d_atan2_params,
      c4d_background_params,
      c4d_binarize_params,
      c4d_canny_params,
      c4d_ceil_params,
      c4d_centroid_mark_params,
      c4d_centroid_params,
      c4d_clear_params,
      c4d_clip_params,
      c4d_color_map_params,
      c4d_compress_params,
      c4d_connected_components_params,
      c4d_conv_params,
      c4d_coordinate_map_physical_params,
      c4d_coordinate_map_voxel_params,
      c4d_copy_transform_params,
      c4d_cos_params,
      c4d_create_params,
      c4d_dicom_series_list_params,
      c4d_dicom_series_read_params,
      c4d_dilate_params,
      c4d_divide_params,
      c4d_duplicate_params,
      c4d_endaccum_params,
      c4d_endfor_params,
      c4d_erf_params,
      c4d_erode_params,
      c4d_execute,
      c4d_exp_params,
      c4d_export_patches_aug_params,
      c4d_export_patches_params,
      c4d_extrude_seg_params,
      c4d_fft_params,
      c4d_fill_background_with_noise_params,
      c4d_flip_params,
      c4d_floor_params,
      c4d_foreach_comp_params,
      c4d_foreach_params,
      c4d_glm_params,
      c4d_gradient_params,
      c4d_hessian_eigenvalues_params,
      c4d_hessian_objectness_params,
      c4d_histogram_match_params,
      c4d_holefill_params,
      c4d_info_full_params,
      c4d_info_params,
      c4d_insert_params,
      c4d_interpolation_params,
      c4d_iterations_params,
      c4d_label_overlap_params,
      c4d_label_statistics_params,
      c4d_landmarks_to_spheres_params,
      c4d_laplacian_params,
      c4d_levelset_advection_params,
      c4d_levelset_curvature_params,
      c4d_levelset_params,
      c4d_log10_params,
      c4d_log_params,
      c4d_manual_params,
      c4d_match_bounding_box_params,
      c4d_mattes_mutual_info_params,
      c4d_maximum_params,
      c4d_mean_filter_params,
      c4d_mean_params,
      c4d_mean_square_params,
      c4d_median_filter_params,
      c4d_merge_params,
      c4d_minimum_params,
      c4d_mixture_model_params,
      c4d_moments_params,
      c4d_multicomponent_split_params,
      c4d_multiply_params,
      c4d_mutual_info_params,
      c4d_n4_bias_correction_params,
      c4d_no_compress_params,
      c4d_no_multicomponent_split_params,
      c4d_noise_gaussian_params,
      c4d_noise_poisson_params,
      c4d_noise_salt_pepper_params,
      c4d_noise_speckle_params,
      c4d_normalize_local_window_params,
      c4d_normalized_correlation_params,
      c4d_normalized_cross_correlation_params,
      c4d_normalized_mutual_info_params,
      c4d_normpdf_params,
      c4d_noround_params,
      c4d_nospm_params,
      c4d_noverbose_params,
      c4d_orient_1_params,
      c4d_orient_params,
      c4d_origin_params,
      c4d_origin_voxel_coord_params,
      c4d_origin_voxel_params,
      c4d_output_multicomponent_params,
      c4d_output_multiple_multicomponent_params,
      c4d_output_multiple_params,
      c4d_output_params,
      c4d_overlap_params,
      c4d_overlay_label_image_params,
      c4d_pad_params,
      c4d_pad_to_params,
      c4d_params,
      c4d_pca_params,
      c4d_percent_intensity_mode_params,
      c4d_pixel_params,
      c4d_pop_params,
      c4d_popas_params,
      c4d_probe_params,
      c4d_push_params,
      c4d_rank_params,
      c4d_reciprocal_params,
      c4d_region_params,
      c4d_reorder_params,
      c4d_replace_params,
      c4d_resample_iso_params,
      c4d_resample_mm_params,
      c4d_resample_params,
      c4d_reslice_identity_params,
      c4d_reslice_itk_params,
      c4d_reslice_matrix_params,
      c4d_retain_labels_params,
      c4d_rf_apply_params,
      c4d_rf_param_nousexyz_params,
      c4d_rf_param_ntrees_params,
      c4d_rf_param_patch_params,
      c4d_rf_param_treedepth_params,
      c4d_rf_param_usexyz_params,
      c4d_rf_train_params,
      c4d_rgb2hsv_params,
      c4d_rms_params,
      c4d_round_params,
      c4d_scale_params,
      c4d_set_params,
      c4d_set_sform_1_params,
      c4d_set_sform_params,
      c4d_sharpen_params,
      c4d_shift_params,
      c4d_signed_distance_transform_params,
      c4d_sin_params,
      c4d_slice_all_params,
      c4d_slice_params,
      c4d_smooth_fast_params,
      c4d_smooth_params,
      c4d_spacing_params,
      c4d_split_params,
      c4d_spm_params,
      c4d_sqrt_params,
      c4d_staple_params,
      c4d_stretch_params,
      c4d_structure_tensor_eigenvalues_params,
      c4d_subtract_params,
      c4d_supervoxel_params,
      c4d_swapdim_params,
      c4d_test_image_params,
      c4d_test_probe_params,
      c4d_threshold_params,
      c4d_tile_params,
      c4d_trim_params,
      c4d_trim_to_size_params,
      c4d_type_params,
      c4d_verbose_params,
      c4d_version_params,
      c4d_vote_label_params,
      c4d_vote_mrf_params,
      c4d_vote_params,
      c4d_voxel_integral_params,
      c4d_voxel_sum_params,
      c4d_voxelwise_regression_params,
      c4d_warp_label_params,
      c4d_warp_params,
      c4d_weighted_sum_params,
      c4d_weighted_sum_voxelwise_params,
      c4d_wrap_params,
};
