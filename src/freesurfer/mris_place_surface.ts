// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRIS_PLACE_SURFACE_METADATA: Metadata = {
    id: "9915e5e7512dc33a00f5de655e43428dcd06c0f1.boutiques",
    name: "mris_place_surface",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface MrisPlaceSurfaceParameters {
    "@type": "freesurfer.mris_place_surface";
    "output_surface": string;
    "input_surface": string;
    "autodetect_gray_white_stats": string;
    "input_volume": string;
    "surface_type_group": "--white" | "--pial";
    "hemi_group": "--lh" | "--rh";
    "wm_segment"?: string | null | undefined;
    "out_volume"?: string | null | undefined;
    "out_volume_only"?: string | null | undefined;
    "restore_255": boolean;
    "segmentation"?: string | null | undefined;
    "cortical_parcellation"?: string | null | undefined;
    "nsmooth"?: number | null | undefined;
    "smooth_after_rip": boolean;
    "max_cbv_dist"?: number | null | undefined;
    "rip_label"?: string | null | undefined;
    "rip_midline": boolean;
    "rip_bg": boolean;
    "rip_bg_no_annot": boolean;
    "no_rip_freeze": boolean;
    "rip_wmsa": boolean;
    "rip_lesion": boolean;
    "no_rip": boolean;
    "rip_overlay"?: string | null | undefined;
    "rip_surface"?: string | null | undefined;
    "rip_projection"?: Array<number> | null | undefined;
    "repulse_surface"?: string | null | undefined;
    "white_surface"?: string | null | undefined;
    "blend_surface"?: string | null | undefined;
    "multimodal_input"?: string | null | undefined;
    "mm_refine": boolean;
    "pin_medial_wall"?: string | null | undefined;
    "no_intensity_proc": boolean;
    "debug_vertex"?: number | null | undefined;
    "ripflag_out"?: string | null | undefined;
    "local_max"?: string | null | undefined;
    "target_surf"?: string | null | undefined;
    "stop_mask": boolean;
    "mm_intensity_limits"?: string | null | undefined;
    "cover_seg"?: string | null | undefined;
    "first_peak_d1": boolean;
    "first_peak_d2": boolean;
    "white_border_low_factor"?: number | null | undefined;
    "fill_lateral_ventricles"?: Array<number> | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "freesurfer.mris_place_surface": mris_place_surface_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `mris_place_surface(...)`.
 *
 * @interface
 */
interface MrisPlaceSurfaceOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param output_surface Output surface
 * @param input_surface Input surface
 * @param autodetect_gray_white_stats Intensity stats created by mris_autodet_gwstats
 * @param input_volume T1-weighed intensity volume used to find white/gray/csf gradients (usually brain.finalsurf.mgz)
 * @param surface_type_group Place the white surface or the pial surface. Must choose one.
 * @param hemi_group Left or right hemisphere. Must choose one.
 * @param wm_segment White matter segmentation
 * @param out_volume Save input volume after preprocessing
 * @param out_volume_only Save input volume after preprocessing and then exit
 * @param restore_255 Set voxels in the input volume that start off as 255 to 110 (white surf only).
 * @param segmentation Whole-brain segmentation (usually aseg.presurf.mgz)
 * @param cortical_parcellation Set cortical parcellation used to rip vertices (usually ?h.aparc.annot)
 * @param nsmooth Smooth input surface by number of iterations
 * @param smooth_after_rip Smooth after ripping
 * @param max_cbv_dist Limit distance MRIScomputeBorderValues() can search from the input
 * @param rip_label Do not move vertices that are NOT in the cortex label
 * @param rip_midline Do not move vertices that are in the midline as indicated by the seg
 * @param rip_bg Do not move vertices near basal ganglia (as defined by seg)
 * @param rip_bg_no_annot Do not require surface have an annotation when ripping BG
 * @param no_rip_freeze Do NOT move vertices in/near freeze voxels (247 as defined in seg)
 * @param rip_wmsa Do not move vertices in/near white-matter signal abnormalities (77,78,79 as defined in seg)
 * @param rip_lesion Do not move vertices in/near lesions (25 and 57 as defined in seg)
 * @param no_rip Turn off all ripping
 * @param rip_overlay Rip vertices > 0.5 in the surface overlay file
 * @param rip_surface Use this surface with ripping midline, BG, Freezes, Lesions, and WMSA.
 * @param rip_projection Control projection depth along normal to ripsurface when sampling seg
 * @param repulse_surface Force input surface away from this surface (usually the white surface when placing the pial).
 * @param white_surface Set the white{xyz} coordinates of the input surface using this surface.
 * @param blend_surface Recompute the xyz coordinates of the input surface by computing a weighted average with the blend surface.
 * @param multimodal_input Specify a T2 or FLAIR input volume used for placing the pial surface. Must be in registration with the input volume.
 * @param mm_refine Use Siless' MultimodalRefinement. Sets tspring=nspring=0.3
 * @param pin_medial_wall Set coordinates in vertices NOT in cortexlabel to be that of the white{xyz} coordinates.
 * @param no_intensity_proc Do not process the input intensity volume (eg, to remove parts of eye socket).
 * @param debug_vertex Debug vertex number
 * @param ripflag_out Save ripflag as overlay
 * @param local_max Save LocalMaxFoundFlag as overlay
 * @param target_surf Save CBV target surface
 * @param stop_mask Stop mask to stop search along normal for max gradient
 * @param mm_intensity_limits Intensity limits for placing pial on multimodal input.
 * @param cover_seg Force surface to cover the segmentation
 * @param first_peak_d1 Use find-first-peak option with 1st derivative in ComputeBorderValues
 * @param first_peak_d2 Use find-first-peak option with 2nd derivative in ComputeBorderValues
 * @param white_border_low_factor white_border_low = f*adgws.gray_mean + (1-f)*adgws.white_mean;
 * @param fill_lateral_ventricles Fill lateral ventricles with 110.
 *
 * @returns Parameter dictionary
 */
function mris_place_surface_params(
    output_surface: string,
    input_surface: string,
    autodetect_gray_white_stats: string,
    input_volume: string,
    surface_type_group: "--white" | "--pial",
    hemi_group: "--lh" | "--rh",
    wm_segment: string | null = null,
    out_volume: string | null = null,
    out_volume_only: string | null = null,
    restore_255: boolean = false,
    segmentation: string | null = null,
    cortical_parcellation: string | null = null,
    nsmooth: number | null = null,
    smooth_after_rip: boolean = false,
    max_cbv_dist: number | null = null,
    rip_label: string | null = null,
    rip_midline: boolean = false,
    rip_bg: boolean = false,
    rip_bg_no_annot: boolean = false,
    no_rip_freeze: boolean = false,
    rip_wmsa: boolean = false,
    rip_lesion: boolean = false,
    no_rip: boolean = false,
    rip_overlay: string | null = null,
    rip_surface: string | null = null,
    rip_projection: Array<number> | null = null,
    repulse_surface: string | null = null,
    white_surface: string | null = null,
    blend_surface: string | null = null,
    multimodal_input: string | null = null,
    mm_refine: boolean = false,
    pin_medial_wall: string | null = null,
    no_intensity_proc: boolean = false,
    debug_vertex: number | null = null,
    ripflag_out: string | null = null,
    local_max: string | null = null,
    target_surf: string | null = null,
    stop_mask: boolean = false,
    mm_intensity_limits: string | null = null,
    cover_seg: string | null = null,
    first_peak_d1: boolean = false,
    first_peak_d2: boolean = false,
    white_border_low_factor: number | null = null,
    fill_lateral_ventricles: Array<number> | null = null,
): MrisPlaceSurfaceParameters {
    const params = {
        "@type": "freesurfer.mris_place_surface" as const,
        "output_surface": output_surface,
        "input_surface": input_surface,
        "autodetect_gray_white_stats": autodetect_gray_white_stats,
        "input_volume": input_volume,
        "surface_type_group": surface_type_group,
        "hemi_group": hemi_group,
        "restore_255": restore_255,
        "smooth_after_rip": smooth_after_rip,
        "rip_midline": rip_midline,
        "rip_bg": rip_bg,
        "rip_bg_no_annot": rip_bg_no_annot,
        "no_rip_freeze": no_rip_freeze,
        "rip_wmsa": rip_wmsa,
        "rip_lesion": rip_lesion,
        "no_rip": no_rip,
        "mm_refine": mm_refine,
        "no_intensity_proc": no_intensity_proc,
        "stop_mask": stop_mask,
        "first_peak_d1": first_peak_d1,
        "first_peak_d2": first_peak_d2,
    };
    if (wm_segment !== null) {
        params["wm_segment"] = wm_segment;
    }
    if (out_volume !== null) {
        params["out_volume"] = out_volume;
    }
    if (out_volume_only !== null) {
        params["out_volume_only"] = out_volume_only;
    }
    if (segmentation !== null) {
        params["segmentation"] = segmentation;
    }
    if (cortical_parcellation !== null) {
        params["cortical_parcellation"] = cortical_parcellation;
    }
    if (nsmooth !== null) {
        params["nsmooth"] = nsmooth;
    }
    if (max_cbv_dist !== null) {
        params["max_cbv_dist"] = max_cbv_dist;
    }
    if (rip_label !== null) {
        params["rip_label"] = rip_label;
    }
    if (rip_overlay !== null) {
        params["rip_overlay"] = rip_overlay;
    }
    if (rip_surface !== null) {
        params["rip_surface"] = rip_surface;
    }
    if (rip_projection !== null) {
        params["rip_projection"] = rip_projection;
    }
    if (repulse_surface !== null) {
        params["repulse_surface"] = repulse_surface;
    }
    if (white_surface !== null) {
        params["white_surface"] = white_surface;
    }
    if (blend_surface !== null) {
        params["blend_surface"] = blend_surface;
    }
    if (multimodal_input !== null) {
        params["multimodal_input"] = multimodal_input;
    }
    if (pin_medial_wall !== null) {
        params["pin_medial_wall"] = pin_medial_wall;
    }
    if (debug_vertex !== null) {
        params["debug_vertex"] = debug_vertex;
    }
    if (ripflag_out !== null) {
        params["ripflag_out"] = ripflag_out;
    }
    if (local_max !== null) {
        params["local_max"] = local_max;
    }
    if (target_surf !== null) {
        params["target_surf"] = target_surf;
    }
    if (mm_intensity_limits !== null) {
        params["mm_intensity_limits"] = mm_intensity_limits;
    }
    if (cover_seg !== null) {
        params["cover_seg"] = cover_seg;
    }
    if (white_border_low_factor !== null) {
        params["white_border_low_factor"] = white_border_low_factor;
    }
    if (fill_lateral_ventricles !== null) {
        params["fill_lateral_ventricles"] = fill_lateral_ventricles;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mris_place_surface_cargs(
    params: MrisPlaceSurfaceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mris_place_surface");
    cargs.push(
        "--o",
        (params["output_surface"] ?? null)
    );
    cargs.push(
        "--i",
        (params["input_surface"] ?? null)
    );
    cargs.push(
        "--adgw",
        (params["autodetect_gray_white_stats"] ?? null)
    );
    cargs.push(
        "--invol",
        (params["input_volume"] ?? null)
    );
    cargs.push((params["surface_type_group"] ?? null));
    cargs.push((params["hemi_group"] ?? null));
    if ((params["wm_segment"] ?? null) !== null) {
        cargs.push(
            "--wm",
            (params["wm_segment"] ?? null)
        );
    }
    if ((params["out_volume"] ?? null) !== null) {
        cargs.push(
            "--outvol",
            (params["out_volume"] ?? null)
        );
    }
    if ((params["out_volume_only"] ?? null) !== null) {
        cargs.push(
            "--outvol-only",
            (params["out_volume_only"] ?? null)
        );
    }
    if ((params["restore_255"] ?? null)) {
        cargs.push("--restore-255");
    }
    if ((params["segmentation"] ?? null) !== null) {
        cargs.push(
            "--seg",
            (params["segmentation"] ?? null)
        );
    }
    if ((params["cortical_parcellation"] ?? null) !== null) {
        cargs.push(
            "--aparc",
            (params["cortical_parcellation"] ?? null)
        );
    }
    if ((params["nsmooth"] ?? null) !== null) {
        cargs.push(
            "--nsmooth",
            String((params["nsmooth"] ?? null))
        );
    }
    if ((params["smooth_after_rip"] ?? null)) {
        cargs.push("--smooth-after-rip");
    }
    if ((params["max_cbv_dist"] ?? null) !== null) {
        cargs.push(
            "--max-cbv-dist",
            String((params["max_cbv_dist"] ?? null))
        );
    }
    if ((params["rip_label"] ?? null) !== null) {
        cargs.push(
            "--rip-label",
            (params["rip_label"] ?? null)
        );
    }
    if ((params["rip_midline"] ?? null)) {
        cargs.push("--rip-midline");
    }
    if ((params["rip_bg"] ?? null)) {
        cargs.push("--rip-bg");
    }
    if ((params["rip_bg_no_annot"] ?? null)) {
        cargs.push("--rip-bg-no-annot");
    }
    if ((params["no_rip_freeze"] ?? null)) {
        cargs.push("--no-rip-freeze");
    }
    if ((params["rip_wmsa"] ?? null)) {
        cargs.push("--rip-wmsa");
    }
    if ((params["rip_lesion"] ?? null)) {
        cargs.push("--rip-lesion");
    }
    if ((params["no_rip"] ?? null)) {
        cargs.push("--no-rip");
    }
    if ((params["rip_overlay"] ?? null) !== null) {
        cargs.push(
            "--rip-overlay",
            (params["rip_overlay"] ?? null)
        );
    }
    if ((params["rip_surface"] ?? null) !== null) {
        cargs.push(
            "--ripsurface",
            (params["rip_surface"] ?? null)
        );
    }
    if ((params["rip_projection"] ?? null) !== null) {
        cargs.push(
            "--rip-projection",
            ...(params["rip_projection"] ?? null).map(String)
        );
    }
    if ((params["repulse_surface"] ?? null) !== null) {
        cargs.push(
            "--repulse-surf",
            (params["repulse_surface"] ?? null)
        );
    }
    if ((params["white_surface"] ?? null) !== null) {
        cargs.push(
            "--white-surf",
            (params["white_surface"] ?? null)
        );
    }
    if ((params["blend_surface"] ?? null) !== null) {
        cargs.push(
            "--blend-surf",
            (params["blend_surface"] ?? null)
        );
    }
    if ((params["multimodal_input"] ?? null) !== null) {
        cargs.push(
            "--mmvol",
            (params["multimodal_input"] ?? null)
        );
    }
    if ((params["mm_refine"] ?? null)) {
        cargs.push("--mm-refine");
    }
    if ((params["pin_medial_wall"] ?? null) !== null) {
        cargs.push(
            "--pin-medial-wall",
            (params["pin_medial_wall"] ?? null)
        );
    }
    if ((params["no_intensity_proc"] ?? null)) {
        cargs.push("--no-intensity-proc");
    }
    if ((params["debug_vertex"] ?? null) !== null) {
        cargs.push(
            "--debug-vertex",
            String((params["debug_vertex"] ?? null))
        );
    }
    if ((params["ripflag_out"] ?? null) !== null) {
        cargs.push(
            "--ripflag-out",
            (params["ripflag_out"] ?? null)
        );
    }
    if ((params["local_max"] ?? null) !== null) {
        cargs.push(
            "--local-max",
            (params["local_max"] ?? null)
        );
    }
    if ((params["target_surf"] ?? null) !== null) {
        cargs.push(
            "--target",
            (params["target_surf"] ?? null)
        );
    }
    if ((params["stop_mask"] ?? null)) {
        cargs.push("--stop");
    }
    if ((params["mm_intensity_limits"] ?? null) !== null) {
        cargs.push(
            "--mm_{min,max}_{inside,outside}",
            (params["mm_intensity_limits"] ?? null)
        );
    }
    if ((params["cover_seg"] ?? null) !== null) {
        cargs.push(
            "--cover-seg",
            (params["cover_seg"] ?? null)
        );
    }
    if ((params["first_peak_d1"] ?? null)) {
        cargs.push("--first-peak-d1");
    }
    if ((params["first_peak_d2"] ?? null)) {
        cargs.push("--first-peak-d2");
    }
    if ((params["white_border_low_factor"] ?? null) !== null) {
        cargs.push(
            "--white_border_low_factor",
            String((params["white_border_low_factor"] ?? null))
        );
    }
    if ((params["fill_lateral_ventricles"] ?? null) !== null) {
        cargs.push(
            "--fill-lat-vents",
            ...(params["fill_lateral_ventricles"] ?? null).map(String)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mris_place_surface_outputs(
    params: MrisPlaceSurfaceParameters,
    execution: Execution,
): MrisPlaceSurfaceOutputs {
    const ret: MrisPlaceSurfaceOutputs = {
        root: execution.outputFile("."),
    };
    return ret;
}


/**
 * This program positions the triangular mesh representing a cortical surface, either the 'white' surface (ie, white/gray boundary) or the 'pial' surface (ie, the gray/csf boundary).
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrisPlaceSurfaceOutputs`).
 */
function mris_place_surface_execute(
    params: MrisPlaceSurfaceParameters,
    runner: Runner | null = null,
): MrisPlaceSurfaceOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRIS_PLACE_SURFACE_METADATA);
    params = execution.params(params)
    const cargs = mris_place_surface_cargs(params, execution)
    const ret = mris_place_surface_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * This program positions the triangular mesh representing a cortical surface, either the 'white' surface (ie, white/gray boundary) or the 'pial' surface (ie, the gray/csf boundary).
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param output_surface Output surface
 * @param input_surface Input surface
 * @param autodetect_gray_white_stats Intensity stats created by mris_autodet_gwstats
 * @param input_volume T1-weighed intensity volume used to find white/gray/csf gradients (usually brain.finalsurf.mgz)
 * @param surface_type_group Place the white surface or the pial surface. Must choose one.
 * @param hemi_group Left or right hemisphere. Must choose one.
 * @param wm_segment White matter segmentation
 * @param out_volume Save input volume after preprocessing
 * @param out_volume_only Save input volume after preprocessing and then exit
 * @param restore_255 Set voxels in the input volume that start off as 255 to 110 (white surf only).
 * @param segmentation Whole-brain segmentation (usually aseg.presurf.mgz)
 * @param cortical_parcellation Set cortical parcellation used to rip vertices (usually ?h.aparc.annot)
 * @param nsmooth Smooth input surface by number of iterations
 * @param smooth_after_rip Smooth after ripping
 * @param max_cbv_dist Limit distance MRIScomputeBorderValues() can search from the input
 * @param rip_label Do not move vertices that are NOT in the cortex label
 * @param rip_midline Do not move vertices that are in the midline as indicated by the seg
 * @param rip_bg Do not move vertices near basal ganglia (as defined by seg)
 * @param rip_bg_no_annot Do not require surface have an annotation when ripping BG
 * @param no_rip_freeze Do NOT move vertices in/near freeze voxels (247 as defined in seg)
 * @param rip_wmsa Do not move vertices in/near white-matter signal abnormalities (77,78,79 as defined in seg)
 * @param rip_lesion Do not move vertices in/near lesions (25 and 57 as defined in seg)
 * @param no_rip Turn off all ripping
 * @param rip_overlay Rip vertices > 0.5 in the surface overlay file
 * @param rip_surface Use this surface with ripping midline, BG, Freezes, Lesions, and WMSA.
 * @param rip_projection Control projection depth along normal to ripsurface when sampling seg
 * @param repulse_surface Force input surface away from this surface (usually the white surface when placing the pial).
 * @param white_surface Set the white{xyz} coordinates of the input surface using this surface.
 * @param blend_surface Recompute the xyz coordinates of the input surface by computing a weighted average with the blend surface.
 * @param multimodal_input Specify a T2 or FLAIR input volume used for placing the pial surface. Must be in registration with the input volume.
 * @param mm_refine Use Siless' MultimodalRefinement. Sets tspring=nspring=0.3
 * @param pin_medial_wall Set coordinates in vertices NOT in cortexlabel to be that of the white{xyz} coordinates.
 * @param no_intensity_proc Do not process the input intensity volume (eg, to remove parts of eye socket).
 * @param debug_vertex Debug vertex number
 * @param ripflag_out Save ripflag as overlay
 * @param local_max Save LocalMaxFoundFlag as overlay
 * @param target_surf Save CBV target surface
 * @param stop_mask Stop mask to stop search along normal for max gradient
 * @param mm_intensity_limits Intensity limits for placing pial on multimodal input.
 * @param cover_seg Force surface to cover the segmentation
 * @param first_peak_d1 Use find-first-peak option with 1st derivative in ComputeBorderValues
 * @param first_peak_d2 Use find-first-peak option with 2nd derivative in ComputeBorderValues
 * @param white_border_low_factor white_border_low = f*adgws.gray_mean + (1-f)*adgws.white_mean;
 * @param fill_lateral_ventricles Fill lateral ventricles with 110.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrisPlaceSurfaceOutputs`).
 */
function mris_place_surface(
    output_surface: string,
    input_surface: string,
    autodetect_gray_white_stats: string,
    input_volume: string,
    surface_type_group: "--white" | "--pial",
    hemi_group: "--lh" | "--rh",
    wm_segment: string | null = null,
    out_volume: string | null = null,
    out_volume_only: string | null = null,
    restore_255: boolean = false,
    segmentation: string | null = null,
    cortical_parcellation: string | null = null,
    nsmooth: number | null = null,
    smooth_after_rip: boolean = false,
    max_cbv_dist: number | null = null,
    rip_label: string | null = null,
    rip_midline: boolean = false,
    rip_bg: boolean = false,
    rip_bg_no_annot: boolean = false,
    no_rip_freeze: boolean = false,
    rip_wmsa: boolean = false,
    rip_lesion: boolean = false,
    no_rip: boolean = false,
    rip_overlay: string | null = null,
    rip_surface: string | null = null,
    rip_projection: Array<number> | null = null,
    repulse_surface: string | null = null,
    white_surface: string | null = null,
    blend_surface: string | null = null,
    multimodal_input: string | null = null,
    mm_refine: boolean = false,
    pin_medial_wall: string | null = null,
    no_intensity_proc: boolean = false,
    debug_vertex: number | null = null,
    ripflag_out: string | null = null,
    local_max: string | null = null,
    target_surf: string | null = null,
    stop_mask: boolean = false,
    mm_intensity_limits: string | null = null,
    cover_seg: string | null = null,
    first_peak_d1: boolean = false,
    first_peak_d2: boolean = false,
    white_border_low_factor: number | null = null,
    fill_lateral_ventricles: Array<number> | null = null,
    runner: Runner | null = null,
): MrisPlaceSurfaceOutputs {
    const params = mris_place_surface_params(output_surface, input_surface, autodetect_gray_white_stats, input_volume, surface_type_group, hemi_group, wm_segment, out_volume, out_volume_only, restore_255, segmentation, cortical_parcellation, nsmooth, smooth_after_rip, max_cbv_dist, rip_label, rip_midline, rip_bg, rip_bg_no_annot, no_rip_freeze, rip_wmsa, rip_lesion, no_rip, rip_overlay, rip_surface, rip_projection, repulse_surface, white_surface, blend_surface, multimodal_input, mm_refine, pin_medial_wall, no_intensity_proc, debug_vertex, ripflag_out, local_max, target_surf, stop_mask, mm_intensity_limits, cover_seg, first_peak_d1, first_peak_d2, white_border_low_factor, fill_lateral_ventricles)
    return mris_place_surface_execute(params, runner);
}


export {
      MRIS_PLACE_SURFACE_METADATA,
      MrisPlaceSurfaceOutputs,
      MrisPlaceSurfaceParameters,
      mris_place_surface,
      mris_place_surface_execute,
      mris_place_surface_params,
};
