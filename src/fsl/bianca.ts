// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const BIANCA_METADATA: Metadata = {
    id: "4427f0db0149582120e673ba7b3a83cb0d2f156f.boutiques",
    name: "bianca",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface BiancaParameters {
    "@type"?: "fsl/bianca";
    "master_file": InputPathType;
    "label_feature_num": number;
    "brain_mask_feature_num": number;
    "query_subject_num": number;
    "training_nums"?: string | null | undefined;
    "feature_subset"?: string | null | undefined;
    "mat_feature_num"?: number | null | undefined;
    "spatial_weight"?: number | null | undefined;
    "patch_sizes"?: string | null | undefined;
    "patch_3d": boolean;
    "select_pts"?: string | null | undefined;
    "training_pts"?: string | null | undefined;
    "non_les_pts"?: string | null | undefined;
    "load_classifier_data"?: string | null | undefined;
    "save_classifier_data"?: string | null | undefined;
    "verbose_flag": boolean;
    "out_name"?: string | null | undefined;
}
type BiancaParametersTagged = Required<Pick<BiancaParameters, '@type'>> & BiancaParameters;


/**
 * Output object returned when calling `BiancaParameters(...)`.
 *
 * @interface
 */
interface BiancaOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Base output file generated by BIANCA
     */
    base_output: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param master_file Name of the master file
 * @param label_feature_num Column number (in the master file) of the manual masks (or any placeholder name for query subjects)
 * @param brain_mask_feature_num Column number (in the master file) of images to derive non-zero mask from
 * @param query_subject_num Row number of query subject (in masterlistfile)
 * @param training_nums Subjects to be used in training. List of row numbers (comma separated, no spaces) or 'all' to use all the subjects in the master file
 * @param feature_subset Set of column numbers (comma separated and no spaces) for features/images to use (default: use all available modalities as intensity features). The image used to derive non-zero mask from must be part of the features subset
 * @param mat_feature_num Column number of matrix files (in masterlistfile). Needed to extract spatial features (MNI coordinates)
 * @param spatial_weight Weighting for spatial coordinates (default = 1, i.e., variance-normalized MNI coordinates). Requires --matfeaturenum to be specified
 * @param patch_sizes List of patch sizes for local averaging
 * @param patch_3d Use 3D patches (default is 2D)
 * @param select_pts "any" (default) or "surround" or "noborder"
 * @param training_pts Number (max) of (lesion) points to use (per training subject) or "equalpoints" to select all lesion points and equal number of non-lesion points
 * @param non_les_pts Number (max) of non-lesion points to use. If not specified will be set to the same amount of lesion points
 * @param load_classifier_data Load training data from file
 * @param save_classifier_data Save training data to file
 * @param verbose_flag Use verbose mode
 * @param out_name Specify (base) output name of files
 *
 * @returns Parameter dictionary
 */
function bianca_params(
    master_file: InputPathType,
    label_feature_num: number,
    brain_mask_feature_num: number,
    query_subject_num: number,
    training_nums: string | null = null,
    feature_subset: string | null = null,
    mat_feature_num: number | null = null,
    spatial_weight: number | null = null,
    patch_sizes: string | null = null,
    patch_3d: boolean = false,
    select_pts: string | null = null,
    training_pts: string | null = null,
    non_les_pts: string | null = null,
    load_classifier_data: string | null = null,
    save_classifier_data: string | null = null,
    verbose_flag: boolean = false,
    out_name: string | null = null,
): BiancaParametersTagged {
    const params = {
        "@type": "fsl/bianca" as const,
        "master_file": master_file,
        "label_feature_num": label_feature_num,
        "brain_mask_feature_num": brain_mask_feature_num,
        "query_subject_num": query_subject_num,
        "patch_3d": patch_3d,
        "verbose_flag": verbose_flag,
    };
    if (training_nums !== null) {
        params["training_nums"] = training_nums;
    }
    if (feature_subset !== null) {
        params["feature_subset"] = feature_subset;
    }
    if (mat_feature_num !== null) {
        params["mat_feature_num"] = mat_feature_num;
    }
    if (spatial_weight !== null) {
        params["spatial_weight"] = spatial_weight;
    }
    if (patch_sizes !== null) {
        params["patch_sizes"] = patch_sizes;
    }
    if (select_pts !== null) {
        params["select_pts"] = select_pts;
    }
    if (training_pts !== null) {
        params["training_pts"] = training_pts;
    }
    if (non_les_pts !== null) {
        params["non_les_pts"] = non_les_pts;
    }
    if (load_classifier_data !== null) {
        params["load_classifier_data"] = load_classifier_data;
    }
    if (save_classifier_data !== null) {
        params["save_classifier_data"] = save_classifier_data;
    }
    if (out_name !== null) {
        params["out_name"] = out_name;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function bianca_cargs(
    params: BiancaParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("bianca");
    cargs.push(["--singlefile=", execution.inputFile((params["master_file"] ?? null))].join(''));
    cargs.push(["labelfeaturenum=", String((params["label_feature_num"] ?? null))].join(''));
    cargs.push(["--brainmaskfeaturenum=", String((params["brain_mask_feature_num"] ?? null))].join(''));
    cargs.push(["--querysubjectnum=", String((params["query_subject_num"] ?? null))].join(''));
    if ((params["training_nums"] ?? null) !== null) {
        cargs.push(["--trainingnums=", (params["training_nums"] ?? null)].join(''));
    }
    if ((params["feature_subset"] ?? null) !== null) {
        cargs.push(["--featuresubset=", (params["feature_subset"] ?? null)].join(''));
    }
    if ((params["mat_feature_num"] ?? null) !== null) {
        cargs.push(["--matfeaturenum=", String((params["mat_feature_num"] ?? null))].join(''));
    }
    if ((params["spatial_weight"] ?? null) !== null) {
        cargs.push(["--spatialweight=", String((params["spatial_weight"] ?? null))].join(''));
    }
    if ((params["patch_sizes"] ?? null) !== null) {
        cargs.push(["--patchsizes=", (params["patch_sizes"] ?? null)].join(''));
    }
    if ((params["patch_3d"] ?? false)) {
        cargs.push("--patch3D");
    }
    if ((params["select_pts"] ?? null) !== null) {
        cargs.push(["--selectpts=", (params["select_pts"] ?? null)].join(''));
    }
    if ((params["training_pts"] ?? null) !== null) {
        cargs.push(["--trainingpts=", (params["training_pts"] ?? null)].join(''));
    }
    if ((params["non_les_pts"] ?? null) !== null) {
        cargs.push(["--nonlespts=", (params["non_les_pts"] ?? null)].join(''));
    }
    if ((params["load_classifier_data"] ?? null) !== null) {
        cargs.push(["--loadclassifierdata=", (params["load_classifier_data"] ?? null)].join(''));
    }
    if ((params["save_classifier_data"] ?? null) !== null) {
        cargs.push(["--saveclassifierdata=", (params["save_classifier_data"] ?? null)].join(''));
    }
    if ((params["verbose_flag"] ?? false)) {
        cargs.push("-v");
    }
    if ((params["out_name"] ?? null) !== null) {
        cargs.push(
            "-o",
            (params["out_name"] ?? null)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function bianca_outputs(
    params: BiancaParameters,
    execution: Execution,
): BiancaOutputs {
    const ret: BiancaOutputs = {
        root: execution.outputFile("."),
        base_output: ((params["out_name"] ?? null) !== null) ? execution.outputFile([(params["out_name"] ?? null), "_bianca"].join('')) : null,
    };
    return ret;
}


/**
 * bianca
 *
 * BIANCA: Brain Intensity AbNormality Classification Algorithm.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `BiancaOutputs`).
 */
function bianca_execute(
    params: BiancaParameters,
    runner: Runner | null = null,
): BiancaOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(BIANCA_METADATA);
    params = execution.params(params)
    const cargs = bianca_cargs(params, execution)
    const ret = bianca_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * bianca
 *
 * BIANCA: Brain Intensity AbNormality Classification Algorithm.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param master_file Name of the master file
 * @param label_feature_num Column number (in the master file) of the manual masks (or any placeholder name for query subjects)
 * @param brain_mask_feature_num Column number (in the master file) of images to derive non-zero mask from
 * @param query_subject_num Row number of query subject (in masterlistfile)
 * @param training_nums Subjects to be used in training. List of row numbers (comma separated, no spaces) or 'all' to use all the subjects in the master file
 * @param feature_subset Set of column numbers (comma separated and no spaces) for features/images to use (default: use all available modalities as intensity features). The image used to derive non-zero mask from must be part of the features subset
 * @param mat_feature_num Column number of matrix files (in masterlistfile). Needed to extract spatial features (MNI coordinates)
 * @param spatial_weight Weighting for spatial coordinates (default = 1, i.e., variance-normalized MNI coordinates). Requires --matfeaturenum to be specified
 * @param patch_sizes List of patch sizes for local averaging
 * @param patch_3d Use 3D patches (default is 2D)
 * @param select_pts "any" (default) or "surround" or "noborder"
 * @param training_pts Number (max) of (lesion) points to use (per training subject) or "equalpoints" to select all lesion points and equal number of non-lesion points
 * @param non_les_pts Number (max) of non-lesion points to use. If not specified will be set to the same amount of lesion points
 * @param load_classifier_data Load training data from file
 * @param save_classifier_data Save training data to file
 * @param verbose_flag Use verbose mode
 * @param out_name Specify (base) output name of files
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `BiancaOutputs`).
 */
function bianca(
    master_file: InputPathType,
    label_feature_num: number,
    brain_mask_feature_num: number,
    query_subject_num: number,
    training_nums: string | null = null,
    feature_subset: string | null = null,
    mat_feature_num: number | null = null,
    spatial_weight: number | null = null,
    patch_sizes: string | null = null,
    patch_3d: boolean = false,
    select_pts: string | null = null,
    training_pts: string | null = null,
    non_les_pts: string | null = null,
    load_classifier_data: string | null = null,
    save_classifier_data: string | null = null,
    verbose_flag: boolean = false,
    out_name: string | null = null,
    runner: Runner | null = null,
): BiancaOutputs {
    const params = bianca_params(master_file, label_feature_num, brain_mask_feature_num, query_subject_num, training_nums, feature_subset, mat_feature_num, spatial_weight, patch_sizes, patch_3d, select_pts, training_pts, non_les_pts, load_classifier_data, save_classifier_data, verbose_flag, out_name)
    return bianca_execute(params, runner);
}


export {
      BIANCA_METADATA,
      BiancaOutputs,
      bianca,
      bianca_execute,
      bianca_params,
};
