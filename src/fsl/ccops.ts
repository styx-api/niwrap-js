// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const CCOPS_METADATA: Metadata = {
    id: "bb51a7a0ac6e27a9b2acd7fc208cb1d43bdc08a5.boutiques",
    name: "ccops",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface CcopsParameters {
    "@type"?: "fsl/ccops";
    "basename": string;
    "infile"?: InputPathType | null | undefined;
    "tract_dir"?: string | null | undefined;
    "exclusion_mask"?: InputPathType | null | undefined;
    "reorder_seedspace": boolean;
    "reorder_tractspace": boolean;
    "tract_reord": boolean;
    "connexity_constraint"?: number | null | undefined;
    "binarise_val"?: number | null | undefined;
    "matrix_power"?: number | null | undefined;
    "brain_mask"?: InputPathType | null | undefined;
    "scheme"?: string | null | undefined;
    "nclusters"?: number | null | undefined;
    "help": boolean;
}
type CcopsParametersTagged = Required<Pick<CcopsParameters, '@type'>> & CcopsParameters;


/**
 * Output object returned when calling `CcopsParameters(...)`.
 *
 * @interface
 */
interface CcopsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output clustered ROI mask
     */
    outfile: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param basename Output basename
 * @param infile Input matrix
 * @param tract_dir Tractography Results Directory
 * @param exclusion_mask Exclusion mask (in tract space)
 * @param reorder_seedspace Do seedspace reordering (default no)
 * @param reorder_tractspace Do tractspace reordering (default no)
 * @param tract_reord Propagate seed reordering onto tract space
 * @param connexity_constraint Add connexity constraint - value between 0 and 1 (0 is no constraint). Default is 0
 * @param binarise_val Binarise at (default 0 - no binarisation)
 * @param matrix_power Power to raise the correlation matrix to (default 1)
 * @param brain_mask Brain mask used to output the clustered ROI mask (not necessary if --dir set)
 * @param scheme Reordering algorithm. Can be either spectral (default), kmeans or fuzzy
 * @param nclusters Number of clusters to be used in kmeans or fuzzy
 * @param help Display this help message
 *
 * @returns Parameter dictionary
 */
function ccops_params(
    basename: string,
    infile: InputPathType | null = null,
    tract_dir: string | null = null,
    exclusion_mask: InputPathType | null = null,
    reorder_seedspace: boolean = false,
    reorder_tractspace: boolean = false,
    tract_reord: boolean = false,
    connexity_constraint: number | null = null,
    binarise_val: number | null = null,
    matrix_power: number | null = null,
    brain_mask: InputPathType | null = null,
    scheme: string | null = null,
    nclusters: number | null = null,
    help: boolean = false,
): CcopsParametersTagged {
    const params = {
        "@type": "fsl/ccops" as const,
        "basename": basename,
        "reorder_seedspace": reorder_seedspace,
        "reorder_tractspace": reorder_tractspace,
        "tract_reord": tract_reord,
        "help": help,
    };
    if (infile !== null) {
        params["infile"] = infile;
    }
    if (tract_dir !== null) {
        params["tract_dir"] = tract_dir;
    }
    if (exclusion_mask !== null) {
        params["exclusion_mask"] = exclusion_mask;
    }
    if (connexity_constraint !== null) {
        params["connexity_constraint"] = connexity_constraint;
    }
    if (binarise_val !== null) {
        params["binarise_val"] = binarise_val;
    }
    if (matrix_power !== null) {
        params["matrix_power"] = matrix_power;
    }
    if (brain_mask !== null) {
        params["brain_mask"] = brain_mask;
    }
    if (scheme !== null) {
        params["scheme"] = scheme;
    }
    if (nclusters !== null) {
        params["nclusters"] = nclusters;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ccops_cargs(
    params: CcopsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("ccops");
    cargs.push(
        "--basename",
        (params["basename"] ?? null)
    );
    if ((params["infile"] ?? null) !== null) {
        cargs.push(
            "--in",
            execution.inputFile((params["infile"] ?? null))
        );
    }
    if ((params["tract_dir"] ?? null) !== null) {
        cargs.push(
            "--dir",
            (params["tract_dir"] ?? null)
        );
    }
    if ((params["exclusion_mask"] ?? null) !== null) {
        cargs.push(
            "-x",
            execution.inputFile((params["exclusion_mask"] ?? null))
        );
    }
    if ((params["reorder_seedspace"] ?? false)) {
        cargs.push("--r1");
    }
    if ((params["reorder_tractspace"] ?? false)) {
        cargs.push("--r2");
    }
    if ((params["tract_reord"] ?? false)) {
        cargs.push("--tractreord");
    }
    if ((params["connexity_constraint"] ?? null) !== null) {
        cargs.push(
            "--con",
            String((params["connexity_constraint"] ?? null))
        );
    }
    if ((params["binarise_val"] ?? null) !== null) {
        cargs.push(
            "--bin",
            String((params["binarise_val"] ?? null))
        );
    }
    if ((params["matrix_power"] ?? null) !== null) {
        cargs.push(
            "--power",
            String((params["matrix_power"] ?? null))
        );
    }
    if ((params["brain_mask"] ?? null) !== null) {
        cargs.push(
            "--mask",
            execution.inputFile((params["brain_mask"] ?? null))
        );
    }
    if ((params["scheme"] ?? null) !== null) {
        cargs.push(
            "--scheme",
            (params["scheme"] ?? null)
        );
    }
    if ((params["nclusters"] ?? null) !== null) {
        cargs.push(
            "--nclusters",
            String((params["nclusters"] ?? null))
        );
    }
    if ((params["help"] ?? false)) {
        cargs.push("--help");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ccops_outputs(
    params: CcopsParameters,
    execution: Execution,
): CcopsOutputs {
    const ret: CcopsOutputs = {
        root: execution.outputFile("."),
        outfile: execution.outputFile([(params["basename"] ?? null), "_output.nii.gz"].join('')),
    };
    return ret;
}


/**
 * ccops
 *
 * ccops - Clustering of Connectomes Using Probabilistic Tractography.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `CcopsOutputs`).
 */
function ccops_execute(
    params: CcopsParameters,
    runner: Runner | null = null,
): CcopsOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(CCOPS_METADATA);
    params = execution.params(params)
    const cargs = ccops_cargs(params, execution)
    const ret = ccops_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * ccops
 *
 * ccops - Clustering of Connectomes Using Probabilistic Tractography.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param basename Output basename
 * @param infile Input matrix
 * @param tract_dir Tractography Results Directory
 * @param exclusion_mask Exclusion mask (in tract space)
 * @param reorder_seedspace Do seedspace reordering (default no)
 * @param reorder_tractspace Do tractspace reordering (default no)
 * @param tract_reord Propagate seed reordering onto tract space
 * @param connexity_constraint Add connexity constraint - value between 0 and 1 (0 is no constraint). Default is 0
 * @param binarise_val Binarise at (default 0 - no binarisation)
 * @param matrix_power Power to raise the correlation matrix to (default 1)
 * @param brain_mask Brain mask used to output the clustered ROI mask (not necessary if --dir set)
 * @param scheme Reordering algorithm. Can be either spectral (default), kmeans or fuzzy
 * @param nclusters Number of clusters to be used in kmeans or fuzzy
 * @param help Display this help message
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `CcopsOutputs`).
 */
function ccops(
    basename: string,
    infile: InputPathType | null = null,
    tract_dir: string | null = null,
    exclusion_mask: InputPathType | null = null,
    reorder_seedspace: boolean = false,
    reorder_tractspace: boolean = false,
    tract_reord: boolean = false,
    connexity_constraint: number | null = null,
    binarise_val: number | null = null,
    matrix_power: number | null = null,
    brain_mask: InputPathType | null = null,
    scheme: string | null = null,
    nclusters: number | null = null,
    help: boolean = false,
    runner: Runner | null = null,
): CcopsOutputs {
    const params = ccops_params(basename, infile, tract_dir, exclusion_mask, reorder_seedspace, reorder_tractspace, tract_reord, connexity_constraint, binarise_val, matrix_power, brain_mask, scheme, nclusters, help)
    return ccops_execute(params, runner);
}


export {
      CCOPS_METADATA,
      CcopsOutputs,
      ccops,
      ccops_execute,
      ccops_params,
};
