// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const FLIRT_FSL_METADATA: Metadata = {
    id: "398eadb6f9dd1993cfd24de7b26c3a35c5d0f1cd.boutiques",
    name: "flirt.fsl",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface FlirtFslParameters {
    "__STYXTYPE__": "flirt.fsl";
    "input_volume": InputPathType;
    "reference_volume": InputPathType;
    "output_volume"?: string | null | undefined;
    "output_matrix"?: string | null | undefined;
    "initial_matrix"?: InputPathType | null | undefined;
    "data_type"?: "char" | "short" | "int" | "float" | "double" | null | undefined;
    "cost_function"?: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | null | undefined;
    "search_cost_function"?: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | null | undefined;
    "use_sform_qform": boolean;
    "display_initial_matrix": boolean;
    "angle_representation"?: "quaternion" | "euler" | null | undefined;
    "interpolation_method"?: "trilinear" | "nearestneighbour" | "sinc" | null | undefined;
    "sinc_width"?: number | null | undefined;
    "sinc_window"?: "rectangular" | "hanning" | "blackman" | null | undefined;
    "histogram_bins"?: number | null | undefined;
    "degrees_of_freedom"?: number | null | undefined;
    "no_resample": boolean;
    "force_scaling": boolean;
    "min_voxel_dimension"?: number | null | undefined;
    "apply_transform": boolean;
    "apply_isotropic_transform"?: number | null | undefined;
    "padding_size"?: number | null | undefined;
    "search_range_x"?: Array<number> | null | undefined;
    "search_range_y"?: Array<number> | null | undefined;
    "search_range_z"?: Array<number> | null | undefined;
    "no_search": boolean;
    "coarse_search_angle"?: number | null | undefined;
    "fine_search_angle"?: number | null | undefined;
    "schedule_file"?: InputPathType | null | undefined;
    "reference_weight"?: InputPathType | null | undefined;
    "input_weight"?: InputPathType | null | undefined;
    "no_clamp": boolean;
    "no_resample_blur": boolean;
    "rigid_body_mode": boolean;
    "verbose": boolean;
    "verbose_level"?: number | null | undefined;
    "pause_stages": boolean;
    "version_flag": boolean;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "flirt.fsl": flirt_fsl_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "flirt.fsl": flirt_fsl_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `flirt_fsl(...)`.
 *
 * @interface
 */
interface FlirtFslOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Resulting registered volume
     */
    registered_volume: OutputPathType | null;
    /**
     * Resulting transformation matrix in ASCII format
     */
    transformation_matrix: OutputPathType | null;
}


function flirt_fsl_params(
    input_volume: InputPathType,
    reference_volume: InputPathType,
    output_volume: string | null = null,
    output_matrix: string | null = null,
    initial_matrix: InputPathType | null = null,
    data_type: "char" | "short" | "int" | "float" | "double" | null = null,
    cost_function: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | null = "corratio",
    search_cost_function: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | null = "corratio",
    use_sform_qform: boolean = false,
    display_initial_matrix: boolean = false,
    angle_representation: "quaternion" | "euler" | null = "euler",
    interpolation_method: "trilinear" | "nearestneighbour" | "sinc" | null = "trilinear",
    sinc_width: number | null = 7,
    sinc_window: "rectangular" | "hanning" | "blackman" | null = null,
    histogram_bins: number | null = 256,
    degrees_of_freedom: number | null = 12,
    no_resample: boolean = false,
    force_scaling: boolean = false,
    min_voxel_dimension: number | null = null,
    apply_transform: boolean = false,
    apply_isotropic_transform: number | null = null,
    padding_size: number | null = null,
    search_range_x: Array<number> | null = [-90, 90],
    search_range_y: Array<number> | null = [-90, 90],
    search_range_z: Array<number> | null = [-90, 90],
    no_search: boolean = false,
    coarse_search_angle: number | null = 60,
    fine_search_angle: number | null = 18,
    schedule_file: InputPathType | null = null,
    reference_weight: InputPathType | null = null,
    input_weight: InputPathType | null = null,
    no_clamp: boolean = false,
    no_resample_blur: boolean = false,
    rigid_body_mode: boolean = false,
    verbose: boolean = false,
    verbose_level: number | null = 0,
    pause_stages: boolean = false,
    version_flag: boolean = false,
): FlirtFslParameters {
    /**
     * Build parameters.
    
     * @param input_volume Input volume
     * @param reference_volume Reference volume
     * @param output_volume Output volume
     * @param output_matrix Output matrix filename (4x4 ASCII format)
     * @param initial_matrix Input 4x4 affine matrix filename
     * @param data_type Force output data type
     * @param cost_function Cost function for registration
     * @param search_cost_function Cost function for search
     * @param use_sform_qform Initialize using appropriate sform or qform
     * @param display_initial_matrix Display initial matrix
     * @param angle_representation Set angle representation
     * @param interpolation_method Interpolation method
     * @param sinc_width Sinc interpolation width
     * @param sinc_window Sinc interpolation window
     * @param histogram_bins Number of histogram bins
     * @param degrees_of_freedom Degrees of freedom
     * @param no_resample Do not change input sampling
     * @param force_scaling Force rescaling even for low-res images
     * @param min_voxel_dimension Minimum voxel dimension for sampling (in mm)
     * @param apply_transform Apply transform (no optimisation), requires -init
     * @param apply_isotropic_transform Apply transform with isotropic resampling
     * @param padding_size Padding size for interpolation outside image
     * @param search_range_x Search range for rotation around x-axis
     * @param search_range_y Search range for rotation around y-axis
     * @param search_range_z Search range for rotation around z-axis
     * @param no_search Set all angular search ranges to 0
     * @param coarse_search_angle Coarse search angle in degrees
     * @param fine_search_angle Fine search angle in degrees
     * @param schedule_file Custom schedule filename
     * @param reference_weight Weights for reference volume
     * @param input_weight Weights for input volume
     * @param no_clamp Do not use intensity clamping
     * @param no_resample_blur Do not use blurring on downsampling
     * @param rigid_body_mode Use 2D rigid body mode (ignores dof)
     * @param verbose Equivalent to -verbose 1
     * @param verbose_level Level of verbosity
     * @param pause_stages Pause at each stage
     * @param version_flag Print version number
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "flirt.fsl" as const,
        "input_volume": input_volume,
        "reference_volume": reference_volume,
        "use_sform_qform": use_sform_qform,
        "display_initial_matrix": display_initial_matrix,
        "no_resample": no_resample,
        "force_scaling": force_scaling,
        "apply_transform": apply_transform,
        "no_search": no_search,
        "no_clamp": no_clamp,
        "no_resample_blur": no_resample_blur,
        "rigid_body_mode": rigid_body_mode,
        "verbose": verbose,
        "pause_stages": pause_stages,
        "version_flag": version_flag,
    };
    if (output_volume !== null) {
        params["output_volume"] = output_volume;
    }
    if (output_matrix !== null) {
        params["output_matrix"] = output_matrix;
    }
    if (initial_matrix !== null) {
        params["initial_matrix"] = initial_matrix;
    }
    if (data_type !== null) {
        params["data_type"] = data_type;
    }
    if (cost_function !== null) {
        params["cost_function"] = cost_function;
    }
    if (search_cost_function !== null) {
        params["search_cost_function"] = search_cost_function;
    }
    if (angle_representation !== null) {
        params["angle_representation"] = angle_representation;
    }
    if (interpolation_method !== null) {
        params["interpolation_method"] = interpolation_method;
    }
    if (sinc_width !== null) {
        params["sinc_width"] = sinc_width;
    }
    if (sinc_window !== null) {
        params["sinc_window"] = sinc_window;
    }
    if (histogram_bins !== null) {
        params["histogram_bins"] = histogram_bins;
    }
    if (degrees_of_freedom !== null) {
        params["degrees_of_freedom"] = degrees_of_freedom;
    }
    if (min_voxel_dimension !== null) {
        params["min_voxel_dimension"] = min_voxel_dimension;
    }
    if (apply_isotropic_transform !== null) {
        params["apply_isotropic_transform"] = apply_isotropic_transform;
    }
    if (padding_size !== null) {
        params["padding_size"] = padding_size;
    }
    if (search_range_x !== null) {
        params["search_range_x"] = search_range_x;
    }
    if (search_range_y !== null) {
        params["search_range_y"] = search_range_y;
    }
    if (search_range_z !== null) {
        params["search_range_z"] = search_range_z;
    }
    if (coarse_search_angle !== null) {
        params["coarse_search_angle"] = coarse_search_angle;
    }
    if (fine_search_angle !== null) {
        params["fine_search_angle"] = fine_search_angle;
    }
    if (schedule_file !== null) {
        params["schedule_file"] = schedule_file;
    }
    if (reference_weight !== null) {
        params["reference_weight"] = reference_weight;
    }
    if (input_weight !== null) {
        params["input_weight"] = input_weight;
    }
    if (verbose_level !== null) {
        params["verbose_level"] = verbose_level;
    }
    return params;
}


function flirt_fsl_cargs(
    params: FlirtFslParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("flirt");
    cargs.push(execution.inputFile((params["input_volume"] ?? null)));
    cargs.push(execution.inputFile((params["reference_volume"] ?? null)));
    if ((params["output_volume"] ?? null) !== null) {
        cargs.push((params["output_volume"] ?? null));
    }
    if ((params["output_matrix"] ?? null) !== null) {
        cargs.push(
            "-omat",
            (params["output_matrix"] ?? null)
        );
    }
    if ((params["initial_matrix"] ?? null) !== null) {
        cargs.push(
            "-init",
            execution.inputFile((params["initial_matrix"] ?? null))
        );
    }
    if ((params["data_type"] ?? null) !== null) {
        cargs.push(
            "-datatype",
            (params["data_type"] ?? null)
        );
    }
    if ((params["cost_function"] ?? null) !== null) {
        cargs.push(
            "-cost",
            (params["cost_function"] ?? null)
        );
    }
    if ((params["search_cost_function"] ?? null) !== null) {
        cargs.push(
            "-searchcost",
            (params["search_cost_function"] ?? null)
        );
    }
    if ((params["use_sform_qform"] ?? null)) {
        cargs.push("-usesqform");
    }
    if ((params["display_initial_matrix"] ?? null)) {
        cargs.push("-displayinit");
    }
    if ((params["angle_representation"] ?? null) !== null) {
        cargs.push(
            "-anglerep",
            (params["angle_representation"] ?? null)
        );
    }
    if ((params["interpolation_method"] ?? null) !== null) {
        cargs.push(
            "-interp",
            (params["interpolation_method"] ?? null)
        );
    }
    if ((params["sinc_width"] ?? null) !== null) {
        cargs.push(
            "-sincwidth",
            String((params["sinc_width"] ?? null))
        );
    }
    if ((params["sinc_window"] ?? null) !== null) {
        cargs.push(
            "-sincwindow",
            (params["sinc_window"] ?? null)
        );
    }
    if ((params["histogram_bins"] ?? null) !== null) {
        cargs.push(
            "-bins",
            String((params["histogram_bins"] ?? null))
        );
    }
    if ((params["degrees_of_freedom"] ?? null) !== null) {
        cargs.push(
            "-dof",
            String((params["degrees_of_freedom"] ?? null))
        );
    }
    if ((params["no_resample"] ?? null)) {
        cargs.push("-noresample");
    }
    if ((params["force_scaling"] ?? null)) {
        cargs.push("-forcescaling");
    }
    if ((params["min_voxel_dimension"] ?? null) !== null) {
        cargs.push(
            "-minsampling",
            String((params["min_voxel_dimension"] ?? null))
        );
    }
    if ((params["apply_transform"] ?? null)) {
        cargs.push("-applyxfm");
    }
    if ((params["apply_isotropic_transform"] ?? null) !== null) {
        cargs.push(
            "-applyisoxfm",
            String((params["apply_isotropic_transform"] ?? null))
        );
    }
    if ((params["padding_size"] ?? null) !== null) {
        cargs.push(
            "-paddingsize",
            String((params["padding_size"] ?? null))
        );
    }
    if ((params["search_range_x"] ?? null) !== null) {
        cargs.push(
            "-searchrx",
            ...(params["search_range_x"] ?? null).map(String)
        );
    }
    if ((params["search_range_y"] ?? null) !== null) {
        cargs.push(
            "-searchry",
            ...(params["search_range_y"] ?? null).map(String)
        );
    }
    if ((params["search_range_z"] ?? null) !== null) {
        cargs.push(
            "-searchrz",
            ...(params["search_range_z"] ?? null).map(String)
        );
    }
    if ((params["no_search"] ?? null)) {
        cargs.push("-nosearch");
    }
    if ((params["coarse_search_angle"] ?? null) !== null) {
        cargs.push(
            "-coarsesearch",
            String((params["coarse_search_angle"] ?? null))
        );
    }
    if ((params["fine_search_angle"] ?? null) !== null) {
        cargs.push(
            "-finesearch",
            String((params["fine_search_angle"] ?? null))
        );
    }
    if ((params["schedule_file"] ?? null) !== null) {
        cargs.push(
            "-schedule",
            execution.inputFile((params["schedule_file"] ?? null))
        );
    }
    if ((params["reference_weight"] ?? null) !== null) {
        cargs.push(
            "-refweight",
            execution.inputFile((params["reference_weight"] ?? null))
        );
    }
    if ((params["input_weight"] ?? null) !== null) {
        cargs.push(
            "-inweight",
            execution.inputFile((params["input_weight"] ?? null))
        );
    }
    if ((params["no_clamp"] ?? null)) {
        cargs.push("-noclamp");
    }
    if ((params["no_resample_blur"] ?? null)) {
        cargs.push("-noresampblur");
    }
    if ((params["rigid_body_mode"] ?? null)) {
        cargs.push("-2D");
    }
    if ((params["verbose"] ?? null)) {
        cargs.push("-v");
    }
    if ((params["verbose_level"] ?? null) !== null) {
        cargs.push(
            "-verbose",
            String((params["verbose_level"] ?? null))
        );
    }
    if ((params["pause_stages"] ?? null)) {
        cargs.push("-i");
    }
    if ((params["version_flag"] ?? null)) {
        cargs.push("-version");
    }
    return cargs;
}


function flirt_fsl_outputs(
    params: FlirtFslParameters,
    execution: Execution,
): FlirtFslOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: FlirtFslOutputs = {
        root: execution.outputFile("."),
        registered_volume: ((params["output_volume"] ?? null) !== null) ? execution.outputFile([(params["output_volume"] ?? null), ".nii"].join('')) : null,
        transformation_matrix: ((params["output_matrix"] ?? null) !== null) ? execution.outputFile([(params["output_matrix"] ?? null)].join('')) : null,
    };
    return ret;
}


function flirt_fsl_execute(
    params: FlirtFslParameters,
    execution: Execution,
): FlirtFslOutputs {
    /**
     * FMRIB's Linear Image Registration Tool.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `FlirtFslOutputs`).
     */
    params = execution.params(params)
    const cargs = flirt_fsl_cargs(params, execution)
    const ret = flirt_fsl_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function flirt_fsl(
    input_volume: InputPathType,
    reference_volume: InputPathType,
    output_volume: string | null = null,
    output_matrix: string | null = null,
    initial_matrix: InputPathType | null = null,
    data_type: "char" | "short" | "int" | "float" | "double" | null = null,
    cost_function: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | null = "corratio",
    search_cost_function: "mutualinfo" | "corratio" | "normcorr" | "normmi" | "leastsq" | "labeldiff" | null = "corratio",
    use_sform_qform: boolean = false,
    display_initial_matrix: boolean = false,
    angle_representation: "quaternion" | "euler" | null = "euler",
    interpolation_method: "trilinear" | "nearestneighbour" | "sinc" | null = "trilinear",
    sinc_width: number | null = 7,
    sinc_window: "rectangular" | "hanning" | "blackman" | null = null,
    histogram_bins: number | null = 256,
    degrees_of_freedom: number | null = 12,
    no_resample: boolean = false,
    force_scaling: boolean = false,
    min_voxel_dimension: number | null = null,
    apply_transform: boolean = false,
    apply_isotropic_transform: number | null = null,
    padding_size: number | null = null,
    search_range_x: Array<number> | null = [-90, 90],
    search_range_y: Array<number> | null = [-90, 90],
    search_range_z: Array<number> | null = [-90, 90],
    no_search: boolean = false,
    coarse_search_angle: number | null = 60,
    fine_search_angle: number | null = 18,
    schedule_file: InputPathType | null = null,
    reference_weight: InputPathType | null = null,
    input_weight: InputPathType | null = null,
    no_clamp: boolean = false,
    no_resample_blur: boolean = false,
    rigid_body_mode: boolean = false,
    verbose: boolean = false,
    verbose_level: number | null = 0,
    pause_stages: boolean = false,
    version_flag: boolean = false,
    runner: Runner | null = null,
): FlirtFslOutputs {
    /**
     * FMRIB's Linear Image Registration Tool.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param input_volume Input volume
     * @param reference_volume Reference volume
     * @param output_volume Output volume
     * @param output_matrix Output matrix filename (4x4 ASCII format)
     * @param initial_matrix Input 4x4 affine matrix filename
     * @param data_type Force output data type
     * @param cost_function Cost function for registration
     * @param search_cost_function Cost function for search
     * @param use_sform_qform Initialize using appropriate sform or qform
     * @param display_initial_matrix Display initial matrix
     * @param angle_representation Set angle representation
     * @param interpolation_method Interpolation method
     * @param sinc_width Sinc interpolation width
     * @param sinc_window Sinc interpolation window
     * @param histogram_bins Number of histogram bins
     * @param degrees_of_freedom Degrees of freedom
     * @param no_resample Do not change input sampling
     * @param force_scaling Force rescaling even for low-res images
     * @param min_voxel_dimension Minimum voxel dimension for sampling (in mm)
     * @param apply_transform Apply transform (no optimisation), requires -init
     * @param apply_isotropic_transform Apply transform with isotropic resampling
     * @param padding_size Padding size for interpolation outside image
     * @param search_range_x Search range for rotation around x-axis
     * @param search_range_y Search range for rotation around y-axis
     * @param search_range_z Search range for rotation around z-axis
     * @param no_search Set all angular search ranges to 0
     * @param coarse_search_angle Coarse search angle in degrees
     * @param fine_search_angle Fine search angle in degrees
     * @param schedule_file Custom schedule filename
     * @param reference_weight Weights for reference volume
     * @param input_weight Weights for input volume
     * @param no_clamp Do not use intensity clamping
     * @param no_resample_blur Do not use blurring on downsampling
     * @param rigid_body_mode Use 2D rigid body mode (ignores dof)
     * @param verbose Equivalent to -verbose 1
     * @param verbose_level Level of verbosity
     * @param pause_stages Pause at each stage
     * @param version_flag Print version number
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `FlirtFslOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(FLIRT_FSL_METADATA);
    const params = flirt_fsl_params(input_volume, reference_volume, output_volume, output_matrix, initial_matrix, data_type, cost_function, search_cost_function, use_sform_qform, display_initial_matrix, angle_representation, interpolation_method, sinc_width, sinc_window, histogram_bins, degrees_of_freedom, no_resample, force_scaling, min_voxel_dimension, apply_transform, apply_isotropic_transform, padding_size, search_range_x, search_range_y, search_range_z, no_search, coarse_search_angle, fine_search_angle, schedule_file, reference_weight, input_weight, no_clamp, no_resample_blur, rigid_body_mode, verbose, verbose_level, pause_stages, version_flag)
    return flirt_fsl_execute(params, execution);
}


export {
      FLIRT_FSL_METADATA,
      FlirtFslOutputs,
      FlirtFslParameters,
      flirt_fsl,
      flirt_fsl_params,
};
