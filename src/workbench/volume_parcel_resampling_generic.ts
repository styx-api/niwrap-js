// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const VOLUME_PARCEL_RESAMPLING_GENERIC_METADATA: Metadata = {
    id: "e32bbe9380f1fe73ba584da4cb72ecad324951cc.workbench",
    name: "volume-parcel-resampling-generic",
    package: "workbench",
    container_image_tag: "nx10x/workbench:2.1.0",
};


interface VolumeParcelResamplingGenericParamsDict {
    "@type"?: "workbench/volume-parcel-resampling-generic";
    "volume-in": InputPathType;
    "cur-parcels": InputPathType;
    "new-parcels": InputPathType;
    "kernel": number;
    "volume-out": string;
    "subvol"?: string | null | undefined;
    "fix-zeros": boolean;
    "fwhm": boolean;
}
type VolumeParcelResamplingGenericParamsDictTagged = Required<Pick<VolumeParcelResamplingGenericParamsDict, '@type'>> & VolumeParcelResamplingGenericParamsDict;


/**
 * Output object returned when calling `VolumeParcelResamplingGenericParamsDict(...)`.
 *
 * @interface
 */
interface VolumeParcelResamplingGenericOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * output volume
     */
    volume_out: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param volume_in the input data volume
 * @param cur_parcels label volume of where the parcels currently are
 * @param new_parcels label volume of where the parcels should be
 * @param kernel gaussian kernel size in mm to smooth by during resampling, as sigma by default
 * @param volume_out output volume
 * @param subvol select a single subvolume as input

the subvolume number or name
 * @param fix_zeros treat zero values as not being data
 * @param fwhm smoothing kernel size is FWHM, not sigma
 *
 * @returns Parameter dictionary
 */
function volume_parcel_resampling_generic_params(
    volume_in: InputPathType,
    cur_parcels: InputPathType,
    new_parcels: InputPathType,
    kernel: number,
    volume_out: string,
    subvol: string | null = null,
    fix_zeros: boolean = false,
    fwhm: boolean = false,
): VolumeParcelResamplingGenericParamsDictTagged {
    const params = {
        "@type": "workbench/volume-parcel-resampling-generic" as const,
        "volume-in": volume_in,
        "cur-parcels": cur_parcels,
        "new-parcels": new_parcels,
        "kernel": kernel,
        "volume-out": volume_out,
        "fix-zeros": fix_zeros,
        "fwhm": fwhm,
    };
    if (subvol !== null) {
        params["subvol"] = subvol;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_parcel_resampling_generic_cargs(
    params: VolumeParcelResamplingGenericParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "wb_command",
        "-volume-parcel-resampling-generic"
    );
    cargs.push(execution.inputFile((params["volume-in"] ?? null)));
    cargs.push(execution.inputFile((params["cur-parcels"] ?? null)));
    cargs.push(execution.inputFile((params["new-parcels"] ?? null)));
    cargs.push(String((params["kernel"] ?? null)));
    cargs.push((params["volume-out"] ?? null));
    if ((params["subvol"] ?? null) !== null) {
        cargs.push(
            "-subvolume",
            (params["subvol"] ?? null)
        );
    }
    if ((params["fix-zeros"] ?? false)) {
        cargs.push("-fix-zeros");
    }
    if ((params["fwhm"] ?? false)) {
        cargs.push("-fwhm");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function volume_parcel_resampling_generic_outputs(
    params: VolumeParcelResamplingGenericParamsDict,
    execution: Execution,
): VolumeParcelResamplingGenericOutputs {
    const ret: VolumeParcelResamplingGenericOutputs = {
        root: execution.outputFile("."),
        volume_out: execution.outputFile([(params["volume-out"] ?? null)].join('')),
    };
    return ret;
}


/**
 * SMOOTH AND RESAMPLE VOLUME PARCELS FROM DIFFERENT VOLUME SPACE.
 *
 * Smooths and resamples the region inside each label in cur-parcels to the region of the same label name in new-parcels.  Any voxels in the output label region but outside the input label region will be extrapolated from nearby data.  The -fix-zeros option causes the smoothing to not use an input value if it is zero, but still write a smoothed value to the voxel, and after smoothing is complete, it will check for any remaining values of zero, and fill them in with extrapolated values.  The output volume will use the volume space of new-parcels, which does not need to be in the same volume space as the input.
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `VolumeParcelResamplingGenericOutputs`).
 */
function volume_parcel_resampling_generic_execute(
    params: VolumeParcelResamplingGenericParamsDict,
    runner: Runner | null = null,
): VolumeParcelResamplingGenericOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(VOLUME_PARCEL_RESAMPLING_GENERIC_METADATA);
    params = execution.params(params)
    const cargs = volume_parcel_resampling_generic_cargs(params, execution)
    const ret = volume_parcel_resampling_generic_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * SMOOTH AND RESAMPLE VOLUME PARCELS FROM DIFFERENT VOLUME SPACE.
 *
 * Smooths and resamples the region inside each label in cur-parcels to the region of the same label name in new-parcels.  Any voxels in the output label region but outside the input label region will be extrapolated from nearby data.  The -fix-zeros option causes the smoothing to not use an input value if it is zero, but still write a smoothed value to the voxel, and after smoothing is complete, it will check for any remaining values of zero, and fill them in with extrapolated values.  The output volume will use the volume space of new-parcels, which does not need to be in the same volume space as the input.
 *
 * @param volume_in the input data volume
 * @param cur_parcels label volume of where the parcels currently are
 * @param new_parcels label volume of where the parcels should be
 * @param kernel gaussian kernel size in mm to smooth by during resampling, as sigma by default
 * @param volume_out output volume
 * @param subvol select a single subvolume as input

the subvolume number or name
 * @param fix_zeros treat zero values as not being data
 * @param fwhm smoothing kernel size is FWHM, not sigma
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `VolumeParcelResamplingGenericOutputs`).
 */
function volume_parcel_resampling_generic(
    volume_in: InputPathType,
    cur_parcels: InputPathType,
    new_parcels: InputPathType,
    kernel: number,
    volume_out: string,
    subvol: string | null = null,
    fix_zeros: boolean = false,
    fwhm: boolean = false,
    runner: Runner | null = null,
): VolumeParcelResamplingGenericOutputs {
    const params = volume_parcel_resampling_generic_params(volume_in, cur_parcels, new_parcels, kernel, volume_out, subvol, fix_zeros, fwhm)
    return volume_parcel_resampling_generic_execute(params, runner);
}


export {
      VOLUME_PARCEL_RESAMPLING_GENERIC_METADATA,
      VolumeParcelResamplingGenericOutputs,
      VolumeParcelResamplingGenericParamsDict,
      VolumeParcelResamplingGenericParamsDictTagged,
      volume_parcel_resampling_generic,
      volume_parcel_resampling_generic_execute,
      volume_parcel_resampling_generic_params,
};
