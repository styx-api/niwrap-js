// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const TCKGEN_METADATA: Metadata = {
    id: "49bb9108a82b9af72391f635d21ece29154ff9f6.boutiques",
    name: "tckgen",
    package: "mrtrix",
    container_image_tag: "mrtrix3/mrtrix3:3.0.4",
};


interface TckgenSeedImageParameters {
    "@type"?: "seed_image";
    "image": InputPathType;
}
type TckgenSeedImageParametersTagged = Required<Pick<TckgenSeedImageParameters, '@type'>> & TckgenSeedImageParameters;


interface TckgenSeedSphereParameters {
    "@type"?: "seed_sphere";
    "spec": Array<number>;
}
type TckgenSeedSphereParametersTagged = Required<Pick<TckgenSeedSphereParameters, '@type'>> & TckgenSeedSphereParameters;


interface TckgenSeedRandomPerVoxelParameters {
    "@type"?: "seed_random_per_voxel";
    "image": InputPathType;
    "num_per_voxel": number;
}
type TckgenSeedRandomPerVoxelParametersTagged = Required<Pick<TckgenSeedRandomPerVoxelParameters, '@type'>> & TckgenSeedRandomPerVoxelParameters;


interface TckgenSeedGridPerVoxelParameters {
    "@type"?: "seed_grid_per_voxel";
    "image": InputPathType;
    "grid_size": number;
}
type TckgenSeedGridPerVoxelParametersTagged = Required<Pick<TckgenSeedGridPerVoxelParameters, '@type'>> & TckgenSeedGridPerVoxelParameters;


interface TckgenSeedRejectionParameters {
    "@type"?: "seed_rejection";
    "image": InputPathType;
}
type TckgenSeedRejectionParametersTagged = Required<Pick<TckgenSeedRejectionParameters, '@type'>> & TckgenSeedRejectionParameters;


interface TckgenSeedGmwmiParameters {
    "@type"?: "seed_gmwmi";
    "image": InputPathType;
}
type TckgenSeedGmwmiParametersTagged = Required<Pick<TckgenSeedGmwmiParameters, '@type'>> & TckgenSeedGmwmiParameters;


interface TckgenVariousStringParameters {
    "@type"?: "VariousString";
    "obj": string;
}
type TckgenVariousStringParametersTagged = Required<Pick<TckgenVariousStringParameters, '@type'>> & TckgenVariousStringParameters;


interface TckgenVariousFileParameters {
    "@type"?: "VariousFile";
    "obj": InputPathType;
}
type TckgenVariousFileParametersTagged = Required<Pick<TckgenVariousFileParameters, '@type'>> & TckgenVariousFileParameters;


interface TckgenIncludeParameters {
    "@type"?: "include";
    "spec": TckgenVariousStringParametersTagged | TckgenVariousFileParametersTagged;
}
type TckgenIncludeParametersTagged = Required<Pick<TckgenIncludeParameters, '@type'>> & TckgenIncludeParameters;


interface TckgenIncludeOrderedParameters {
    "@type"?: "include_ordered";
    "image": string;
}
type TckgenIncludeOrderedParametersTagged = Required<Pick<TckgenIncludeOrderedParameters, '@type'>> & TckgenIncludeOrderedParameters;


interface TckgenVariousString1Parameters {
    "@type"?: "VariousString_1";
    "obj": string;
}
type TckgenVariousString1ParametersTagged = Required<Pick<TckgenVariousString1Parameters, '@type'>> & TckgenVariousString1Parameters;


interface TckgenVariousFile1Parameters {
    "@type"?: "VariousFile_1";
    "obj": InputPathType;
}
type TckgenVariousFile1ParametersTagged = Required<Pick<TckgenVariousFile1Parameters, '@type'>> & TckgenVariousFile1Parameters;


interface TckgenExcludeParameters {
    "@type"?: "exclude";
    "spec": TckgenVariousString1ParametersTagged | TckgenVariousFile1ParametersTagged;
}
type TckgenExcludeParametersTagged = Required<Pick<TckgenExcludeParameters, '@type'>> & TckgenExcludeParameters;


interface TckgenVariousString2Parameters {
    "@type"?: "VariousString_2";
    "obj": string;
}
type TckgenVariousString2ParametersTagged = Required<Pick<TckgenVariousString2Parameters, '@type'>> & TckgenVariousString2Parameters;


interface TckgenVariousFile2Parameters {
    "@type"?: "VariousFile_2";
    "obj": InputPathType;
}
type TckgenVariousFile2ParametersTagged = Required<Pick<TckgenVariousFile2Parameters, '@type'>> & TckgenVariousFile2Parameters;


interface TckgenMaskParameters {
    "@type"?: "mask";
    "spec": TckgenVariousString2ParametersTagged | TckgenVariousFile2ParametersTagged;
}
type TckgenMaskParametersTagged = Required<Pick<TckgenMaskParameters, '@type'>> & TckgenMaskParameters;


interface TckgenFslgradParameters {
    "@type"?: "fslgrad";
    "bvecs": InputPathType;
    "bvals": InputPathType;
}
type TckgenFslgradParametersTagged = Required<Pick<TckgenFslgradParameters, '@type'>> & TckgenFslgradParameters;


interface TckgenConfigParameters {
    "@type"?: "config";
    "key": string;
    "value": string;
}
type TckgenConfigParametersTagged = Required<Pick<TckgenConfigParameters, '@type'>> & TckgenConfigParameters;


interface TckgenParameters {
    "@type"?: "mrtrix/tckgen";
    "algorithm"?: string | null | undefined;
    "select"?: number | null | undefined;
    "step"?: number | null | undefined;
    "angle"?: number | null | undefined;
    "minlength"?: number | null | undefined;
    "maxlength"?: number | null | undefined;
    "cutoff"?: number | null | undefined;
    "trials"?: number | null | undefined;
    "noprecomputed": boolean;
    "rk4": boolean;
    "stop": boolean;
    "downsample"?: number | null | undefined;
    "seed_image"?: Array<TckgenSeedImageParameters> | null | undefined;
    "seed_sphere"?: Array<TckgenSeedSphereParameters> | null | undefined;
    "seed_random_per_voxel"?: Array<TckgenSeedRandomPerVoxelParameters> | null | undefined;
    "seed_grid_per_voxel"?: Array<TckgenSeedGridPerVoxelParameters> | null | undefined;
    "seed_rejection"?: Array<TckgenSeedRejectionParameters> | null | undefined;
    "seed_gmwmi"?: Array<TckgenSeedGmwmiParameters> | null | undefined;
    "seed_dynamic"?: InputPathType | null | undefined;
    "seeds"?: number | null | undefined;
    "max_attempts_per_seed"?: number | null | undefined;
    "seed_cutoff"?: number | null | undefined;
    "seed_unidirectional": boolean;
    "seed_direction"?: Array<number> | null | undefined;
    "output_seeds"?: string | null | undefined;
    "include"?: Array<TckgenIncludeParameters> | null | undefined;
    "include_ordered"?: Array<TckgenIncludeOrderedParameters> | null | undefined;
    "exclude"?: Array<TckgenExcludeParameters> | null | undefined;
    "mask"?: Array<TckgenMaskParameters> | null | undefined;
    "act"?: InputPathType | null | undefined;
    "backtrack": boolean;
    "crop_at_gmwmi": boolean;
    "power"?: number | null | undefined;
    "samples"?: number | null | undefined;
    "grad"?: InputPathType | null | undefined;
    "fslgrad"?: TckgenFslgradParameters | null | undefined;
    "info": boolean;
    "quiet": boolean;
    "debug": boolean;
    "force": boolean;
    "nthreads"?: number | null | undefined;
    "config"?: Array<TckgenConfigParameters> | null | undefined;
    "help": boolean;
    "version": boolean;
    "source": InputPathType;
    "tracks": string;
}
type TckgenParametersTagged = Required<Pick<TckgenParameters, '@type'>> & TckgenParameters;


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function tckgen_spec_cargs_dyn_fn(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "VariousString": tckgen_various_string_cargs,
        "VariousFile": tckgen_various_file_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function tckgen_spec_outputs_dyn_fn(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function tckgen_spec_cargs_dyn_fn_(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "VariousString_1": tckgen_various_string_1_cargs,
        "VariousFile_1": tckgen_various_file_1_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function tckgen_spec_outputs_dyn_fn_(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function tckgen_spec_cargs_dyn_fn_2(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "VariousString_2": tckgen_various_string_2_cargs,
        "VariousFile_2": tckgen_various_file_2_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function tckgen_spec_outputs_dyn_fn_2(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @param image seed streamlines entirely at random within a mask image 
 *
 * @returns Parameter dictionary
 */
function tckgen_seed_image_params(
    image: InputPathType,
): TckgenSeedImageParametersTagged {
    const params = {
        "@type": "seed_image" as const,
        "image": image,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_seed_image_cargs(
    params: TckgenSeedImageParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-seed_image");
    cargs.push(execution.inputFile((params["image"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param spec spherical seed as four comma-separated values (XYZ position and radius)
 *
 * @returns Parameter dictionary
 */
function tckgen_seed_sphere_params(
    spec: Array<number>,
): TckgenSeedSphereParametersTagged {
    const params = {
        "@type": "seed_sphere" as const,
        "spec": spec,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_seed_sphere_cargs(
    params: TckgenSeedSphereParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-seed_sphere");
    cargs.push((params["spec"] ?? null).map(String).join(","));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param image seed a fixed number of streamlines per voxel in a mask image; random placement of seeds in each voxel
 * @param num_per_voxel seed a fixed number of streamlines per voxel in a mask image; random placement of seeds in each voxel
 *
 * @returns Parameter dictionary
 */
function tckgen_seed_random_per_voxel_params(
    image: InputPathType,
    num_per_voxel: number,
): TckgenSeedRandomPerVoxelParametersTagged {
    const params = {
        "@type": "seed_random_per_voxel" as const,
        "image": image,
        "num_per_voxel": num_per_voxel,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_seed_random_per_voxel_cargs(
    params: TckgenSeedRandomPerVoxelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-seed_random_per_voxel");
    cargs.push(execution.inputFile((params["image"] ?? null)));
    cargs.push(String((params["num_per_voxel"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param image seed a fixed number of streamlines per voxel in a mask image; place seeds on a 3D mesh grid (grid_size argument is per axis; so a grid_size of 3 results in 27 seeds per voxel)
 * @param grid_size seed a fixed number of streamlines per voxel in a mask image; place seeds on a 3D mesh grid (grid_size argument is per axis; so a grid_size of 3 results in 27 seeds per voxel)
 *
 * @returns Parameter dictionary
 */
function tckgen_seed_grid_per_voxel_params(
    image: InputPathType,
    grid_size: number,
): TckgenSeedGridPerVoxelParametersTagged {
    const params = {
        "@type": "seed_grid_per_voxel" as const,
        "image": image,
        "grid_size": grid_size,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_seed_grid_per_voxel_cargs(
    params: TckgenSeedGridPerVoxelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-seed_grid_per_voxel");
    cargs.push(execution.inputFile((params["image"] ?? null)));
    cargs.push(String((params["grid_size"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param image seed from an image using rejection sampling (higher values = more probable to seed from)
 *
 * @returns Parameter dictionary
 */
function tckgen_seed_rejection_params(
    image: InputPathType,
): TckgenSeedRejectionParametersTagged {
    const params = {
        "@type": "seed_rejection" as const,
        "image": image,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_seed_rejection_cargs(
    params: TckgenSeedRejectionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-seed_rejection");
    cargs.push(execution.inputFile((params["image"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param image seed from the grey matter - white matter interface (only valid if using ACT framework). Input image should be a 3D seeding volume; seeds drawn within this image will be optimised to the interface using the 5TT image provided using the -act option.
 *
 * @returns Parameter dictionary
 */
function tckgen_seed_gmwmi_params(
    image: InputPathType,
): TckgenSeedGmwmiParametersTagged {
    const params = {
        "@type": "seed_gmwmi" as const,
        "image": image,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_seed_gmwmi_cargs(
    params: TckgenSeedGmwmiParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-seed_gmwmi");
    cargs.push(execution.inputFile((params["image"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj String object.
 *
 * @returns Parameter dictionary
 */
function tckgen_various_string_params(
    obj: string,
): TckgenVariousStringParametersTagged {
    const params = {
        "@type": "VariousString" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_various_string_cargs(
    params: TckgenVariousStringParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["obj"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj File object.
 *
 * @returns Parameter dictionary
 */
function tckgen_various_file_params(
    obj: InputPathType,
): TckgenVariousFileParametersTagged {
    const params = {
        "@type": "VariousFile" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_various_file_cargs(
    params: TckgenVariousFileParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["obj"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param spec specify an inclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines must traverse ALL inclusion regions to be accepted.
 *
 * @returns Parameter dictionary
 */
function tckgen_include_params(
    spec: TckgenVariousStringParametersTagged | TckgenVariousFileParametersTagged,
): TckgenIncludeParametersTagged {
    const params = {
        "@type": "include" as const,
        "spec": spec,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_include_cargs(
    params: TckgenIncludeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-include");
    cargs.push(...tckgen_spec_cargs_dyn_fn((params["spec"] ?? null)["@type"])((params["spec"] ?? null), execution));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param image specify an inclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines must traverse ALL inclusion_ordered regions in the order they are specified in order to be accepted.
 *
 * @returns Parameter dictionary
 */
function tckgen_include_ordered_params(
    image: string,
): TckgenIncludeOrderedParametersTagged {
    const params = {
        "@type": "include_ordered" as const,
        "image": image,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_include_ordered_cargs(
    params: TckgenIncludeOrderedParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-include_ordered");
    cargs.push((params["image"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj String object.
 *
 * @returns Parameter dictionary
 */
function tckgen_various_string_1_params(
    obj: string,
): TckgenVariousString1ParametersTagged {
    const params = {
        "@type": "VariousString_1" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_various_string_1_cargs(
    params: TckgenVariousString1Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["obj"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj File object.
 *
 * @returns Parameter dictionary
 */
function tckgen_various_file_1_params(
    obj: InputPathType,
): TckgenVariousFile1ParametersTagged {
    const params = {
        "@type": "VariousFile_1" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_various_file_1_cargs(
    params: TckgenVariousFile1Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["obj"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param spec specify an exclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines that enter ANY exclude region will be discarded.
 *
 * @returns Parameter dictionary
 */
function tckgen_exclude_params(
    spec: TckgenVariousString1ParametersTagged | TckgenVariousFile1ParametersTagged,
): TckgenExcludeParametersTagged {
    const params = {
        "@type": "exclude" as const,
        "spec": spec,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_exclude_cargs(
    params: TckgenExcludeParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-exclude");
    cargs.push(...tckgen_spec_cargs_dyn_fn_((params["spec"] ?? null)["@type"])((params["spec"] ?? null), execution));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj String object.
 *
 * @returns Parameter dictionary
 */
function tckgen_various_string_2_params(
    obj: string,
): TckgenVariousString2ParametersTagged {
    const params = {
        "@type": "VariousString_2" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_various_string_2_cargs(
    params: TckgenVariousString2Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["obj"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj File object.
 *
 * @returns Parameter dictionary
 */
function tckgen_various_file_2_params(
    obj: InputPathType,
): TckgenVariousFile2ParametersTagged {
    const params = {
        "@type": "VariousFile_2" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_various_file_2_cargs(
    params: TckgenVariousFile2Parameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["obj"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param spec specify a masking region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). If defined, streamlines exiting the mask will be truncated.
 *
 * @returns Parameter dictionary
 */
function tckgen_mask_params(
    spec: TckgenVariousString2ParametersTagged | TckgenVariousFile2ParametersTagged,
): TckgenMaskParametersTagged {
    const params = {
        "@type": "mask" as const,
        "spec": spec,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_mask_cargs(
    params: TckgenMaskParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-mask");
    cargs.push(...tckgen_spec_cargs_dyn_fn_2((params["spec"] ?? null)["@type"])((params["spec"] ?? null), execution));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param bvecs Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param bvals Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 *
 * @returns Parameter dictionary
 */
function tckgen_fslgrad_params(
    bvecs: InputPathType,
    bvals: InputPathType,
): TckgenFslgradParametersTagged {
    const params = {
        "@type": "fslgrad" as const,
        "bvecs": bvecs,
        "bvals": bvals,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_fslgrad_cargs(
    params: TckgenFslgradParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-fslgrad");
    cargs.push(execution.inputFile((params["bvecs"] ?? null)));
    cargs.push(execution.inputFile((params["bvals"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param key temporarily set the value of an MRtrix config file entry.
 * @param value temporarily set the value of an MRtrix config file entry.
 *
 * @returns Parameter dictionary
 */
function tckgen_config_params(
    key: string,
    value: string,
): TckgenConfigParametersTagged {
    const params = {
        "@type": "config" as const,
        "key": key,
        "value": value,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_config_cargs(
    params: TckgenConfigParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-config");
    cargs.push((params["key"] ?? null));
    cargs.push((params["value"] ?? null));
    return cargs;
}


/**
 * Output object returned when calling `TckgenParameters(...)`.
 *
 * @interface
 */
interface TckgenOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output file containing the tracks generated.
     */
    tracks: OutputPathType;
    /**
     * output the seed location of all successful streamlines to a file 
     */
    output_seeds: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param source The image containing the source data. The type of image data required depends on the algorithm used (see Description section).
 * @param tracks the output file containing the tracks generated.
 * @param algorithm specify the tractography algorithm to use. Valid choices are: FACT, iFOD1, iFOD2, Nulldist1, Nulldist2, SD_Stream, Seedtest, Tensor_Det, Tensor_Prob (default: iFOD2).
 * @param select set the desired number of streamlines to be selected by tckgen, after all selection criteria have been applied (i.e. inclusion/exclusion ROIs, min/max length, etc). tckgen will keep seeding streamlines until this number of streamlines have been selected, or the maximum allowed number of seeds has been exceeded (see -seeds option). By default, 5000 streamlines are to be selected. Set to zero to disable, which will result in streamlines being seeded until the number specified by -seeds has been reached.
 * @param step set the step size of the algorithm in mm (defaults: for first-order algorithms, 0.1 x voxelsize; if using RK4, 0.25 x voxelsize; for iFOD2: 0.5 x voxelsize).
 * @param angle set the maximum angle in degrees between successive steps (defaults: 60 for deterministic algorithms; 15 for iFOD1 / nulldist1; 45 for iFOD2 / nulldist2)
 * @param minlength set the minimum length of any track in mm (defaults: without ACT, 5 x voxelsize; with ACT, 2 x voxelsize).
 * @param maxlength set the maximum length of any track in mm (default: 100 x voxelsize).
 * @param cutoff set the FOD amplitude / fixel size / tensor FA cutoff for terminating tracks (defaults: 0.1 for FOD-based algorithms; 0.1 for fixel-based algorithms; 0.1 for tensor-based algorithms; threshold multiplied by 0.5 when using ACT).
 * @param trials set the maximum number of sampling trials at each point (only used for iFOD1 / iFOD2) (default: 1000).
 * @param noprecomputed do NOT pre-compute legendre polynomial values. Warning: this will slow down the algorithm by a factor of approximately 4.
 * @param rk4 use 4th-order Runge-Kutta integration (slower, but eliminates curvature overshoot in 1st-order deterministic methods)
 * @param stop stop propagating a streamline once it has traversed all include regions
 * @param downsample downsample the generated streamlines to reduce output file size (default is (samples-1) for iFOD2, no downsampling for all other algorithms)
 * @param seed_image seed streamlines entirely at random within a mask image 
 * @param seed_sphere spherical seed as four comma-separated values (XYZ position and radius)
 * @param seed_random_per_voxel seed a fixed number of streamlines per voxel in a mask image; random placement of seeds in each voxel
 * @param seed_grid_per_voxel seed a fixed number of streamlines per voxel in a mask image; place seeds on a 3D mesh grid (grid_size argument is per axis; so a grid_size of 3 results in 27 seeds per voxel)
 * @param seed_rejection seed from an image using rejection sampling (higher values = more probable to seed from)
 * @param seed_gmwmi seed from the grey matter - white matter interface (only valid if using ACT framework). Input image should be a 3D seeding volume; seeds drawn within this image will be optimised to the interface using the 5TT image provided using the -act option.
 * @param seed_dynamic determine seed points dynamically using the SIFT model (must not provide any other seeding mechanism). Note that while this seeding mechanism improves the distribution of reconstructed streamlines density, it should NOT be used as a substitute for the SIFT method itself.
 * @param seeds set the number of seeds that tckgen will attempt to track from. If this option is NOT provided, the default number of seeds is set to 1000Ã— the number of selected streamlines. If -select is NOT also specified, tckgen will continue tracking until this number of seeds has been attempted. However, if -select is also specified, tckgen will stop when the number of seeds attempted reaches the number specified here, OR when the number of streamlines selected reaches the number requested with the -select option. This can be used to prevent the program from running indefinitely when no or very few streamlines can be found that match the selection criteria. Setting this to zero will cause tckgen to keep attempting seeds until the number specified by -select has been reached.
 * @param max_attempts_per_seed set the maximum number of times that the tracking algorithm should attempt to find an appropriate tracking direction from a given seed point. This should be set high enough to ensure that an actual plausible seed point is not discarded prematurely as being unable to initiate tracking from. Higher settings may affect performance if many seeds are genuinely impossible to track from, as many attempts will still be made in vain for such seeds. (default: 1000)
 * @param seed_cutoff set the minimum FA or FOD amplitude for seeding tracks (default is the same as the normal -cutoff).
 * @param seed_unidirectional track from the seed point in one direction only (default is to track in both directions).
 * @param seed_direction specify a seeding direction for the tracking (this should be supplied as a vector of 3 comma-separated values.
 * @param output_seeds output the seed location of all successful streamlines to a file
 * @param include specify an inclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines must traverse ALL inclusion regions to be accepted.
 * @param include_ordered specify an inclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines must traverse ALL inclusion_ordered regions in the order they are specified in order to be accepted.
 * @param exclude specify an exclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines that enter ANY exclude region will be discarded.
 * @param mask specify a masking region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). If defined, streamlines exiting the mask will be truncated.
 * @param act use the Anatomically-Constrained Tractography framework during tracking; provided image must be in the 5TT (five-tissue-type) format
 * @param backtrack allow tracks to be truncated and re-tracked if a poor structural termination is encountered
 * @param crop_at_gmwmi crop streamline endpoints more precisely as they cross the GM-WM interface
 * @param power raise the FOD to the power specified (defaults are: 1.0 for iFOD1; 1.0/nsamples for iFOD2).
 * @param samples set the number of FOD samples to take per step (Default: 4).
 * @param grad Provide the diffusion-weighted gradient scheme used in the acquisition in a text file. This should be supplied as a 4xN text file with each line is in the format [ X Y Z b ], where [ X Y Z ] describe the direction of the applied gradient, and b gives the b-value in units of s/mm^2. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param fslgrad Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 *
 * @returns Parameter dictionary
 */
function tckgen_params(
    source: InputPathType,
    tracks: string,
    algorithm: string | null = null,
    select: number | null = null,
    step: number | null = null,
    angle: number | null = null,
    minlength: number | null = null,
    maxlength: number | null = null,
    cutoff: number | null = null,
    trials: number | null = null,
    noprecomputed: boolean = false,
    rk4: boolean = false,
    stop: boolean = false,
    downsample: number | null = null,
    seed_image: Array<TckgenSeedImageParameters> | null = null,
    seed_sphere: Array<TckgenSeedSphereParameters> | null = null,
    seed_random_per_voxel: Array<TckgenSeedRandomPerVoxelParameters> | null = null,
    seed_grid_per_voxel: Array<TckgenSeedGridPerVoxelParameters> | null = null,
    seed_rejection: Array<TckgenSeedRejectionParameters> | null = null,
    seed_gmwmi: Array<TckgenSeedGmwmiParameters> | null = null,
    seed_dynamic: InputPathType | null = null,
    seeds: number | null = null,
    max_attempts_per_seed: number | null = null,
    seed_cutoff: number | null = null,
    seed_unidirectional: boolean = false,
    seed_direction: Array<number> | null = null,
    output_seeds: string | null = null,
    include: Array<TckgenIncludeParameters> | null = null,
    include_ordered: Array<TckgenIncludeOrderedParameters> | null = null,
    exclude: Array<TckgenExcludeParameters> | null = null,
    mask: Array<TckgenMaskParameters> | null = null,
    act: InputPathType | null = null,
    backtrack: boolean = false,
    crop_at_gmwmi: boolean = false,
    power: number | null = null,
    samples: number | null = null,
    grad: InputPathType | null = null,
    fslgrad: TckgenFslgradParameters | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<TckgenConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
): TckgenParametersTagged {
    const params = {
        "@type": "mrtrix/tckgen" as const,
        "noprecomputed": noprecomputed,
        "rk4": rk4,
        "stop": stop,
        "seed_unidirectional": seed_unidirectional,
        "backtrack": backtrack,
        "crop_at_gmwmi": crop_at_gmwmi,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help,
        "version": version,
        "source": source,
        "tracks": tracks,
    };
    if (algorithm !== null) {
        params["algorithm"] = algorithm;
    }
    if (select !== null) {
        params["select"] = select;
    }
    if (step !== null) {
        params["step"] = step;
    }
    if (angle !== null) {
        params["angle"] = angle;
    }
    if (minlength !== null) {
        params["minlength"] = minlength;
    }
    if (maxlength !== null) {
        params["maxlength"] = maxlength;
    }
    if (cutoff !== null) {
        params["cutoff"] = cutoff;
    }
    if (trials !== null) {
        params["trials"] = trials;
    }
    if (downsample !== null) {
        params["downsample"] = downsample;
    }
    if (seed_image !== null) {
        params["seed_image"] = seed_image;
    }
    if (seed_sphere !== null) {
        params["seed_sphere"] = seed_sphere;
    }
    if (seed_random_per_voxel !== null) {
        params["seed_random_per_voxel"] = seed_random_per_voxel;
    }
    if (seed_grid_per_voxel !== null) {
        params["seed_grid_per_voxel"] = seed_grid_per_voxel;
    }
    if (seed_rejection !== null) {
        params["seed_rejection"] = seed_rejection;
    }
    if (seed_gmwmi !== null) {
        params["seed_gmwmi"] = seed_gmwmi;
    }
    if (seed_dynamic !== null) {
        params["seed_dynamic"] = seed_dynamic;
    }
    if (seeds !== null) {
        params["seeds"] = seeds;
    }
    if (max_attempts_per_seed !== null) {
        params["max_attempts_per_seed"] = max_attempts_per_seed;
    }
    if (seed_cutoff !== null) {
        params["seed_cutoff"] = seed_cutoff;
    }
    if (seed_direction !== null) {
        params["seed_direction"] = seed_direction;
    }
    if (output_seeds !== null) {
        params["output_seeds"] = output_seeds;
    }
    if (include !== null) {
        params["include"] = include;
    }
    if (include_ordered !== null) {
        params["include_ordered"] = include_ordered;
    }
    if (exclude !== null) {
        params["exclude"] = exclude;
    }
    if (mask !== null) {
        params["mask"] = mask;
    }
    if (act !== null) {
        params["act"] = act;
    }
    if (power !== null) {
        params["power"] = power;
    }
    if (samples !== null) {
        params["samples"] = samples;
    }
    if (grad !== null) {
        params["grad"] = grad;
    }
    if (fslgrad !== null) {
        params["fslgrad"] = fslgrad;
    }
    if (nthreads !== null) {
        params["nthreads"] = nthreads;
    }
    if (config !== null) {
        params["config"] = config;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function tckgen_cargs(
    params: TckgenParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("tckgen");
    if ((params["algorithm"] ?? null) !== null) {
        cargs.push(
            "-algorithm",
            (params["algorithm"] ?? null)
        );
    }
    if ((params["select"] ?? null) !== null) {
        cargs.push(
            "-select",
            String((params["select"] ?? null))
        );
    }
    if ((params["step"] ?? null) !== null) {
        cargs.push(
            "-step",
            String((params["step"] ?? null))
        );
    }
    if ((params["angle"] ?? null) !== null) {
        cargs.push(
            "-angle",
            String((params["angle"] ?? null))
        );
    }
    if ((params["minlength"] ?? null) !== null) {
        cargs.push(
            "-minlength",
            String((params["minlength"] ?? null))
        );
    }
    if ((params["maxlength"] ?? null) !== null) {
        cargs.push(
            "-maxlength",
            String((params["maxlength"] ?? null))
        );
    }
    if ((params["cutoff"] ?? null) !== null) {
        cargs.push(
            "-cutoff",
            String((params["cutoff"] ?? null))
        );
    }
    if ((params["trials"] ?? null) !== null) {
        cargs.push(
            "-trials",
            String((params["trials"] ?? null))
        );
    }
    if ((params["noprecomputed"] ?? false)) {
        cargs.push("-noprecomputed");
    }
    if ((params["rk4"] ?? false)) {
        cargs.push("-rk4");
    }
    if ((params["stop"] ?? false)) {
        cargs.push("-stop");
    }
    if ((params["downsample"] ?? null) !== null) {
        cargs.push(
            "-downsample",
            String((params["downsample"] ?? null))
        );
    }
    if ((params["seed_image"] ?? null) !== null) {
        cargs.push(...(params["seed_image"] ?? null).map(s => tckgen_seed_image_cargs(s, execution)).flat());
    }
    if ((params["seed_sphere"] ?? null) !== null) {
        cargs.push(...(params["seed_sphere"] ?? null).map(s => tckgen_seed_sphere_cargs(s, execution)).flat());
    }
    if ((params["seed_random_per_voxel"] ?? null) !== null) {
        cargs.push(...(params["seed_random_per_voxel"] ?? null).map(s => tckgen_seed_random_per_voxel_cargs(s, execution)).flat());
    }
    if ((params["seed_grid_per_voxel"] ?? null) !== null) {
        cargs.push(...(params["seed_grid_per_voxel"] ?? null).map(s => tckgen_seed_grid_per_voxel_cargs(s, execution)).flat());
    }
    if ((params["seed_rejection"] ?? null) !== null) {
        cargs.push(...(params["seed_rejection"] ?? null).map(s => tckgen_seed_rejection_cargs(s, execution)).flat());
    }
    if ((params["seed_gmwmi"] ?? null) !== null) {
        cargs.push(...(params["seed_gmwmi"] ?? null).map(s => tckgen_seed_gmwmi_cargs(s, execution)).flat());
    }
    if ((params["seed_dynamic"] ?? null) !== null) {
        cargs.push(
            "-seed_dynamic",
            execution.inputFile((params["seed_dynamic"] ?? null))
        );
    }
    if ((params["seeds"] ?? null) !== null) {
        cargs.push(
            "-seeds",
            String((params["seeds"] ?? null))
        );
    }
    if ((params["max_attempts_per_seed"] ?? null) !== null) {
        cargs.push(
            "-max_attempts_per_seed",
            String((params["max_attempts_per_seed"] ?? null))
        );
    }
    if ((params["seed_cutoff"] ?? null) !== null) {
        cargs.push(
            "-seed_cutoff",
            String((params["seed_cutoff"] ?? null))
        );
    }
    if ((params["seed_unidirectional"] ?? false)) {
        cargs.push("-seed_unidirectional");
    }
    if ((params["seed_direction"] ?? null) !== null) {
        cargs.push(
            "-seed_direction",
            (params["seed_direction"] ?? null).map(String).join(",")
        );
    }
    if ((params["output_seeds"] ?? null) !== null) {
        cargs.push(
            "-output_seeds",
            (params["output_seeds"] ?? null)
        );
    }
    if ((params["include"] ?? null) !== null) {
        cargs.push(...(params["include"] ?? null).map(s => tckgen_include_cargs(s, execution)).flat());
    }
    if ((params["include_ordered"] ?? null) !== null) {
        cargs.push(...(params["include_ordered"] ?? null).map(s => tckgen_include_ordered_cargs(s, execution)).flat());
    }
    if ((params["exclude"] ?? null) !== null) {
        cargs.push(...(params["exclude"] ?? null).map(s => tckgen_exclude_cargs(s, execution)).flat());
    }
    if ((params["mask"] ?? null) !== null) {
        cargs.push(...(params["mask"] ?? null).map(s => tckgen_mask_cargs(s, execution)).flat());
    }
    if ((params["act"] ?? null) !== null) {
        cargs.push(
            "-act",
            execution.inputFile((params["act"] ?? null))
        );
    }
    if ((params["backtrack"] ?? false)) {
        cargs.push("-backtrack");
    }
    if ((params["crop_at_gmwmi"] ?? false)) {
        cargs.push("-crop_at_gmwmi");
    }
    if ((params["power"] ?? null) !== null) {
        cargs.push(
            "-power",
            String((params["power"] ?? null))
        );
    }
    if ((params["samples"] ?? null) !== null) {
        cargs.push(
            "-samples",
            String((params["samples"] ?? null))
        );
    }
    if ((params["grad"] ?? null) !== null) {
        cargs.push(
            "-grad",
            execution.inputFile((params["grad"] ?? null))
        );
    }
    if ((params["fslgrad"] ?? null) !== null) {
        cargs.push(...tckgen_fslgrad_cargs((params["fslgrad"] ?? null), execution));
    }
    if ((params["info"] ?? false)) {
        cargs.push("-info");
    }
    if ((params["quiet"] ?? false)) {
        cargs.push("-quiet");
    }
    if ((params["debug"] ?? false)) {
        cargs.push("-debug");
    }
    if ((params["force"] ?? false)) {
        cargs.push("-force");
    }
    if ((params["nthreads"] ?? null) !== null) {
        cargs.push(
            "-nthreads",
            String((params["nthreads"] ?? null))
        );
    }
    if ((params["config"] ?? null) !== null) {
        cargs.push(...(params["config"] ?? null).map(s => tckgen_config_cargs(s, execution)).flat());
    }
    if ((params["help"] ?? false)) {
        cargs.push("-help");
    }
    if ((params["version"] ?? false)) {
        cargs.push("-version");
    }
    cargs.push(execution.inputFile((params["source"] ?? null)));
    cargs.push((params["tracks"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function tckgen_outputs(
    params: TckgenParameters,
    execution: Execution,
): TckgenOutputs {
    const ret: TckgenOutputs = {
        root: execution.outputFile("."),
        tracks: execution.outputFile([(params["tracks"] ?? null)].join('')),
        output_seeds: ((params["output_seeds"] ?? null) !== null) ? execution.outputFile([(params["output_seeds"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * tckgen
 *
 * Perform streamlines tractography.
 *
 * By default, tckgen produces a fixed number of streamlines, by attempting to seed from new random locations until the target number of streamlines have been selected (in other words, after all inclusion & exclusion criteria have been applied), or the maximum number of seeds has been exceeded (by default, this is 1000 x the desired number of selected streamlines). Use the -select and/or -seeds options to modify as required. See also the Seeding options section for alternative seeding strategies.
 *
 * Below is a list of available tracking algorithms, the input image data that they require, and a brief description of their behaviour:
 *
 * - FACT: Fiber Assigned by Continuous Tracking. A deterministic algorithm that takes as input a 4D image, with 3xN volumes, where N is the maximum number of fiber orientations in a voxel. Each triplet of volumes represents a 3D vector corresponding to a fiber orientation; the length of the vector additionally indicates some measure of density or anisotropy. As streamlines move from one voxel to another, the fiber orientation most collinear with the streamline orientation is selected (i.e. there is no intra-voxel interpolation).
 *
 * - iFOD1: First-order Integration over Fiber Orientation Distributions. A probabilistic algorithm that takes as input a Fiber Orientation Distribution (FOD) image represented in the Spherical Harmonic (SH) basis. At each streamline step, random samples from the local (trilinear interpolated) FOD are taken. A streamline is more probable to follow orientations where the FOD amplitude is large; but it may also rarely traverse orientations with small FOD amplitude.
 *
 * - iFOD2 (default): Second-order Integration over Fiber Orientation Distributions. A probabilistic algorithm that takes as input a Fiber Orientation Distribution (FOD) image represented in the Spherical Harmonic (SH) basis. Candidate streamline paths (based on short curved "arcs") are drawn, and the underlying (trilinear-interpolated) FOD amplitudes along those arcs are sampled. A streamline is more probable to follow a path where the FOD amplitudes along that path are large; but it may also rarely traverse orientations where the FOD amplitudes are small, as long as the amplitude remains above the FOD amplitude threshold along the entire path.
 *
 * - NullDist1 / NullDist2: Null Distribution tracking algorithms. These probabilistic algorithms expect as input the same image that was used when invoking the corresponding algorithm for which the null distribution is sought. These algorithms generate streamlines based on random orientation samples; that is, no image information relating to fiber orientations is used, and streamlines trajectories are determined entirely from random sampling. The NullDist2 algorithm is designed to be used in conjunction with iFOD2; NullDist1 should be used in conjunction with any first-order algorithm.
 *
 * - SD_STREAM: Streamlines tractography based on Spherical Deconvolution (SD). A deterministic algorithm that takes as input a Fiber Orientation Distribution (FOD) image represented in the Spherical Harmonic (SH) basis. At each streamline step, the local (trilinear-interpolated) FOD is sampled, and from the current streamline tangent orientation, a Newton optimisation on the sphere is performed in order to locate the orientation of the nearest FOD amplitude peak.
 *
 * - SeedTest: A dummy streamlines algorithm used for testing streamline seeding mechanisms. Any image can be used as input; the image will not be used in any way. For each seed point generated by the seeding mechanism(s), a streamline containing a single point corresponding to that seed location will be written to the output track file.
 *
 * - Tensor_Det: A deterministic algorithm that takes as input a 4D diffusion-weighted image (DWI) series. At each streamline step, the diffusion tensor is fitted to the local (trilinear-interpolated) diffusion data, and the streamline trajectory is determined as the principal eigenvector of that tensor.
 *
 * - Tensor_Prob: A probabilistic algorithm that takes as input a 4D diffusion-weighted image (DWI) series. Within each image voxel, a residual bootstrap is performed to obtain a unique realisation of the DWI data in that voxel for each streamline. These data are then sampled via trilinear interpolation at each streamline step, the diffusion tensor model is fitted, and the streamline follows the orientation of the principal eigenvector of that tensor.
 *
 * Note that the behaviour of the -angle option varies slightly depending on the order of integration: for any first-order method, this angle corresponds to the deviation in streamline trajectory per step; for higher-order methods, this corresponds to the change in underlying fibre orientation between the start and end points of each step.
 *
 * References:
 *
 * References based on streamlines algorithm used:
 *
 * * FACT:
 * Mori, S.; Crain, B. J.; Chacko, V. P. & van Zijl, P. C. M. Three-dimensional tracking of axonal projections in the brain by magnetic resonance imaging. Annals of Neurology, 1999, 45, 265-269
 *
 * * iFOD1 or SD_STREAM:
 * Tournier, J.-D.; Calamante, F. & Connelly, A. MRtrix: Diffusion tractography in crossing fiber regions. Int. J. Imaging Syst. Technol., 2012, 22, 53-66
 *
 * * iFOD2:
 * Tournier, J.-D.; Calamante, F. & Connelly, A. Improved probabilistic streamlines tractography by 2nd order integration over fibre orientation distributions. Proceedings of the International Society for Magnetic Resonance in Medicine, 2010, 1670
 *
 * * Nulldist1 / Nulldist2:
 * Morris, D. M.; Embleton, K. V. & Parker, G. J. Probabilistic fibre tracking: Differentiation of connections from chance events. NeuroImage, 2008, 42, 1329-1339
 *
 * * Tensor_Det:
 * Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000, 44, 625-632
 *
 * * Tensor_Prob:
 * Jones, D. Tractography Gone Wild: Probabilistic Fibre Tracking Using the Wild Bootstrap With Diffusion Tensor MRI. IEEE Transactions on Medical Imaging, 2008, 27, 1268-1274
 *
 * References based on command-line options:
 *
 * * -rk4:
 * Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000, 44, 625-632
 *
 * * -act, -backtrack, -seed_gmwmi:
 * Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. Anatomically-constrained tractography: Improved diffusion MRI streamlines tractography through effective use of anatomical information. NeuroImage, 2012, 62, 1924-1938
 *
 * * -seed_dynamic:
 * Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT2: Enabling dense quantitative assessment of brain white matter connectivity using streamlines tractography. NeuroImage, 2015, 119, 338-351.
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `TckgenOutputs`).
 */
function tckgen_execute(
    params: TckgenParameters,
    runner: Runner | null = null,
): TckgenOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(TCKGEN_METADATA);
    params = execution.params(params)
    const cargs = tckgen_cargs(params, execution)
    const ret = tckgen_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * tckgen
 *
 * Perform streamlines tractography.
 *
 * By default, tckgen produces a fixed number of streamlines, by attempting to seed from new random locations until the target number of streamlines have been selected (in other words, after all inclusion & exclusion criteria have been applied), or the maximum number of seeds has been exceeded (by default, this is 1000 x the desired number of selected streamlines). Use the -select and/or -seeds options to modify as required. See also the Seeding options section for alternative seeding strategies.
 *
 * Below is a list of available tracking algorithms, the input image data that they require, and a brief description of their behaviour:
 *
 * - FACT: Fiber Assigned by Continuous Tracking. A deterministic algorithm that takes as input a 4D image, with 3xN volumes, where N is the maximum number of fiber orientations in a voxel. Each triplet of volumes represents a 3D vector corresponding to a fiber orientation; the length of the vector additionally indicates some measure of density or anisotropy. As streamlines move from one voxel to another, the fiber orientation most collinear with the streamline orientation is selected (i.e. there is no intra-voxel interpolation).
 *
 * - iFOD1: First-order Integration over Fiber Orientation Distributions. A probabilistic algorithm that takes as input a Fiber Orientation Distribution (FOD) image represented in the Spherical Harmonic (SH) basis. At each streamline step, random samples from the local (trilinear interpolated) FOD are taken. A streamline is more probable to follow orientations where the FOD amplitude is large; but it may also rarely traverse orientations with small FOD amplitude.
 *
 * - iFOD2 (default): Second-order Integration over Fiber Orientation Distributions. A probabilistic algorithm that takes as input a Fiber Orientation Distribution (FOD) image represented in the Spherical Harmonic (SH) basis. Candidate streamline paths (based on short curved "arcs") are drawn, and the underlying (trilinear-interpolated) FOD amplitudes along those arcs are sampled. A streamline is more probable to follow a path where the FOD amplitudes along that path are large; but it may also rarely traverse orientations where the FOD amplitudes are small, as long as the amplitude remains above the FOD amplitude threshold along the entire path.
 *
 * - NullDist1 / NullDist2: Null Distribution tracking algorithms. These probabilistic algorithms expect as input the same image that was used when invoking the corresponding algorithm for which the null distribution is sought. These algorithms generate streamlines based on random orientation samples; that is, no image information relating to fiber orientations is used, and streamlines trajectories are determined entirely from random sampling. The NullDist2 algorithm is designed to be used in conjunction with iFOD2; NullDist1 should be used in conjunction with any first-order algorithm.
 *
 * - SD_STREAM: Streamlines tractography based on Spherical Deconvolution (SD). A deterministic algorithm that takes as input a Fiber Orientation Distribution (FOD) image represented in the Spherical Harmonic (SH) basis. At each streamline step, the local (trilinear-interpolated) FOD is sampled, and from the current streamline tangent orientation, a Newton optimisation on the sphere is performed in order to locate the orientation of the nearest FOD amplitude peak.
 *
 * - SeedTest: A dummy streamlines algorithm used for testing streamline seeding mechanisms. Any image can be used as input; the image will not be used in any way. For each seed point generated by the seeding mechanism(s), a streamline containing a single point corresponding to that seed location will be written to the output track file.
 *
 * - Tensor_Det: A deterministic algorithm that takes as input a 4D diffusion-weighted image (DWI) series. At each streamline step, the diffusion tensor is fitted to the local (trilinear-interpolated) diffusion data, and the streamline trajectory is determined as the principal eigenvector of that tensor.
 *
 * - Tensor_Prob: A probabilistic algorithm that takes as input a 4D diffusion-weighted image (DWI) series. Within each image voxel, a residual bootstrap is performed to obtain a unique realisation of the DWI data in that voxel for each streamline. These data are then sampled via trilinear interpolation at each streamline step, the diffusion tensor model is fitted, and the streamline follows the orientation of the principal eigenvector of that tensor.
 *
 * Note that the behaviour of the -angle option varies slightly depending on the order of integration: for any first-order method, this angle corresponds to the deviation in streamline trajectory per step; for higher-order methods, this corresponds to the change in underlying fibre orientation between the start and end points of each step.
 *
 * References:
 *
 * References based on streamlines algorithm used:
 *
 * * FACT:
 * Mori, S.; Crain, B. J.; Chacko, V. P. & van Zijl, P. C. M. Three-dimensional tracking of axonal projections in the brain by magnetic resonance imaging. Annals of Neurology, 1999, 45, 265-269
 *
 * * iFOD1 or SD_STREAM:
 * Tournier, J.-D.; Calamante, F. & Connelly, A. MRtrix: Diffusion tractography in crossing fiber regions. Int. J. Imaging Syst. Technol., 2012, 22, 53-66
 *
 * * iFOD2:
 * Tournier, J.-D.; Calamante, F. & Connelly, A. Improved probabilistic streamlines tractography by 2nd order integration over fibre orientation distributions. Proceedings of the International Society for Magnetic Resonance in Medicine, 2010, 1670
 *
 * * Nulldist1 / Nulldist2:
 * Morris, D. M.; Embleton, K. V. & Parker, G. J. Probabilistic fibre tracking: Differentiation of connections from chance events. NeuroImage, 2008, 42, 1329-1339
 *
 * * Tensor_Det:
 * Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000, 44, 625-632
 *
 * * Tensor_Prob:
 * Jones, D. Tractography Gone Wild: Probabilistic Fibre Tracking Using the Wild Bootstrap With Diffusion Tensor MRI. IEEE Transactions on Medical Imaging, 2008, 27, 1268-1274
 *
 * References based on command-line options:
 *
 * * -rk4:
 * Basser, P. J.; Pajevic, S.; Pierpaoli, C.; Duda, J. & Aldroubi, A. In vivo fiber tractography using DT-MRI data. Magnetic Resonance in Medicine, 2000, 44, 625-632
 *
 * * -act, -backtrack, -seed_gmwmi:
 * Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. Anatomically-constrained tractography: Improved diffusion MRI streamlines tractography through effective use of anatomical information. NeuroImage, 2012, 62, 1924-1938
 *
 * * -seed_dynamic:
 * Smith, R. E.; Tournier, J.-D.; Calamante, F. & Connelly, A. SIFT2: Enabling dense quantitative assessment of brain white matter connectivity using streamlines tractography. NeuroImage, 2015, 119, 338-351.
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param source The image containing the source data. The type of image data required depends on the algorithm used (see Description section).
 * @param tracks the output file containing the tracks generated.
 * @param algorithm specify the tractography algorithm to use. Valid choices are: FACT, iFOD1, iFOD2, Nulldist1, Nulldist2, SD_Stream, Seedtest, Tensor_Det, Tensor_Prob (default: iFOD2).
 * @param select set the desired number of streamlines to be selected by tckgen, after all selection criteria have been applied (i.e. inclusion/exclusion ROIs, min/max length, etc). tckgen will keep seeding streamlines until this number of streamlines have been selected, or the maximum allowed number of seeds has been exceeded (see -seeds option). By default, 5000 streamlines are to be selected. Set to zero to disable, which will result in streamlines being seeded until the number specified by -seeds has been reached.
 * @param step set the step size of the algorithm in mm (defaults: for first-order algorithms, 0.1 x voxelsize; if using RK4, 0.25 x voxelsize; for iFOD2: 0.5 x voxelsize).
 * @param angle set the maximum angle in degrees between successive steps (defaults: 60 for deterministic algorithms; 15 for iFOD1 / nulldist1; 45 for iFOD2 / nulldist2)
 * @param minlength set the minimum length of any track in mm (defaults: without ACT, 5 x voxelsize; with ACT, 2 x voxelsize).
 * @param maxlength set the maximum length of any track in mm (default: 100 x voxelsize).
 * @param cutoff set the FOD amplitude / fixel size / tensor FA cutoff for terminating tracks (defaults: 0.1 for FOD-based algorithms; 0.1 for fixel-based algorithms; 0.1 for tensor-based algorithms; threshold multiplied by 0.5 when using ACT).
 * @param trials set the maximum number of sampling trials at each point (only used for iFOD1 / iFOD2) (default: 1000).
 * @param noprecomputed do NOT pre-compute legendre polynomial values. Warning: this will slow down the algorithm by a factor of approximately 4.
 * @param rk4 use 4th-order Runge-Kutta integration (slower, but eliminates curvature overshoot in 1st-order deterministic methods)
 * @param stop stop propagating a streamline once it has traversed all include regions
 * @param downsample downsample the generated streamlines to reduce output file size (default is (samples-1) for iFOD2, no downsampling for all other algorithms)
 * @param seed_image seed streamlines entirely at random within a mask image 
 * @param seed_sphere spherical seed as four comma-separated values (XYZ position and radius)
 * @param seed_random_per_voxel seed a fixed number of streamlines per voxel in a mask image; random placement of seeds in each voxel
 * @param seed_grid_per_voxel seed a fixed number of streamlines per voxel in a mask image; place seeds on a 3D mesh grid (grid_size argument is per axis; so a grid_size of 3 results in 27 seeds per voxel)
 * @param seed_rejection seed from an image using rejection sampling (higher values = more probable to seed from)
 * @param seed_gmwmi seed from the grey matter - white matter interface (only valid if using ACT framework). Input image should be a 3D seeding volume; seeds drawn within this image will be optimised to the interface using the 5TT image provided using the -act option.
 * @param seed_dynamic determine seed points dynamically using the SIFT model (must not provide any other seeding mechanism). Note that while this seeding mechanism improves the distribution of reconstructed streamlines density, it should NOT be used as a substitute for the SIFT method itself.
 * @param seeds set the number of seeds that tckgen will attempt to track from. If this option is NOT provided, the default number of seeds is set to 1000Ã— the number of selected streamlines. If -select is NOT also specified, tckgen will continue tracking until this number of seeds has been attempted. However, if -select is also specified, tckgen will stop when the number of seeds attempted reaches the number specified here, OR when the number of streamlines selected reaches the number requested with the -select option. This can be used to prevent the program from running indefinitely when no or very few streamlines can be found that match the selection criteria. Setting this to zero will cause tckgen to keep attempting seeds until the number specified by -select has been reached.
 * @param max_attempts_per_seed set the maximum number of times that the tracking algorithm should attempt to find an appropriate tracking direction from a given seed point. This should be set high enough to ensure that an actual plausible seed point is not discarded prematurely as being unable to initiate tracking from. Higher settings may affect performance if many seeds are genuinely impossible to track from, as many attempts will still be made in vain for such seeds. (default: 1000)
 * @param seed_cutoff set the minimum FA or FOD amplitude for seeding tracks (default is the same as the normal -cutoff).
 * @param seed_unidirectional track from the seed point in one direction only (default is to track in both directions).
 * @param seed_direction specify a seeding direction for the tracking (this should be supplied as a vector of 3 comma-separated values.
 * @param output_seeds output the seed location of all successful streamlines to a file
 * @param include specify an inclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines must traverse ALL inclusion regions to be accepted.
 * @param include_ordered specify an inclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines must traverse ALL inclusion_ordered regions in the order they are specified in order to be accepted.
 * @param exclude specify an exclusion region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). Streamlines that enter ANY exclude region will be discarded.
 * @param mask specify a masking region of interest, as either a binary mask image, or as a sphere using 4 comma-separared values (x,y,z,radius). If defined, streamlines exiting the mask will be truncated.
 * @param act use the Anatomically-Constrained Tractography framework during tracking; provided image must be in the 5TT (five-tissue-type) format
 * @param backtrack allow tracks to be truncated and re-tracked if a poor structural termination is encountered
 * @param crop_at_gmwmi crop streamline endpoints more precisely as they cross the GM-WM interface
 * @param power raise the FOD to the power specified (defaults are: 1.0 for iFOD1; 1.0/nsamples for iFOD2).
 * @param samples set the number of FOD samples to take per step (Default: 4).
 * @param grad Provide the diffusion-weighted gradient scheme used in the acquisition in a text file. This should be supplied as a 4xN text file with each line is in the format [ X Y Z b ], where [ X Y Z ] describe the direction of the applied gradient, and b gives the b-value in units of s/mm^2. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param fslgrad Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `TckgenOutputs`).
 */
function tckgen(
    source: InputPathType,
    tracks: string,
    algorithm: string | null = null,
    select: number | null = null,
    step: number | null = null,
    angle: number | null = null,
    minlength: number | null = null,
    maxlength: number | null = null,
    cutoff: number | null = null,
    trials: number | null = null,
    noprecomputed: boolean = false,
    rk4: boolean = false,
    stop: boolean = false,
    downsample: number | null = null,
    seed_image: Array<TckgenSeedImageParameters> | null = null,
    seed_sphere: Array<TckgenSeedSphereParameters> | null = null,
    seed_random_per_voxel: Array<TckgenSeedRandomPerVoxelParameters> | null = null,
    seed_grid_per_voxel: Array<TckgenSeedGridPerVoxelParameters> | null = null,
    seed_rejection: Array<TckgenSeedRejectionParameters> | null = null,
    seed_gmwmi: Array<TckgenSeedGmwmiParameters> | null = null,
    seed_dynamic: InputPathType | null = null,
    seeds: number | null = null,
    max_attempts_per_seed: number | null = null,
    seed_cutoff: number | null = null,
    seed_unidirectional: boolean = false,
    seed_direction: Array<number> | null = null,
    output_seeds: string | null = null,
    include: Array<TckgenIncludeParameters> | null = null,
    include_ordered: Array<TckgenIncludeOrderedParameters> | null = null,
    exclude: Array<TckgenExcludeParameters> | null = null,
    mask: Array<TckgenMaskParameters> | null = null,
    act: InputPathType | null = null,
    backtrack: boolean = false,
    crop_at_gmwmi: boolean = false,
    power: number | null = null,
    samples: number | null = null,
    grad: InputPathType | null = null,
    fslgrad: TckgenFslgradParameters | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<TckgenConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
    runner: Runner | null = null,
): TckgenOutputs {
    const params = tckgen_params(source, tracks, algorithm, select, step, angle, minlength, maxlength, cutoff, trials, noprecomputed, rk4, stop, downsample, seed_image, seed_sphere, seed_random_per_voxel, seed_grid_per_voxel, seed_rejection, seed_gmwmi, seed_dynamic, seeds, max_attempts_per_seed, seed_cutoff, seed_unidirectional, seed_direction, output_seeds, include, include_ordered, exclude, mask, act, backtrack, crop_at_gmwmi, power, samples, grad, fslgrad, info, quiet, debug, force, nthreads, config, help, version)
    return tckgen_execute(params, runner);
}


export {
      TCKGEN_METADATA,
      TckgenOutputs,
      tckgen,
      tckgen_config_params,
      tckgen_exclude_params,
      tckgen_execute,
      tckgen_fslgrad_params,
      tckgen_include_ordered_params,
      tckgen_include_params,
      tckgen_mask_params,
      tckgen_params,
      tckgen_seed_gmwmi_params,
      tckgen_seed_grid_per_voxel_params,
      tckgen_seed_image_params,
      tckgen_seed_random_per_voxel_params,
      tckgen_seed_rejection_params,
      tckgen_seed_sphere_params,
      tckgen_various_file_1_params,
      tckgen_various_file_2_params,
      tckgen_various_file_params,
      tckgen_various_string_1_params,
      tckgen_various_string_2_params,
      tckgen_various_string_params,
};
