// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const BRAIN_SKIN_METADATA: Metadata = {
    id: "d0d1c3e3c3e6ac7de4b980399cd1d6fc70595b98.boutiques",
    name: "BrainSkin",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface BrainSkinParameters {
    "@type"?: "afni/BrainSkin";
    "surface": string;
    "skingrid_volume": InputPathType;
    "prefix": string;
    "plimit"?: number | null | undefined;
    "dlimit"?: number | null | undefined;
    "segdo"?: string | null | undefined;
    "voxelize"?: string | null | undefined;
    "infill"?: string | null | undefined;
    "out_file"?: InputPathType | null | undefined;
    "vol_skin"?: InputPathType | null | undefined;
    "vol_hull"?: InputPathType | null | undefined;
    "no_zero_attraction": boolean;
    "node_dbg"?: number | null | undefined;
}
type BrainSkinParametersTagged = Required<Pick<BrainSkinParameters, '@type'>> & BrainSkinParameters;


/**
 * Output object returned when calling `BrainSkinParameters(...)`.
 *
 * @interface
 */
interface BrainSkinOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * A bunch of triangles for closing the surface.
     */
    stitch_surface: OutputPathType;
    /**
     * Initial skin surface
     */
    initial_skin_surface: OutputPathType;
    /**
     * Reduced mesh version of initial skin surface.
     */
    reduced_skin_surface: OutputPathType;
    /**
     * Original surface inflated inside skin surface.
     */
    inflated_skin_surface: OutputPathType;
    /**
     * Surface patching voxels.
     */
    patching_voxels: OutputPathType;
    /**
     * Voxels inside original surface
     */
    surf_voxels: OutputPathType;
    /**
     * Mix of ptchvox and surfvox.
     */
    skin_voxels: OutputPathType;
    /**
     * Skin vox dataset filled in.
     */
    infilled_voxels: OutputPathType;
    /**
     * Results of computations for finding node pairs that span sulci.
     */
    node_pairs_results: OutputPathType;
    /**
     * Results of computations for inflating initial surface inside skin surface.
     */
    inflating_surface_results: OutputPathType;
    /**
     * Segments between node pairs spanning sulci.
     */
    segments_display: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param surface Surface to smooth or the domain over which DSET is defined.
 * @param skingrid_volume A high-res volume to provide a grid for voxelization steps.
 * @param prefix Prefix to use for variety of output files.
 * @param plimit Maximum length of path along surface in mm for node pairing.
 * @param dlimit Maximum length of Euclidean distance in mm for node pairing.
 * @param segdo Output a displayable object file that contains segments between paired nodes.
 * @param voxelize Voxelization method. Choose from: slow: Sure footed but slow, fast: Faster and works OK, mask: Fastest and works OK too (default).
 * @param infill Infill method. Choose from: slow: proper infill, but not needed, fast: brutish infill, all we need (default).
 * @param out_file Output intermediary results from skin forming step.
 * @param vol_skin Deform an Icosahedron to match the outer boundary of a mask volume.
 * @param vol_hull Deform an Icosahedron to match the convex hull of a mask volume.
 * @param no_zero_attraction With vol_skin, the surface will try to shrink aggressively, even if there is no promise of non-zero values below.
 * @param node_dbg Output debugging information for node N for -vol_skin and -vol_hull options.
 *
 * @returns Parameter dictionary
 */
function brain_skin_params(
    surface: string,
    skingrid_volume: InputPathType,
    prefix: string,
    plimit: number | null = null,
    dlimit: number | null = null,
    segdo: string | null = null,
    voxelize: string | null = null,
    infill: string | null = null,
    out_file: InputPathType | null = null,
    vol_skin: InputPathType | null = null,
    vol_hull: InputPathType | null = null,
    no_zero_attraction: boolean = false,
    node_dbg: number | null = null,
): BrainSkinParametersTagged {
    const params = {
        "@type": "afni/BrainSkin" as const,
        "surface": surface,
        "skingrid_volume": skingrid_volume,
        "prefix": prefix,
        "no_zero_attraction": no_zero_attraction,
    };
    if (plimit !== null) {
        params["plimit"] = plimit;
    }
    if (dlimit !== null) {
        params["dlimit"] = dlimit;
    }
    if (segdo !== null) {
        params["segdo"] = segdo;
    }
    if (voxelize !== null) {
        params["voxelize"] = voxelize;
    }
    if (infill !== null) {
        params["infill"] = infill;
    }
    if (out_file !== null) {
        params["out_file"] = out_file;
    }
    if (vol_skin !== null) {
        params["vol_skin"] = vol_skin;
    }
    if (vol_hull !== null) {
        params["vol_hull"] = vol_hull;
    }
    if (node_dbg !== null) {
        params["node_dbg"] = node_dbg;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function brain_skin_cargs(
    params: BrainSkinParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("BrainSkin");
    cargs.push((params["surface"] ?? null));
    cargs.push(
        "-skingrid",
        execution.inputFile((params["skingrid_volume"] ?? null))
    );
    cargs.push(
        "-prefix",
        (params["prefix"] ?? null)
    );
    if ((params["plimit"] ?? null) !== null) {
        cargs.push(
            "-plimit",
            String((params["plimit"] ?? null))
        );
    }
    if ((params["dlimit"] ?? null) !== null) {
        cargs.push(
            "-dlimit",
            String((params["dlimit"] ?? null))
        );
    }
    if ((params["segdo"] ?? null) !== null) {
        cargs.push(
            "-segdo",
            (params["segdo"] ?? null)
        );
    }
    if ((params["voxelize"] ?? null) !== null) {
        cargs.push(
            "-voxelize",
            (params["voxelize"] ?? null)
        );
    }
    if ((params["infill"] ?? null) !== null) {
        cargs.push(
            "-infill",
            (params["infill"] ?? null)
        );
    }
    if ((params["out_file"] ?? null) !== null) {
        cargs.push(
            "-out",
            execution.inputFile((params["out_file"] ?? null))
        );
    }
    if ((params["vol_skin"] ?? null) !== null) {
        cargs.push(
            "-vol_skin",
            execution.inputFile((params["vol_skin"] ?? null))
        );
    }
    if ((params["vol_hull"] ?? null) !== null) {
        cargs.push(
            "-vol_hull",
            execution.inputFile((params["vol_hull"] ?? null))
        );
    }
    if ((params["no_zero_attraction"] ?? false)) {
        cargs.push("-no_zero_attraction");
    }
    if ((params["node_dbg"] ?? null) !== null) {
        cargs.push(
            "-node_dbg",
            String((params["node_dbg"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function brain_skin_outputs(
    params: BrainSkinParameters,
    execution: Execution,
): BrainSkinOutputs {
    const ret: BrainSkinOutputs = {
        root: execution.outputFile("."),
        stitch_surface: execution.outputFile([(params["prefix"] ?? null), ".stitch.gii"].join('')),
        initial_skin_surface: execution.outputFile([(params["prefix"] ?? null), ".skin.gii"].join('')),
        reduced_skin_surface: execution.outputFile([(params["prefix"] ?? null), ".skin_simp.gii"].join('')),
        inflated_skin_surface: execution.outputFile([(params["prefix"] ?? null), ".skin.isotopic.gii"].join('')),
        patching_voxels: execution.outputFile([(params["prefix"] ?? null), ".ptchvox+orig"].join('')),
        surf_voxels: execution.outputFile([(params["prefix"] ?? null), ".surfvox+orig"].join('')),
        skin_voxels: execution.outputFile([(params["prefix"] ?? null), ".skinvox+orig"].join('')),
        infilled_voxels: execution.outputFile([(params["prefix"] ?? null), ".infilled+orig"].join('')),
        node_pairs_results: execution.outputFile([(params["prefix"] ?? null), ".niml.dset"].join('')),
        inflating_surface_results: execution.outputFile([(params["prefix"] ?? null), ".areas.niml.dset"].join('')),
        segments_display: execution.outputFile([(params["prefix"] ?? null), ".1D.do"].join('')),
    };
    return ret;
}


/**
 * BrainSkin
 *
 * A program to create an unfolded surface that wraps the brain (skin) and Gyrification Indices.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `BrainSkinOutputs`).
 */
function brain_skin_execute(
    params: BrainSkinParameters,
    runner: Runner | null = null,
): BrainSkinOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(BRAIN_SKIN_METADATA);
    params = execution.params(params)
    const cargs = brain_skin_cargs(params, execution)
    const ret = brain_skin_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * BrainSkin
 *
 * A program to create an unfolded surface that wraps the brain (skin) and Gyrification Indices.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param surface Surface to smooth or the domain over which DSET is defined.
 * @param skingrid_volume A high-res volume to provide a grid for voxelization steps.
 * @param prefix Prefix to use for variety of output files.
 * @param plimit Maximum length of path along surface in mm for node pairing.
 * @param dlimit Maximum length of Euclidean distance in mm for node pairing.
 * @param segdo Output a displayable object file that contains segments between paired nodes.
 * @param voxelize Voxelization method. Choose from: slow: Sure footed but slow, fast: Faster and works OK, mask: Fastest and works OK too (default).
 * @param infill Infill method. Choose from: slow: proper infill, but not needed, fast: brutish infill, all we need (default).
 * @param out_file Output intermediary results from skin forming step.
 * @param vol_skin Deform an Icosahedron to match the outer boundary of a mask volume.
 * @param vol_hull Deform an Icosahedron to match the convex hull of a mask volume.
 * @param no_zero_attraction With vol_skin, the surface will try to shrink aggressively, even if there is no promise of non-zero values below.
 * @param node_dbg Output debugging information for node N for -vol_skin and -vol_hull options.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `BrainSkinOutputs`).
 */
function brain_skin(
    surface: string,
    skingrid_volume: InputPathType,
    prefix: string,
    plimit: number | null = null,
    dlimit: number | null = null,
    segdo: string | null = null,
    voxelize: string | null = null,
    infill: string | null = null,
    out_file: InputPathType | null = null,
    vol_skin: InputPathType | null = null,
    vol_hull: InputPathType | null = null,
    no_zero_attraction: boolean = false,
    node_dbg: number | null = null,
    runner: Runner | null = null,
): BrainSkinOutputs {
    const params = brain_skin_params(surface, skingrid_volume, prefix, plimit, dlimit, segdo, voxelize, infill, out_file, vol_skin, vol_hull, no_zero_attraction, node_dbg)
    return brain_skin_execute(params, runner);
}


export {
      BRAIN_SKIN_METADATA,
      BrainSkinOutputs,
      brain_skin,
      brain_skin_execute,
      brain_skin_params,
};
