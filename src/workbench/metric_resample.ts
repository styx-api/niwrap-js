// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const METRIC_RESAMPLE_METADATA: Metadata = {
    id: "4d1e7adf2fc4fb2797a0f461eb652d3ebf3b8ce7.boutiques",
    name: "metric-resample",
    package: "workbench",
    container_image_tag: "brainlife/connectome_workbench:1.5.0-freesurfer-update",
};


interface MetricResampleAreaSurfsParameters {
    "@type"?: "area_surfs";
    "current_area": InputPathType;
    "new_area": InputPathType;
}
type MetricResampleAreaSurfsParametersTagged = Required<Pick<MetricResampleAreaSurfsParameters, '@type'>> & MetricResampleAreaSurfsParameters;


interface MetricResampleAreaMetricsParameters {
    "@type"?: "area_metrics";
    "current_area": InputPathType;
    "new_area": InputPathType;
}
type MetricResampleAreaMetricsParametersTagged = Required<Pick<MetricResampleAreaMetricsParameters, '@type'>> & MetricResampleAreaMetricsParameters;


interface MetricResampleParameters {
    "@type"?: "workbench/metric-resample";
    "metric_in": InputPathType;
    "current_sphere": InputPathType;
    "new_sphere": InputPathType;
    "method": string;
    "metric_out": string;
    "area_surfs"?: MetricResampleAreaSurfsParameters | null | undefined;
    "area_metrics"?: MetricResampleAreaMetricsParameters | null | undefined;
    "opt_current_roi_roi_metric"?: InputPathType | null | undefined;
    "opt_valid_roi_out_roi_out"?: string | null | undefined;
    "opt_largest": boolean;
    "opt_bypass_sphere_check": boolean;
}
type MetricResampleParametersTagged = Required<Pick<MetricResampleParameters, '@type'>> & MetricResampleParameters;


/**
 * Build parameters.
 *
 * @param current_area a relevant anatomical surface with <current-sphere> mesh
 * @param new_area a relevant anatomical surface with <new-sphere> mesh
 *
 * @returns Parameter dictionary
 */
function metric_resample_area_surfs_params(
    current_area: InputPathType,
    new_area: InputPathType,
): MetricResampleAreaSurfsParametersTagged {
    const params = {
        "@type": "area_surfs" as const,
        "current_area": current_area,
        "new_area": new_area,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function metric_resample_area_surfs_cargs(
    params: MetricResampleAreaSurfsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-area-surfs");
    cargs.push(execution.inputFile((params["current_area"] ?? null)));
    cargs.push(execution.inputFile((params["new_area"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param current_area a metric file with vertex areas for <current-sphere> mesh
 * @param new_area a metric file with vertex areas for <new-sphere> mesh
 *
 * @returns Parameter dictionary
 */
function metric_resample_area_metrics_params(
    current_area: InputPathType,
    new_area: InputPathType,
): MetricResampleAreaMetricsParametersTagged {
    const params = {
        "@type": "area_metrics" as const,
        "current_area": current_area,
        "new_area": new_area,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function metric_resample_area_metrics_cargs(
    params: MetricResampleAreaMetricsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-area-metrics");
    cargs.push(execution.inputFile((params["current_area"] ?? null)));
    cargs.push(execution.inputFile((params["new_area"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `MetricResampleParameters(...)`.
 *
 * @interface
 */
interface MetricResampleOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output metric
     */
    metric_out: OutputPathType;
    /**
     * output the ROI of vertices that got data from valid source vertices: the output roi as a metric
     */
    opt_valid_roi_out_roi_out: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param metric_in the metric file to resample
 * @param current_sphere a sphere surface with the mesh that the metric is currently on
 * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
 * @param method the method name
 * @param metric_out the output metric
 * @param area_surfs specify surfaces to do vertex area correction based on
 * @param area_metrics specify vertex area metrics to do area correction based on
 * @param opt_current_roi_roi_metric use an input roi on the current mesh to exclude non-data vertices: the roi, as a metric file
 * @param opt_valid_roi_out_roi_out output the ROI of vertices that got data from valid source vertices: the output roi as a metric
 * @param opt_largest use only the value of the vertex with the largest weight
 * @param opt_bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
 *
 * @returns Parameter dictionary
 */
function metric_resample_params(
    metric_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    metric_out: string,
    area_surfs: MetricResampleAreaSurfsParameters | null = null,
    area_metrics: MetricResampleAreaMetricsParameters | null = null,
    opt_current_roi_roi_metric: InputPathType | null = null,
    opt_valid_roi_out_roi_out: string | null = null,
    opt_largest: boolean = false,
    opt_bypass_sphere_check: boolean = false,
): MetricResampleParametersTagged {
    const params = {
        "@type": "workbench/metric-resample" as const,
        "metric_in": metric_in,
        "current_sphere": current_sphere,
        "new_sphere": new_sphere,
        "method": method,
        "metric_out": metric_out,
        "opt_largest": opt_largest,
        "opt_bypass_sphere_check": opt_bypass_sphere_check,
    };
    if (area_surfs !== null) {
        params["area_surfs"] = area_surfs;
    }
    if (area_metrics !== null) {
        params["area_metrics"] = area_metrics;
    }
    if (opt_current_roi_roi_metric !== null) {
        params["opt_current_roi_roi_metric"] = opt_current_roi_roi_metric;
    }
    if (opt_valid_roi_out_roi_out !== null) {
        params["opt_valid_roi_out_roi_out"] = opt_valid_roi_out_roi_out;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function metric_resample_cargs(
    params: MetricResampleParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("wb_command");
    cargs.push("-metric-resample");
    cargs.push(execution.inputFile((params["metric_in"] ?? null)));
    cargs.push(execution.inputFile((params["current_sphere"] ?? null)));
    cargs.push(execution.inputFile((params["new_sphere"] ?? null)));
    cargs.push((params["method"] ?? null));
    cargs.push((params["metric_out"] ?? null));
    if ((params["area_surfs"] ?? null) !== null) {
        cargs.push(...metric_resample_area_surfs_cargs((params["area_surfs"] ?? null), execution));
    }
    if ((params["area_metrics"] ?? null) !== null) {
        cargs.push(...metric_resample_area_metrics_cargs((params["area_metrics"] ?? null), execution));
    }
    if ((params["opt_current_roi_roi_metric"] ?? null) !== null) {
        cargs.push(
            "-current-roi",
            execution.inputFile((params["opt_current_roi_roi_metric"] ?? null))
        );
    }
    if ((params["opt_valid_roi_out_roi_out"] ?? null) !== null) {
        cargs.push(
            "-valid-roi-out",
            (params["opt_valid_roi_out_roi_out"] ?? null)
        );
    }
    if ((params["opt_largest"] ?? false)) {
        cargs.push("-largest");
    }
    if ((params["opt_bypass_sphere_check"] ?? false)) {
        cargs.push("-bypass-sphere-check");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function metric_resample_outputs(
    params: MetricResampleParameters,
    execution: Execution,
): MetricResampleOutputs {
    const ret: MetricResampleOutputs = {
        root: execution.outputFile("."),
        metric_out: execution.outputFile([(params["metric_out"] ?? null)].join('')),
        opt_valid_roi_out_roi_out: ((params["opt_valid_roi_out_roi_out"] ?? null) !== null) ? execution.outputFile([(params["opt_valid_roi_out_roi_out"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * metric-resample
 *
 * Resample a metric file to a different mesh.
 *
 * Resamples a metric file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
 *
 * The ADAP_BARY_AREA method is recommended for ordinary metric data, because it should use all data while downsampling, unlike BARYCENTRIC.  The recommended areas option for most data is individual midthicknesses for individual data, and averaged vertex area metrics from individual midthicknesses for group average data.
 *
 * The -current-roi option only masks the input, the output may be slightly dilated in comparison, consider using -metric-mask on the output when using -current-roi.
 *
 * The -largest option results in nearest vertex behavior when used with BARYCENTRIC.  When resampling a binary metric, consider thresholding at 0.5 after resampling rather than using -largest.
 *
 * The <method> argument must be one of the following:
 *
 * ADAP_BARY_AREA
 * BARYCENTRIC
 * .
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MetricResampleOutputs`).
 */
function metric_resample_execute(
    params: MetricResampleParameters,
    runner: Runner | null = null,
): MetricResampleOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(METRIC_RESAMPLE_METADATA);
    params = execution.params(params)
    const cargs = metric_resample_cargs(params, execution)
    const ret = metric_resample_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * metric-resample
 *
 * Resample a metric file to a different mesh.
 *
 * Resamples a metric file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
 *
 * The ADAP_BARY_AREA method is recommended for ordinary metric data, because it should use all data while downsampling, unlike BARYCENTRIC.  The recommended areas option for most data is individual midthicknesses for individual data, and averaged vertex area metrics from individual midthicknesses for group average data.
 *
 * The -current-roi option only masks the input, the output may be slightly dilated in comparison, consider using -metric-mask on the output when using -current-roi.
 *
 * The -largest option results in nearest vertex behavior when used with BARYCENTRIC.  When resampling a binary metric, consider thresholding at 0.5 after resampling rather than using -largest.
 *
 * The <method> argument must be one of the following:
 *
 * ADAP_BARY_AREA
 * BARYCENTRIC
 * .
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param metric_in the metric file to resample
 * @param current_sphere a sphere surface with the mesh that the metric is currently on
 * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
 * @param method the method name
 * @param metric_out the output metric
 * @param area_surfs specify surfaces to do vertex area correction based on
 * @param area_metrics specify vertex area metrics to do area correction based on
 * @param opt_current_roi_roi_metric use an input roi on the current mesh to exclude non-data vertices: the roi, as a metric file
 * @param opt_valid_roi_out_roi_out output the ROI of vertices that got data from valid source vertices: the output roi as a metric
 * @param opt_largest use only the value of the vertex with the largest weight
 * @param opt_bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MetricResampleOutputs`).
 */
function metric_resample(
    metric_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    metric_out: string,
    area_surfs: MetricResampleAreaSurfsParameters | null = null,
    area_metrics: MetricResampleAreaMetricsParameters | null = null,
    opt_current_roi_roi_metric: InputPathType | null = null,
    opt_valid_roi_out_roi_out: string | null = null,
    opt_largest: boolean = false,
    opt_bypass_sphere_check: boolean = false,
    runner: Runner | null = null,
): MetricResampleOutputs {
    const params = metric_resample_params(metric_in, current_sphere, new_sphere, method, metric_out, area_surfs, area_metrics, opt_current_roi_roi_metric, opt_valid_roi_out_roi_out, opt_largest, opt_bypass_sphere_check)
    return metric_resample_execute(params, runner);
}


export {
      METRIC_RESAMPLE_METADATA,
      MetricResampleOutputs,
      metric_resample,
      metric_resample_area_metrics_params,
      metric_resample_area_surfs_params,
      metric_resample_execute,
      metric_resample_params,
};
