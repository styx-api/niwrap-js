// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ANTS_JOINT_FUSION_METADATA: Metadata = {
    id: "ead66a78d253bbef7d330bdf2dee14d07d54b7fe.boutiques",
    name: "antsJointFusion",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface AntsJointFusionParameters {
    "@type": "ants.antsJointFusion";
    "image_dimensionality"?: 2 | 3 | 4 | null | undefined;
    "target_image": Array<InputPathType>;
    "atlas_image": Array<InputPathType>;
    "atlas_segmentation": InputPathType;
    "alpha"?: number | null | undefined;
    "beta"?: number | null | undefined;
    "constrain_nonnegative"?: 0 | 1 | null | undefined;
    "patch_radius"?: string | null | undefined;
    "patch_metric"?: "PC" | "MSQ" | null | undefined;
    "search_radius"?: string | null | undefined;
    "exclusion_image"?: InputPathType | null | undefined;
    "mask_image"?: InputPathType | null | undefined;
    "output": string;
    "verbose"?: 0 | 1 | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "ants.antsJointFusion": ants_joint_fusion_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "ants.antsJointFusion": ants_joint_fusion_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `ants_joint_fusion(...)`.
 *
 * @interface
 */
interface AntsJointFusionOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output label fusion image.
     */
    label_fusion_image: OutputPathType;
    /**
     * The output intensity fusion image format.
     */
    intensity_fusion_image: OutputPathType;
    /**
     * The output label posterior probability image format.
     */
    label_posterior_probability_image: OutputPathType;
    /**
     * The output atlas voting weight image format.
     */
    atlas_voting_weight_image: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param target_image The target image (or multimodal target images) assumed to be aligned to a common image domain.
 * @param atlas_image The atlas image (or multimodal atlas images) assumed to be aligned to a common image domain.
 * @param atlas_segmentation The atlas segmentation images. For performing label fusion the number of specified segmentations should be identical to the number of atlas image sets.
 * @param output The output is the intensity and/or label fusion image. Additional optional outputs include the label posterior probability images and the atlas voting weight images.
 * @param image_dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, the program tries to infer the dimensionality from the input image.
 * @param alpha Regularization term added to matrix Mx for calculating the inverse. Default = 0.1.
 * @param beta Exponent for mapping intensity difference to the joint error. Default = 2.0.
 * @param constrain_nonnegative Constrain solution to non-negative weights.
 * @param patch_radius Patch radius for similarity measures. Default = 2x2x2.
 * @param patch_metric Metric to be used in determining the most similar neighborhood patch. Options include Pearson's correlation (PC) and mean squares (MSQ). Default = PC (Pearson correlation).
 * @param search_radius Search radius for similarity measures. Default = 3x3x3. One can also specify an image where the value at the voxel specifies the isotropic search radius at that voxel.
 * @param exclusion_image Specify an exclusion region for the given label.
 * @param mask_image If a mask image is specified, fusion is only performed in the mask region.
 * @param verbose Verbose output.
 *
 * @returns Parameter dictionary
 */
function ants_joint_fusion_params(
    target_image: Array<InputPathType>,
    atlas_image: Array<InputPathType>,
    atlas_segmentation: InputPathType,
    output: string,
    image_dimensionality: 2 | 3 | 4 | null = null,
    alpha: number | null = 0.1,
    beta: number | null = 2.0,
    constrain_nonnegative: 0 | 1 | null = null,
    patch_radius: string | null = "2x2x2",
    patch_metric: "PC" | "MSQ" | null = "PC",
    search_radius: string | null = "3x3x3",
    exclusion_image: InputPathType | null = null,
    mask_image: InputPathType | null = null,
    verbose: 0 | 1 | null = null,
): AntsJointFusionParameters {
    const params = {
        "@type": "ants.antsJointFusion" as const,
        "target_image": target_image,
        "atlas_image": atlas_image,
        "atlas_segmentation": atlas_segmentation,
        "output": output,
    };
    if (image_dimensionality !== null) {
        params["image_dimensionality"] = image_dimensionality;
    }
    if (alpha !== null) {
        params["alpha"] = alpha;
    }
    if (beta !== null) {
        params["beta"] = beta;
    }
    if (constrain_nonnegative !== null) {
        params["constrain_nonnegative"] = constrain_nonnegative;
    }
    if (patch_radius !== null) {
        params["patch_radius"] = patch_radius;
    }
    if (patch_metric !== null) {
        params["patch_metric"] = patch_metric;
    }
    if (search_radius !== null) {
        params["search_radius"] = search_radius;
    }
    if (exclusion_image !== null) {
        params["exclusion_image"] = exclusion_image;
    }
    if (mask_image !== null) {
        params["mask_image"] = mask_image;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_joint_fusion_cargs(
    params: AntsJointFusionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("antsJointFusion");
    if ((params["image_dimensionality"] ?? null) !== null) {
        cargs.push(
            "--image-dimensionality",
            String((params["image_dimensionality"] ?? null))
        );
    }
    cargs.push(
        "--target-image",
        ...(params["target_image"] ?? null).map(f => execution.inputFile(f))
    );
    cargs.push(
        "--atlas-image",
        ...(params["atlas_image"] ?? null).map(f => execution.inputFile(f))
    );
    cargs.push(
        "--atlas-segmentation",
        execution.inputFile((params["atlas_segmentation"] ?? null))
    );
    if ((params["alpha"] ?? null) !== null) {
        cargs.push(
            "--alpha",
            String((params["alpha"] ?? null))
        );
    }
    if ((params["beta"] ?? null) !== null) {
        cargs.push(
            "--beta",
            String((params["beta"] ?? null))
        );
    }
    if ((params["constrain_nonnegative"] ?? null) !== null) {
        cargs.push(
            "--constrain-nonnegative",
            String((params["constrain_nonnegative"] ?? null))
        );
    }
    if ((params["patch_radius"] ?? null) !== null) {
        cargs.push(
            "--patch-radius",
            (params["patch_radius"] ?? null)
        );
    }
    if ((params["patch_metric"] ?? null) !== null) {
        cargs.push(
            "--patch-metric",
            (params["patch_metric"] ?? null)
        );
    }
    if ((params["search_radius"] ?? null) !== null) {
        cargs.push(
            "--search-radius",
            (params["search_radius"] ?? null)
        );
    }
    if ((params["exclusion_image"] ?? null) !== null) {
        cargs.push(
            "--exclusion-image",
            execution.inputFile((params["exclusion_image"] ?? null))
        );
    }
    if ((params["mask_image"] ?? null) !== null) {
        cargs.push(
            "--mask-image",
            execution.inputFile((params["mask_image"] ?? null))
        );
    }
    cargs.push(
        "--output",
        (params["output"] ?? null)
    );
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "--verbose",
            String((params["verbose"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ants_joint_fusion_outputs(
    params: AntsJointFusionParameters,
    execution: Execution,
): AntsJointFusionOutputs {
    const ret: AntsJointFusionOutputs = {
        root: execution.outputFile("."),
        label_fusion_image: execution.outputFile(["[LABELFUSIONIMAGE]"].join('')),
        intensity_fusion_image: execution.outputFile(["[INTENSITYFUSIONIMAGEFILENAMEFORMAT]"].join('')),
        label_posterior_probability_image: execution.outputFile(["[LABELPOSTERIORPROBABILITYIMAGEFILENAMEFORMAT]"].join('')),
        atlas_voting_weight_image: execution.outputFile(["[ATLASVOTINGWEIGHTIMAGEFILENAMEFORMAT]"].join('')),
    };
    return ret;
}


/**
 * antsJointFusion is an image fusion algorithm developed by Hongzhi Wang and Paul Yushkevich. This implementation is based on Paul's original ITK-style implementation and Brian's ANTsR implementation. The original label fusion framework was extended to accommodate intensities.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsJointFusionOutputs`).
 */
function ants_joint_fusion_execute(
    params: AntsJointFusionParameters,
    runner: Runner | null = null,
): AntsJointFusionOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ANTS_JOINT_FUSION_METADATA);
    params = execution.params(params)
    const cargs = ants_joint_fusion_cargs(params, execution)
    const ret = ants_joint_fusion_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * antsJointFusion is an image fusion algorithm developed by Hongzhi Wang and Paul Yushkevich. This implementation is based on Paul's original ITK-style implementation and Brian's ANTsR implementation. The original label fusion framework was extended to accommodate intensities.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param target_image The target image (or multimodal target images) assumed to be aligned to a common image domain.
 * @param atlas_image The atlas image (or multimodal atlas images) assumed to be aligned to a common image domain.
 * @param atlas_segmentation The atlas segmentation images. For performing label fusion the number of specified segmentations should be identical to the number of atlas image sets.
 * @param output The output is the intensity and/or label fusion image. Additional optional outputs include the label posterior probability images and the atlas voting weight images.
 * @param image_dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, the program tries to infer the dimensionality from the input image.
 * @param alpha Regularization term added to matrix Mx for calculating the inverse. Default = 0.1.
 * @param beta Exponent for mapping intensity difference to the joint error. Default = 2.0.
 * @param constrain_nonnegative Constrain solution to non-negative weights.
 * @param patch_radius Patch radius for similarity measures. Default = 2x2x2.
 * @param patch_metric Metric to be used in determining the most similar neighborhood patch. Options include Pearson's correlation (PC) and mean squares (MSQ). Default = PC (Pearson correlation).
 * @param search_radius Search radius for similarity measures. Default = 3x3x3. One can also specify an image where the value at the voxel specifies the isotropic search radius at that voxel.
 * @param exclusion_image Specify an exclusion region for the given label.
 * @param mask_image If a mask image is specified, fusion is only performed in the mask region.
 * @param verbose Verbose output.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsJointFusionOutputs`).
 */
function ants_joint_fusion(
    target_image: Array<InputPathType>,
    atlas_image: Array<InputPathType>,
    atlas_segmentation: InputPathType,
    output: string,
    image_dimensionality: 2 | 3 | 4 | null = null,
    alpha: number | null = 0.1,
    beta: number | null = 2.0,
    constrain_nonnegative: 0 | 1 | null = null,
    patch_radius: string | null = "2x2x2",
    patch_metric: "PC" | "MSQ" | null = "PC",
    search_radius: string | null = "3x3x3",
    exclusion_image: InputPathType | null = null,
    mask_image: InputPathType | null = null,
    verbose: 0 | 1 | null = null,
    runner: Runner | null = null,
): AntsJointFusionOutputs {
    const params = ants_joint_fusion_params(target_image, atlas_image, atlas_segmentation, output, image_dimensionality, alpha, beta, constrain_nonnegative, patch_radius, patch_metric, search_radius, exclusion_image, mask_image, verbose)
    return ants_joint_fusion_execute(params, runner);
}


export {
      ANTS_JOINT_FUSION_METADATA,
      AntsJointFusionOutputs,
      AntsJointFusionParameters,
      ants_joint_fusion,
      ants_joint_fusion_execute,
      ants_joint_fusion_params,
};
