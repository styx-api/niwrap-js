// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_1DEVAL_METADATA: Metadata = {
    id: "2d05acc3dd71b6fa154f28feedd32f1badace561.boutiques",
    name: "1deval",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V1devalParameters {
    "@type": "afni.1deval";
    "del"?: number | null | undefined;
    "start"?: number | null | undefined;
    "num"?: number | null | undefined;
    "index"?: InputPathType | null | undefined;
    "1D": boolean;
    "symbols"?: Array<InputPathType> | null | undefined;
    "symbol_values"?: Array<string> | null | undefined;
    "expression": string;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "afni.1deval": v_1deval_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "afni.1deval": v_1deval_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `v_1deval(...)`.
 *
 * @interface
 */
interface V1devalOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output of evaluated expression.
     */
    output_1_d: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param expression Expression to evaluate.
 * @param del Use 'd' as the step for a single undetermined variable in the expression.
 * @param start Start at value 's' for a single undetermined variable in the expression.
 * @param num Evaluate the expression 'n' times.
 * @param index Read index column from file i.1D and write it out as 1st column of output.
 * @param v_1_d Write output in the form of a single '1D:' string suitable for input on the command line of another program.
 * @param symbols Read time series file and assign it to the symbol 'a'. Letters 'a' to 'z' may be used as symbols.
 * @param symbol_values Assign a fixed numerical value to the symbol 'a'. Letters 'a' to 'z' may be used as symbols.
 *
 * @returns Parameter dictionary
 */
function v_1deval_params(
    expression: string,
    del: number | null = null,
    start: number | null = null,
    num: number | null = null,
    index: InputPathType | null = null,
    v_1_d: boolean = false,
    symbols: Array<InputPathType> | null = null,
    symbol_values: Array<string> | null = null,
): V1devalParameters {
    const params = {
        "@type": "afni.1deval" as const,
        "1D": v_1_d,
        "expression": expression,
    };
    if (del !== null) {
        params["del"] = del;
    }
    if (start !== null) {
        params["start"] = start;
    }
    if (num !== null) {
        params["num"] = num;
    }
    if (index !== null) {
        params["index"] = index;
    }
    if (symbols !== null) {
        params["symbols"] = symbols;
    }
    if (symbol_values !== null) {
        params["symbol_values"] = symbol_values;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function v_1deval_cargs(
    params: V1devalParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("1deval");
    if ((params["del"] ?? null) !== null) {
        cargs.push(
            "-del",
            String((params["del"] ?? null))
        );
    }
    if ((params["start"] ?? null) !== null) {
        cargs.push(
            "-start",
            String((params["start"] ?? null))
        );
    }
    if ((params["num"] ?? null) !== null) {
        cargs.push(
            "-num",
            String((params["num"] ?? null))
        );
    }
    if ((params["index"] ?? null) !== null) {
        cargs.push(
            "-index",
            execution.inputFile((params["index"] ?? null))
        );
    }
    if ((params["1D"] ?? null)) {
        cargs.push("-1D:");
    }
    if ((params["symbols"] ?? null) !== null) {
        cargs.push(
            "-a",
            ...(params["symbols"] ?? null).map(f => execution.inputFile(f))
        );
    }
    if ((params["symbol_values"] ?? null) !== null) {
        cargs.push(
            "-a=",
            ...(params["symbol_values"] ?? null)
        );
    }
    cargs.push(
        "-expr",
        (params["expression"] ?? null)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function v_1deval_outputs(
    params: V1devalParameters,
    execution: Execution,
): V1devalOutputs {
    const ret: V1devalOutputs = {
        root: execution.outputFile("."),
        output_1_d: execution.outputFile(["output.1D"].join('')),
    };
    return ret;
}


/**
 * Evaluates an expression that may include columns of data from one or more text files and writes the result to stdout.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param execution The execution object.
 *
 * @returns NamedTuple of outputs (described in `V1devalOutputs`).
 */
function v_1deval_execute(
    params: V1devalParameters,
    execution: Execution,
): V1devalOutputs {
    params = execution.params(params)
    const cargs = v_1deval_cargs(params, execution)
    const ret = v_1deval_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * Evaluates an expression that may include columns of data from one or more text files and writes the result to stdout.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param expression Expression to evaluate.
 * @param del Use 'd' as the step for a single undetermined variable in the expression.
 * @param start Start at value 's' for a single undetermined variable in the expression.
 * @param num Evaluate the expression 'n' times.
 * @param index Read index column from file i.1D and write it out as 1st column of output.
 * @param v_1_d Write output in the form of a single '1D:' string suitable for input on the command line of another program.
 * @param symbols Read time series file and assign it to the symbol 'a'. Letters 'a' to 'z' may be used as symbols.
 * @param symbol_values Assign a fixed numerical value to the symbol 'a'. Letters 'a' to 'z' may be used as symbols.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V1devalOutputs`).
 */
function v_1deval(
    expression: string,
    del: number | null = null,
    start: number | null = null,
    num: number | null = null,
    index: InputPathType | null = null,
    v_1_d: boolean = false,
    symbols: Array<InputPathType> | null = null,
    symbol_values: Array<string> | null = null,
    runner: Runner | null = null,
): V1devalOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_1DEVAL_METADATA);
    const params = v_1deval_params(expression, del, start, num, index, v_1_d, symbols, symbol_values)
    return v_1deval_execute(params, execution);
}


export {
      V1devalOutputs,
      V1devalParameters,
      V_1DEVAL_METADATA,
      v_1deval,
      v_1deval_cargs,
      v_1deval_execute,
      v_1deval_outputs,
      v_1deval_params,
};
