// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const EXTRACT_SEG_WAVEFORM_METADATA: Metadata = {
    id: "871847f8fc6a902c317b011804ed6c2c847d8460.boutiques",
    name: "extract_seg_waveform",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface ExtractSegWaveformParameters {
    "__STYXTYPE__": "extract_seg_waveform";
    "seg_file": InputPathType;
    "seg_indices": Array<number>;
    "input_volume": InputPathType;
    "reg_file": InputPathType;
    "vsm_file"?: InputPathType | null | undefined;
    "regheader_flag": boolean;
    "demean_flag": boolean;
    "output_file": string;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "extract_seg_waveform": extract_seg_waveform_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `extract_seg_waveform(...)`.
 *
 * @interface
 */
interface ExtractSegWaveformOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
}


function extract_seg_waveform_params(
    seg_file: InputPathType,
    seg_indices: Array<number>,
    input_volume: InputPathType,
    reg_file: InputPathType,
    output_file: string,
    vsm_file: InputPathType | null = null,
    regheader_flag: boolean = false,
    demean_flag: boolean = false,
): ExtractSegWaveformParameters {
    /**
     * Build parameters.
    
     * @param seg_file Segmentation file
     * @param seg_indices Segmentation indices, one or more indices can be specified
     * @param input_volume Input volume
     * @param reg_file Registration file (.lta)
     * @param output_file Output waveform file
     * @param vsm_file Voxel shift map for B0 distortion correction
     * @param regheader_flag Uses the header information in the registration file
     * @param demean_flag Remove mean, first, and second order trends
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "extract_seg_waveform" as const,
        "seg_file": seg_file,
        "seg_indices": seg_indices,
        "input_volume": input_volume,
        "reg_file": reg_file,
        "regheader_flag": regheader_flag,
        "demean_flag": demean_flag,
        "output_file": output_file,
    };
    if (vsm_file !== null) {
        params["vsm_file"] = vsm_file;
    }
    return params;
}


function extract_seg_waveform_cargs(
    params: ExtractSegWaveformParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("extract_seg_waveform");
    cargs.push(
        "--seg",
        execution.inputFile((params["seg_file"] ?? null))
    );
    cargs.push(
        "--id",
        ...(params["seg_indices"] ?? null).map(String)
    );
    cargs.push(
        "--i",
        execution.inputFile((params["input_volume"] ?? null))
    );
    cargs.push(
        "--reg",
        execution.inputFile((params["reg_file"] ?? null))
    );
    if ((params["vsm_file"] ?? null) !== null) {
        cargs.push(
            "--vsm",
            execution.inputFile((params["vsm_file"] ?? null))
        );
    }
    if ((params["regheader_flag"] ?? null)) {
        cargs.push("--regheader");
    }
    if ((params["demean_flag"] ?? null)) {
        cargs.push("--demean");
    }
    cargs.push(
        "--o",
        (params["output_file"] ?? null)
    );
    return cargs;
}


function extract_seg_waveform_outputs(
    params: ExtractSegWaveformParameters,
    execution: Execution,
): ExtractSegWaveformOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: ExtractSegWaveformOutputs = {
        root: execution.outputFile("."),
    };
    return ret;
}


function extract_seg_waveform_execute(
    params: ExtractSegWaveformParameters,
    execution: Execution,
): ExtractSegWaveformOutputs {
    /**
     * This program extracts an average waveform from an input volume where the average is computed over the voxels in the given segmentation indices. The input volume is mapped to the space of the segmentation given the registration, and if a voxel shift map (VSM) is supplied, it is applied simultaneously as part of the transform.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `ExtractSegWaveformOutputs`).
     */
    params = execution.params(params)
    const cargs = extract_seg_waveform_cargs(params, execution)
    const ret = extract_seg_waveform_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function extract_seg_waveform(
    seg_file: InputPathType,
    seg_indices: Array<number>,
    input_volume: InputPathType,
    reg_file: InputPathType,
    output_file: string,
    vsm_file: InputPathType | null = null,
    regheader_flag: boolean = false,
    demean_flag: boolean = false,
    runner: Runner | null = null,
): ExtractSegWaveformOutputs {
    /**
     * This program extracts an average waveform from an input volume where the average is computed over the voxels in the given segmentation indices. The input volume is mapped to the space of the segmentation given the registration, and if a voxel shift map (VSM) is supplied, it is applied simultaneously as part of the transform.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param seg_file Segmentation file
     * @param seg_indices Segmentation indices, one or more indices can be specified
     * @param input_volume Input volume
     * @param reg_file Registration file (.lta)
     * @param output_file Output waveform file
     * @param vsm_file Voxel shift map for B0 distortion correction
     * @param regheader_flag Uses the header information in the registration file
     * @param demean_flag Remove mean, first, and second order trends
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `ExtractSegWaveformOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(EXTRACT_SEG_WAVEFORM_METADATA);
    const params = extract_seg_waveform_params(seg_file, seg_indices, input_volume, reg_file, output_file, vsm_file, regheader_flag, demean_flag)
    return extract_seg_waveform_execute(params, execution);
}


export {
      EXTRACT_SEG_WAVEFORM_METADATA,
      ExtractSegWaveformOutputs,
      ExtractSegWaveformParameters,
      extract_seg_waveform,
      extract_seg_waveform_params,
};
