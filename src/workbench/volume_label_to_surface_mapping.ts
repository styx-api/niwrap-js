// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const VOLUME_LABEL_TO_SURFACE_MAPPING_METADATA: Metadata = {
    id: "7b2c1281854788e8dba27a0d6884b9c1e7b7708e.boutiques",
    name: "volume-label-to-surface-mapping",
    package: "workbench",
    container_image_tag: "brainlife/connectome_workbench:1.5.0-freesurfer-update",
};


interface VolumeLabelToSurfaceMappingRibbonConstrainedParameters {
    "@type"?: "ribbon_constrained";
    "inner_surf": InputPathType;
    "outer_surf": InputPathType;
    "opt_volume_roi_roi_volume"?: InputPathType | null | undefined;
    "opt_voxel_subdiv_subdiv_num"?: number | null | undefined;
    "opt_thin_columns": boolean;
}
type VolumeLabelToSurfaceMappingRibbonConstrainedParametersTagged = Required<Pick<VolumeLabelToSurfaceMappingRibbonConstrainedParameters, '@type'>> & VolumeLabelToSurfaceMappingRibbonConstrainedParameters;


interface VolumeLabelToSurfaceMappingParameters {
    "@type"?: "workbench/volume-label-to-surface-mapping";
    "volume": InputPathType;
    "surface": InputPathType;
    "label_out": string;
    "ribbon_constrained"?: VolumeLabelToSurfaceMappingRibbonConstrainedParameters | null | undefined;
    "opt_subvol_select_subvol"?: string | null | undefined;
}
type VolumeLabelToSurfaceMappingParametersTagged = Required<Pick<VolumeLabelToSurfaceMappingParameters, '@type'>> & VolumeLabelToSurfaceMappingParameters;


/**
 * Build parameters.
 *
 * @param inner_surf the inner surface of the ribbon
 * @param outer_surf the outer surface of the ribbon
 * @param opt_volume_roi_roi_volume use a volume roi: the volume file
 * @param opt_voxel_subdiv_subdiv_num voxel divisions while estimating voxel weights: number of subdivisions, default 3
 * @param opt_thin_columns use non-overlapping polyhedra
 *
 * @returns Parameter dictionary
 */
function volume_label_to_surface_mapping_ribbon_constrained_params(
    inner_surf: InputPathType,
    outer_surf: InputPathType,
    opt_volume_roi_roi_volume: InputPathType | null = null,
    opt_voxel_subdiv_subdiv_num: number | null = null,
    opt_thin_columns: boolean = false,
): VolumeLabelToSurfaceMappingRibbonConstrainedParametersTagged {
    const params = {
        "@type": "ribbon_constrained" as const,
        "inner_surf": inner_surf,
        "outer_surf": outer_surf,
        "opt_thin_columns": opt_thin_columns,
    };
    if (opt_volume_roi_roi_volume !== null) {
        params["opt_volume_roi_roi_volume"] = opt_volume_roi_roi_volume;
    }
    if (opt_voxel_subdiv_subdiv_num !== null) {
        params["opt_voxel_subdiv_subdiv_num"] = opt_voxel_subdiv_subdiv_num;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_label_to_surface_mapping_ribbon_constrained_cargs(
    params: VolumeLabelToSurfaceMappingRibbonConstrainedParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-ribbon-constrained");
    cargs.push(execution.inputFile((params["inner_surf"] ?? null)));
    cargs.push(execution.inputFile((params["outer_surf"] ?? null)));
    if ((params["opt_volume_roi_roi_volume"] ?? null) !== null) {
        cargs.push(
            "-volume-roi",
            execution.inputFile((params["opt_volume_roi_roi_volume"] ?? null))
        );
    }
    if ((params["opt_voxel_subdiv_subdiv_num"] ?? null) !== null) {
        cargs.push(
            "-voxel-subdiv",
            String((params["opt_voxel_subdiv_subdiv_num"] ?? null))
        );
    }
    if ((params["opt_thin_columns"] ?? false)) {
        cargs.push("-thin-columns");
    }
    return cargs;
}


/**
 * Output object returned when calling `VolumeLabelToSurfaceMappingParameters(...)`.
 *
 * @interface
 */
interface VolumeLabelToSurfaceMappingOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output gifti label file
     */
    label_out: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param volume the volume to map data from
 * @param surface the surface to map the data onto
 * @param label_out the output gifti label file
 * @param ribbon_constrained use ribbon constrained mapping algorithm
 * @param opt_subvol_select_subvol select a single subvolume to map: the subvolume number or name
 *
 * @returns Parameter dictionary
 */
function volume_label_to_surface_mapping_params(
    volume: InputPathType,
    surface: InputPathType,
    label_out: string,
    ribbon_constrained: VolumeLabelToSurfaceMappingRibbonConstrainedParameters | null = null,
    opt_subvol_select_subvol: string | null = null,
): VolumeLabelToSurfaceMappingParametersTagged {
    const params = {
        "@type": "workbench/volume-label-to-surface-mapping" as const,
        "volume": volume,
        "surface": surface,
        "label_out": label_out,
    };
    if (ribbon_constrained !== null) {
        params["ribbon_constrained"] = ribbon_constrained;
    }
    if (opt_subvol_select_subvol !== null) {
        params["opt_subvol_select_subvol"] = opt_subvol_select_subvol;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function volume_label_to_surface_mapping_cargs(
    params: VolumeLabelToSurfaceMappingParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("wb_command");
    cargs.push("-volume-label-to-surface-mapping");
    cargs.push(execution.inputFile((params["volume"] ?? null)));
    cargs.push(execution.inputFile((params["surface"] ?? null)));
    cargs.push((params["label_out"] ?? null));
    if ((params["ribbon_constrained"] ?? null) !== null) {
        cargs.push(...volume_label_to_surface_mapping_ribbon_constrained_cargs((params["ribbon_constrained"] ?? null), execution));
    }
    if ((params["opt_subvol_select_subvol"] ?? null) !== null) {
        cargs.push(
            "-subvol-select",
            (params["opt_subvol_select_subvol"] ?? null)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function volume_label_to_surface_mapping_outputs(
    params: VolumeLabelToSurfaceMappingParameters,
    execution: Execution,
): VolumeLabelToSurfaceMappingOutputs {
    const ret: VolumeLabelToSurfaceMappingOutputs = {
        root: execution.outputFile("."),
        label_out: execution.outputFile([(params["label_out"] ?? null)].join('')),
    };
    return ret;
}


/**
 * volume-label-to-surface-mapping
 *
 * Map a label volume to a surface label file.
 *
 * Map label volume data to a surface.  If -ribbon-constrained is not specified, uses the enclosing voxel method.  The ribbon mapping method constructs a polyhedron from the vertex's neighbors on each surface, and estimates the amount of this polyhedron's volume that falls inside any nearby voxels, to use as the weights for a popularity comparison.  If -thin-columns is specified, the polyhedron uses the edge midpoints and triangle centroids, so that neighboring vertices do not have overlapping polyhedra.  This may require increasing -voxel-subdiv to get enough samples in each voxel to reliably land inside these smaller polyhedra.  The volume ROI is useful to exclude partial volume effects of voxels the surfaces pass through, and will cause the mapping to ignore voxels that don't have a positive value in the mask.  The subdivision number specifies how it approximates the amount of the volume the polyhedron intersects, by splitting each voxel into NxNxN pieces, and checking whether the center of each piece is inside the polyhedron.  If you have very large voxels, consider increasing this if you get unexpected unlabeled vertices in your output.
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `VolumeLabelToSurfaceMappingOutputs`).
 */
function volume_label_to_surface_mapping_execute(
    params: VolumeLabelToSurfaceMappingParameters,
    runner: Runner | null = null,
): VolumeLabelToSurfaceMappingOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(VOLUME_LABEL_TO_SURFACE_MAPPING_METADATA);
    params = execution.params(params)
    const cargs = volume_label_to_surface_mapping_cargs(params, execution)
    const ret = volume_label_to_surface_mapping_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * volume-label-to-surface-mapping
 *
 * Map a label volume to a surface label file.
 *
 * Map label volume data to a surface.  If -ribbon-constrained is not specified, uses the enclosing voxel method.  The ribbon mapping method constructs a polyhedron from the vertex's neighbors on each surface, and estimates the amount of this polyhedron's volume that falls inside any nearby voxels, to use as the weights for a popularity comparison.  If -thin-columns is specified, the polyhedron uses the edge midpoints and triangle centroids, so that neighboring vertices do not have overlapping polyhedra.  This may require increasing -voxel-subdiv to get enough samples in each voxel to reliably land inside these smaller polyhedra.  The volume ROI is useful to exclude partial volume effects of voxels the surfaces pass through, and will cause the mapping to ignore voxels that don't have a positive value in the mask.  The subdivision number specifies how it approximates the amount of the volume the polyhedron intersects, by splitting each voxel into NxNxN pieces, and checking whether the center of each piece is inside the polyhedron.  If you have very large voxels, consider increasing this if you get unexpected unlabeled vertices in your output.
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param volume the volume to map data from
 * @param surface the surface to map the data onto
 * @param label_out the output gifti label file
 * @param ribbon_constrained use ribbon constrained mapping algorithm
 * @param opt_subvol_select_subvol select a single subvolume to map: the subvolume number or name
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `VolumeLabelToSurfaceMappingOutputs`).
 */
function volume_label_to_surface_mapping(
    volume: InputPathType,
    surface: InputPathType,
    label_out: string,
    ribbon_constrained: VolumeLabelToSurfaceMappingRibbonConstrainedParameters | null = null,
    opt_subvol_select_subvol: string | null = null,
    runner: Runner | null = null,
): VolumeLabelToSurfaceMappingOutputs {
    const params = volume_label_to_surface_mapping_params(volume, surface, label_out, ribbon_constrained, opt_subvol_select_subvol)
    return volume_label_to_surface_mapping_execute(params, runner);
}


export {
      VOLUME_LABEL_TO_SURFACE_MAPPING_METADATA,
      VolumeLabelToSurfaceMappingOutputs,
      volume_label_to_surface_mapping,
      volume_label_to_surface_mapping_execute,
      volume_label_to_surface_mapping_params,
      volume_label_to_surface_mapping_ribbon_constrained_params,
};
