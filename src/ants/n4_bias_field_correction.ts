// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const N4_BIAS_FIELD_CORRECTION_METADATA: Metadata = {
    id: "3f10828e86e53eef2772983bf2e0a920246c4729.boutiques",
    name: "N4BiasFieldCorrection",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface N4BiasFieldCorrectionConvergenceParameters {
    "@type"?: "convergence";
    "convergence": Array<number>;
    "convergence_threshold"?: number | null | undefined;
}
type N4BiasFieldCorrectionConvergenceParametersTagged = Required<Pick<N4BiasFieldCorrectionConvergenceParameters, '@type'>> & N4BiasFieldCorrectionConvergenceParameters;


interface N4BiasFieldCorrectionBsplineFittingParameters {
    "@type"?: "bspline_fitting";
    "spline_distance": Array<number>;
    "spline_order"?: number | null | undefined;
}
type N4BiasFieldCorrectionBsplineFittingParametersTagged = Required<Pick<N4BiasFieldCorrectionBsplineFittingParameters, '@type'>> & N4BiasFieldCorrectionBsplineFittingParameters;


interface N4BiasFieldCorrectionHistogramSharpeningParameters {
    "@type"?: "histogram_sharpening";
    "fwhm"?: number | null | undefined;
    "wiener_noise"?: number | null | undefined;
    "number_of_histogram_bins"?: number | null | undefined;
}
type N4BiasFieldCorrectionHistogramSharpeningParametersTagged = Required<Pick<N4BiasFieldCorrectionHistogramSharpeningParameters, '@type'>> & N4BiasFieldCorrectionHistogramSharpeningParameters;


interface N4BiasFieldCorrectionCorrectedOutputParameters {
    "@type"?: "correctedOutput";
    "correctedOutputFileName": string;
}
type N4BiasFieldCorrectionCorrectedOutputParametersTagged = Required<Pick<N4BiasFieldCorrectionCorrectedOutputParameters, '@type'>> & N4BiasFieldCorrectionCorrectedOutputParameters;


interface N4BiasFieldCorrectionCorrectedOutputNoiseParameters {
    "@type"?: "correctedOutputNoise";
    "correctedOutputFileName": string;
    "biasFile"?: string | null | undefined;
}
type N4BiasFieldCorrectionCorrectedOutputNoiseParametersTagged = Required<Pick<N4BiasFieldCorrectionCorrectedOutputNoiseParameters, '@type'>> & N4BiasFieldCorrectionCorrectedOutputNoiseParameters;


interface N4BiasFieldCorrectionParameters {
    "@type"?: "ants/N4BiasFieldCorrection";
    "image_dimensionality"?: 2 | 3 | 4 | null | undefined;
    "shrink_factor"?: number | null | undefined;
    "mask_image"?: InputPathType | null | undefined;
    "rescale_intensities"?: 0 | 1 | null | undefined;
    "weight_image"?: InputPathType | null | undefined;
    "convergence"?: N4BiasFieldCorrectionConvergenceParameters | null | undefined;
    "bspline_fitting"?: N4BiasFieldCorrectionBsplineFittingParameters | null | undefined;
    "histogram_sharpening"?: N4BiasFieldCorrectionHistogramSharpeningParameters | null | undefined;
    "verbose"?: 0 | 1 | null | undefined;
    "input_image": InputPathType;
    "output": N4BiasFieldCorrectionCorrectedOutputParametersTagged | N4BiasFieldCorrectionCorrectedOutputNoiseParametersTagged;
}
type N4BiasFieldCorrectionParametersTagged = Required<Pick<N4BiasFieldCorrectionParameters, '@type'>> & N4BiasFieldCorrectionParameters;


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function n4_bias_field_correction_output_cargs_dyn_fn(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "correctedOutput": n4_bias_field_correction_corrected_output_cargs,
        "correctedOutputNoise": n4_bias_field_correction_corrected_output_noise_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function n4_bias_field_correction_output_outputs_dyn_fn(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "correctedOutput": n4_bias_field_correction_corrected_output_outputs,
        "correctedOutputNoise": n4_bias_field_correction_corrected_output_noise_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 *
 * @returns Parameter dictionary
 */
function n4_bias_field_correction_convergence_params(
    convergence: Array<number>,
    convergence_threshold: number | null = null,
): N4BiasFieldCorrectionConvergenceParametersTagged {
    const params = {
        "@type": "convergence" as const,
        "convergence": convergence,
    };
    if (convergence_threshold !== null) {
        params["convergence_threshold"] = convergence_threshold;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function n4_bias_field_correction_convergence_cargs(
    params: N4BiasFieldCorrectionConvergenceParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["convergence_threshold"] ?? null) !== null) {
        cargs.push(["[", (params["convergence"] ?? null).map(String).join("x"), ",", String((params["convergence_threshold"] ?? null)), "]"].join(''));
    }
    return cargs;
}


/**
 * Build parameters.
 *
 *
 * @returns Parameter dictionary
 */
function n4_bias_field_correction_bspline_fitting_params(
    spline_distance: Array<number>,
    spline_order: number | null = null,
): N4BiasFieldCorrectionBsplineFittingParametersTagged {
    const params = {
        "@type": "bspline_fitting" as const,
        "spline_distance": spline_distance,
    };
    if (spline_order !== null) {
        params["spline_order"] = spline_order;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function n4_bias_field_correction_bspline_fitting_cargs(
    params: N4BiasFieldCorrectionBsplineFittingParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["spline_order"] ?? null) !== null) {
        cargs.push(["[", (params["spline_distance"] ?? null).map(String).join("x"), ",", String((params["spline_order"] ?? null)), "]"].join(''));
    }
    return cargs;
}


/**
 * Build parameters.
 *
 *
 * @returns Parameter dictionary
 */
function n4_bias_field_correction_histogram_sharpening_params(
    fwhm: number | null = null,
    wiener_noise: number | null = null,
    number_of_histogram_bins: number | null = null,
): N4BiasFieldCorrectionHistogramSharpeningParametersTagged {
    const params = {
        "@type": "histogram_sharpening" as const,
    };
    if (fwhm !== null) {
        params["fwhm"] = fwhm;
    }
    if (wiener_noise !== null) {
        params["wiener_noise"] = wiener_noise;
    }
    if (number_of_histogram_bins !== null) {
        params["number_of_histogram_bins"] = number_of_histogram_bins;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function n4_bias_field_correction_histogram_sharpening_cargs(
    params: N4BiasFieldCorrectionHistogramSharpeningParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["fwhm"] ?? null) !== null || (params["wiener_noise"] ?? null) !== null || (params["number_of_histogram_bins"] ?? null) !== null) {
        cargs.push(["[", (((params["fwhm"] ?? null) !== null) ? String((params["fwhm"] ?? null)) : ""), ",", (((params["wiener_noise"] ?? null) !== null) ? String((params["wiener_noise"] ?? null)) : ""), ",", (((params["number_of_histogram_bins"] ?? null) !== null) ? String((params["number_of_histogram_bins"] ?? null)) : ""), "]"].join(''));
    }
    return cargs;
}


/**
 * Output object returned when calling `N4BiasFieldCorrectionCorrectedOutputParameters(...)`.
 *
 * @interface
 */
interface N4BiasFieldCorrectionCorrectedOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Bias corrected image.
     */
    output_image_outfile: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param corrected_output_file_name Output file name.
 *
 * @returns Parameter dictionary
 */
function n4_bias_field_correction_corrected_output_params(
    corrected_output_file_name: string,
): N4BiasFieldCorrectionCorrectedOutputParametersTagged {
    const params = {
        "@type": "correctedOutput" as const,
        "correctedOutputFileName": corrected_output_file_name,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function n4_bias_field_correction_corrected_output_cargs(
    params: N4BiasFieldCorrectionCorrectedOutputParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["correctedOutputFileName"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function n4_bias_field_correction_corrected_output_outputs(
    params: N4BiasFieldCorrectionCorrectedOutputParameters,
    execution: Execution,
): N4BiasFieldCorrectionCorrectedOutputOutputs {
    const ret: N4BiasFieldCorrectionCorrectedOutputOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["correctedOutputFileName"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `N4BiasFieldCorrectionCorrectedOutputNoiseParameters(...)`.
 *
 * @interface
 */
interface N4BiasFieldCorrectionCorrectedOutputNoiseOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Bias corrected image.
     */
    output_image_outfile: OutputPathType;
    /**
     * Bias field image.
     */
    output_bias_image: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param corrected_output_file_name Output file name.
 * @param bias_file Output bias field image.
 *
 * @returns Parameter dictionary
 */
function n4_bias_field_correction_corrected_output_noise_params(
    corrected_output_file_name: string,
    bias_file: string | null = null,
): N4BiasFieldCorrectionCorrectedOutputNoiseParametersTagged {
    const params = {
        "@type": "correctedOutputNoise" as const,
        "correctedOutputFileName": corrected_output_file_name,
    };
    if (bias_file !== null) {
        params["biasFile"] = bias_file;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function n4_bias_field_correction_corrected_output_noise_cargs(
    params: N4BiasFieldCorrectionCorrectedOutputNoiseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["biasFile"] ?? null) !== null) {
        cargs.push(["[", (params["correctedOutputFileName"] ?? null), ",", (params["biasFile"] ?? null), "]"].join(''));
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function n4_bias_field_correction_corrected_output_noise_outputs(
    params: N4BiasFieldCorrectionCorrectedOutputNoiseParameters,
    execution: Execution,
): N4BiasFieldCorrectionCorrectedOutputNoiseOutputs {
    const ret: N4BiasFieldCorrectionCorrectedOutputNoiseOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["correctedOutputFileName"] ?? null)].join('')),
        output_bias_image: ((params["biasFile"] ?? null) !== null) ? execution.outputFile([(params["biasFile"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * Output object returned when calling `N4BiasFieldCorrectionParameters(...)`.
 *
 * @interface
 */
interface N4BiasFieldCorrectionOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Outputs from `N4BiasFieldCorrectionCorrectedOutputParameters` or `N4BiasFieldCorrectionCorrectedOutputNoiseParameters`.
     */
    output: N4BiasFieldCorrectionCorrectedOutputOutputs | N4BiasFieldCorrectionCorrectedOutputNoiseOutputs;
}


/**
 * Build parameters.
 *
 * @param input_image -i, --input-image inputImageFilename. A scalar image is expected as input for bias correction. Since N4 log transforms the intensities, negative values or values close to zero should be processed prior to correction.
 * @param output The bias corrected version of the input image, with optional noise image.
 * @param image_dimensionality -d, --image-dimensionality 2/3/4. This option forces the image to be treated as a specified-dimensional image. If not specified, N4 tries to infer the dimensionality from the input image.
 * @param shrink_factor -s, --shrink-factor 1/2/3/(4)/... Running N4 on large images can be time consuming. To lessen computation time, the input image can be resampled. The shrink factor, specified as a single integer, describes this resampling. Shrink factors <= 4 are commonly used. Note that the shrink factor is only applied to the first two or three dimensions which we assume are spatial.
 * @param mask_image -x, --mask-image maskImageFilename. If a mask image is specified, the final bias correction is only performed in the mask region. If a weight image is not specified, only intensity values inside the masked region are used during the execution of the algorithm. If a weight image is specified, only the non-zero weights are used in the execution of the algorithm although the mask region defines where bias correction is performed in the final output. Otherwise bias correction occurs over the entire image domain.  See also the option description for the weight image. If a mask image is *not* specified then the entire image region will be used as the mask region. Note that this is different than the N3 implementation which uses the results of Otsu thresholding to define a mask. However, this leads to unknown anatomical regions being included and excluded during the bias correction.
 * @param rescale_intensities -r, --rescale-intensities 0/(1). At each iteration, a new intensity mapping is calculated and applied but there is nothing which constrains the new intensity range to be within certain values.  The result is that the range can "drift" from the original at each iteration.  This option rescales to the [min,max] range of the original image intensities within the user-specified mask. A mask is required to perform rescaling.
 * @param weight_image -w, --weight-image weightImageFilename. The weight image allows the user to perform a relative weighting of specific voxels during the B-spline fitting. For example, some studies have shown that N3 performed on white matter segmentations improves performance. If one has a spatial probability map of the white matter, one can use this map to weight the b-spline fitting towards those voxels which are more probabilistically classified as white matter. See also the option description for the mask image.
 * @param convergence -c, --convergence [<numberOfIterations=50x50x50x50>,<convergenceThreshold=0.0>]. Convergence is determined by calculating the coefficient of variation between subsequent iterations. When this value is less than the specified threshold from the previous iteration or the maximum number of iterations is exceeded the program terminates. Multiple resolutions can be specified by using 'x' between the number of iterations at each resolution, e.g. 100x50x50.
 * @param bspline_fitting -b, --bspline-fitting [splineDistance,<splineOrder=3>]. These options describe the b-spline fitting parameters. The initial b-spline mesh at the coarsest resolution is specified either as the number of elements in each dimension, e.g. 2x2x3 for 3-D images, or it can be specified as a single scalar parameter which describes the isotropic sizing of the mesh elements. The latter option is typically preferred. For each subsequent level, the spline distance decreases in half, or equivalently, the number of mesh elements doubles Cubic splines (order = 3) are typically used. The default setting is to employ a single mesh element over the entire domain, i.e., -b [1x1x1,3].
 * @param histogram_sharpening -t, --histogram-sharpening [<FWHM=0.15>,<wienerNoise=0.01>,<numberOfHistogramBins=200>]. These options describe the histogram sharpening parameters, i.e. the deconvolution step parameters described in the original N3 algorithm. The default values have been shown to work fairly well.
 * @param verbose Verbose output.
 *
 * @returns Parameter dictionary
 */
function n4_bias_field_correction_params(
    input_image: InputPathType,
    output: N4BiasFieldCorrectionCorrectedOutputParametersTagged | N4BiasFieldCorrectionCorrectedOutputNoiseParametersTagged,
    image_dimensionality: 2 | 3 | 4 | null = null,
    shrink_factor: number | null = null,
    mask_image: InputPathType | null = null,
    rescale_intensities: 0 | 1 | null = null,
    weight_image: InputPathType | null = null,
    convergence: N4BiasFieldCorrectionConvergenceParameters | null = null,
    bspline_fitting: N4BiasFieldCorrectionBsplineFittingParameters | null = null,
    histogram_sharpening: N4BiasFieldCorrectionHistogramSharpeningParameters | null = null,
    verbose: 0 | 1 | null = null,
): N4BiasFieldCorrectionParametersTagged {
    const params = {
        "@type": "ants/N4BiasFieldCorrection" as const,
        "input_image": input_image,
        "output": output,
    };
    if (image_dimensionality !== null) {
        params["image_dimensionality"] = image_dimensionality;
    }
    if (shrink_factor !== null) {
        params["shrink_factor"] = shrink_factor;
    }
    if (mask_image !== null) {
        params["mask_image"] = mask_image;
    }
    if (rescale_intensities !== null) {
        params["rescale_intensities"] = rescale_intensities;
    }
    if (weight_image !== null) {
        params["weight_image"] = weight_image;
    }
    if (convergence !== null) {
        params["convergence"] = convergence;
    }
    if (bspline_fitting !== null) {
        params["bspline_fitting"] = bspline_fitting;
    }
    if (histogram_sharpening !== null) {
        params["histogram_sharpening"] = histogram_sharpening;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function n4_bias_field_correction_cargs(
    params: N4BiasFieldCorrectionParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("N4BiasFieldCorrection");
    if ((params["image_dimensionality"] ?? null) !== null) {
        cargs.push(
            "--image-dimensionality",
            String((params["image_dimensionality"] ?? null))
        );
    }
    if ((params["shrink_factor"] ?? null) !== null) {
        cargs.push(
            "--shrink-factor",
            String((params["shrink_factor"] ?? null))
        );
    }
    if ((params["mask_image"] ?? null) !== null) {
        cargs.push(
            "--mask-image",
            execution.inputFile((params["mask_image"] ?? null))
        );
    }
    if ((params["rescale_intensities"] ?? null) !== null) {
        cargs.push(
            "--rescale-intensities",
            String((params["rescale_intensities"] ?? null))
        );
    }
    if ((params["weight_image"] ?? null) !== null) {
        cargs.push(
            "--weight-image",
            execution.inputFile((params["weight_image"] ?? null))
        );
    }
    if ((params["convergence"] ?? null) !== null) {
        cargs.push(
            "--convergence",
            ...n4_bias_field_correction_convergence_cargs((params["convergence"] ?? null), execution)
        );
    }
    if ((params["bspline_fitting"] ?? null) !== null) {
        cargs.push(
            "--bspline-fitting",
            ...n4_bias_field_correction_bspline_fitting_cargs((params["bspline_fitting"] ?? null), execution)
        );
    }
    if ((params["histogram_sharpening"] ?? null) !== null) {
        cargs.push(
            "--histogram-sharpening",
            ...n4_bias_field_correction_histogram_sharpening_cargs((params["histogram_sharpening"] ?? null), execution)
        );
    }
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "--verbose",
            String((params["verbose"] ?? null))
        );
    }
    cargs.push(
        "--input-image",
        execution.inputFile((params["input_image"] ?? null))
    );
    cargs.push(
        "--output",
        ...n4_bias_field_correction_output_cargs_dyn_fn((params["output"] ?? null)["@type"])((params["output"] ?? null), execution)
    );
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function n4_bias_field_correction_outputs(
    params: N4BiasFieldCorrectionParameters,
    execution: Execution,
): N4BiasFieldCorrectionOutputs {
    const ret: N4BiasFieldCorrectionOutputs = {
        root: execution.outputFile("."),
        output: n4_bias_field_correction_output_outputs_dyn_fn((params["output"] ?? null)["@type"])?.((params["output"] ?? null), execution),
    };
    return ret;
}


/**
 * N4BiasFieldCorrection
 *
 * N4 is a variant of the popular N3 (nonparameteric nonuniform normalization) retrospective bias correction algorithm. Based on the assumption that the corruption of the low frequency bias field can be modeled as a convolution of the intensity histogram by a Gaussian, the basic algorithmic protocol is to iterate between deconvolving the intensity histogram by a Gaussian, remapping the intensities, and then spatially smoothing this result by a B-spline modeling of the bias field itself.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `N4BiasFieldCorrectionOutputs`).
 */
function n4_bias_field_correction_execute(
    params: N4BiasFieldCorrectionParameters,
    runner: Runner | null = null,
): N4BiasFieldCorrectionOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(N4_BIAS_FIELD_CORRECTION_METADATA);
    params = execution.params(params)
    const cargs = n4_bias_field_correction_cargs(params, execution)
    const ret = n4_bias_field_correction_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * N4BiasFieldCorrection
 *
 * N4 is a variant of the popular N3 (nonparameteric nonuniform normalization) retrospective bias correction algorithm. Based on the assumption that the corruption of the low frequency bias field can be modeled as a convolution of the intensity histogram by a Gaussian, the basic algorithmic protocol is to iterate between deconvolving the intensity histogram by a Gaussian, remapping the intensities, and then spatially smoothing this result by a B-spline modeling of the bias field itself.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param input_image -i, --input-image inputImageFilename. A scalar image is expected as input for bias correction. Since N4 log transforms the intensities, negative values or values close to zero should be processed prior to correction.
 * @param output The bias corrected version of the input image, with optional noise image.
 * @param image_dimensionality -d, --image-dimensionality 2/3/4. This option forces the image to be treated as a specified-dimensional image. If not specified, N4 tries to infer the dimensionality from the input image.
 * @param shrink_factor -s, --shrink-factor 1/2/3/(4)/... Running N4 on large images can be time consuming. To lessen computation time, the input image can be resampled. The shrink factor, specified as a single integer, describes this resampling. Shrink factors <= 4 are commonly used. Note that the shrink factor is only applied to the first two or three dimensions which we assume are spatial.
 * @param mask_image -x, --mask-image maskImageFilename. If a mask image is specified, the final bias correction is only performed in the mask region. If a weight image is not specified, only intensity values inside the masked region are used during the execution of the algorithm. If a weight image is specified, only the non-zero weights are used in the execution of the algorithm although the mask region defines where bias correction is performed in the final output. Otherwise bias correction occurs over the entire image domain.  See also the option description for the weight image. If a mask image is *not* specified then the entire image region will be used as the mask region. Note that this is different than the N3 implementation which uses the results of Otsu thresholding to define a mask. However, this leads to unknown anatomical regions being included and excluded during the bias correction.
 * @param rescale_intensities -r, --rescale-intensities 0/(1). At each iteration, a new intensity mapping is calculated and applied but there is nothing which constrains the new intensity range to be within certain values.  The result is that the range can "drift" from the original at each iteration.  This option rescales to the [min,max] range of the original image intensities within the user-specified mask. A mask is required to perform rescaling.
 * @param weight_image -w, --weight-image weightImageFilename. The weight image allows the user to perform a relative weighting of specific voxels during the B-spline fitting. For example, some studies have shown that N3 performed on white matter segmentations improves performance. If one has a spatial probability map of the white matter, one can use this map to weight the b-spline fitting towards those voxels which are more probabilistically classified as white matter. See also the option description for the mask image.
 * @param convergence -c, --convergence [<numberOfIterations=50x50x50x50>,<convergenceThreshold=0.0>]. Convergence is determined by calculating the coefficient of variation between subsequent iterations. When this value is less than the specified threshold from the previous iteration or the maximum number of iterations is exceeded the program terminates. Multiple resolutions can be specified by using 'x' between the number of iterations at each resolution, e.g. 100x50x50.
 * @param bspline_fitting -b, --bspline-fitting [splineDistance,<splineOrder=3>]. These options describe the b-spline fitting parameters. The initial b-spline mesh at the coarsest resolution is specified either as the number of elements in each dimension, e.g. 2x2x3 for 3-D images, or it can be specified as a single scalar parameter which describes the isotropic sizing of the mesh elements. The latter option is typically preferred. For each subsequent level, the spline distance decreases in half, or equivalently, the number of mesh elements doubles Cubic splines (order = 3) are typically used. The default setting is to employ a single mesh element over the entire domain, i.e., -b [1x1x1,3].
 * @param histogram_sharpening -t, --histogram-sharpening [<FWHM=0.15>,<wienerNoise=0.01>,<numberOfHistogramBins=200>]. These options describe the histogram sharpening parameters, i.e. the deconvolution step parameters described in the original N3 algorithm. The default values have been shown to work fairly well.
 * @param verbose Verbose output.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `N4BiasFieldCorrectionOutputs`).
 */
function n4_bias_field_correction(
    input_image: InputPathType,
    output: N4BiasFieldCorrectionCorrectedOutputParametersTagged | N4BiasFieldCorrectionCorrectedOutputNoiseParametersTagged,
    image_dimensionality: 2 | 3 | 4 | null = null,
    shrink_factor: number | null = null,
    mask_image: InputPathType | null = null,
    rescale_intensities: 0 | 1 | null = null,
    weight_image: InputPathType | null = null,
    convergence: N4BiasFieldCorrectionConvergenceParameters | null = null,
    bspline_fitting: N4BiasFieldCorrectionBsplineFittingParameters | null = null,
    histogram_sharpening: N4BiasFieldCorrectionHistogramSharpeningParameters | null = null,
    verbose: 0 | 1 | null = null,
    runner: Runner | null = null,
): N4BiasFieldCorrectionOutputs {
    const params = n4_bias_field_correction_params(input_image, output, image_dimensionality, shrink_factor, mask_image, rescale_intensities, weight_image, convergence, bspline_fitting, histogram_sharpening, verbose)
    return n4_bias_field_correction_execute(params, runner);
}


export {
      N4BiasFieldCorrectionCorrectedOutputNoiseOutputs,
      N4BiasFieldCorrectionCorrectedOutputOutputs,
      N4BiasFieldCorrectionOutputs,
      N4_BIAS_FIELD_CORRECTION_METADATA,
      n4_bias_field_correction,
      n4_bias_field_correction_bspline_fitting_params,
      n4_bias_field_correction_convergence_params,
      n4_bias_field_correction_corrected_output_noise_params,
      n4_bias_field_correction_corrected_output_params,
      n4_bias_field_correction_execute,
      n4_bias_field_correction_histogram_sharpening_params,
      n4_bias_field_correction_params,
};
