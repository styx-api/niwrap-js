// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRI_MS_FITPARMS_METADATA: Metadata = {
    id: "9d959cb42d2739bddab44c9edd707c41d45521c3.boutiques",
    name: "mri_ms_fitparms",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface MriMsFitparmsParameters {
    "@type"?: "freesurfer/mri_ms_fitparms";
    "volumes": Array<InputPathType>;
    "output_dir": string;
    "afi_flag": boolean;
    "ait_flag": boolean;
    "at"?: string | null | undefined;
    "conform_flag": boolean;
    "correct_flag": boolean;
    "cubic_flag": boolean;
    "debug_slice_flag": boolean;
    "debug_voxel_flag": boolean;
    "dt"?: string | null | undefined;
    "fa"?: string | null | undefined;
    "fa_scale"?: number | null | undefined;
    "faf"?: string | null | undefined;
    "fsmooth"?: number | null | undefined;
    "invert_flag": boolean;
    "momentum"?: string | null | undefined;
    "max_t2"?: string | null | undefined;
    "n_iter"?: number | null | undefined;
    "nearest_flag": boolean;
    "nocompress_flag": boolean;
    "nosynth_flag": boolean;
    "residuals"?: string | null | undefined;
    "smooth_sigma"?: number | null | undefined;
    "scale_factor"?: number | null | undefined;
    "sinc_flag": boolean;
    "transform_flag": boolean;
    "echo_time"?: number | null | undefined;
    "repetition_time"?: number | null | undefined;
    "trilinear_flag": boolean;
    "tukey_flag": boolean;
    "help_flag": boolean;
    "use_brain_mask_flag": boolean;
    "write_intermediate"?: number | null | undefined;
    "extract_subimage"?: Array<number> | null | undefined;
    "window_flag": boolean;
}
type MriMsFitparmsParametersTagged = Required<Pick<MriMsFitparmsParameters, '@type'>> & MriMsFitparmsParameters;


/**
 * Output object returned when calling `MriMsFitparmsParameters(...)`.
 *
 * @interface
 */
interface MriMsFitparmsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Compressed T1 map
     */
    t1_map: OutputPathType;
    /**
     * Compressed Proton Density map
     */
    pd_map: OutputPathType;
    /**
     * Compressed Synthetic volume for input vol_1, in motion corrected space
     */
    vol0_synthetic: OutputPathType;
    /**
     * Motion correction affine information for vol_1
     */
    vol0_affine: OutputPathType;
    /**
     * Compressed Synthetic volume for input vol_2, in motion corrected space
     */
    vol1_synthetic: OutputPathType;
    /**
     * Motion correction affine information for vol_2
     */
    vol1_affine: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param volumes List of 3D FLASH images with different flip angles.
 * @param output_dir Output directory
 * @param afi_flag Designate flip angle map to use with nominal value 60 degrees
 * @param ait_flag Apply inverse of transform
 * @param at Set acquisition time
 * @param conform_flag Interpolate volume to be isotropic 1mm^3
 * @param correct_flag Correct proton density map (PD) by T2* estimates
 * @param cubic_flag Use cubic interpolation (NOT WORKING!)
 * @param debug_slice_flag Debug slice processing ???
 * @param debug_voxel_flag Debug voxel processing ???
 * @param dt Set time step dt ???
 * @param fa Set flip angle
 * @param fa_scale Set value to scale all flip angles by
 * @param faf Designate flip angle map to use with specified control points
 * @param fsmooth Smooth flip angle map for X iterations of soap bubble smoothing
 * @param invert_flag Invert volumes
 * @param momentum Set momentum
 * @param max_t2 Set max T2*
 * @param n_iter Perform estimation/motion correction X times
 * @param nearest_flag Use nearest-neighbor interpolation
 * @param nocompress_flag Do not compress output volumes (save as .mgh)
 * @param nosynth_flag Disable volume synthesis
 * @param residuals Write out residuals to designated location
 * @param smooth_sigma Smooth faf field with sigma=X
 * @param scale_factor Scale volumes by X after reading
 * @param sinc_flag Use sinc interpolation (default window width is 6)
 * @param transform_flag Apply transform to output volumes
 * @param echo_time Set echo time (TE) in ms
 * @param repetition_time Set repetition time (TR) in ms
 * @param trilinear_flag Use trilinear interpolation
 * @param tukey_flag Use Tukey bi-weight of residuals
 * @param help_flag Display help text
 * @param use_brain_mask_flag Compute a brain mask from the PD map and use it for registration
 * @param write_intermediate Write out intermediate results every X iterations
 * @param extract_subimage Extract a subimage for each input image, specified by x0 y0 z0 dx dy dz
 * @param window_flag Not implemented
 *
 * @returns Parameter dictionary
 */
function mri_ms_fitparms_params(
    volumes: Array<InputPathType>,
    output_dir: string,
    afi_flag: boolean = false,
    ait_flag: boolean = false,
    at: string | null = null,
    conform_flag: boolean = false,
    correct_flag: boolean = false,
    cubic_flag: boolean = false,
    debug_slice_flag: boolean = false,
    debug_voxel_flag: boolean = false,
    dt: string | null = null,
    fa: string | null = null,
    fa_scale: number | null = null,
    faf: string | null = null,
    fsmooth: number | null = null,
    invert_flag: boolean = false,
    momentum: string | null = null,
    max_t2: string | null = null,
    n_iter: number | null = null,
    nearest_flag: boolean = false,
    nocompress_flag: boolean = false,
    nosynth_flag: boolean = false,
    residuals: string | null = null,
    smooth_sigma: number | null = null,
    scale_factor: number | null = null,
    sinc_flag: boolean = false,
    transform_flag: boolean = false,
    echo_time: number | null = null,
    repetition_time: number | null = null,
    trilinear_flag: boolean = false,
    tukey_flag: boolean = false,
    help_flag: boolean = false,
    use_brain_mask_flag: boolean = false,
    write_intermediate: number | null = null,
    extract_subimage: Array<number> | null = null,
    window_flag: boolean = false,
): MriMsFitparmsParametersTagged {
    const params = {
        "@type": "freesurfer/mri_ms_fitparms" as const,
        "volumes": volumes,
        "output_dir": output_dir,
        "afi_flag": afi_flag,
        "ait_flag": ait_flag,
        "conform_flag": conform_flag,
        "correct_flag": correct_flag,
        "cubic_flag": cubic_flag,
        "debug_slice_flag": debug_slice_flag,
        "debug_voxel_flag": debug_voxel_flag,
        "invert_flag": invert_flag,
        "nearest_flag": nearest_flag,
        "nocompress_flag": nocompress_flag,
        "nosynth_flag": nosynth_flag,
        "sinc_flag": sinc_flag,
        "transform_flag": transform_flag,
        "trilinear_flag": trilinear_flag,
        "tukey_flag": tukey_flag,
        "help_flag": help_flag,
        "use_brain_mask_flag": use_brain_mask_flag,
        "window_flag": window_flag,
    };
    if (at !== null) {
        params["at"] = at;
    }
    if (dt !== null) {
        params["dt"] = dt;
    }
    if (fa !== null) {
        params["fa"] = fa;
    }
    if (fa_scale !== null) {
        params["fa_scale"] = fa_scale;
    }
    if (faf !== null) {
        params["faf"] = faf;
    }
    if (fsmooth !== null) {
        params["fsmooth"] = fsmooth;
    }
    if (momentum !== null) {
        params["momentum"] = momentum;
    }
    if (max_t2 !== null) {
        params["max_t2"] = max_t2;
    }
    if (n_iter !== null) {
        params["n_iter"] = n_iter;
    }
    if (residuals !== null) {
        params["residuals"] = residuals;
    }
    if (smooth_sigma !== null) {
        params["smooth_sigma"] = smooth_sigma;
    }
    if (scale_factor !== null) {
        params["scale_factor"] = scale_factor;
    }
    if (echo_time !== null) {
        params["echo_time"] = echo_time;
    }
    if (repetition_time !== null) {
        params["repetition_time"] = repetition_time;
    }
    if (write_intermediate !== null) {
        params["write_intermediate"] = write_intermediate;
    }
    if (extract_subimage !== null) {
        params["extract_subimage"] = extract_subimage;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mri_ms_fitparms_cargs(
    params: MriMsFitparmsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mri_ms_fitparms");
    cargs.push(...(params["volumes"] ?? null).map(f => execution.inputFile(f)));
    cargs.push((params["output_dir"] ?? null));
    if ((params["afi_flag"] ?? false)) {
        cargs.push("-afi");
    }
    if ((params["ait_flag"] ?? false)) {
        cargs.push("-ait");
    }
    if ((params["at"] ?? null) !== null) {
        cargs.push(
            "-at",
            (params["at"] ?? null)
        );
    }
    if ((params["conform_flag"] ?? false)) {
        cargs.push("-conform");
    }
    if ((params["correct_flag"] ?? false)) {
        cargs.push("-correct");
    }
    if ((params["cubic_flag"] ?? false)) {
        cargs.push("-cubic");
    }
    if ((params["debug_slice_flag"] ?? false)) {
        cargs.push("-debug_slice");
    }
    if ((params["debug_voxel_flag"] ?? false)) {
        cargs.push("-debug_voxel");
    }
    if ((params["dt"] ?? null) !== null) {
        cargs.push(
            "-dt",
            (params["dt"] ?? null)
        );
    }
    if ((params["fa"] ?? null) !== null) {
        cargs.push(
            "-fa",
            (params["fa"] ?? null)
        );
    }
    if ((params["fa_scale"] ?? null) !== null) {
        cargs.push(
            "-fa_scale",
            String((params["fa_scale"] ?? null))
        );
    }
    if ((params["faf"] ?? null) !== null) {
        cargs.push(
            "-faf",
            (params["faf"] ?? null)
        );
    }
    if ((params["fsmooth"] ?? null) !== null) {
        cargs.push(
            "-fsmooth",
            String((params["fsmooth"] ?? null))
        );
    }
    if ((params["invert_flag"] ?? false)) {
        cargs.push("-i");
    }
    if ((params["momentum"] ?? null) !== null) {
        cargs.push(
            "-m",
            (params["momentum"] ?? null)
        );
    }
    if ((params["max_t2"] ?? null) !== null) {
        cargs.push(
            "-max",
            (params["max_t2"] ?? null)
        );
    }
    if ((params["n_iter"] ?? null) !== null) {
        cargs.push(
            "-n",
            String((params["n_iter"] ?? null))
        );
    }
    if ((params["nearest_flag"] ?? false)) {
        cargs.push("-nearest");
    }
    if ((params["nocompress_flag"] ?? false)) {
        cargs.push("-nocompress");
    }
    if ((params["nosynth_flag"] ?? false)) {
        cargs.push("-nosynth");
    }
    if ((params["residuals"] ?? null) !== null) {
        cargs.push(
            "-r",
            (params["residuals"] ?? null)
        );
    }
    if ((params["smooth_sigma"] ?? null) !== null) {
        cargs.push(
            "-s",
            String((params["smooth_sigma"] ?? null))
        );
    }
    if ((params["scale_factor"] ?? null) !== null) {
        cargs.push(
            "-scale",
            String((params["scale_factor"] ?? null))
        );
    }
    if ((params["sinc_flag"] ?? false)) {
        cargs.push("-sinc");
    }
    if ((params["transform_flag"] ?? false)) {
        cargs.push("-t");
    }
    if ((params["echo_time"] ?? null) !== null) {
        cargs.push(
            "-te",
            String((params["echo_time"] ?? null))
        );
    }
    if ((params["repetition_time"] ?? null) !== null) {
        cargs.push(
            "-tr",
            String((params["repetition_time"] ?? null))
        );
    }
    if ((params["trilinear_flag"] ?? false)) {
        cargs.push("-trilinear");
    }
    if ((params["tukey_flag"] ?? false)) {
        cargs.push("-tukey");
    }
    if ((params["help_flag"] ?? false)) {
        cargs.push("-u");
    }
    if ((params["use_brain_mask_flag"] ?? false)) {
        cargs.push("-use_brain_mask");
    }
    if ((params["write_intermediate"] ?? null) !== null) {
        cargs.push(
            "-w",
            String((params["write_intermediate"] ?? null))
        );
    }
    if ((params["extract_subimage"] ?? null) !== null) {
        cargs.push(
            "-extract",
            ...(params["extract_subimage"] ?? null).map(String)
        );
    }
    if ((params["window_flag"] ?? false)) {
        cargs.push("-window");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mri_ms_fitparms_outputs(
    params: MriMsFitparmsParameters,
    execution: Execution,
): MriMsFitparmsOutputs {
    const ret: MriMsFitparmsOutputs = {
        root: execution.outputFile("."),
        t1_map: execution.outputFile(["T1.mgz"].join('')),
        pd_map: execution.outputFile(["PD.mgz"].join('')),
        vol0_synthetic: execution.outputFile(["vol0.mgz"].join('')),
        vol0_affine: execution.outputFile(["vol0.lta"].join('')),
        vol1_synthetic: execution.outputFile(["vol1.mgz"].join('')),
        vol1_affine: execution.outputFile(["vol1.lta"].join('')),
    };
    return ret;
}


/**
 * mri_ms_fitparms
 *
 * Tool for estimating T1 and PD values from FLASH images and applying transformations.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MriMsFitparmsOutputs`).
 */
function mri_ms_fitparms_execute(
    params: MriMsFitparmsParameters,
    runner: Runner | null = null,
): MriMsFitparmsOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRI_MS_FITPARMS_METADATA);
    params = execution.params(params)
    const cargs = mri_ms_fitparms_cargs(params, execution)
    const ret = mri_ms_fitparms_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * mri_ms_fitparms
 *
 * Tool for estimating T1 and PD values from FLASH images and applying transformations.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param volumes List of 3D FLASH images with different flip angles.
 * @param output_dir Output directory
 * @param afi_flag Designate flip angle map to use with nominal value 60 degrees
 * @param ait_flag Apply inverse of transform
 * @param at Set acquisition time
 * @param conform_flag Interpolate volume to be isotropic 1mm^3
 * @param correct_flag Correct proton density map (PD) by T2* estimates
 * @param cubic_flag Use cubic interpolation (NOT WORKING!)
 * @param debug_slice_flag Debug slice processing ???
 * @param debug_voxel_flag Debug voxel processing ???
 * @param dt Set time step dt ???
 * @param fa Set flip angle
 * @param fa_scale Set value to scale all flip angles by
 * @param faf Designate flip angle map to use with specified control points
 * @param fsmooth Smooth flip angle map for X iterations of soap bubble smoothing
 * @param invert_flag Invert volumes
 * @param momentum Set momentum
 * @param max_t2 Set max T2*
 * @param n_iter Perform estimation/motion correction X times
 * @param nearest_flag Use nearest-neighbor interpolation
 * @param nocompress_flag Do not compress output volumes (save as .mgh)
 * @param nosynth_flag Disable volume synthesis
 * @param residuals Write out residuals to designated location
 * @param smooth_sigma Smooth faf field with sigma=X
 * @param scale_factor Scale volumes by X after reading
 * @param sinc_flag Use sinc interpolation (default window width is 6)
 * @param transform_flag Apply transform to output volumes
 * @param echo_time Set echo time (TE) in ms
 * @param repetition_time Set repetition time (TR) in ms
 * @param trilinear_flag Use trilinear interpolation
 * @param tukey_flag Use Tukey bi-weight of residuals
 * @param help_flag Display help text
 * @param use_brain_mask_flag Compute a brain mask from the PD map and use it for registration
 * @param write_intermediate Write out intermediate results every X iterations
 * @param extract_subimage Extract a subimage for each input image, specified by x0 y0 z0 dx dy dz
 * @param window_flag Not implemented
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MriMsFitparmsOutputs`).
 */
function mri_ms_fitparms(
    volumes: Array<InputPathType>,
    output_dir: string,
    afi_flag: boolean = false,
    ait_flag: boolean = false,
    at: string | null = null,
    conform_flag: boolean = false,
    correct_flag: boolean = false,
    cubic_flag: boolean = false,
    debug_slice_flag: boolean = false,
    debug_voxel_flag: boolean = false,
    dt: string | null = null,
    fa: string | null = null,
    fa_scale: number | null = null,
    faf: string | null = null,
    fsmooth: number | null = null,
    invert_flag: boolean = false,
    momentum: string | null = null,
    max_t2: string | null = null,
    n_iter: number | null = null,
    nearest_flag: boolean = false,
    nocompress_flag: boolean = false,
    nosynth_flag: boolean = false,
    residuals: string | null = null,
    smooth_sigma: number | null = null,
    scale_factor: number | null = null,
    sinc_flag: boolean = false,
    transform_flag: boolean = false,
    echo_time: number | null = null,
    repetition_time: number | null = null,
    trilinear_flag: boolean = false,
    tukey_flag: boolean = false,
    help_flag: boolean = false,
    use_brain_mask_flag: boolean = false,
    write_intermediate: number | null = null,
    extract_subimage: Array<number> | null = null,
    window_flag: boolean = false,
    runner: Runner | null = null,
): MriMsFitparmsOutputs {
    const params = mri_ms_fitparms_params(volumes, output_dir, afi_flag, ait_flag, at, conform_flag, correct_flag, cubic_flag, debug_slice_flag, debug_voxel_flag, dt, fa, fa_scale, faf, fsmooth, invert_flag, momentum, max_t2, n_iter, nearest_flag, nocompress_flag, nosynth_flag, residuals, smooth_sigma, scale_factor, sinc_flag, transform_flag, echo_time, repetition_time, trilinear_flag, tukey_flag, help_flag, use_brain_mask_flag, write_intermediate, extract_subimage, window_flag)
    return mri_ms_fitparms_execute(params, runner);
}


export {
      MRI_MS_FITPARMS_METADATA,
      MriMsFitparmsOutputs,
      mri_ms_fitparms,
      mri_ms_fitparms_execute,
      mri_ms_fitparms_params,
};
