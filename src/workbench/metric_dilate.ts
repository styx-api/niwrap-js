// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const METRIC_DILATE_METADATA: Metadata = {
    id: "5f7bbed13558b8a40bfedd7f35e6b45da7a74ffa.workbench",
    name: "metric-dilate",
    package: "workbench",
    container_image_tag: "nx10x/workbench:2.1.0",
};


interface MetricDilateParamsDict {
    "@type"?: "workbench/metric-dilate";
    "metric": InputPathType;
    "surface": InputPathType;
    "distance": number;
    "metric-out": string;
    "area-metric"?: InputPathType | null | undefined;
    "exponent"?: number | null | undefined;
    "column"?: string | null | undefined;
    "roi-metric"?: InputPathType | null | undefined;
    "roi-metric"?: InputPathType | null | undefined;
    "legacy-cutoff": boolean;
    "linear": boolean;
    "nearest": boolean;
}
type MetricDilateParamsDictTagged = Required<Pick<MetricDilateParamsDict, '@type'>> & MetricDilateParamsDict;


/**
 * Output object returned when calling `MetricDilateParamsDict(...)`.
 *
 * @interface
 */
interface MetricDilateOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output metric
     */
    metric_out: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param metric the metric to dilate
 * @param surface the surface to compute on
 * @param distance distance in mm to dilate
 * @param metric_out the output metric
 * @param area_metric vertex areas to use instead of computing them from the surface

the corrected vertex areas, as a metric
 * @param exponent use a different exponent in the weighting function

exponent 'n' to use in (area / (distance ^ n)) as the weighting function (default 6)
 * @param column select a single column to dilate

the column number or name
 * @param roi_metric specify an roi of where there is data

metric file, positive values denote vertices that have data
 * @param roi_metric_ specify an roi of vertices to overwrite, rather than vertices with value zero

metric file, positive values denote vertices to have their values replaced
 * @param legacy_cutoff use the v1.3.2 method of choosing how many vertices to use when calulating the dilated value with weighted method
 * @param linear fill in values with linear interpolation along strongest gradient
 * @param nearest use the nearest good value instead of a weighted average
 *
 * @returns Parameter dictionary
 */
function metric_dilate_params(
    metric: InputPathType,
    surface: InputPathType,
    distance: number,
    metric_out: string,
    area_metric: InputPathType | null = null,
    exponent: number | null = null,
    column: string | null = null,
    roi_metric: InputPathType | null = null,
    roi_metric_: InputPathType | null = null,
    legacy_cutoff: boolean = false,
    linear: boolean = false,
    nearest: boolean = false,
): MetricDilateParamsDictTagged {
    const params = {
        "@type": "workbench/metric-dilate" as const,
        "metric": metric,
        "surface": surface,
        "distance": distance,
        "metric-out": metric_out,
        "legacy-cutoff": legacy_cutoff,
        "linear": linear,
        "nearest": nearest,
    };
    if (area_metric !== null) {
        params["area-metric"] = area_metric;
    }
    if (exponent !== null) {
        params["exponent"] = exponent;
    }
    if (column !== null) {
        params["column"] = column;
    }
    if (roi_metric !== null) {
        params["roi-metric"] = roi_metric;
    }
    if (roi_metric_ !== null) {
        params["roi-metric"] = roi_metric_;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function metric_dilate_cargs(
    params: MetricDilateParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(
        "wb_command",
        "-metric-dilate"
    );
    cargs.push(execution.inputFile((params["metric"] ?? null)));
    cargs.push(execution.inputFile((params["surface"] ?? null)));
    cargs.push(String((params["distance"] ?? null)));
    cargs.push((params["metric-out"] ?? null));
    if ((params["area-metric"] ?? null) !== null) {
        cargs.push(
            "-corrected-areas",
            execution.inputFile((params["area-metric"] ?? null))
        );
    }
    if ((params["exponent"] ?? null) !== null) {
        cargs.push(
            "-exponent",
            String((params["exponent"] ?? null))
        );
    }
    if ((params["column"] ?? null) !== null) {
        cargs.push(
            "-column",
            (params["column"] ?? null)
        );
    }
    if ((params["roi-metric"] ?? null) !== null) {
        cargs.push(
            "-data-roi",
            execution.inputFile((params["roi-metric"] ?? null))
        );
    }
    if ((params["roi-metric"] ?? null) !== null) {
        cargs.push(
            "-bad-vertex-roi",
            execution.inputFile((params["roi-metric"] ?? null))
        );
    }
    if ((params["legacy-cutoff"] ?? false)) {
        cargs.push("-legacy-cutoff");
    }
    if ((params["linear"] ?? false)) {
        cargs.push("-linear");
    }
    if ((params["nearest"] ?? false)) {
        cargs.push("-nearest");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function metric_dilate_outputs(
    params: MetricDilateParamsDict,
    execution: Execution,
): MetricDilateOutputs {
    const ret: MetricDilateOutputs = {
        root: execution.outputFile("."),
        metric_out: execution.outputFile([(params["metric-out"] ?? null)].join('')),
    };
    return ret;
}


/**
 * DILATE A METRIC FILE.
 *
 * For all metric vertices that are designated as bad, if they neighbor a non-bad vertex with data or are within the specified distance of such a vertex, replace the value with a distance-based weighted average of nearby non-bad vertices that have data, otherwise set the value to zero.  No matter how small <distance> is, dilation will always use at least the immediate neighbor vertices.  If -nearest is specified, it will use the value from the closest non-bad vertex with data within range instead of a weighted average.
 *
 * If -bad-vertex-roi is specified, all vertices with a positive ROI value are bad.  If it is not specified, only vertices that have data, with a value of zero, are bad.  If -data-roi is not specified, all vertices are assumed to have data.
 *
 * Note that the -corrected-areas option uses an approximate correction for the change in distances along a group average surface.
 *
 * To get the behavior of version 1.3.2 or earlier, use '-legacy-cutoff -exponent 2'.
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MetricDilateOutputs`).
 */
function metric_dilate_execute(
    params: MetricDilateParamsDict,
    runner: Runner | null = null,
): MetricDilateOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(METRIC_DILATE_METADATA);
    params = execution.params(params)
    const cargs = metric_dilate_cargs(params, execution)
    const ret = metric_dilate_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * DILATE A METRIC FILE.
 *
 * For all metric vertices that are designated as bad, if they neighbor a non-bad vertex with data or are within the specified distance of such a vertex, replace the value with a distance-based weighted average of nearby non-bad vertices that have data, otherwise set the value to zero.  No matter how small <distance> is, dilation will always use at least the immediate neighbor vertices.  If -nearest is specified, it will use the value from the closest non-bad vertex with data within range instead of a weighted average.
 *
 * If -bad-vertex-roi is specified, all vertices with a positive ROI value are bad.  If it is not specified, only vertices that have data, with a value of zero, are bad.  If -data-roi is not specified, all vertices are assumed to have data.
 *
 * Note that the -corrected-areas option uses an approximate correction for the change in distances along a group average surface.
 *
 * To get the behavior of version 1.3.2 or earlier, use '-legacy-cutoff -exponent 2'.
 *
 * @param metric the metric to dilate
 * @param surface the surface to compute on
 * @param distance distance in mm to dilate
 * @param metric_out the output metric
 * @param area_metric vertex areas to use instead of computing them from the surface

the corrected vertex areas, as a metric
 * @param exponent use a different exponent in the weighting function

exponent 'n' to use in (area / (distance ^ n)) as the weighting function (default 6)
 * @param column select a single column to dilate

the column number or name
 * @param roi_metric specify an roi of where there is data

metric file, positive values denote vertices that have data
 * @param roi_metric_ specify an roi of vertices to overwrite, rather than vertices with value zero

metric file, positive values denote vertices to have their values replaced
 * @param legacy_cutoff use the v1.3.2 method of choosing how many vertices to use when calulating the dilated value with weighted method
 * @param linear fill in values with linear interpolation along strongest gradient
 * @param nearest use the nearest good value instead of a weighted average
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MetricDilateOutputs`).
 */
function metric_dilate(
    metric: InputPathType,
    surface: InputPathType,
    distance: number,
    metric_out: string,
    area_metric: InputPathType | null = null,
    exponent: number | null = null,
    column: string | null = null,
    roi_metric: InputPathType | null = null,
    roi_metric_: InputPathType | null = null,
    legacy_cutoff: boolean = false,
    linear: boolean = false,
    nearest: boolean = false,
    runner: Runner | null = null,
): MetricDilateOutputs {
    const params = metric_dilate_params(metric, surface, distance, metric_out, area_metric, exponent, column, roi_metric, roi_metric_, legacy_cutoff, linear, nearest)
    return metric_dilate_execute(params, runner);
}


export {
      METRIC_DILATE_METADATA,
      MetricDilateOutputs,
      MetricDilateParamsDict,
      MetricDilateParamsDictTagged,
      metric_dilate,
      metric_dilate_execute,
      metric_dilate_params,
};
