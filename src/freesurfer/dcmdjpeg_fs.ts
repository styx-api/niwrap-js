// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const DCMDJPEG_FS_METADATA: Metadata = {
    id: "72def5b0b090531bebd9d33b2cf8001287532af2.boutiques",
    name: "dcmdjpeg.fs",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface DcmdjpegFsParameters {
    "__STYXTYPE__": "dcmdjpeg.fs";
    "input_file": InputPathType;
    "output_file": string;
    "help": boolean;
    "version": boolean;
    "arguments": boolean;
    "quiet": boolean;
    "verbose": boolean;
    "debug": boolean;
    "log_level"?: string | null | undefined;
    "log_config"?: InputPathType | null | undefined;
    "read_file": boolean;
    "read_file_only": boolean;
    "read_dataset": boolean;
    "conv_photometric": boolean;
    "conv_lossy": boolean;
    "conv_guess": boolean;
    "conv_guess_lossy": boolean;
    "conv_always": boolean;
    "conv_never": boolean;
    "planar_auto": boolean;
    "color_by_pixel": boolean;
    "color_by_plane": boolean;
    "uid_default": boolean;
    "uid_always": boolean;
    "workaround_pred6": boolean;
    "workaround_incpl": boolean;
    "write_file": boolean;
    "write_dataset": boolean;
    "write_xfer_little": boolean;
    "write_xfer_big": boolean;
    "write_xfer_implicit": boolean;
    "enable_new_vr": boolean;
    "disable_new_vr": boolean;
    "group_length_recalc": boolean;
    "group_length_create": boolean;
    "group_length_remove": boolean;
    "length_explicit": boolean;
    "length_undefined": boolean;
    "padding_retain": boolean;
    "padding_off": boolean;
    "padding_create"?: Array<number> | null | undefined;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "dcmdjpeg.fs": dcmdjpeg_fs_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "dcmdjpeg.fs": dcmdjpeg_fs_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `dcmdjpeg_fs(...)`.
 *
 * @interface
 */
interface DcmdjpegFsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * DICOM output file
     */
    output_file: OutputPathType;
}


function dcmdjpeg_fs_params(
    input_file: InputPathType,
    output_file: string,
    help: boolean = false,
    version: boolean = false,
    arguments_: boolean = false,
    quiet: boolean = false,
    verbose: boolean = false,
    debug: boolean = false,
    log_level: string | null = null,
    log_config: InputPathType | null = null,
    read_file: boolean = false,
    read_file_only: boolean = false,
    read_dataset: boolean = false,
    conv_photometric: boolean = false,
    conv_lossy: boolean = false,
    conv_guess: boolean = false,
    conv_guess_lossy: boolean = false,
    conv_always: boolean = false,
    conv_never: boolean = false,
    planar_auto: boolean = false,
    color_by_pixel: boolean = false,
    color_by_plane: boolean = false,
    uid_default: boolean = false,
    uid_always: boolean = false,
    workaround_pred6: boolean = false,
    workaround_incpl: boolean = false,
    write_file: boolean = false,
    write_dataset: boolean = false,
    write_xfer_little: boolean = false,
    write_xfer_big: boolean = false,
    write_xfer_implicit: boolean = false,
    enable_new_vr: boolean = false,
    disable_new_vr: boolean = false,
    group_length_recalc: boolean = false,
    group_length_create: boolean = false,
    group_length_remove: boolean = false,
    length_explicit: boolean = false,
    length_undefined: boolean = false,
    padding_retain: boolean = false,
    padding_off: boolean = false,
    padding_create: Array<number> | null = null,
): DcmdjpegFsParameters {
    /**
     * Build parameters.
    
     * @param input_file DICOM input filename to be converted
     * @param output_file DICOM output filename
     * @param help Print this help text and exit
     * @param version Print version information and exit
     * @param arguments_ Print expanded command line arguments
     * @param quiet Quiet mode, print no warnings and errors
     * @param verbose Verbose mode, print processing details
     * @param debug Debug mode, print debug information
     * @param log_level Use level l for the logger (fatal, error, warn, info, debug, trace)
     * @param log_config Use config file f for the logger
     * @param read_file Read file format or data set (default)
     * @param read_file_only Read file format only
     * @param read_dataset Read data set without file meta information
     * @param conv_photometric Convert if YCbCr photometric interpretation (default)
     * @param conv_lossy Convert YCbCr to RGB if lossy JPEG
     * @param conv_guess Convert to RGB if YCbCr is guessed by library
     * @param conv_guess_lossy Convert to RGB if lossy JPEG and YCbCr is guessed
     * @param conv_always Always convert YCbCr to RGB
     * @param conv_never Never convert color space
     * @param planar_auto Automatically determine planar configuration from SOP class and color space (default)
     * @param color_by_pixel Always store color-by-pixel
     * @param color_by_plane Always store color-by-plane
     * @param uid_default Keep same SOP Instance UID (default)
     * @param uid_always Always assign new UID
     * @param workaround_pred6 Enable workaround for JPEG lossless images with overflow in predictor 6
     * @param workaround_incpl Enable workaround for incomplete JPEG data
     * @param write_file Write file format (default)
     * @param write_dataset Write data set without file meta information
     * @param write_xfer_little Write with explicit VR little endian (default)
     * @param write_xfer_big Write with explicit VR big endian TS
     * @param write_xfer_implicit Write with implicit VR little endian TS
     * @param enable_new_vr Enable support for new VRs (UN/UT) (default)
     * @param disable_new_vr Disable support for new VRs, convert to OB
     * @param group_length_recalc Recalculate group lengths if present (default)
     * @param group_length_create Always write with group length elements
     * @param group_length_remove Always write without group length elements
     * @param length_explicit Write with explicit lengths (default)
     * @param length_undefined Write with undefined lengths
     * @param padding_retain Do not change padding (default if not --write-dataset)
     * @param padding_off No padding (implicit if --write-dataset)
     * @param padding_create Align file on multiple of f bytes and items on multiple of i bytes
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "dcmdjpeg.fs" as const,
        "input_file": input_file,
        "output_file": output_file,
        "help": help,
        "version": version,
        "arguments": arguments_,
        "quiet": quiet,
        "verbose": verbose,
        "debug": debug,
        "read_file": read_file,
        "read_file_only": read_file_only,
        "read_dataset": read_dataset,
        "conv_photometric": conv_photometric,
        "conv_lossy": conv_lossy,
        "conv_guess": conv_guess,
        "conv_guess_lossy": conv_guess_lossy,
        "conv_always": conv_always,
        "conv_never": conv_never,
        "planar_auto": planar_auto,
        "color_by_pixel": color_by_pixel,
        "color_by_plane": color_by_plane,
        "uid_default": uid_default,
        "uid_always": uid_always,
        "workaround_pred6": workaround_pred6,
        "workaround_incpl": workaround_incpl,
        "write_file": write_file,
        "write_dataset": write_dataset,
        "write_xfer_little": write_xfer_little,
        "write_xfer_big": write_xfer_big,
        "write_xfer_implicit": write_xfer_implicit,
        "enable_new_vr": enable_new_vr,
        "disable_new_vr": disable_new_vr,
        "group_length_recalc": group_length_recalc,
        "group_length_create": group_length_create,
        "group_length_remove": group_length_remove,
        "length_explicit": length_explicit,
        "length_undefined": length_undefined,
        "padding_retain": padding_retain,
        "padding_off": padding_off,
    };
    if (log_level !== null) {
        params["log_level"] = log_level;
    }
    if (log_config !== null) {
        params["log_config"] = log_config;
    }
    if (padding_create !== null) {
        params["padding_create"] = padding_create;
    }
    return params;
}


function dcmdjpeg_fs_cargs(
    params: DcmdjpegFsParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("dcmdjpeg");
    cargs.push(execution.inputFile((params["input_file"] ?? null)));
    cargs.push((params["output_file"] ?? null));
    if ((params["help"] ?? null)) {
        cargs.push("-h");
    }
    if ((params["version"] ?? null)) {
        cargs.push("--version");
    }
    if ((params["arguments"] ?? null)) {
        cargs.push("--arguments");
    }
    if ((params["quiet"] ?? null)) {
        cargs.push("-q");
    }
    if ((params["verbose"] ?? null)) {
        cargs.push("-v");
    }
    if ((params["debug"] ?? null)) {
        cargs.push("-d");
    }
    if ((params["log_level"] ?? null) !== null) {
        cargs.push(
            "-ll",
            (params["log_level"] ?? null)
        );
    }
    if ((params["log_config"] ?? null) !== null) {
        cargs.push(
            "-lc",
            execution.inputFile((params["log_config"] ?? null))
        );
    }
    if ((params["read_file"] ?? null)) {
        cargs.push("+f");
    }
    if ((params["read_file_only"] ?? null)) {
        cargs.push("+fo");
    }
    if ((params["read_dataset"] ?? null)) {
        cargs.push("-f");
    }
    if ((params["conv_photometric"] ?? null)) {
        cargs.push("+cp");
    }
    if ((params["conv_lossy"] ?? null)) {
        cargs.push("+cl");
    }
    if ((params["conv_guess"] ?? null)) {
        cargs.push("+cg");
    }
    if ((params["conv_guess_lossy"] ?? null)) {
        cargs.push("+cgl");
    }
    if ((params["conv_always"] ?? null)) {
        cargs.push("+ca");
    }
    if ((params["conv_never"] ?? null)) {
        cargs.push("+cn");
    }
    if ((params["planar_auto"] ?? null)) {
        cargs.push("+pa");
    }
    if ((params["color_by_pixel"] ?? null)) {
        cargs.push("+px");
    }
    if ((params["color_by_plane"] ?? null)) {
        cargs.push("+pl");
    }
    if ((params["uid_default"] ?? null)) {
        cargs.push("+ud");
    }
    if ((params["uid_always"] ?? null)) {
        cargs.push("+ua");
    }
    if ((params["workaround_pred6"] ?? null)) {
        cargs.push("+w6");
    }
    if ((params["workaround_incpl"] ?? null)) {
        cargs.push("+wi");
    }
    if ((params["write_file"] ?? null)) {
        cargs.push("+F");
    }
    if ((params["write_dataset"] ?? null)) {
        cargs.push("-F");
    }
    if ((params["write_xfer_little"] ?? null)) {
        cargs.push("+te");
    }
    if ((params["write_xfer_big"] ?? null)) {
        cargs.push("+tb");
    }
    if ((params["write_xfer_implicit"] ?? null)) {
        cargs.push("+ti");
    }
    if ((params["enable_new_vr"] ?? null)) {
        cargs.push("+u");
    }
    if ((params["disable_new_vr"] ?? null)) {
        cargs.push("-u");
    }
    if ((params["group_length_recalc"] ?? null)) {
        cargs.push("+g=");
    }
    if ((params["group_length_create"] ?? null)) {
        cargs.push("+g");
    }
    if ((params["group_length_remove"] ?? null)) {
        cargs.push("-g");
    }
    if ((params["length_explicit"] ?? null)) {
        cargs.push("+e");
    }
    if ((params["length_undefined"] ?? null)) {
        cargs.push("-e");
    }
    if ((params["padding_retain"] ?? null)) {
        cargs.push("-p=");
    }
    if ((params["padding_off"] ?? null)) {
        cargs.push("-p");
    }
    if ((params["padding_create"] ?? null) !== null) {
        cargs.push(
            "+p",
            ...(params["padding_create"] ?? null).map(String)
        );
    }
    return cargs;
}


function dcmdjpeg_fs_outputs(
    params: DcmdjpegFsParameters,
    execution: Execution,
): DcmdjpegFsOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: DcmdjpegFsOutputs = {
        root: execution.outputFile("."),
        output_file: execution.outputFile([(params["output_file"] ?? null)].join('')),
    };
    return ret;
}


function dcmdjpeg_fs_execute(
    params: DcmdjpegFsParameters,
    execution: Execution,
): DcmdjpegFsOutputs {
    /**
     * A tool to decode JPEG-compressed DICOM files.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `DcmdjpegFsOutputs`).
     */
    params = execution.params(params)
    const cargs = dcmdjpeg_fs_cargs(params, execution)
    const ret = dcmdjpeg_fs_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function dcmdjpeg_fs(
    input_file: InputPathType,
    output_file: string,
    help: boolean = false,
    version: boolean = false,
    arguments_: boolean = false,
    quiet: boolean = false,
    verbose: boolean = false,
    debug: boolean = false,
    log_level: string | null = null,
    log_config: InputPathType | null = null,
    read_file: boolean = false,
    read_file_only: boolean = false,
    read_dataset: boolean = false,
    conv_photometric: boolean = false,
    conv_lossy: boolean = false,
    conv_guess: boolean = false,
    conv_guess_lossy: boolean = false,
    conv_always: boolean = false,
    conv_never: boolean = false,
    planar_auto: boolean = false,
    color_by_pixel: boolean = false,
    color_by_plane: boolean = false,
    uid_default: boolean = false,
    uid_always: boolean = false,
    workaround_pred6: boolean = false,
    workaround_incpl: boolean = false,
    write_file: boolean = false,
    write_dataset: boolean = false,
    write_xfer_little: boolean = false,
    write_xfer_big: boolean = false,
    write_xfer_implicit: boolean = false,
    enable_new_vr: boolean = false,
    disable_new_vr: boolean = false,
    group_length_recalc: boolean = false,
    group_length_create: boolean = false,
    group_length_remove: boolean = false,
    length_explicit: boolean = false,
    length_undefined: boolean = false,
    padding_retain: boolean = false,
    padding_off: boolean = false,
    padding_create: Array<number> | null = null,
    runner: Runner | null = null,
): DcmdjpegFsOutputs {
    /**
     * A tool to decode JPEG-compressed DICOM files.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param input_file DICOM input filename to be converted
     * @param output_file DICOM output filename
     * @param help Print this help text and exit
     * @param version Print version information and exit
     * @param arguments_ Print expanded command line arguments
     * @param quiet Quiet mode, print no warnings and errors
     * @param verbose Verbose mode, print processing details
     * @param debug Debug mode, print debug information
     * @param log_level Use level l for the logger (fatal, error, warn, info, debug, trace)
     * @param log_config Use config file f for the logger
     * @param read_file Read file format or data set (default)
     * @param read_file_only Read file format only
     * @param read_dataset Read data set without file meta information
     * @param conv_photometric Convert if YCbCr photometric interpretation (default)
     * @param conv_lossy Convert YCbCr to RGB if lossy JPEG
     * @param conv_guess Convert to RGB if YCbCr is guessed by library
     * @param conv_guess_lossy Convert to RGB if lossy JPEG and YCbCr is guessed
     * @param conv_always Always convert YCbCr to RGB
     * @param conv_never Never convert color space
     * @param planar_auto Automatically determine planar configuration from SOP class and color space (default)
     * @param color_by_pixel Always store color-by-pixel
     * @param color_by_plane Always store color-by-plane
     * @param uid_default Keep same SOP Instance UID (default)
     * @param uid_always Always assign new UID
     * @param workaround_pred6 Enable workaround for JPEG lossless images with overflow in predictor 6
     * @param workaround_incpl Enable workaround for incomplete JPEG data
     * @param write_file Write file format (default)
     * @param write_dataset Write data set without file meta information
     * @param write_xfer_little Write with explicit VR little endian (default)
     * @param write_xfer_big Write with explicit VR big endian TS
     * @param write_xfer_implicit Write with implicit VR little endian TS
     * @param enable_new_vr Enable support for new VRs (UN/UT) (default)
     * @param disable_new_vr Disable support for new VRs, convert to OB
     * @param group_length_recalc Recalculate group lengths if present (default)
     * @param group_length_create Always write with group length elements
     * @param group_length_remove Always write without group length elements
     * @param length_explicit Write with explicit lengths (default)
     * @param length_undefined Write with undefined lengths
     * @param padding_retain Do not change padding (default if not --write-dataset)
     * @param padding_off No padding (implicit if --write-dataset)
     * @param padding_create Align file on multiple of f bytes and items on multiple of i bytes
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `DcmdjpegFsOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(DCMDJPEG_FS_METADATA);
    const params = dcmdjpeg_fs_params(input_file, output_file, help, version, arguments_, quiet, verbose, debug, log_level, log_config, read_file, read_file_only, read_dataset, conv_photometric, conv_lossy, conv_guess, conv_guess_lossy, conv_always, conv_never, planar_auto, color_by_pixel, color_by_plane, uid_default, uid_always, workaround_pred6, workaround_incpl, write_file, write_dataset, write_xfer_little, write_xfer_big, write_xfer_implicit, enable_new_vr, disable_new_vr, group_length_recalc, group_length_create, group_length_remove, length_explicit, length_undefined, padding_retain, padding_off, padding_create)
    return dcmdjpeg_fs_execute(params, execution);
}


export {
      DCMDJPEG_FS_METADATA,
      DcmdjpegFsOutputs,
      DcmdjpegFsParameters,
      dcmdjpeg_fs,
      dcmdjpeg_fs_params,
};
