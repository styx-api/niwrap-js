// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const SEG2RECON_METADATA: Metadata = {
    id: "22df8aaa390ed4db847c18846a8feb2c642ed1eb.boutiques",
    name: "seg2recon",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface Seg2reconParameters {
    "@type"?: "freesurfer/seg2recon";
    "subject": string;
    "segvol": InputPathType;
    "inputvol": InputPathType;
    "ctab"?: InputPathType | null | undefined;
    "ndilate"?: number | null | undefined;
    "threads"?: number | null | undefined;
    "force_update": boolean;
    "no_cc": boolean;
    "mask"?: InputPathType | null | undefined;
    "headmask"?: InputPathType | null | undefined;
    "thresh"?: number | null | undefined;
    "expert"?: InputPathType | null | undefined;
    "rca": boolean;
    "no_bias_field_cor": boolean;
}
type Seg2reconParametersTagged = Required<Pick<Seg2reconParameters, '@type'>> & Seg2reconParameters;


/**
 * Output object returned when calling `Seg2reconParameters(...)`.
 *
 * @interface
 */
interface Seg2reconOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output aseg.auto.mgz file including corpus callosum segmentation
     */
    aseg_auto_mgz: OutputPathType;
    /**
     * Bias field corrected output nu.mgz file
     */
    nu_mgz: OutputPathType;
    /**
     * Output brainmask.mgz file
     */
    brainmask_mgz: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param subject Output subject directory name.
 * @param segvol Aseg-type volume, e.g., from synthseg, fastsurfer, psacnn, samseg, or aseg.
 * @param inputvol Input volume as would be passed to recon-all.
 * @param ctab Color table for the segmentation. Uses embedded table if available, or FreeSurferColorLUT.txt if not specified.
 * @param ndilate Dilate binarization of segmentation when creating brainmask. Default is 2.
 * @param threads Number of threads to use for processing.
 * @param force_update Force regeneration of files whether needed or not.
 * @param no_cc Do not segment corpus callosum.
 * @param mask Use this mask as brainmask instead of computing from segmentation.
 * @param headmask Use this headmask instead of running mri_seghead.
 * @param thresh Threshold for bias field estimation.
 * @param expert Path to expert options file.
 * @param rca Run recon-all on the output.
 * @param no_bias_field_cor Do not compute or apply bias field correction.
 *
 * @returns Parameter dictionary
 */
function seg2recon_params(
    subject: string,
    segvol: InputPathType,
    inputvol: InputPathType,
    ctab: InputPathType | null = null,
    ndilate: number | null = null,
    threads: number | null = null,
    force_update: boolean = false,
    no_cc: boolean = false,
    mask: InputPathType | null = null,
    headmask: InputPathType | null = null,
    thresh: number | null = null,
    expert: InputPathType | null = null,
    rca: boolean = false,
    no_bias_field_cor: boolean = false,
): Seg2reconParametersTagged {
    const params = {
        "@type": "freesurfer/seg2recon" as const,
        "subject": subject,
        "segvol": segvol,
        "inputvol": inputvol,
        "force_update": force_update,
        "no_cc": no_cc,
        "rca": rca,
        "no_bias_field_cor": no_bias_field_cor,
    };
    if (ctab !== null) {
        params["ctab"] = ctab;
    }
    if (ndilate !== null) {
        params["ndilate"] = ndilate;
    }
    if (threads !== null) {
        params["threads"] = threads;
    }
    if (mask !== null) {
        params["mask"] = mask;
    }
    if (headmask !== null) {
        params["headmask"] = headmask;
    }
    if (thresh !== null) {
        params["thresh"] = thresh;
    }
    if (expert !== null) {
        params["expert"] = expert;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function seg2recon_cargs(
    params: Seg2reconParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("seg2recon");
    cargs.push(
        "-s",
        (params["subject"] ?? null)
    );
    cargs.push(
        "-seg",
        execution.inputFile((params["segvol"] ?? null))
    );
    cargs.push(
        "-i",
        execution.inputFile((params["inputvol"] ?? null))
    );
    if ((params["ctab"] ?? null) !== null) {
        cargs.push(
            "-ctab",
            execution.inputFile((params["ctab"] ?? null))
        );
    }
    if ((params["ndilate"] ?? null) !== null) {
        cargs.push(
            "--ndilate",
            String((params["ndilate"] ?? null))
        );
    }
    if ((params["threads"] ?? null) !== null) {
        cargs.push(
            "--threads",
            String((params["threads"] ?? null))
        );
    }
    if ((params["force_update"] ?? false)) {
        cargs.push("--force-update");
    }
    if ((params["no_cc"] ?? false)) {
        cargs.push("--no-cc");
    }
    if ((params["mask"] ?? null) !== null) {
        cargs.push(
            "--m",
            execution.inputFile((params["mask"] ?? null))
        );
    }
    if ((params["headmask"] ?? null) !== null) {
        cargs.push(
            "--h",
            execution.inputFile((params["headmask"] ?? null))
        );
    }
    if ((params["thresh"] ?? null) !== null) {
        cargs.push(
            "--thresh",
            String((params["thresh"] ?? null))
        );
    }
    if ((params["expert"] ?? null) !== null) {
        cargs.push(
            "--expert",
            execution.inputFile((params["expert"] ?? null))
        );
    }
    if ((params["rca"] ?? false)) {
        cargs.push("--rca");
    }
    if ((params["no_bias_field_cor"] ?? false)) {
        cargs.push("--no-bias-field-cor");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function seg2recon_outputs(
    params: Seg2reconParameters,
    execution: Execution,
): Seg2reconOutputs {
    const ret: Seg2reconOutputs = {
        root: execution.outputFile("."),
        aseg_auto_mgz: execution.outputFile([(params["subject"] ?? null), "/aseg.auto.mgz"].join('')),
        nu_mgz: execution.outputFile([(params["subject"] ?? null), "/nu.mgz"].join('')),
        brainmask_mgz: execution.outputFile([(params["subject"] ?? null), "/brainmask.mgz"].join('')),
    };
    return ret;
}


/**
 * seg2recon
 *
 * Creates and populates a subjects directory from an input image and segmentation suitable for running recon-all.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `Seg2reconOutputs`).
 */
function seg2recon_execute(
    params: Seg2reconParameters,
    runner: Runner | null = null,
): Seg2reconOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(SEG2RECON_METADATA);
    params = execution.params(params)
    const cargs = seg2recon_cargs(params, execution)
    const ret = seg2recon_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * seg2recon
 *
 * Creates and populates a subjects directory from an input image and segmentation suitable for running recon-all.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param subject Output subject directory name.
 * @param segvol Aseg-type volume, e.g., from synthseg, fastsurfer, psacnn, samseg, or aseg.
 * @param inputvol Input volume as would be passed to recon-all.
 * @param ctab Color table for the segmentation. Uses embedded table if available, or FreeSurferColorLUT.txt if not specified.
 * @param ndilate Dilate binarization of segmentation when creating brainmask. Default is 2.
 * @param threads Number of threads to use for processing.
 * @param force_update Force regeneration of files whether needed or not.
 * @param no_cc Do not segment corpus callosum.
 * @param mask Use this mask as brainmask instead of computing from segmentation.
 * @param headmask Use this headmask instead of running mri_seghead.
 * @param thresh Threshold for bias field estimation.
 * @param expert Path to expert options file.
 * @param rca Run recon-all on the output.
 * @param no_bias_field_cor Do not compute or apply bias field correction.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `Seg2reconOutputs`).
 */
function seg2recon(
    subject: string,
    segvol: InputPathType,
    inputvol: InputPathType,
    ctab: InputPathType | null = null,
    ndilate: number | null = null,
    threads: number | null = null,
    force_update: boolean = false,
    no_cc: boolean = false,
    mask: InputPathType | null = null,
    headmask: InputPathType | null = null,
    thresh: number | null = null,
    expert: InputPathType | null = null,
    rca: boolean = false,
    no_bias_field_cor: boolean = false,
    runner: Runner | null = null,
): Seg2reconOutputs {
    const params = seg2recon_params(subject, segvol, inputvol, ctab, ndilate, threads, force_update, no_cc, mask, headmask, thresh, expert, rca, no_bias_field_cor)
    return seg2recon_execute(params, runner);
}


export {
      SEG2RECON_METADATA,
      Seg2reconOutputs,
      seg2recon,
      seg2recon_execute,
      seg2recon_params,
};
