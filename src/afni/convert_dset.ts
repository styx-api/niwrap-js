// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const CONVERT_DSET_METADATA: Metadata = {
    id: "4beee4c1c48b313053c056b039eaf7a92a5a5c03.boutiques",
    name: "ConvertDset",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface ConvertDsetParameters {
    "@type": "afni.ConvertDset";
    "output_type": Array<"niml_asc" | "niml_bi" | "1D" | "1Dp" | "1Dpt" | "gii" | "gii_asc" | "gii_b64" | "gii_b64gz" | "1D_stderr" | "1D_stdout" | "niml_stderr" | "niml_stdout" | "1Dp_stdout" | "1Dp_stderr" | "1Dpt_stdout" | "1Dpt_stderr">;
    "input_dataset": InputPathType;
    "input_type"?: "niml" | "1D" | "dx" | null | undefined;
    "output_prefix"?: string | null | undefined;
    "dset_labels"?: string | null | undefined;
    "add_node_index": boolean;
    "node_index_file"?: InputPathType | null | undefined;
    "node_select_file"?: InputPathType | null | undefined;
    "prepend_node_index": boolean;
    "pad_to_node"?: string | null | undefined;
    "labelize"?: InputPathType | null | undefined;
    "graphize": boolean;
    "graph_nodelist"?: string | null | undefined;
    "graph_full_nodelist"?: InputPathType | null | undefined;
    "graph_named_nodelist"?: string | null | undefined;
    "graph_xyz_lpi": boolean;
    "graph_edgelist"?: InputPathType | null | undefined;
    "onegraph": boolean;
    "multigraph": boolean;
    "split"?: number | null | undefined;
    "no_history": boolean;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "afni.ConvertDset": convert_dset_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "afni.ConvertDset": convert_dset_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `convert_dset(...)`.
 *
 * @interface
 */
interface ConvertDsetOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Converted dataset output
     */
    converted_dataset: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param output_type Type of output datasets
 * @param input_dataset Input dataset to be converted
 * @param input_type Type of input datasets
 * @param output_prefix Output prefix for dataset
 * @param dset_labels Label the columns (sub-bricks) of the output dataset
 * @param add_node_index Add a node index element if one does not exist in the input dataset
 * @param node_index_file File containing node indices
 * @param node_select_file File specifying the nodes to keep in the output
 * @param prepend_node_index Add a node index column to the data
 * @param pad_to_node Output a full dataset from node 0 to MAX_INDEX
 * @param labelize Turn the dataset into a labeled set per the colormap in CMAP
 * @param graphize Turn the dataset into a SUMA graph dataset
 * @param graph_nodelist Two files specifying the indices and the coordinates of the graph's nodes
 * @param graph_full_nodelist Similar to -graph_nodelist_1D but without need for NODEINDLIST.1D
 * @param graph_named_nodelist Two files specifying graph node indices, string labels, and their coordinates
 * @param graph_xyz_lpi Coordinates in NodeList.1D are in LPI instead of RAI
 * @param graph_edgelist Indices of graph nodes defining edge
 * @param onegraph Expect input dataset to be one square matrix defining the graph (default)
 * @param multigraph Expect each column in input dataset to define an entire graph
 * @param split Split a multi-column dataset into about N output datasets
 * @param no_history Do not include a history element in the output
 *
 * @returns Parameter dictionary
 */
function convert_dset_params(
    output_type: Array<"niml_asc" | "niml_bi" | "1D" | "1Dp" | "1Dpt" | "gii" | "gii_asc" | "gii_b64" | "gii_b64gz" | "1D_stderr" | "1D_stdout" | "niml_stderr" | "niml_stdout" | "1Dp_stdout" | "1Dp_stderr" | "1Dpt_stdout" | "1Dpt_stderr">,
    input_dataset: InputPathType,
    input_type: "niml" | "1D" | "dx" | null = null,
    output_prefix: string | null = null,
    dset_labels: string | null = null,
    add_node_index: boolean = false,
    node_index_file: InputPathType | null = null,
    node_select_file: InputPathType | null = null,
    prepend_node_index: boolean = false,
    pad_to_node: string | null = null,
    labelize: InputPathType | null = null,
    graphize: boolean = false,
    graph_nodelist: string | null = null,
    graph_full_nodelist: InputPathType | null = null,
    graph_named_nodelist: string | null = null,
    graph_xyz_lpi: boolean = false,
    graph_edgelist: InputPathType | null = null,
    onegraph: boolean = false,
    multigraph: boolean = false,
    split: number | null = null,
    no_history: boolean = false,
): ConvertDsetParameters {
    const params = {
        "@type": "afni.ConvertDset" as const,
        "output_type": output_type,
        "input_dataset": input_dataset,
        "add_node_index": add_node_index,
        "prepend_node_index": prepend_node_index,
        "graphize": graphize,
        "graph_xyz_lpi": graph_xyz_lpi,
        "onegraph": onegraph,
        "multigraph": multigraph,
        "no_history": no_history,
    };
    if (input_type !== null) {
        params["input_type"] = input_type;
    }
    if (output_prefix !== null) {
        params["output_prefix"] = output_prefix;
    }
    if (dset_labels !== null) {
        params["dset_labels"] = dset_labels;
    }
    if (node_index_file !== null) {
        params["node_index_file"] = node_index_file;
    }
    if (node_select_file !== null) {
        params["node_select_file"] = node_select_file;
    }
    if (pad_to_node !== null) {
        params["pad_to_node"] = pad_to_node;
    }
    if (labelize !== null) {
        params["labelize"] = labelize;
    }
    if (graph_nodelist !== null) {
        params["graph_nodelist"] = graph_nodelist;
    }
    if (graph_full_nodelist !== null) {
        params["graph_full_nodelist"] = graph_full_nodelist;
    }
    if (graph_named_nodelist !== null) {
        params["graph_named_nodelist"] = graph_named_nodelist;
    }
    if (graph_edgelist !== null) {
        params["graph_edgelist"] = graph_edgelist;
    }
    if (split !== null) {
        params["split"] = split;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function convert_dset_cargs(
    params: ConvertDsetParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("ConvertDset");
    cargs.push(
        "-o_",
        ...(params["output_type"] ?? null)
    );
    cargs.push(
        "-input",
        execution.inputFile((params["input_dataset"] ?? null))
    );
    if ((params["input_type"] ?? null) !== null) {
        cargs.push(
            "-i_",
            (params["input_type"] ?? null)
        );
    }
    if ((params["output_prefix"] ?? null) !== null) {
        cargs.push(
            "-prefix",
            (params["output_prefix"] ?? null)
        );
    }
    if ((params["dset_labels"] ?? null) !== null) {
        cargs.push(
            "-dset_labels",
            (params["dset_labels"] ?? null)
        );
    }
    if ((params["add_node_index"] ?? null)) {
        cargs.push("-add_node_index");
    }
    if ((params["node_index_file"] ?? null) !== null) {
        cargs.push(
            "-node_index_1D",
            execution.inputFile((params["node_index_file"] ?? null))
        );
    }
    if ((params["node_select_file"] ?? null) !== null) {
        cargs.push(
            "-node_select_1D",
            execution.inputFile((params["node_select_file"] ?? null))
        );
    }
    if ((params["prepend_node_index"] ?? null)) {
        cargs.push("-prepend_node_index_1D");
    }
    if ((params["pad_to_node"] ?? null) !== null) {
        cargs.push(
            "-pad_to_node",
            (params["pad_to_node"] ?? null)
        );
    }
    if ((params["labelize"] ?? null) !== null) {
        cargs.push(
            "-labelize",
            execution.inputFile((params["labelize"] ?? null))
        );
    }
    if ((params["graphize"] ?? null)) {
        cargs.push("-graphize");
    }
    if ((params["graph_nodelist"] ?? null) !== null) {
        cargs.push(
            "-graph_nodelist_1D",
            (params["graph_nodelist"] ?? null)
        );
    }
    if ((params["graph_full_nodelist"] ?? null) !== null) {
        cargs.push(
            "-graph_full_nodelist_1D",
            execution.inputFile((params["graph_full_nodelist"] ?? null))
        );
    }
    if ((params["graph_named_nodelist"] ?? null) !== null) {
        cargs.push(
            "-graph_named_nodelist_txt",
            (params["graph_named_nodelist"] ?? null)
        );
    }
    if ((params["graph_xyz_lpi"] ?? null)) {
        cargs.push("-graph_XYZ_LPI");
    }
    if ((params["graph_edgelist"] ?? null) !== null) {
        cargs.push(
            "-graph_edgelist_1D",
            execution.inputFile((params["graph_edgelist"] ?? null))
        );
    }
    if ((params["onegraph"] ?? null)) {
        cargs.push("-onegraph");
    }
    if ((params["multigraph"] ?? null)) {
        cargs.push("-multigraph");
    }
    if ((params["split"] ?? null) !== null) {
        cargs.push(
            "-split",
            String((params["split"] ?? null))
        );
    }
    if ((params["no_history"] ?? null)) {
        cargs.push("-no_history");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function convert_dset_outputs(
    params: ConvertDsetParameters,
    execution: Execution,
): ConvertDsetOutputs {
    const ret: ConvertDsetOutputs = {
        root: execution.outputFile("."),
        converted_dataset: ((params["output_prefix"] ?? null) !== null) ? execution.outputFile([(params["output_prefix"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * ConvertDset
 *
 * Converts a surface dataset from one format to another.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ConvertDsetOutputs`).
 */
function convert_dset_execute(
    params: ConvertDsetParameters,
    runner: Runner | null = null,
): ConvertDsetOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(CONVERT_DSET_METADATA);
    params = execution.params(params)
    const cargs = convert_dset_cargs(params, execution)
    const ret = convert_dset_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * ConvertDset
 *
 * Converts a surface dataset from one format to another.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param output_type Type of output datasets
 * @param input_dataset Input dataset to be converted
 * @param input_type Type of input datasets
 * @param output_prefix Output prefix for dataset
 * @param dset_labels Label the columns (sub-bricks) of the output dataset
 * @param add_node_index Add a node index element if one does not exist in the input dataset
 * @param node_index_file File containing node indices
 * @param node_select_file File specifying the nodes to keep in the output
 * @param prepend_node_index Add a node index column to the data
 * @param pad_to_node Output a full dataset from node 0 to MAX_INDEX
 * @param labelize Turn the dataset into a labeled set per the colormap in CMAP
 * @param graphize Turn the dataset into a SUMA graph dataset
 * @param graph_nodelist Two files specifying the indices and the coordinates of the graph's nodes
 * @param graph_full_nodelist Similar to -graph_nodelist_1D but without need for NODEINDLIST.1D
 * @param graph_named_nodelist Two files specifying graph node indices, string labels, and their coordinates
 * @param graph_xyz_lpi Coordinates in NodeList.1D are in LPI instead of RAI
 * @param graph_edgelist Indices of graph nodes defining edge
 * @param onegraph Expect input dataset to be one square matrix defining the graph (default)
 * @param multigraph Expect each column in input dataset to define an entire graph
 * @param split Split a multi-column dataset into about N output datasets
 * @param no_history Do not include a history element in the output
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ConvertDsetOutputs`).
 */
function convert_dset(
    output_type: Array<"niml_asc" | "niml_bi" | "1D" | "1Dp" | "1Dpt" | "gii" | "gii_asc" | "gii_b64" | "gii_b64gz" | "1D_stderr" | "1D_stdout" | "niml_stderr" | "niml_stdout" | "1Dp_stdout" | "1Dp_stderr" | "1Dpt_stdout" | "1Dpt_stderr">,
    input_dataset: InputPathType,
    input_type: "niml" | "1D" | "dx" | null = null,
    output_prefix: string | null = null,
    dset_labels: string | null = null,
    add_node_index: boolean = false,
    node_index_file: InputPathType | null = null,
    node_select_file: InputPathType | null = null,
    prepend_node_index: boolean = false,
    pad_to_node: string | null = null,
    labelize: InputPathType | null = null,
    graphize: boolean = false,
    graph_nodelist: string | null = null,
    graph_full_nodelist: InputPathType | null = null,
    graph_named_nodelist: string | null = null,
    graph_xyz_lpi: boolean = false,
    graph_edgelist: InputPathType | null = null,
    onegraph: boolean = false,
    multigraph: boolean = false,
    split: number | null = null,
    no_history: boolean = false,
    runner: Runner | null = null,
): ConvertDsetOutputs {
    const params = convert_dset_params(output_type, input_dataset, input_type, output_prefix, dset_labels, add_node_index, node_index_file, node_select_file, prepend_node_index, pad_to_node, labelize, graphize, graph_nodelist, graph_full_nodelist, graph_named_nodelist, graph_xyz_lpi, graph_edgelist, onegraph, multigraph, split, no_history)
    return convert_dset_execute(params, runner);
}


export {
      CONVERT_DSET_METADATA,
      ConvertDsetOutputs,
      ConvertDsetParameters,
      convert_dset,
      convert_dset_execute,
      convert_dset_params,
};
