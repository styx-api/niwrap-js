// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const REG_TRANSFORM_METADATA: Metadata = {
    id: "3298d98092db6f80d10399aa1e1af8a634ba3e9c.boutiques",
    name: "reg_transform",
    package: "niftyreg",
    container_image_tag: "vnmd/niftyreg_1.4.0:20220819",
};


interface RegTransformParameters {
    "__STYXTYPE__": "reg_transform";
    "reference_image": InputPathType;
    "cpp2def_input"?: InputPathType | null | undefined;
    "cpp2def_output"?: string | null | undefined;
    "comp1_cpp2"?: InputPathType | null | undefined;
    "comp1_cpp1"?: InputPathType | null | undefined;
    "comp1_output"?: string | null | undefined;
    "comp2_cpp"?: InputPathType | null | undefined;
    "comp2_def"?: InputPathType | null | undefined;
    "comp2_output"?: string | null | undefined;
    "comp3_def2"?: InputPathType | null | undefined;
    "comp3_def1"?: InputPathType | null | undefined;
    "comp3_output"?: string | null | undefined;
    "def2disp_input"?: InputPathType | null | undefined;
    "def2disp_output"?: string | null | undefined;
    "disp2def_input"?: InputPathType | null | undefined;
    "disp2def_output"?: string | null | undefined;
    "upd_sform_image"?: InputPathType | null | undefined;
    "upd_sform_affine"?: InputPathType | null | undefined;
    "upd_sform_output"?: string | null | undefined;
    "aff2def_affine"?: InputPathType | null | undefined;
    "aff2def_target"?: InputPathType | null | undefined;
    "aff2def_cpp_or_def"?: InputPathType | null | undefined;
    "aff2def_output"?: string | null | undefined;
    "inv_affine_input"?: InputPathType | null | undefined;
    "inv_affine_output"?: string | null | undefined;
    "comp_aff_1st"?: InputPathType | null | undefined;
    "comp_aff_2nd"?: InputPathType | null | undefined;
    "comp_aff_output"?: string | null | undefined;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "reg_transform": reg_transform_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "reg_transform": reg_transform_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `reg_transform(...)`.
 *
 * @interface
 */
interface RegTransformOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * File containing the CPP to DEF converted deformation field.
     */
    cpp2def_output_file: OutputPathType | null;
    /**
     * File containing the composed deformation field from two control point lattices.
     */
    comp1_output_file: OutputPathType | null;
    /**
     * File containing the composed deformation field from a deformation field and a control point lattice.
     */
    comp2_output_file: OutputPathType | null;
    /**
     * File containing the composed deformation field from two deformation fields.
     */
    comp3_output_file: OutputPathType | null;
    /**
     * File containing the converted displacement field from a deformation field.
     */
    def2disp_output_file: OutputPathType | null;
    /**
     * File containing the converted deformation field from a displacement field.
     */
    disp2def_output_file: OutputPathType | null;
    /**
     * File containing the updated image with modified sform.
     */
    upd_sform_output_file: OutputPathType | null;
    /**
     * File containing the composed deformation field from a non-rigid and an affine transformation.
     */
    aff2def_output_file: OutputPathType | null;
    /**
     * File containing the inverted affine matrix.
     */
    inv_affine_output_file: OutputPathType | null;
    /**
     * File containing the composed affine matrix.
     */
    comp_aff_output_file: OutputPathType | null;
}


function reg_transform_params(
    reference_image: InputPathType,
    cpp2def_input: InputPathType | null = null,
    cpp2def_output: string | null = null,
    comp1_cpp2: InputPathType | null = null,
    comp1_cpp1: InputPathType | null = null,
    comp1_output: string | null = null,
    comp2_cpp: InputPathType | null = null,
    comp2_def: InputPathType | null = null,
    comp2_output: string | null = null,
    comp3_def2: InputPathType | null = null,
    comp3_def1: InputPathType | null = null,
    comp3_output: string | null = null,
    def2disp_input: InputPathType | null = null,
    def2disp_output: string | null = null,
    disp2def_input: InputPathType | null = null,
    disp2def_output: string | null = null,
    upd_sform_image: InputPathType | null = null,
    upd_sform_affine: InputPathType | null = null,
    upd_sform_output: string | null = null,
    aff2def_affine: InputPathType | null = null,
    aff2def_target: InputPathType | null = null,
    aff2def_cpp_or_def: InputPathType | null = null,
    aff2def_output: string | null = null,
    inv_affine_input: InputPathType | null = null,
    inv_affine_output: string | null = null,
    comp_aff_1st: InputPathType | null = null,
    comp_aff_2nd: InputPathType | null = null,
    comp_aff_output: string | null = null,
): RegTransformParameters {
    /**
     * Build parameters.
    
     * @param reference_image Filename of the reference image
     * @param cpp2def_input Conversion from control point position to deformation field. Filename of input lattice of control point positions (CPP).
     * @param cpp2def_output Filename of the output deformation field image (DEF).
     * @param comp1_cpp2 Composition of two lattices of control points. CPP2(CPP1(x)). Filename of lattice of control point that contains the second deformation (CPP2).
     * @param comp1_cpp1 Filename of lattice of control point that contains the initial deformation (CPP1).
     * @param comp1_output Filename of the output deformation field.
     * @param comp2_cpp Composition of a deformation field with a lattice of control points. CPP(DEF(x)). Filename of lattice of control point that contains the second deformation (CPP).
     * @param comp2_def Filename of the deformation field to be used as initial deformation (DEF).
     * @param comp2_output Filename of the output deformation field.
     * @param comp3_def2 Composition of two deformation fields. DEF2(DEF1(x)). Filename of the second deformation field (DEF2).
     * @param comp3_def1 Filename of the first deformation field (DEF1).
     * @param comp3_output Filename of the output deformation field.
     * @param def2disp_input Convert a deformation field into a displacement field. Filename of deformation field x'=T(x).
     * @param def2disp_output Filename of displacement field x'=x+T(x).
     * @param disp2def_input Convert a displacement field into a deformation field. Filename of displacement field x'=x+T(x).
     * @param disp2def_output Filename of deformation field x'=T(x).
     * @param upd_sform_image Update the sform of a floating (source) image using an affine transformation. Filename of image to be updated.
     * @param upd_sform_affine Affine transformation defined as Affine x Reference = Floating. Filename of affine transformation.
     * @param upd_sform_output Updated image filename.
     * @param aff2def_affine Compose a non-rigid with an affine. Filename of affine transformation.
     * @param aff2def_target Image used as a target for the non-rigid step.
     * @param aff2def_cpp_or_def Reference image (B). Filename of control point position or deformation field.
     * @param aff2def_output Output deformation field filename.
     * @param inv_affine_input Invert an affine transformation matrix. Filename of input affine matrix.
     * @param inv_affine_output Filename of inverted affine matrix.
     * @param comp_aff_1st Compose two affine transformation matrices. Filename of first affine matrix.
     * @param comp_aff_2nd Filename of second affine matrix.
     * @param comp_aff_output Filename of composed affine matrix result.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "reg_transform" as const,
        "reference_image": reference_image,
    };
    if (cpp2def_input !== null) {
        params["cpp2def_input"] = cpp2def_input;
    }
    if (cpp2def_output !== null) {
        params["cpp2def_output"] = cpp2def_output;
    }
    if (comp1_cpp2 !== null) {
        params["comp1_cpp2"] = comp1_cpp2;
    }
    if (comp1_cpp1 !== null) {
        params["comp1_cpp1"] = comp1_cpp1;
    }
    if (comp1_output !== null) {
        params["comp1_output"] = comp1_output;
    }
    if (comp2_cpp !== null) {
        params["comp2_cpp"] = comp2_cpp;
    }
    if (comp2_def !== null) {
        params["comp2_def"] = comp2_def;
    }
    if (comp2_output !== null) {
        params["comp2_output"] = comp2_output;
    }
    if (comp3_def2 !== null) {
        params["comp3_def2"] = comp3_def2;
    }
    if (comp3_def1 !== null) {
        params["comp3_def1"] = comp3_def1;
    }
    if (comp3_output !== null) {
        params["comp3_output"] = comp3_output;
    }
    if (def2disp_input !== null) {
        params["def2disp_input"] = def2disp_input;
    }
    if (def2disp_output !== null) {
        params["def2disp_output"] = def2disp_output;
    }
    if (disp2def_input !== null) {
        params["disp2def_input"] = disp2def_input;
    }
    if (disp2def_output !== null) {
        params["disp2def_output"] = disp2def_output;
    }
    if (upd_sform_image !== null) {
        params["upd_sform_image"] = upd_sform_image;
    }
    if (upd_sform_affine !== null) {
        params["upd_sform_affine"] = upd_sform_affine;
    }
    if (upd_sform_output !== null) {
        params["upd_sform_output"] = upd_sform_output;
    }
    if (aff2def_affine !== null) {
        params["aff2def_affine"] = aff2def_affine;
    }
    if (aff2def_target !== null) {
        params["aff2def_target"] = aff2def_target;
    }
    if (aff2def_cpp_or_def !== null) {
        params["aff2def_cpp_or_def"] = aff2def_cpp_or_def;
    }
    if (aff2def_output !== null) {
        params["aff2def_output"] = aff2def_output;
    }
    if (inv_affine_input !== null) {
        params["inv_affine_input"] = inv_affine_input;
    }
    if (inv_affine_output !== null) {
        params["inv_affine_output"] = inv_affine_output;
    }
    if (comp_aff_1st !== null) {
        params["comp_aff_1st"] = comp_aff_1st;
    }
    if (comp_aff_2nd !== null) {
        params["comp_aff_2nd"] = comp_aff_2nd;
    }
    if (comp_aff_output !== null) {
        params["comp_aff_output"] = comp_aff_output;
    }
    return params;
}


function reg_transform_cargs(
    params: RegTransformParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("reg_transform");
    cargs.push(
        "-ref",
        execution.inputFile((params["reference_image"] ?? null))
    );
    if ((params["cpp2def_input"] ?? null) !== null) {
        cargs.push(
            "-cpp2def",
            execution.inputFile((params["cpp2def_input"] ?? null))
        );
    }
    if ((params["cpp2def_output"] ?? null) !== null) {
        cargs.push((params["cpp2def_output"] ?? null));
    }
    if ((params["comp1_cpp2"] ?? null) !== null) {
        cargs.push(
            "-comp1",
            execution.inputFile((params["comp1_cpp2"] ?? null))
        );
    }
    if ((params["comp1_cpp1"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["comp1_cpp1"] ?? null)));
    }
    if ((params["comp1_output"] ?? null) !== null) {
        cargs.push((params["comp1_output"] ?? null));
    }
    if ((params["comp2_cpp"] ?? null) !== null) {
        cargs.push(
            "-comp2",
            execution.inputFile((params["comp2_cpp"] ?? null))
        );
    }
    if ((params["comp2_def"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["comp2_def"] ?? null)));
    }
    if ((params["comp2_output"] ?? null) !== null) {
        cargs.push((params["comp2_output"] ?? null));
    }
    if ((params["comp3_def2"] ?? null) !== null) {
        cargs.push(
            "-comp3",
            execution.inputFile((params["comp3_def2"] ?? null))
        );
    }
    if ((params["comp3_def1"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["comp3_def1"] ?? null)));
    }
    if ((params["comp3_output"] ?? null) !== null) {
        cargs.push((params["comp3_output"] ?? null));
    }
    if ((params["def2disp_input"] ?? null) !== null) {
        cargs.push(
            "-def2disp",
            execution.inputFile((params["def2disp_input"] ?? null))
        );
    }
    if ((params["def2disp_output"] ?? null) !== null) {
        cargs.push((params["def2disp_output"] ?? null));
    }
    if ((params["disp2def_input"] ?? null) !== null) {
        cargs.push(
            "-disp2def",
            execution.inputFile((params["disp2def_input"] ?? null))
        );
    }
    if ((params["disp2def_output"] ?? null) !== null) {
        cargs.push((params["disp2def_output"] ?? null));
    }
    if ((params["upd_sform_image"] ?? null) !== null) {
        cargs.push(
            "-updSform",
            execution.inputFile((params["upd_sform_image"] ?? null))
        );
    }
    if ((params["upd_sform_affine"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["upd_sform_affine"] ?? null)));
    }
    if ((params["upd_sform_output"] ?? null) !== null) {
        cargs.push((params["upd_sform_output"] ?? null));
    }
    if ((params["aff2def_affine"] ?? null) !== null) {
        cargs.push(
            "-aff2def",
            execution.inputFile((params["aff2def_affine"] ?? null))
        );
    }
    if ((params["aff2def_target"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["aff2def_target"] ?? null)));
    }
    if ((params["aff2def_cpp_or_def"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["aff2def_cpp_or_def"] ?? null)));
    }
    if ((params["aff2def_output"] ?? null) !== null) {
        cargs.push((params["aff2def_output"] ?? null));
    }
    if ((params["inv_affine_input"] ?? null) !== null) {
        cargs.push(
            "-invAffine",
            execution.inputFile((params["inv_affine_input"] ?? null))
        );
    }
    if ((params["inv_affine_output"] ?? null) !== null) {
        cargs.push((params["inv_affine_output"] ?? null));
    }
    if ((params["comp_aff_1st"] ?? null) !== null) {
        cargs.push(
            "-compAff",
            execution.inputFile((params["comp_aff_1st"] ?? null))
        );
    }
    if ((params["comp_aff_2nd"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["comp_aff_2nd"] ?? null)));
    }
    if ((params["comp_aff_output"] ?? null) !== null) {
        cargs.push((params["comp_aff_output"] ?? null));
    }
    return cargs;
}


function reg_transform_outputs(
    params: RegTransformParameters,
    execution: Execution,
): RegTransformOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: RegTransformOutputs = {
        root: execution.outputFile("."),
        cpp2def_output_file: ((params["cpp2def_output"] ?? null) !== null) ? execution.outputFile([(params["cpp2def_output"] ?? null)].join('')) : null,
        comp1_output_file: ((params["comp1_output"] ?? null) !== null) ? execution.outputFile([(params["comp1_output"] ?? null)].join('')) : null,
        comp2_output_file: ((params["comp2_output"] ?? null) !== null) ? execution.outputFile([(params["comp2_output"] ?? null)].join('')) : null,
        comp3_output_file: ((params["comp3_output"] ?? null) !== null) ? execution.outputFile([(params["comp3_output"] ?? null)].join('')) : null,
        def2disp_output_file: ((params["def2disp_output"] ?? null) !== null) ? execution.outputFile([(params["def2disp_output"] ?? null)].join('')) : null,
        disp2def_output_file: ((params["disp2def_output"] ?? null) !== null) ? execution.outputFile([(params["disp2def_output"] ?? null)].join('')) : null,
        upd_sform_output_file: ((params["upd_sform_output"] ?? null) !== null) ? execution.outputFile([(params["upd_sform_output"] ?? null)].join('')) : null,
        aff2def_output_file: ((params["aff2def_output"] ?? null) !== null) ? execution.outputFile([(params["aff2def_output"] ?? null)].join('')) : null,
        inv_affine_output_file: ((params["inv_affine_output"] ?? null) !== null) ? execution.outputFile([(params["inv_affine_output"] ?? null)].join('')) : null,
        comp_aff_output_file: ((params["comp_aff_output"] ?? null) !== null) ? execution.outputFile([(params["comp_aff_output"] ?? null)].join('')) : null,
    };
    return ret;
}


function reg_transform_execute(
    params: RegTransformParameters,
    execution: Execution,
): RegTransformOutputs {
    /**
     * Tool for performing various transformation operations on medical images including control point to deformation conversion, composition of transformations, and converting between deformation and displacement fields.
     * 
     * Author: NiftyReg Developers
     * 
     * URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `RegTransformOutputs`).
     */
    params = execution.params(params)
    const cargs = reg_transform_cargs(params, execution)
    const ret = reg_transform_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function reg_transform(
    reference_image: InputPathType,
    cpp2def_input: InputPathType | null = null,
    cpp2def_output: string | null = null,
    comp1_cpp2: InputPathType | null = null,
    comp1_cpp1: InputPathType | null = null,
    comp1_output: string | null = null,
    comp2_cpp: InputPathType | null = null,
    comp2_def: InputPathType | null = null,
    comp2_output: string | null = null,
    comp3_def2: InputPathType | null = null,
    comp3_def1: InputPathType | null = null,
    comp3_output: string | null = null,
    def2disp_input: InputPathType | null = null,
    def2disp_output: string | null = null,
    disp2def_input: InputPathType | null = null,
    disp2def_output: string | null = null,
    upd_sform_image: InputPathType | null = null,
    upd_sform_affine: InputPathType | null = null,
    upd_sform_output: string | null = null,
    aff2def_affine: InputPathType | null = null,
    aff2def_target: InputPathType | null = null,
    aff2def_cpp_or_def: InputPathType | null = null,
    aff2def_output: string | null = null,
    inv_affine_input: InputPathType | null = null,
    inv_affine_output: string | null = null,
    comp_aff_1st: InputPathType | null = null,
    comp_aff_2nd: InputPathType | null = null,
    comp_aff_output: string | null = null,
    runner: Runner | null = null,
): RegTransformOutputs {
    /**
     * Tool for performing various transformation operations on medical images including control point to deformation conversion, composition of transformations, and converting between deformation and displacement fields.
     * 
     * Author: NiftyReg Developers
     * 
     * URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
    
     * @param reference_image Filename of the reference image
     * @param cpp2def_input Conversion from control point position to deformation field. Filename of input lattice of control point positions (CPP).
     * @param cpp2def_output Filename of the output deformation field image (DEF).
     * @param comp1_cpp2 Composition of two lattices of control points. CPP2(CPP1(x)). Filename of lattice of control point that contains the second deformation (CPP2).
     * @param comp1_cpp1 Filename of lattice of control point that contains the initial deformation (CPP1).
     * @param comp1_output Filename of the output deformation field.
     * @param comp2_cpp Composition of a deformation field with a lattice of control points. CPP(DEF(x)). Filename of lattice of control point that contains the second deformation (CPP).
     * @param comp2_def Filename of the deformation field to be used as initial deformation (DEF).
     * @param comp2_output Filename of the output deformation field.
     * @param comp3_def2 Composition of two deformation fields. DEF2(DEF1(x)). Filename of the second deformation field (DEF2).
     * @param comp3_def1 Filename of the first deformation field (DEF1).
     * @param comp3_output Filename of the output deformation field.
     * @param def2disp_input Convert a deformation field into a displacement field. Filename of deformation field x'=T(x).
     * @param def2disp_output Filename of displacement field x'=x+T(x).
     * @param disp2def_input Convert a displacement field into a deformation field. Filename of displacement field x'=x+T(x).
     * @param disp2def_output Filename of deformation field x'=T(x).
     * @param upd_sform_image Update the sform of a floating (source) image using an affine transformation. Filename of image to be updated.
     * @param upd_sform_affine Affine transformation defined as Affine x Reference = Floating. Filename of affine transformation.
     * @param upd_sform_output Updated image filename.
     * @param aff2def_affine Compose a non-rigid with an affine. Filename of affine transformation.
     * @param aff2def_target Image used as a target for the non-rigid step.
     * @param aff2def_cpp_or_def Reference image (B). Filename of control point position or deformation field.
     * @param aff2def_output Output deformation field filename.
     * @param inv_affine_input Invert an affine transformation matrix. Filename of input affine matrix.
     * @param inv_affine_output Filename of inverted affine matrix.
     * @param comp_aff_1st Compose two affine transformation matrices. Filename of first affine matrix.
     * @param comp_aff_2nd Filename of second affine matrix.
     * @param comp_aff_output Filename of composed affine matrix result.
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `RegTransformOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(REG_TRANSFORM_METADATA);
    const params = reg_transform_params(reference_image, cpp2def_input, cpp2def_output, comp1_cpp2, comp1_cpp1, comp1_output, comp2_cpp, comp2_def, comp2_output, comp3_def2, comp3_def1, comp3_output, def2disp_input, def2disp_output, disp2def_input, disp2def_output, upd_sform_image, upd_sform_affine, upd_sform_output, aff2def_affine, aff2def_target, aff2def_cpp_or_def, aff2def_output, inv_affine_input, inv_affine_output, comp_aff_1st, comp_aff_2nd, comp_aff_output)
    return reg_transform_execute(params, execution);
}


export {
      REG_TRANSFORM_METADATA,
      RegTransformOutputs,
      RegTransformParameters,
      reg_transform,
      reg_transform_params,
};
