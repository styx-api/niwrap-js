// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ANTS_APPLY_TRANSFORMS_METADATA: Metadata = {
    id: "5bae5c4751160f7ccaa07fc3078825fcfbfea774.boutiques",
    name: "antsApplyTransforms",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface AntsApplyTransformsWarpedOutputParameters {
    "@type": "ants.antsApplyTransforms.warpedOutput";
    "warpedOutputFileName": string;
}


interface AntsApplyTransformsCompositeDisplacementFieldOutputParameters {
    "@type": "ants.antsApplyTransforms.compositeDisplacementFieldOutput";
    "compositeDisplacementField": string;
    "printOutCompositeWarpFile"?: 0 | 1 | null | undefined;
}


interface AntsApplyTransformsGenericAffineTransformOutputParameters {
    "@type": "ants.antsApplyTransforms.genericAffineTransformOutput";
    "genericAffineTransformFile": string;
    "calculateInverse"?: 0 | 1 | null | undefined;
}


interface AntsApplyTransformsLinearParameters {
    "@type": "ants.antsApplyTransforms.linear";
}


interface AntsApplyTransformsNearestNeighborParameters {
    "@type": "ants.antsApplyTransforms.nearestNeighbor";
}


interface AntsApplyTransformsMultiLabelnoparamsParameters {
    "@type": "ants.antsApplyTransforms.multiLabelnoparams";
}


interface AntsApplyTransformsSigmaParameters {
    "@type": "ants.antsApplyTransforms.multiLabel.params.sigma";
    "sigma": number;
}


interface AntsApplyTransformsAlphaParameters {
    "@type": "ants.antsApplyTransforms.multiLabel.params.alpha";
    "alpha": number;
}


interface AntsApplyTransformsParamParameters {
    "@type": "ants.antsApplyTransforms.multiLabel.params";
    "params": Array<AntsApplyTransformsSigmaParameters | AntsApplyTransformsAlphaParameters>;
}


interface AntsApplyTransformsMultiLabelParameters {
    "@type": "ants.antsApplyTransforms.multiLabel";
    "params": AntsApplyTransformsParamParameters;
}


interface AntsApplyTransformsGaussianParameters {
    "@type": "ants.antsApplyTransforms.gaussian";
    "sigma"?: number | null | undefined;
    "alpha"?: number | null | undefined;
}


interface AntsApplyTransformsBsplineParameters {
    "@type": "ants.antsApplyTransforms.bspline";
    "order"?: number | null | undefined;
}


interface AntsApplyTransformsCosineWindowedSincParameters {
    "@type": "ants.antsApplyTransforms.cosineWindowedSinc";
}


interface AntsApplyTransformsWelchWindowedSincParameters {
    "@type": "ants.antsApplyTransforms.welchWindowedSinc";
}


interface AntsApplyTransformsHammingWindowedSincParameters {
    "@type": "ants.antsApplyTransforms.hammingWindowedSinc";
}


interface AntsApplyTransformsLanczosWindowedSincParameters {
    "@type": "ants.antsApplyTransforms.lanczosWindowedSinc";
}


interface AntsApplyTransformsGenericLabelParameters {
    "@type": "ants.antsApplyTransforms.genericLabel";
    "interpolator"?: string | null | undefined;
}


interface AntsApplyTransformsTransformFileNameParameters {
    "@type": "ants.antsApplyTransforms.transformFileName";
    "transformFileName": InputPathType;
}


interface AntsApplyTransformsUseInverseParameters {
    "@type": "ants.antsApplyTransforms.useInverse";
    "transformFileName": InputPathType;
}


interface AntsApplyTransformsParameters {
    "@type": "ants.antsApplyTransforms";
    "dimensionality"?: 2 | 3 | 4 | null | undefined;
    "input_image_type"?: 0 | 1 | 2 | 3 | 4 | 5 | null | undefined;
    "input_image"?: InputPathType | null | undefined;
    "reference_image": InputPathType;
    "output": AntsApplyTransformsWarpedOutputParameters | AntsApplyTransformsCompositeDisplacementFieldOutputParameters | AntsApplyTransformsGenericAffineTransformOutputParameters;
    "interpolation"?: AntsApplyTransformsLinearParameters | AntsApplyTransformsNearestNeighborParameters | AntsApplyTransformsMultiLabelnoparamsParameters | AntsApplyTransformsMultiLabelParameters | AntsApplyTransformsGaussianParameters | AntsApplyTransformsBsplineParameters | AntsApplyTransformsCosineWindowedSincParameters | AntsApplyTransformsWelchWindowedSincParameters | AntsApplyTransformsHammingWindowedSincParameters | AntsApplyTransformsLanczosWindowedSincParameters | AntsApplyTransformsGenericLabelParameters | null | undefined;
    "output_data_type"?: "char" | "uchar" | "short" | "int" | "float" | "double" | "default" | null | undefined;
    "transform"?: Array<AntsApplyTransformsTransformFileNameParameters | AntsApplyTransformsUseInverseParameters> | null | undefined;
    "default_value"?: number | null | undefined;
    "static_cast_for_R"?: string | null | undefined;
    "float"?: 0 | 1 | null | undefined;
    "verbose"?: 0 | 1 | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "ants.antsApplyTransforms": ants_apply_transforms_cargs,
        "ants.antsApplyTransforms.warpedOutput": ants_apply_transforms_warped_output_cargs,
        "ants.antsApplyTransforms.compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_cargs,
        "ants.antsApplyTransforms.genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_cargs,
        "ants.antsApplyTransforms.linear": ants_apply_transforms_linear_cargs,
        "ants.antsApplyTransforms.nearestNeighbor": ants_apply_transforms_nearest_neighbor_cargs,
        "ants.antsApplyTransforms.multiLabelnoparams": ants_apply_transforms_multi_labelnoparams_cargs,
        "ants.antsApplyTransforms.multiLabel": ants_apply_transforms_multi_label_cargs,
        "ants.antsApplyTransforms.multiLabel.params": ants_apply_transforms_param_cargs,
        "ants.antsApplyTransforms.multiLabel.params.sigma": ants_apply_transforms_sigma_cargs,
        "ants.antsApplyTransforms.multiLabel.params.alpha": ants_apply_transforms_alpha_cargs,
        "ants.antsApplyTransforms.gaussian": ants_apply_transforms_gaussian_cargs,
        "ants.antsApplyTransforms.bspline": ants_apply_transforms_bspline_cargs,
        "ants.antsApplyTransforms.cosineWindowedSinc": ants_apply_transforms_cosine_windowed_sinc_cargs,
        "ants.antsApplyTransforms.welchWindowedSinc": ants_apply_transforms_welch_windowed_sinc_cargs,
        "ants.antsApplyTransforms.hammingWindowedSinc": ants_apply_transforms_hamming_windowed_sinc_cargs,
        "ants.antsApplyTransforms.lanczosWindowedSinc": ants_apply_transforms_lanczos_windowed_sinc_cargs,
        "ants.antsApplyTransforms.genericLabel": ants_apply_transforms_generic_label_cargs,
        "ants.antsApplyTransforms.transformFileName": ants_apply_transforms_transform_file_name_cargs,
        "ants.antsApplyTransforms.useInverse": ants_apply_transforms_use_inverse_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "ants.antsApplyTransforms": ants_apply_transforms_outputs,
        "ants.antsApplyTransforms.warpedOutput": ants_apply_transforms_warped_output_outputs,
        "ants.antsApplyTransforms.compositeDisplacementFieldOutput": ants_apply_transforms_composite_displacement_field_output_outputs,
        "ants.antsApplyTransforms.genericAffineTransformOutput": ants_apply_transforms_generic_affine_transform_output_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `AntsApplyTransformsWarpedOutputParameters(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsWarpedOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Warped image.
     */
    output_image_outfile: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param warped_output_file_name Output file name.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_warped_output_params(
    warped_output_file_name: string,
): AntsApplyTransformsWarpedOutputParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.warpedOutput" as const,
        "warpedOutputFileName": warped_output_file_name,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_warped_output_cargs(
    params: AntsApplyTransformsWarpedOutputParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["warpedOutputFileName"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ants_apply_transforms_warped_output_outputs(
    params: AntsApplyTransformsWarpedOutputParameters,
    execution: Execution,
): AntsApplyTransformsWarpedOutputOutputs {
    const ret: AntsApplyTransformsWarpedOutputOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["warpedOutputFileName"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `AntsApplyTransformsCompositeDisplacementFieldOutputParameters(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsCompositeDisplacementFieldOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Warped image.
     */
    output_image_outfile: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param composite_displacement_field Output file name.
 * @param print_out_composite_warp_file Output a composite warp file instead of a transformed image.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_composite_displacement_field_output_params(
    composite_displacement_field: string,
    print_out_composite_warp_file: 0 | 1 | null = null,
): AntsApplyTransformsCompositeDisplacementFieldOutputParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.compositeDisplacementFieldOutput" as const,
        "compositeDisplacementField": composite_displacement_field,
    };
    if (print_out_composite_warp_file !== null) {
        params["printOutCompositeWarpFile"] = print_out_composite_warp_file;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_composite_displacement_field_output_cargs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["printOutCompositeWarpFile"] ?? null) !== null) {
        cargs.push(["[", (params["compositeDisplacementField"] ?? null), ",printOutCompositeWarpFile=", String((params["printOutCompositeWarpFile"] ?? null)), "]"].join(''));
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ants_apply_transforms_composite_displacement_field_output_outputs(
    params: AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
    execution: Execution,
): AntsApplyTransformsCompositeDisplacementFieldOutputOutputs {
    const ret: AntsApplyTransformsCompositeDisplacementFieldOutputOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["compositeDisplacementField"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `AntsApplyTransformsGenericAffineTransformOutputParameters(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsGenericAffineTransformOutputOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Warped image.
     */
    output_image_outfile: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param generic_affine_transform_file Output file name.
 * @param calculate_inverse Calculate the inverse of the affine transform.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_generic_affine_transform_output_params(
    generic_affine_transform_file: string,
    calculate_inverse: 0 | 1 | null = null,
): AntsApplyTransformsGenericAffineTransformOutputParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.genericAffineTransformOutput" as const,
        "genericAffineTransformFile": generic_affine_transform_file,
    };
    if (calculate_inverse !== null) {
        params["calculateInverse"] = calculate_inverse;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_generic_affine_transform_output_cargs(
    params: AntsApplyTransformsGenericAffineTransformOutputParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["calculateInverse"] ?? null) !== null) {
        cargs.push(["Linear[", (params["genericAffineTransformFile"] ?? null), ",calculateInverse=", String((params["calculateInverse"] ?? null)), "]"].join(''));
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ants_apply_transforms_generic_affine_transform_output_outputs(
    params: AntsApplyTransformsGenericAffineTransformOutputParameters,
    execution: Execution,
): AntsApplyTransformsGenericAffineTransformOutputOutputs {
    const ret: AntsApplyTransformsGenericAffineTransformOutputOutputs = {
        root: execution.outputFile("."),
        output_image_outfile: execution.outputFile([(params["genericAffineTransformFile"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_linear_params(
): AntsApplyTransformsLinearParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.linear" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_linear_cargs(
    params: AntsApplyTransformsLinearParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("Linear");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_nearest_neighbor_params(
): AntsApplyTransformsNearestNeighborParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.nearestNeighbor" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_nearest_neighbor_cargs(
    params: AntsApplyTransformsNearestNeighborParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("NearestNeighbor");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_multi_labelnoparams_params(
): AntsApplyTransformsMultiLabelnoparamsParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.multiLabelnoparams" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_multi_labelnoparams_cargs(
    params: AntsApplyTransformsMultiLabelnoparamsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("MultiLabel");
    return cargs;
}


/**
 * Build parameters.
 *
 * @param sigma Sigma value.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_sigma_params(
    sigma: number,
): AntsApplyTransformsSigmaParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.multiLabel.params.sigma" as const,
        "sigma": sigma,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_sigma_cargs(
    params: AntsApplyTransformsSigmaParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(["sigma=", String((params["sigma"] ?? null))].join(''));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param alpha Alpha value.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_alpha_params(
    alpha: number,
): AntsApplyTransformsAlphaParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.multiLabel.params.alpha" as const,
        "alpha": alpha,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_alpha_cargs(
    params: AntsApplyTransformsAlphaParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(["alpha=", String((params["alpha"] ?? null))].join(''));
    return cargs;
}


/**
 * Build parameters.
 *
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_param_params(
    params_: Array<AntsApplyTransformsSigmaParameters | AntsApplyTransformsAlphaParameters>,
): AntsApplyTransformsParamParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.multiLabel.params" as const,
        "params": params_,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_param_cargs(
    params: AntsApplyTransformsParamParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(["[", (params["params"] ?? null).map(s => dynCargs(s["@type"])(s, execution)).flat().join(","), "]"].join(''));
    return cargs;
}


/**
 * Build parameters.
 *
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_multi_label_params(
    params_: AntsApplyTransformsParamParameters,
): AntsApplyTransformsMultiLabelParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.multiLabel" as const,
        "params": params_,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_multi_label_cargs(
    params: AntsApplyTransformsMultiLabelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(["MultiLabel", dynCargs((params["params"] ?? null)["@type"])((params["params"] ?? null), execution).join("")].join(''));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param sigma Sigma value.
 * @param alpha Alpha value.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_gaussian_params(
    sigma: number | null = null,
    alpha: number | null = null,
): AntsApplyTransformsGaussianParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.gaussian" as const,
    };
    if (sigma !== null) {
        params["sigma"] = sigma;
    }
    if (alpha !== null) {
        params["alpha"] = alpha;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_gaussian_cargs(
    params: AntsApplyTransformsGaussianParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["sigma"] ?? null) !== null || (params["alpha"] ?? null) !== null) {
        cargs.push(["Gaussian[sigma=", (((params["sigma"] ?? null) !== null) ? String((params["sigma"] ?? null)) : ""), ",alpha=", (((params["alpha"] ?? null) !== null) ? String((params["alpha"] ?? null)) : ""), "]"].join(''));
    }
    return cargs;
}


/**
 * Build parameters.
 *
 * @param order Order value.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_bspline_params(
    order: number | null = null,
): AntsApplyTransformsBsplineParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.bspline" as const,
    };
    if (order !== null) {
        params["order"] = order;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_bspline_cargs(
    params: AntsApplyTransformsBsplineParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["order"] ?? null) !== null) {
        cargs.push(["BSpline[order=", String((params["order"] ?? null)), "]"].join(''));
    }
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_cosine_windowed_sinc_params(
): AntsApplyTransformsCosineWindowedSincParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.cosineWindowedSinc" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_cosine_windowed_sinc_cargs(
    params: AntsApplyTransformsCosineWindowedSincParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("CosineWindowedSinc");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_welch_windowed_sinc_params(
): AntsApplyTransformsWelchWindowedSincParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.welchWindowedSinc" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_welch_windowed_sinc_cargs(
    params: AntsApplyTransformsWelchWindowedSincParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("WelchWindowedSinc");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_hamming_windowed_sinc_params(
): AntsApplyTransformsHammingWindowedSincParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.hammingWindowedSinc" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_hamming_windowed_sinc_cargs(
    params: AntsApplyTransformsHammingWindowedSincParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("HammingWindowedSinc");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_lanczos_windowed_sinc_params(
): AntsApplyTransformsLanczosWindowedSincParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.lanczosWindowedSinc" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_lanczos_windowed_sinc_cargs(
    params: AntsApplyTransformsLanczosWindowedSincParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("LanczosWindowedSinc");
    return cargs;
}


/**
 * Build parameters.
 *
 * @param interpolator Interpolator value.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_generic_label_params(
    interpolator: string | null = null,
): AntsApplyTransformsGenericLabelParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.genericLabel" as const,
    };
    if (interpolator !== null) {
        params["interpolator"] = interpolator;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_generic_label_cargs(
    params: AntsApplyTransformsGenericLabelParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    if ((params["interpolator"] ?? null) !== null) {
        cargs.push(["GenericLabel[interpolator=", (params["interpolator"] ?? null), "]"].join(''));
    }
    return cargs;
}


/**
 * Build parameters.
 *
 * @param transform_file_name Transform file name.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_transform_file_name_params(
    transform_file_name: InputPathType,
): AntsApplyTransformsTransformFileNameParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.transformFileName" as const,
        "transformFileName": transform_file_name,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_transform_file_name_cargs(
    params: AntsApplyTransformsTransformFileNameParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["transformFileName"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param transform_file_name Transform file name.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_use_inverse_params(
    transform_file_name: InputPathType,
): AntsApplyTransformsUseInverseParameters {
    const params = {
        "@type": "ants.antsApplyTransforms.useInverse" as const,
        "transformFileName": transform_file_name,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_use_inverse_cargs(
    params: AntsApplyTransformsUseInverseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(["[", execution.inputFile((params["transformFileName"] ?? null)), ",useInverse]"].join(''));
    return cargs;
}


/**
 * Output object returned when calling `ants_apply_transforms(...)`.
 *
 * @interface
 */
interface AntsApplyTransformsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Outputs from `AntsApplyTransformsWarpedOutputParameters` or `AntsApplyTransformsCompositeDisplacementFieldOutputParameters` or `AntsApplyTransformsGenericAffineTransformOutputParameters`.
     */
    output: AntsApplyTransformsWarpedOutputOutputs | AntsApplyTransformsCompositeDisplacementFieldOutputOutputs | AntsApplyTransformsGenericAffineTransformOutputOutputs;
}


/**
 * Build parameters.
 *
 * @param reference_image For warping input images, the reference image defines the spacing, origin, size, and direction of the output warped image.
 * @param output One can either output the warped image or, if the boolean is set, one can print out the displacement field based on the composite transform and the reference image. A third option is to compose all affine transforms and (if boolean is set) calculate its inverse which is then written to an ITK file.
 * @param dimensionality This option forces the image to be treated as a specified-dimensional image. if not specified, antswarp tries to infer the dimensionality from the input image.
 * @param input_image_type Option specifying the input image type of scalar (default), vector, tensor, time series, or multi-channel. A time series image is a scalar image defined by an additional dimension for the time component whereas a multi-channel image is a vector image with only spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
 * @param input_image Currently, the only input objects supported are image objects. However, the current framework allows for warping of other objects such as meshes and point sets.
 * @param interpolation Several interpolation options are available in ITK. These have all been made available.
 * @param output_data_type Output image data type. This is a direct typecast; output values are not rescaled. Default is to use the internal data type (float or double). uchar is unsigned char; others are signed. WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values exceed the range allowed by your choice. Note that some pixel types are not supported by some image formats. e.g. int is not supported by jpg.
 * @param transform Several transform options are supported including all those defined in the ITK library in addition to a deformation field transform. The ordering of the transformations follows the ordering specified on the command line. An identity transform is pushed onto the transformation stack. Each new transform encountered on the command line is also pushed onto the transformation stack. Then, to warp the input object, each point comprising the input object is warped first according to the last transform pushed onto the stack followed by the second to last transform, etc. until the last transform encountered which is the identity transform. Also, it should be noted that the inverse transform can be accommodated with the usual caveat that such an inverse must be defined by the specified transform class.
 * @param default_value Default voxel value to be used with input images only. Specifies the voxel value when the input point maps outside the output domain. With tensor input images, specifies the default voxel eigenvalues.
 * @param static_cast_for_r Forces static cast in ReadTransform (for R).
 * @param float Use float instead of double for computations.
 * @param verbose Verbose output.
 *
 * @returns Parameter dictionary
 */
function ants_apply_transforms_params(
    reference_image: InputPathType,
    output: AntsApplyTransformsWarpedOutputParameters | AntsApplyTransformsCompositeDisplacementFieldOutputParameters | AntsApplyTransformsGenericAffineTransformOutputParameters,
    dimensionality: 2 | 3 | 4 | null = null,
    input_image_type: 0 | 1 | 2 | 3 | 4 | 5 | null = null,
    input_image: InputPathType | null = null,
    interpolation: AntsApplyTransformsLinearParameters | AntsApplyTransformsNearestNeighborParameters | AntsApplyTransformsMultiLabelnoparamsParameters | AntsApplyTransformsMultiLabelParameters | AntsApplyTransformsGaussianParameters | AntsApplyTransformsBsplineParameters | AntsApplyTransformsCosineWindowedSincParameters | AntsApplyTransformsWelchWindowedSincParameters | AntsApplyTransformsHammingWindowedSincParameters | AntsApplyTransformsLanczosWindowedSincParameters | AntsApplyTransformsGenericLabelParameters | null = null,
    output_data_type: "char" | "uchar" | "short" | "int" | "float" | "double" | "default" | null = null,
    transform: Array<AntsApplyTransformsTransformFileNameParameters | AntsApplyTransformsUseInverseParameters> | null = null,
    default_value: number | null = null,
    static_cast_for_r: string | null = null,
    float: 0 | 1 | null = null,
    verbose: 0 | 1 | null = null,
): AntsApplyTransformsParameters {
    const params = {
        "@type": "ants.antsApplyTransforms" as const,
        "reference_image": reference_image,
        "output": output,
    };
    if (dimensionality !== null) {
        params["dimensionality"] = dimensionality;
    }
    if (input_image_type !== null) {
        params["input_image_type"] = input_image_type;
    }
    if (input_image !== null) {
        params["input_image"] = input_image;
    }
    if (interpolation !== null) {
        params["interpolation"] = interpolation;
    }
    if (output_data_type !== null) {
        params["output_data_type"] = output_data_type;
    }
    if (transform !== null) {
        params["transform"] = transform;
    }
    if (default_value !== null) {
        params["default_value"] = default_value;
    }
    if (static_cast_for_r !== null) {
        params["static_cast_for_R"] = static_cast_for_r;
    }
    if (float !== null) {
        params["float"] = float;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_apply_transforms_cargs(
    params: AntsApplyTransformsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("antsApplyTransforms");
    if ((params["dimensionality"] ?? null) !== null) {
        cargs.push(
            "--dimensionality",
            String((params["dimensionality"] ?? null))
        );
    }
    if ((params["input_image_type"] ?? null) !== null) {
        cargs.push(
            "--input-image-type",
            String((params["input_image_type"] ?? null))
        );
    }
    if ((params["input_image"] ?? null) !== null) {
        cargs.push(
            "--input",
            execution.inputFile((params["input_image"] ?? null))
        );
    }
    cargs.push(
        "--reference-image",
        execution.inputFile((params["reference_image"] ?? null))
    );
    cargs.push(
        "--output",
        ...dynCargs((params["output"] ?? null)["@type"])((params["output"] ?? null), execution)
    );
    if ((params["interpolation"] ?? null) !== null) {
        cargs.push(
            "--interpolation",
            ...dynCargs((params["interpolation"] ?? null)["@type"])((params["interpolation"] ?? null), execution)
        );
    }
    if ((params["output_data_type"] ?? null) !== null) {
        cargs.push(
            "--output-data-type",
            (params["output_data_type"] ?? null)
        );
    }
    if ((params["transform"] ?? null) !== null) {
        cargs.push(
            "--transform",
            ...(params["transform"] ?? null).map(s => dynCargs(s["@type"])(s, execution)).flat()
        );
    }
    if ((params["default_value"] ?? null) !== null) {
        cargs.push(
            "--default-value",
            String((params["default_value"] ?? null))
        );
    }
    if ((params["static_cast_for_R"] ?? null) !== null) {
        cargs.push(
            "--static-cast-for-R",
            (params["static_cast_for_R"] ?? null)
        );
    }
    if ((params["float"] ?? null) !== null) {
        cargs.push(
            "--float",
            String((params["float"] ?? null))
        );
    }
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "--verbose",
            String((params["verbose"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ants_apply_transforms_outputs(
    params: AntsApplyTransformsParameters,
    execution: Execution,
): AntsApplyTransformsOutputs {
    const ret: AntsApplyTransformsOutputs = {
        root: execution.outputFile("."),
        output: dynOutputs((params["output"] ?? null)["@type"])?.((params["output"] ?? null), execution),
    };
    return ret;
}


/**
 * antsApplyTransforms
 *
 * antsApplyTransforms, applied to an input image, transforms it according to a reference image and a transform (or a set of transforms).
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
 */
function ants_apply_transforms_execute(
    params: AntsApplyTransformsParameters,
    runner: Runner | null = null,
): AntsApplyTransformsOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ANTS_APPLY_TRANSFORMS_METADATA);
    params = execution.params(params)
    const cargs = ants_apply_transforms_cargs(params, execution)
    const ret = ants_apply_transforms_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * antsApplyTransforms
 *
 * antsApplyTransforms, applied to an input image, transforms it according to a reference image and a transform (or a set of transforms).
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param reference_image For warping input images, the reference image defines the spacing, origin, size, and direction of the output warped image.
 * @param output One can either output the warped image or, if the boolean is set, one can print out the displacement field based on the composite transform and the reference image. A third option is to compose all affine transforms and (if boolean is set) calculate its inverse which is then written to an ITK file.
 * @param dimensionality This option forces the image to be treated as a specified-dimensional image. if not specified, antswarp tries to infer the dimensionality from the input image.
 * @param input_image_type Option specifying the input image type of scalar (default), vector, tensor, time series, or multi-channel. A time series image is a scalar image defined by an additional dimension for the time component whereas a multi-channel image is a vector image with only spatial dimensions. Five-dimensional images are e.g., AFNI stats image.
 * @param input_image Currently, the only input objects supported are image objects. However, the current framework allows for warping of other objects such as meshes and point sets.
 * @param interpolation Several interpolation options are available in ITK. These have all been made available.
 * @param output_data_type Output image data type. This is a direct typecast; output values are not rescaled. Default is to use the internal data type (float or double). uchar is unsigned char; others are signed. WARNING: Outputs will be incorrect (overflowed/reinterpreted) if values exceed the range allowed by your choice. Note that some pixel types are not supported by some image formats. e.g. int is not supported by jpg.
 * @param transform Several transform options are supported including all those defined in the ITK library in addition to a deformation field transform. The ordering of the transformations follows the ordering specified on the command line. An identity transform is pushed onto the transformation stack. Each new transform encountered on the command line is also pushed onto the transformation stack. Then, to warp the input object, each point comprising the input object is warped first according to the last transform pushed onto the stack followed by the second to last transform, etc. until the last transform encountered which is the identity transform. Also, it should be noted that the inverse transform can be accommodated with the usual caveat that such an inverse must be defined by the specified transform class.
 * @param default_value Default voxel value to be used with input images only. Specifies the voxel value when the input point maps outside the output domain. With tensor input images, specifies the default voxel eigenvalues.
 * @param static_cast_for_r Forces static cast in ReadTransform (for R).
 * @param float Use float instead of double for computations.
 * @param verbose Verbose output.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsApplyTransformsOutputs`).
 */
function ants_apply_transforms(
    reference_image: InputPathType,
    output: AntsApplyTransformsWarpedOutputParameters | AntsApplyTransformsCompositeDisplacementFieldOutputParameters | AntsApplyTransformsGenericAffineTransformOutputParameters,
    dimensionality: 2 | 3 | 4 | null = null,
    input_image_type: 0 | 1 | 2 | 3 | 4 | 5 | null = null,
    input_image: InputPathType | null = null,
    interpolation: AntsApplyTransformsLinearParameters | AntsApplyTransformsNearestNeighborParameters | AntsApplyTransformsMultiLabelnoparamsParameters | AntsApplyTransformsMultiLabelParameters | AntsApplyTransformsGaussianParameters | AntsApplyTransformsBsplineParameters | AntsApplyTransformsCosineWindowedSincParameters | AntsApplyTransformsWelchWindowedSincParameters | AntsApplyTransformsHammingWindowedSincParameters | AntsApplyTransformsLanczosWindowedSincParameters | AntsApplyTransformsGenericLabelParameters | null = null,
    output_data_type: "char" | "uchar" | "short" | "int" | "float" | "double" | "default" | null = null,
    transform: Array<AntsApplyTransformsTransformFileNameParameters | AntsApplyTransformsUseInverseParameters> | null = null,
    default_value: number | null = null,
    static_cast_for_r: string | null = null,
    float: 0 | 1 | null = null,
    verbose: 0 | 1 | null = null,
    runner: Runner | null = null,
): AntsApplyTransformsOutputs {
    const params = ants_apply_transforms_params(reference_image, output, dimensionality, input_image_type, input_image, interpolation, output_data_type, transform, default_value, static_cast_for_r, float, verbose)
    return ants_apply_transforms_execute(params, runner);
}


export {
      ANTS_APPLY_TRANSFORMS_METADATA,
      AntsApplyTransformsAlphaParameters,
      AntsApplyTransformsBsplineParameters,
      AntsApplyTransformsCompositeDisplacementFieldOutputOutputs,
      AntsApplyTransformsCompositeDisplacementFieldOutputParameters,
      AntsApplyTransformsCosineWindowedSincParameters,
      AntsApplyTransformsGaussianParameters,
      AntsApplyTransformsGenericAffineTransformOutputOutputs,
      AntsApplyTransformsGenericAffineTransformOutputParameters,
      AntsApplyTransformsGenericLabelParameters,
      AntsApplyTransformsHammingWindowedSincParameters,
      AntsApplyTransformsLanczosWindowedSincParameters,
      AntsApplyTransformsLinearParameters,
      AntsApplyTransformsMultiLabelParameters,
      AntsApplyTransformsMultiLabelnoparamsParameters,
      AntsApplyTransformsNearestNeighborParameters,
      AntsApplyTransformsOutputs,
      AntsApplyTransformsParamParameters,
      AntsApplyTransformsParameters,
      AntsApplyTransformsSigmaParameters,
      AntsApplyTransformsTransformFileNameParameters,
      AntsApplyTransformsUseInverseParameters,
      AntsApplyTransformsWarpedOutputOutputs,
      AntsApplyTransformsWarpedOutputParameters,
      AntsApplyTransformsWelchWindowedSincParameters,
      ants_apply_transforms,
      ants_apply_transforms_alpha_params,
      ants_apply_transforms_bspline_params,
      ants_apply_transforms_composite_displacement_field_output_params,
      ants_apply_transforms_cosine_windowed_sinc_params,
      ants_apply_transforms_execute,
      ants_apply_transforms_gaussian_params,
      ants_apply_transforms_generic_affine_transform_output_params,
      ants_apply_transforms_generic_label_params,
      ants_apply_transforms_hamming_windowed_sinc_params,
      ants_apply_transforms_lanczos_windowed_sinc_params,
      ants_apply_transforms_linear_params,
      ants_apply_transforms_multi_label_params,
      ants_apply_transforms_multi_labelnoparams_params,
      ants_apply_transforms_nearest_neighbor_params,
      ants_apply_transforms_param_params,
      ants_apply_transforms_params,
      ants_apply_transforms_sigma_params,
      ants_apply_transforms_transform_file_name_params,
      ants_apply_transforms_use_inverse_params,
      ants_apply_transforms_warped_output_params,
      ants_apply_transforms_welch_windowed_sinc_params,
};
