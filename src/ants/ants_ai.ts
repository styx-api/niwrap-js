// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ANTS_AI_METADATA: Metadata = {
    id: "694c77fb3122e7ae7609dc66837caa7834538472.boutiques",
    name: "antsAI",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface AntsAiParameters {
    "__STYXTYPE__": "antsAI";
    "dimensionality"?: 2 | 3 | null | undefined;
    "metric": "Mattes[fixedImage,movingImage]" | "GC[fixedImage,movingImage]" | "MI[fixedImage,movingImage]";
    "transform": "Rigid[gradientStep]" | "Affine[gradientStep]" | "Similarity[gradientStep]" | "AlignGeometricCenters" | "AlignCentersOfMass";
    "align_principal_axes"?: 0 | 1 | null | undefined;
    "align_blobs"?: "numberOfBlobsToExtract" | "[numberOfBlobsToExtract,numberOfBlobsToMatch]" | null | undefined;
    "search_factor"?: "searchFactor" | "[searchFactor,arcFraction]" | null | undefined;
    "translation_search_grid"?: "[stepSize, AxBxC]" | null | undefined;
    "convergence"?: "numberOfIterations" | "[numberOfIterations,convergenceThreshold,convergenceWindowSize]" | null | undefined;
    "masks"?: "fixedImageMask" | "[fixedImageMask,movingImageMask]" | null | undefined;
    "output": string;
    "random_seed"?: number | null | undefined;
    "verbose"?: 0 | 1 | null | undefined;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "antsAI": ants_ai_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "antsAI": ants_ai_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `ants_ai(...)`.
 *
 * @interface
 */
interface AntsAiOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output transform (ITK .mat file).
     */
    output_transform: OutputPathType;
}


function ants_ai_params(
    metric: "Mattes[fixedImage,movingImage]" | "GC[fixedImage,movingImage]" | "MI[fixedImage,movingImage]",
    transform: "Rigid[gradientStep]" | "Affine[gradientStep]" | "Similarity[gradientStep]" | "AlignGeometricCenters" | "AlignCentersOfMass",
    output: string,
    dimensionality: 2 | 3 | null = null,
    align_principal_axes: 0 | 1 | null = null,
    align_blobs: "numberOfBlobsToExtract" | "[numberOfBlobsToExtract,numberOfBlobsToMatch]" | null = null,
    search_factor: "searchFactor" | "[searchFactor,arcFraction]" | null = null,
    translation_search_grid: "[stepSize, AxBxC]" | null = null,
    convergence: "numberOfIterations" | "[numberOfIterations,convergenceThreshold,convergenceWindowSize]" | null = null,
    masks: "fixedImageMask" | "[fixedImageMask,movingImageMask]" | null = null,
    random_seed: number | null = null,
    verbose: 0 | 1 | null = null,
): AntsAiParameters {
    /**
     * Build parameters.
    
     * @param metric These image metrics are available: Mattes: Mattes mutual information (recommended), GC: global correlation, MI: joint histogram mutual information
     * @param transform Several transform options are available. For the rigid, affine, and similarity transforms, the gradientStep characterizes the gradient descent optimization. The other two transform types finds the simple translation transform which aligns the specified image feature.
     * @param output Specify the output transform (output format an ITK .mat file).
     * @param dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, we try to infer the dimensionality from the input image.
     * @param align_principal_axes Boolean indicating alignment by principal axes. Alternatively, one can align using blobs.
     * @param align_blobs Boolean indicating alignment by a set of blobs.
     * @param search_factor Incremental search factor (in degrees) which will sample the arc fraction around the principal axis or default axis.
     * @param translation_search_grid Translation search grid in mm, which will translate the moving image in each dimension in increments of the step size.
     * @param convergence Number of iterations.
     * @param masks Image masks to limit voxels considered by the metric.
     * @param random_seed Use a fixed seed for random number generation.
     * @param verbose Verbose output.
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "antsAI" as const,
        "metric": metric,
        "transform": transform,
        "output": output,
    };
    if (dimensionality !== null) {
        params["dimensionality"] = dimensionality;
    }
    if (align_principal_axes !== null) {
        params["align_principal_axes"] = align_principal_axes;
    }
    if (align_blobs !== null) {
        params["align_blobs"] = align_blobs;
    }
    if (search_factor !== null) {
        params["search_factor"] = search_factor;
    }
    if (translation_search_grid !== null) {
        params["translation_search_grid"] = translation_search_grid;
    }
    if (convergence !== null) {
        params["convergence"] = convergence;
    }
    if (masks !== null) {
        params["masks"] = masks;
    }
    if (random_seed !== null) {
        params["random_seed"] = random_seed;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    return params;
}


function ants_ai_cargs(
    params: AntsAiParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("antsAI");
    if ((params["dimensionality"] ?? null) !== null) {
        cargs.push(
            "--dimensionality",
            String((params["dimensionality"] ?? null))
        );
    }
    cargs.push(
        "-m",
        (params["metric"] ?? null)
    );
    cargs.push(
        "-t",
        (params["transform"] ?? null)
    );
    if ((params["align_principal_axes"] ?? null) !== null) {
        cargs.push(
            "-p",
            String((params["align_principal_axes"] ?? null))
        );
    }
    if ((params["align_blobs"] ?? null) !== null) {
        cargs.push(
            "-b",
            (params["align_blobs"] ?? null)
        );
    }
    if ((params["search_factor"] ?? null) !== null) {
        cargs.push(
            "-s",
            (params["search_factor"] ?? null)
        );
    }
    if ((params["translation_search_grid"] ?? null) !== null) {
        cargs.push(
            "-g",
            (params["translation_search_grid"] ?? null)
        );
    }
    if ((params["convergence"] ?? null) !== null) {
        cargs.push(
            "-c",
            (params["convergence"] ?? null)
        );
    }
    if ((params["masks"] ?? null) !== null) {
        cargs.push(
            "-x",
            (params["masks"] ?? null)
        );
    }
    cargs.push(
        "-o",
        (params["output"] ?? null)
    );
    if ((params["random_seed"] ?? null) !== null) {
        cargs.push(
            "--random-seed",
            String((params["random_seed"] ?? null))
        );
    }
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "-v",
            String((params["verbose"] ?? null))
        );
    }
    return cargs;
}


function ants_ai_outputs(
    params: AntsAiParameters,
    execution: Execution,
): AntsAiOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: AntsAiOutputs = {
        root: execution.outputFile("."),
        output_transform: execution.outputFile([(params["output"] ?? null), ".mat"].join('')),
    };
    return ret;
}


function ants_ai_execute(
    params: AntsAiParameters,
    execution: Execution,
): AntsAiOutputs {
    /**
     * Program to calculate the optimal linear transform parameters for aligning two images.
     * 
     * Author: ANTs Developers
     * 
     * URL: https://github.com/ANTsX/ANTs
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `AntsAiOutputs`).
     */
    params = execution.params(params)
    const cargs = ants_ai_cargs(params, execution)
    const ret = ants_ai_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function ants_ai(
    metric: "Mattes[fixedImage,movingImage]" | "GC[fixedImage,movingImage]" | "MI[fixedImage,movingImage]",
    transform: "Rigid[gradientStep]" | "Affine[gradientStep]" | "Similarity[gradientStep]" | "AlignGeometricCenters" | "AlignCentersOfMass",
    output: string,
    dimensionality: 2 | 3 | null = null,
    align_principal_axes: 0 | 1 | null = null,
    align_blobs: "numberOfBlobsToExtract" | "[numberOfBlobsToExtract,numberOfBlobsToMatch]" | null = null,
    search_factor: "searchFactor" | "[searchFactor,arcFraction]" | null = null,
    translation_search_grid: "[stepSize, AxBxC]" | null = null,
    convergence: "numberOfIterations" | "[numberOfIterations,convergenceThreshold,convergenceWindowSize]" | null = null,
    masks: "fixedImageMask" | "[fixedImageMask,movingImageMask]" | null = null,
    random_seed: number | null = null,
    verbose: 0 | 1 | null = null,
    runner: Runner | null = null,
): AntsAiOutputs {
    /**
     * Program to calculate the optimal linear transform parameters for aligning two images.
     * 
     * Author: ANTs Developers
     * 
     * URL: https://github.com/ANTsX/ANTs
    
     * @param metric These image metrics are available: Mattes: Mattes mutual information (recommended), GC: global correlation, MI: joint histogram mutual information
     * @param transform Several transform options are available. For the rigid, affine, and similarity transforms, the gradientStep characterizes the gradient descent optimization. The other two transform types finds the simple translation transform which aligns the specified image feature.
     * @param output Specify the output transform (output format an ITK .mat file).
     * @param dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, we try to infer the dimensionality from the input image.
     * @param align_principal_axes Boolean indicating alignment by principal axes. Alternatively, one can align using blobs.
     * @param align_blobs Boolean indicating alignment by a set of blobs.
     * @param search_factor Incremental search factor (in degrees) which will sample the arc fraction around the principal axis or default axis.
     * @param translation_search_grid Translation search grid in mm, which will translate the moving image in each dimension in increments of the step size.
     * @param convergence Number of iterations.
     * @param masks Image masks to limit voxels considered by the metric.
     * @param random_seed Use a fixed seed for random number generation.
     * @param verbose Verbose output.
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `AntsAiOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ANTS_AI_METADATA);
    const params = ants_ai_params(metric, transform, output, dimensionality, align_principal_axes, align_blobs, search_factor, translation_search_grid, convergence, masks, random_seed, verbose)
    return ants_ai_execute(params, execution);
}


export {
      ANTS_AI_METADATA,
      AntsAiOutputs,
      AntsAiParameters,
      ants_ai,
      ants_ai_params,
};
