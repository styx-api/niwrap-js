// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRIS_CURVATURE_METADATA: Metadata = {
    id: "b2be5c74ffe0d5cc95cc6e6fc9fb27e6b3355ec4.boutiques",
    name: "mris_curvature",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface MrisCurvatureParameters {
    "__STYXTYPE__": "mris_curvature";
    "save_curvature_files": boolean;
    "max_principal_curvature": boolean;
    "mgh_output_format": boolean;
    "min_principal_curvature": boolean;
    "iterative_averages"?: number | null | undefined;
    "neighborhood_size"?: number | null | undefined;
    "random_seed"?: number | null | undefined;
    "curvatures"?: string | null | undefined;
    "H_curvature"?: string | null | undefined;
    "K_curvature"?: string | null | undefined;
    "k1_curvature"?: string | null | undefined;
    "k2_curvature"?: string | null | undefined;
    "k1k2_curvature"?: string | null | undefined;
    "input_surface": InputPathType;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "mris_curvature": mris_curvature_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "mris_curvature": mris_curvature_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `mris_curvature(...)`.
 *
 * @interface
 */
interface MrisCurvatureOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Mean curvature file
     */
    mean_curvature: OutputPathType;
    /**
     * Gaussian curvature file
     */
    gaussian_curvature: OutputPathType;
}


function mris_curvature_params(
    input_surface: InputPathType,
    save_curvature_files: boolean = false,
    max_principal_curvature: boolean = false,
    mgh_output_format: boolean = false,
    min_principal_curvature: boolean = false,
    iterative_averages: number | null = null,
    neighborhood_size: number | null = null,
    random_seed: number | null = null,
    curvatures: string | null = null,
    h_curvature: string | null = null,
    k_curvature: string | null = null,
    k1_curvature: string | null = null,
    k2_curvature: string | null = null,
    k1k2_curvature: string | null = null,
): MrisCurvatureParameters {
    /**
     * Build parameters.
    
     * @param input_surface Input surface file
     * @param save_curvature_files Save curvature files (will only generate screen output without this option)
     * @param max_principal_curvature Save 1st (max) principal curvature in ?h.<surface>.max file
     * @param mgh_output_format Save outputs in .mgz format
     * @param min_principal_curvature Save 2nd (min) principal curvature in ?h.<surface>.min file
     * @param iterative_averages Perform <avgs> iterative averages of curvature measure before saving
     * @param neighborhood_size Set neighborhood size to nbrs
     * @param random_seed Set random number generator to seed N
     * @param curvatures Stand-alone option to save H (mean), K (gaussian), k1, and k2 curvatures to stem.{curvname}.mgz
     * @param h_curvature Stand-alone option to save H mean curvature to stem.H.mgz
     * @param k_curvature Stand-alone option to save K gaussian curvature to stem.K.mgz
     * @param k1_curvature Stand-alone option to save k1 (primary principle) curvature to stem.k1.mgz
     * @param k2_curvature Stand-alone option to save k2 (secondary principle) curvature to stem.k2.mgz
     * @param k1k2_curvature Stand-alone option to save k1 and k2 curvature to stem.{k1,k2}.mgz
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "mris_curvature" as const,
        "save_curvature_files": save_curvature_files,
        "max_principal_curvature": max_principal_curvature,
        "mgh_output_format": mgh_output_format,
        "min_principal_curvature": min_principal_curvature,
        "input_surface": input_surface,
    };
    if (iterative_averages !== null) {
        params["iterative_averages"] = iterative_averages;
    }
    if (neighborhood_size !== null) {
        params["neighborhood_size"] = neighborhood_size;
    }
    if (random_seed !== null) {
        params["random_seed"] = random_seed;
    }
    if (curvatures !== null) {
        params["curvatures"] = curvatures;
    }
    if (h_curvature !== null) {
        params["H_curvature"] = h_curvature;
    }
    if (k_curvature !== null) {
        params["K_curvature"] = k_curvature;
    }
    if (k1_curvature !== null) {
        params["k1_curvature"] = k1_curvature;
    }
    if (k2_curvature !== null) {
        params["k2_curvature"] = k2_curvature;
    }
    if (k1k2_curvature !== null) {
        params["k1k2_curvature"] = k1k2_curvature;
    }
    return params;
}


function mris_curvature_cargs(
    params: MrisCurvatureParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("mris_curvature");
    if ((params["save_curvature_files"] ?? null)) {
        cargs.push("-w");
    }
    if ((params["max_principal_curvature"] ?? null)) {
        cargs.push("-max");
    }
    if ((params["mgh_output_format"] ?? null)) {
        cargs.push("-mgh");
    }
    if ((params["min_principal_curvature"] ?? null)) {
        cargs.push("-min");
    }
    if ((params["iterative_averages"] ?? null) !== null) {
        cargs.push(
            "-a",
            String((params["iterative_averages"] ?? null))
        );
    }
    if ((params["neighborhood_size"] ?? null) !== null) {
        cargs.push(
            "-nbrs",
            String((params["neighborhood_size"] ?? null))
        );
    }
    if ((params["random_seed"] ?? null) !== null) {
        cargs.push(
            "-seed",
            String((params["random_seed"] ?? null))
        );
    }
    if ((params["curvatures"] ?? null) !== null) {
        cargs.push(
            "-curvs",
            (params["curvatures"] ?? null)
        );
    }
    if ((params["H_curvature"] ?? null) !== null) {
        cargs.push(
            "-H",
            (params["H_curvature"] ?? null)
        );
    }
    if ((params["K_curvature"] ?? null) !== null) {
        cargs.push(
            "-K",
            (params["K_curvature"] ?? null)
        );
    }
    if ((params["k1_curvature"] ?? null) !== null) {
        cargs.push(
            "-k1",
            (params["k1_curvature"] ?? null)
        );
    }
    if ((params["k2_curvature"] ?? null) !== null) {
        cargs.push(
            "-k2",
            (params["k2_curvature"] ?? null)
        );
    }
    if ((params["k1k2_curvature"] ?? null) !== null) {
        cargs.push(
            "-k1k2",
            (params["k1k2_curvature"] ?? null)
        );
    }
    cargs.push(execution.inputFile((params["input_surface"] ?? null)));
    return cargs;
}


function mris_curvature_outputs(
    params: MrisCurvatureParameters,
    execution: Execution,
): MrisCurvatureOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: MrisCurvatureOutputs = {
        root: execution.outputFile("."),
        mean_curvature: execution.outputFile(["<hemi>.<surface>.H"].join('')),
        gaussian_curvature: execution.outputFile(["<hemi>.<surface>.K"].join('')),
    };
    return ret;
}


function mris_curvature_execute(
    params: MrisCurvatureParameters,
    execution: Execution,
): MrisCurvatureOutputs {
    /**
     * Compute the second fundamental form of a cortical surface to generate mean and Gaussian curvature.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `MrisCurvatureOutputs`).
     */
    params = execution.params(params)
    const cargs = mris_curvature_cargs(params, execution)
    const ret = mris_curvature_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function mris_curvature(
    input_surface: InputPathType,
    save_curvature_files: boolean = false,
    max_principal_curvature: boolean = false,
    mgh_output_format: boolean = false,
    min_principal_curvature: boolean = false,
    iterative_averages: number | null = null,
    neighborhood_size: number | null = null,
    random_seed: number | null = null,
    curvatures: string | null = null,
    h_curvature: string | null = null,
    k_curvature: string | null = null,
    k1_curvature: string | null = null,
    k2_curvature: string | null = null,
    k1k2_curvature: string | null = null,
    runner: Runner | null = null,
): MrisCurvatureOutputs {
    /**
     * Compute the second fundamental form of a cortical surface to generate mean and Gaussian curvature.
     * 
     * Author: FreeSurfer Developers
     * 
     * URL: https://github.com/freesurfer/freesurfer
    
     * @param input_surface Input surface file
     * @param save_curvature_files Save curvature files (will only generate screen output without this option)
     * @param max_principal_curvature Save 1st (max) principal curvature in ?h.<surface>.max file
     * @param mgh_output_format Save outputs in .mgz format
     * @param min_principal_curvature Save 2nd (min) principal curvature in ?h.<surface>.min file
     * @param iterative_averages Perform <avgs> iterative averages of curvature measure before saving
     * @param neighborhood_size Set neighborhood size to nbrs
     * @param random_seed Set random number generator to seed N
     * @param curvatures Stand-alone option to save H (mean), K (gaussian), k1, and k2 curvatures to stem.{curvname}.mgz
     * @param h_curvature Stand-alone option to save H mean curvature to stem.H.mgz
     * @param k_curvature Stand-alone option to save K gaussian curvature to stem.K.mgz
     * @param k1_curvature Stand-alone option to save k1 (primary principle) curvature to stem.k1.mgz
     * @param k2_curvature Stand-alone option to save k2 (secondary principle) curvature to stem.k2.mgz
     * @param k1k2_curvature Stand-alone option to save k1 and k2 curvature to stem.{k1,k2}.mgz
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `MrisCurvatureOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRIS_CURVATURE_METADATA);
    const params = mris_curvature_params(input_surface, save_curvature_files, max_principal_curvature, mgh_output_format, min_principal_curvature, iterative_averages, neighborhood_size, random_seed, curvatures, h_curvature, k_curvature, k1_curvature, k2_curvature, k1k2_curvature)
    return mris_curvature_execute(params, execution);
}


export {
      MRIS_CURVATURE_METADATA,
      MrisCurvatureOutputs,
      MrisCurvatureParameters,
      mris_curvature,
      mris_curvature_params,
};
