// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ANTS_AI_METADATA: Metadata = {
    id: "678184c76f859365d010d230b1d56a4b04e420a7.boutiques",
    name: "antsAI",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface AntsAiParameters {
    "@type"?: "ants/antsAI";
    "dimensionality"?: 2 | 3 | null | undefined;
    "metric": "Mattes[fixedImage,movingImage]" | "GC[fixedImage,movingImage]" | "MI[fixedImage,movingImage]";
    "transform": "Rigid[gradientStep]" | "Affine[gradientStep]" | "Similarity[gradientStep]" | "AlignGeometricCenters" | "AlignCentersOfMass";
    "align_principal_axes"?: 0 | 1 | null | undefined;
    "align_blobs"?: "numberOfBlobsToExtract" | "[numberOfBlobsToExtract,numberOfBlobsToMatch]" | null | undefined;
    "search_factor"?: "searchFactor" | "[searchFactor,arcFraction]" | null | undefined;
    "translation_search_grid"?: "[stepSize, AxBxC]" | null | undefined;
    "convergence"?: "numberOfIterations" | "[numberOfIterations,convergenceThreshold,convergenceWindowSize]" | null | undefined;
    "masks"?: "fixedImageMask" | "[fixedImageMask,movingImageMask]" | null | undefined;
    "output": string;
    "random_seed"?: number | null | undefined;
    "verbose"?: 0 | 1 | null | undefined;
}
type AntsAiParametersTagged = Required<Pick<AntsAiParameters, '@type'>> & AntsAiParameters;


/**
 * Output object returned when calling `AntsAiParameters(...)`.
 *
 * @interface
 */
interface AntsAiOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output transform (ITK .mat file).
     */
    output_transform: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param metric These image metrics are available: Mattes: Mattes mutual information (recommended), GC: global correlation, MI: joint histogram mutual information
 * @param transform Several transform options are available. For the rigid, affine, and similarity transforms, the gradientStep characterizes the gradient descent optimization. The other two transform types finds the simple translation transform which aligns the specified image feature.
 * @param output Specify the output transform (output format an ITK .mat file).
 * @param dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, we try to infer the dimensionality from the input image.
 * @param align_principal_axes Boolean indicating alignment by principal axes. Alternatively, one can align using blobs.
 * @param align_blobs Boolean indicating alignment by a set of blobs.
 * @param search_factor Incremental search factor (in degrees) which will sample the arc fraction around the principal axis or default axis.
 * @param translation_search_grid Translation search grid in mm, which will translate the moving image in each dimension in increments of the step size.
 * @param convergence Number of iterations.
 * @param masks Image masks to limit voxels considered by the metric.
 * @param random_seed Use a fixed seed for random number generation.
 * @param verbose Verbose output.
 *
 * @returns Parameter dictionary
 */
function ants_ai_params(
    metric: "Mattes[fixedImage,movingImage]" | "GC[fixedImage,movingImage]" | "MI[fixedImage,movingImage]",
    transform: "Rigid[gradientStep]" | "Affine[gradientStep]" | "Similarity[gradientStep]" | "AlignGeometricCenters" | "AlignCentersOfMass",
    output: string,
    dimensionality: 2 | 3 | null = null,
    align_principal_axes: 0 | 1 | null = null,
    align_blobs: "numberOfBlobsToExtract" | "[numberOfBlobsToExtract,numberOfBlobsToMatch]" | null = null,
    search_factor: "searchFactor" | "[searchFactor,arcFraction]" | null = null,
    translation_search_grid: "[stepSize, AxBxC]" | null = null,
    convergence: "numberOfIterations" | "[numberOfIterations,convergenceThreshold,convergenceWindowSize]" | null = null,
    masks: "fixedImageMask" | "[fixedImageMask,movingImageMask]" | null = null,
    random_seed: number | null = null,
    verbose: 0 | 1 | null = null,
): AntsAiParametersTagged {
    const params = {
        "@type": "ants/antsAI" as const,
        "metric": metric,
        "transform": transform,
        "output": output,
    };
    if (dimensionality !== null) {
        params["dimensionality"] = dimensionality;
    }
    if (align_principal_axes !== null) {
        params["align_principal_axes"] = align_principal_axes;
    }
    if (align_blobs !== null) {
        params["align_blobs"] = align_blobs;
    }
    if (search_factor !== null) {
        params["search_factor"] = search_factor;
    }
    if (translation_search_grid !== null) {
        params["translation_search_grid"] = translation_search_grid;
    }
    if (convergence !== null) {
        params["convergence"] = convergence;
    }
    if (masks !== null) {
        params["masks"] = masks;
    }
    if (random_seed !== null) {
        params["random_seed"] = random_seed;
    }
    if (verbose !== null) {
        params["verbose"] = verbose;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function ants_ai_cargs(
    params: AntsAiParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("antsAI");
    if ((params["dimensionality"] ?? null) !== null) {
        cargs.push(
            "--dimensionality",
            String((params["dimensionality"] ?? null))
        );
    }
    cargs.push(
        "-m",
        (params["metric"] ?? null)
    );
    cargs.push(
        "-t",
        (params["transform"] ?? null)
    );
    if ((params["align_principal_axes"] ?? null) !== null) {
        cargs.push(
            "-p",
            String((params["align_principal_axes"] ?? null))
        );
    }
    if ((params["align_blobs"] ?? null) !== null) {
        cargs.push(
            "-b",
            (params["align_blobs"] ?? null)
        );
    }
    if ((params["search_factor"] ?? null) !== null) {
        cargs.push(
            "-s",
            (params["search_factor"] ?? null)
        );
    }
    if ((params["translation_search_grid"] ?? null) !== null) {
        cargs.push(
            "-g",
            (params["translation_search_grid"] ?? null)
        );
    }
    if ((params["convergence"] ?? null) !== null) {
        cargs.push(
            "-c",
            (params["convergence"] ?? null)
        );
    }
    if ((params["masks"] ?? null) !== null) {
        cargs.push(
            "-x",
            (params["masks"] ?? null)
        );
    }
    cargs.push(
        "-o",
        (params["output"] ?? null)
    );
    if ((params["random_seed"] ?? null) !== null) {
        cargs.push(
            "--random-seed",
            String((params["random_seed"] ?? null))
        );
    }
    if ((params["verbose"] ?? null) !== null) {
        cargs.push(
            "-v",
            String((params["verbose"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function ants_ai_outputs(
    params: AntsAiParameters,
    execution: Execution,
): AntsAiOutputs {
    const ret: AntsAiOutputs = {
        root: execution.outputFile("."),
        output_transform: execution.outputFile([(params["output"] ?? null), ".mat"].join('')),
    };
    return ret;
}


/**
 * antsAI
 *
 * Program to calculate the optimal linear transform parameters for aligning two images.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsAiOutputs`).
 */
function ants_ai_execute(
    params: AntsAiParameters,
    runner: Runner | null = null,
): AntsAiOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ANTS_AI_METADATA);
    params = execution.params(params)
    const cargs = ants_ai_cargs(params, execution)
    const ret = ants_ai_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * antsAI
 *
 * Program to calculate the optimal linear transform parameters for aligning two images.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param metric These image metrics are available: Mattes: Mattes mutual information (recommended), GC: global correlation, MI: joint histogram mutual information
 * @param transform Several transform options are available. For the rigid, affine, and similarity transforms, the gradientStep characterizes the gradient descent optimization. The other two transform types finds the simple translation transform which aligns the specified image feature.
 * @param output Specify the output transform (output format an ITK .mat file).
 * @param dimensionality This option forces the image to be treated as a specified-dimensional image. If not specified, we try to infer the dimensionality from the input image.
 * @param align_principal_axes Boolean indicating alignment by principal axes. Alternatively, one can align using blobs.
 * @param align_blobs Boolean indicating alignment by a set of blobs.
 * @param search_factor Incremental search factor (in degrees) which will sample the arc fraction around the principal axis or default axis.
 * @param translation_search_grid Translation search grid in mm, which will translate the moving image in each dimension in increments of the step size.
 * @param convergence Number of iterations.
 * @param masks Image masks to limit voxels considered by the metric.
 * @param random_seed Use a fixed seed for random number generation.
 * @param verbose Verbose output.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `AntsAiOutputs`).
 */
function ants_ai(
    metric: "Mattes[fixedImage,movingImage]" | "GC[fixedImage,movingImage]" | "MI[fixedImage,movingImage]",
    transform: "Rigid[gradientStep]" | "Affine[gradientStep]" | "Similarity[gradientStep]" | "AlignGeometricCenters" | "AlignCentersOfMass",
    output: string,
    dimensionality: 2 | 3 | null = null,
    align_principal_axes: 0 | 1 | null = null,
    align_blobs: "numberOfBlobsToExtract" | "[numberOfBlobsToExtract,numberOfBlobsToMatch]" | null = null,
    search_factor: "searchFactor" | "[searchFactor,arcFraction]" | null = null,
    translation_search_grid: "[stepSize, AxBxC]" | null = null,
    convergence: "numberOfIterations" | "[numberOfIterations,convergenceThreshold,convergenceWindowSize]" | null = null,
    masks: "fixedImageMask" | "[fixedImageMask,movingImageMask]" | null = null,
    random_seed: number | null = null,
    verbose: 0 | 1 | null = null,
    runner: Runner | null = null,
): AntsAiOutputs {
    const params = ants_ai_params(metric, transform, output, dimensionality, align_principal_axes, align_blobs, search_factor, translation_search_grid, convergence, masks, random_seed, verbose)
    return ants_ai_execute(params, runner);
}


export {
      ANTS_AI_METADATA,
      AntsAiOutputs,
      ants_ai,
      ants_ai_execute,
      ants_ai_params,
};
