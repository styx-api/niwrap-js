// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRI_SEGSTATS_METADATA: Metadata = {
    id: "89e84151f707eca137cb1525638242cb895be018.boutiques",
    name: "mri_segstats",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface MriSegstatsParameters {
    "@type"?: "freesurfer/mri_segstats";
    "segvol": InputPathType;
    "annot_subject"?: string | null | undefined;
    "annot_hemisphere"?: string | null | undefined;
    "annot_parcellation"?: string | null | undefined;
    "slabel_subject"?: string | null | undefined;
    "slabel_hemisphere"?: string | null | undefined;
    "slabel_label"?: InputPathType | null | undefined;
    "output_file": string;
    "partial_vol_comp"?: InputPathType | null | undefined;
    "input_volume"?: InputPathType | null | undefined;
    "seg_erode"?: number | null | undefined;
    "frame"?: number | null | undefined;
    "robust"?: number | null | undefined;
    "square_input": boolean;
    "sqrt_input": boolean;
    "multiply_input"?: number | null | undefined;
    "divide_input"?: number | null | undefined;
    "snr_column": boolean;
    "absolute_value": boolean;
    "accumulate_mean": boolean;
    "color_table"?: InputPathType | null | undefined;
    "default_color_table": boolean;
    "gca_color_table"?: InputPathType | null | undefined;
    "ids"?: string | null | undefined;
    "exclude_ids"?: string | null | undefined;
    "exclude_gm_wm": boolean;
    "surf_wm_vol": boolean;
    "surf_ctx_vol": boolean;
    "no_global_stats": boolean;
    "empty_segments": boolean;
    "ctab_output"?: string | null | undefined;
    "mask_volume"?: InputPathType | null | undefined;
    "mask_threshold"?: number | null | undefined;
    "mask_sign"?: string | null | undefined;
    "mask_frame"?: number | null | undefined;
    "invert_mask": boolean;
    "mask_erode"?: number | null | undefined;
    "brain_vol_seg": boolean;
    "brain_mask_vol"?: InputPathType | null | undefined;
    "subcortical_gray": boolean;
    "total_gray": boolean;
    "intracranial_volume": boolean;
    "intracranial_volume_only": boolean;
    "old_intracranial_volume_only": boolean;
    "talairach_transform"?: InputPathType | null | undefined;
    "xfm_to_etiv"?: string | null | undefined;
    "euler_hole_count": boolean;
    "avg_waveform"?: string | null | undefined;
    "sum_waveform"?: string | null | undefined;
    "avg_waveform_vol"?: string | null | undefined;
    "remove_avgwf_mean": boolean;
    "spatial_frame_avg"?: string | null | undefined;
    "voxel_crs"?: string | null | undefined;
    "replace_ids"?: string | null | undefined;
    "replace_ids_file"?: InputPathType | null | undefined;
    "gtm_default_seg_merge": boolean;
    "gtm_default_seg_merge_choroid": boolean;
    "qa_stats_file"?: string | null | undefined;
    "subjects_dir"?: string | null | undefined;
    "random_seed"?: number | null | undefined;
}
type MriSegstatsParametersTagged = Required<Pick<MriSegstatsParameters, '@type'>> & MriSegstatsParameters;


/**
 * Output object returned when calling `MriSegstatsParameters(...)`.
 *
 * @interface
 */
interface MriSegstatsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output file for summary statistics.
     */
    summary_output_file: OutputPathType;
    /**
     * Average waveform output text file.
     */
    avg_waveform_output: OutputPathType | null;
    /**
     * Sum waveform output text file.
     */
    sum_waveform_output: OutputPathType | null;
    /**
     * Average waveform volume output file.
     */
    avg_waveform_vol_output: OutputPathType | null;
    /**
     * Spatial frame average output file.
     */
    spatial_frame_avg_output: OutputPathType | null;
    /**
     * Output color table with the reported segmentations.
     */
    ctab_output_file: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param segvol Input segmentation volume. This volume's voxel values indicate a segmentation or class.
 * @param output_file ASCII file in which summary statistics are saved.
 * @param annot_subject Create a segmentation from hemi.parc.annot. Subject is the name of the subject.
 * @param slabel_subject Create a segmentation from the given surface label. The points in the label are given a value of 1; 0 for outside.
 * @param partial_vol_comp Use pvvol to compensate for partial voluming, resulting in more accurate volumes.
 * @param input_volume Input volume from which to compute more statistics.
 * @param seg_erode Erode segmentation boundaries by Nerodes.
 * @param frame Report statistics of the input volume at the specified 0-based frame number.
 * @param robust Compute stats after excluding a percentage of high and low values.
 * @param square_input Compute the square of the input before computing stats.
 * @param sqrt_input Compute the square root of the input before computing stats.
 * @param multiply_input Multiply input by value.
 * @param divide_input Divide input by value.
 * @param snr_column Save mean/std as extra column in output table.
 * @param absolute_value Compute absolute value of input before spatial average.
 * @param accumulate_mean Save mean*nvoxels instead of mean.
 * @param color_table FreeSurfer color table file to specify how each segmentation index is mapped to a segmentation name and color.
 * @param default_color_table Use default color table from FreeSurferColorLUT.txt.
 * @param gca_color_table Get color table from the given GCA file.
 * @param ids Specify numeric segmentation ids.
 * @param exclude_ids Exclude the given segmentation id(s) from report.
 * @param exclude_gm_wm Exclude cortical gray and white matter based on predefined IDs.
 * @param surf_wm_vol Compute cortical matter volume based on the white surface volume.
 * @param surf_ctx_vol Compute cortical volumes from surface.
 * @param no_global_stats Turns off computation of global stats.
 * @param empty_segments Report on segmentations listed in the color table even if they are not found in the segmentation volume.
 * @param ctab_output Create an output color table with just the segmentations reported.
 * @param mask_volume Exclude voxels that are not in the mask. Voxels to be excluded are assigned a segid of 0.
 * @param mask_threshold Exclude voxels that are below thresh, above -thresh, or between -thresh and +thresh.
 * @param mask_sign Specify sign for masking threshold. Choices are abs, pos, and neg.
 * @param mask_frame Derive the mask volume from the specified 0-based frame.
 * @param invert_mask After applying all the masking criteria, invert the mask.
 * @param mask_erode Erode mask by specified number of iterations.
 * @param brain_vol_seg Get volume of brain as the sum of the volumes of the segmentations that are in the brain.
 * @param brain_mask_vol Load brain mask and compute brain volume from non-zero voxels.
 * @param subcortical_gray Compute volume of subcortical gray matter.
 * @param total_gray Compute volume of total gray matter.
 * @param intracranial_volume Compute intracranial volume from talairach.xfm.
 * @param intracranial_volume_only Compute intracranial volume from talairach.xfm and exit.
 * @param old_intracranial_volume_only Compute intracranial volume from talairach_with_skull.lta and exit.
 * @param talairach_transform Specify path to talairach.xfm file for eTIV.
 * @param xfm_to_etiv Convert xfm to eTIV and write to output file.
 * @param euler_hole_count Write out number of defect holes based on the Euler number.
 * @param avg_waveform Compute the average waveform and save to text file.
 * @param sum_waveform Compute the sum waveform and save to text file.
 * @param avg_waveform_vol Compute average waveform and save to MRI volume.
 * @param remove_avgwf_mean Remove temporal mean from avgwf and avgwfvol.
 * @param spatial_frame_avg Save mean across space and frame.
 * @param voxel_crs Replace segmentation with all 0s except at specified voxel.
 * @param replace_ids Replace segmentation ID1 with ID2.
 * @param replace_ids_file Replace segmentations based on pairs in file.
 * @param gtm_default_seg_merge Replace segmentations based on GTM default.
 * @param gtm_default_seg_merge_choroid Replace segmentations based on GTM default excluding choroid.
 * @param qa_stats_file Compute stats useful for quality control.
 * @param subjects_dir Set SUBJECTS_DIR environment variable.
 * @param random_seed Set random number generator seed value.
 *
 * @returns Parameter dictionary
 */
function mri_segstats_params(
    segvol: InputPathType,
    output_file: string,
    annot_subject: string | null = null,
    annot_hemisphere: string | null = null,
    annot_parcellation: string | null = null,
    slabel_subject: string | null = null,
    slabel_hemisphere: string | null = null,
    slabel_label: InputPathType | null = null,
    partial_vol_comp: InputPathType | null = null,
    input_volume: InputPathType | null = null,
    seg_erode: number | null = null,
    frame: number | null = null,
    robust: number | null = null,
    square_input: boolean = false,
    sqrt_input: boolean = false,
    multiply_input: number | null = null,
    divide_input: number | null = null,
    snr_column: boolean = false,
    absolute_value: boolean = false,
    accumulate_mean: boolean = false,
    color_table: InputPathType | null = null,
    default_color_table: boolean = false,
    gca_color_table: InputPathType | null = null,
    ids: string | null = null,
    exclude_ids: string | null = null,
    exclude_gm_wm: boolean = false,
    surf_wm_vol: boolean = false,
    surf_ctx_vol: boolean = false,
    no_global_stats: boolean = false,
    empty_segments: boolean = false,
    ctab_output: string | null = null,
    mask_volume: InputPathType | null = null,
    mask_threshold: number | null = null,
    mask_sign: string | null = null,
    mask_frame: number | null = null,
    invert_mask: boolean = false,
    mask_erode: number | null = null,
    brain_vol_seg: boolean = false,
    brain_mask_vol: InputPathType | null = null,
    subcortical_gray: boolean = false,
    total_gray: boolean = false,
    intracranial_volume: boolean = false,
    intracranial_volume_only: boolean = false,
    old_intracranial_volume_only: boolean = false,
    talairach_transform: InputPathType | null = null,
    xfm_to_etiv: string | null = null,
    euler_hole_count: boolean = false,
    avg_waveform: string | null = null,
    sum_waveform: string | null = null,
    avg_waveform_vol: string | null = null,
    remove_avgwf_mean: boolean = false,
    spatial_frame_avg: string | null = null,
    voxel_crs: string | null = null,
    replace_ids: string | null = null,
    replace_ids_file: InputPathType | null = null,
    gtm_default_seg_merge: boolean = false,
    gtm_default_seg_merge_choroid: boolean = false,
    qa_stats_file: string | null = null,
    subjects_dir: string | null = null,
    random_seed: number | null = null,
): MriSegstatsParametersTagged {
    const params = {
        "@type": "freesurfer/mri_segstats" as const,
        "segvol": segvol,
        "output_file": output_file,
        "square_input": square_input,
        "sqrt_input": sqrt_input,
        "snr_column": snr_column,
        "absolute_value": absolute_value,
        "accumulate_mean": accumulate_mean,
        "default_color_table": default_color_table,
        "exclude_gm_wm": exclude_gm_wm,
        "surf_wm_vol": surf_wm_vol,
        "surf_ctx_vol": surf_ctx_vol,
        "no_global_stats": no_global_stats,
        "empty_segments": empty_segments,
        "invert_mask": invert_mask,
        "brain_vol_seg": brain_vol_seg,
        "subcortical_gray": subcortical_gray,
        "total_gray": total_gray,
        "intracranial_volume": intracranial_volume,
        "intracranial_volume_only": intracranial_volume_only,
        "old_intracranial_volume_only": old_intracranial_volume_only,
        "euler_hole_count": euler_hole_count,
        "remove_avgwf_mean": remove_avgwf_mean,
        "gtm_default_seg_merge": gtm_default_seg_merge,
        "gtm_default_seg_merge_choroid": gtm_default_seg_merge_choroid,
    };
    if (annot_subject !== null) {
        params["annot_subject"] = annot_subject;
    }
    if (annot_hemisphere !== null) {
        params["annot_hemisphere"] = annot_hemisphere;
    }
    if (annot_parcellation !== null) {
        params["annot_parcellation"] = annot_parcellation;
    }
    if (slabel_subject !== null) {
        params["slabel_subject"] = slabel_subject;
    }
    if (slabel_hemisphere !== null) {
        params["slabel_hemisphere"] = slabel_hemisphere;
    }
    if (slabel_label !== null) {
        params["slabel_label"] = slabel_label;
    }
    if (partial_vol_comp !== null) {
        params["partial_vol_comp"] = partial_vol_comp;
    }
    if (input_volume !== null) {
        params["input_volume"] = input_volume;
    }
    if (seg_erode !== null) {
        params["seg_erode"] = seg_erode;
    }
    if (frame !== null) {
        params["frame"] = frame;
    }
    if (robust !== null) {
        params["robust"] = robust;
    }
    if (multiply_input !== null) {
        params["multiply_input"] = multiply_input;
    }
    if (divide_input !== null) {
        params["divide_input"] = divide_input;
    }
    if (color_table !== null) {
        params["color_table"] = color_table;
    }
    if (gca_color_table !== null) {
        params["gca_color_table"] = gca_color_table;
    }
    if (ids !== null) {
        params["ids"] = ids;
    }
    if (exclude_ids !== null) {
        params["exclude_ids"] = exclude_ids;
    }
    if (ctab_output !== null) {
        params["ctab_output"] = ctab_output;
    }
    if (mask_volume !== null) {
        params["mask_volume"] = mask_volume;
    }
    if (mask_threshold !== null) {
        params["mask_threshold"] = mask_threshold;
    }
    if (mask_sign !== null) {
        params["mask_sign"] = mask_sign;
    }
    if (mask_frame !== null) {
        params["mask_frame"] = mask_frame;
    }
    if (mask_erode !== null) {
        params["mask_erode"] = mask_erode;
    }
    if (brain_mask_vol !== null) {
        params["brain_mask_vol"] = brain_mask_vol;
    }
    if (talairach_transform !== null) {
        params["talairach_transform"] = talairach_transform;
    }
    if (xfm_to_etiv !== null) {
        params["xfm_to_etiv"] = xfm_to_etiv;
    }
    if (avg_waveform !== null) {
        params["avg_waveform"] = avg_waveform;
    }
    if (sum_waveform !== null) {
        params["sum_waveform"] = sum_waveform;
    }
    if (avg_waveform_vol !== null) {
        params["avg_waveform_vol"] = avg_waveform_vol;
    }
    if (spatial_frame_avg !== null) {
        params["spatial_frame_avg"] = spatial_frame_avg;
    }
    if (voxel_crs !== null) {
        params["voxel_crs"] = voxel_crs;
    }
    if (replace_ids !== null) {
        params["replace_ids"] = replace_ids;
    }
    if (replace_ids_file !== null) {
        params["replace_ids_file"] = replace_ids_file;
    }
    if (qa_stats_file !== null) {
        params["qa_stats_file"] = qa_stats_file;
    }
    if (subjects_dir !== null) {
        params["subjects_dir"] = subjects_dir;
    }
    if (random_seed !== null) {
        params["random_seed"] = random_seed;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mri_segstats_cargs(
    params: MriSegstatsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mri_segstats");
    cargs.push(
        "--seg",
        execution.inputFile((params["segvol"] ?? null))
    );
    if ((params["annot_subject"] ?? null) !== null) {
        cargs.push(
            "--annot",
            (params["annot_subject"] ?? null)
        );
    }
    if ((params["annot_hemisphere"] ?? null) !== null) {
        cargs.push((params["annot_hemisphere"] ?? null));
    }
    if ((params["annot_parcellation"] ?? null) !== null) {
        cargs.push((params["annot_parcellation"] ?? null));
    }
    if ((params["slabel_subject"] ?? null) !== null) {
        cargs.push(
            "--slabel",
            (params["slabel_subject"] ?? null)
        );
    }
    if ((params["slabel_hemisphere"] ?? null) !== null) {
        cargs.push((params["slabel_hemisphere"] ?? null));
    }
    if ((params["slabel_label"] ?? null) !== null) {
        cargs.push(execution.inputFile((params["slabel_label"] ?? null)));
    }
    cargs.push(
        "--o",
        (params["output_file"] ?? null)
    );
    if ((params["partial_vol_comp"] ?? null) !== null) {
        cargs.push(
            "--pv",
            execution.inputFile((params["partial_vol_comp"] ?? null))
        );
    }
    if ((params["input_volume"] ?? null) !== null) {
        cargs.push(
            "--i",
            execution.inputFile((params["input_volume"] ?? null))
        );
    }
    if ((params["seg_erode"] ?? null) !== null) {
        cargs.push(
            "--seg-erode",
            String((params["seg_erode"] ?? null))
        );
    }
    if ((params["frame"] ?? null) !== null) {
        cargs.push(
            "--frame",
            String((params["frame"] ?? null))
        );
    }
    if ((params["robust"] ?? null) !== null) {
        cargs.push(
            "--robust",
            String((params["robust"] ?? null))
        );
    }
    if ((params["square_input"] ?? false)) {
        cargs.push("--sqr");
    }
    if ((params["sqrt_input"] ?? false)) {
        cargs.push("--sqrt");
    }
    if ((params["multiply_input"] ?? null) !== null) {
        cargs.push(
            "--mul",
            String((params["multiply_input"] ?? null))
        );
    }
    if ((params["divide_input"] ?? null) !== null) {
        cargs.push(
            "--div",
            String((params["divide_input"] ?? null))
        );
    }
    if ((params["snr_column"] ?? false)) {
        cargs.push("--snr");
    }
    if ((params["absolute_value"] ?? false)) {
        cargs.push("--abs");
    }
    if ((params["accumulate_mean"] ?? false)) {
        cargs.push("--accumulate");
    }
    if ((params["color_table"] ?? null) !== null) {
        cargs.push(
            "--ctab",
            execution.inputFile((params["color_table"] ?? null))
        );
    }
    if ((params["default_color_table"] ?? false)) {
        cargs.push("--ctab-default");
    }
    if ((params["gca_color_table"] ?? null) !== null) {
        cargs.push(
            "--ctab-gca",
            execution.inputFile((params["gca_color_table"] ?? null))
        );
    }
    if ((params["ids"] ?? null) !== null) {
        cargs.push(
            "--id",
            (params["ids"] ?? null)
        );
    }
    if ((params["exclude_ids"] ?? null) !== null) {
        cargs.push(
            "--excludeid",
            (params["exclude_ids"] ?? null)
        );
    }
    if ((params["exclude_gm_wm"] ?? false)) {
        cargs.push("--excl-ctxgmwm");
    }
    if ((params["surf_wm_vol"] ?? false)) {
        cargs.push("--surf-wm-vol");
    }
    if ((params["surf_ctx_vol"] ?? false)) {
        cargs.push("--surf-ctx-vol");
    }
    if ((params["no_global_stats"] ?? false)) {
        cargs.push("--no-global-stats");
    }
    if ((params["empty_segments"] ?? false)) {
        cargs.push("--empty");
    }
    if ((params["ctab_output"] ?? null) !== null) {
        cargs.push(
            "--ctab-out",
            (params["ctab_output"] ?? null)
        );
    }
    if ((params["mask_volume"] ?? null) !== null) {
        cargs.push(
            "--mask",
            execution.inputFile((params["mask_volume"] ?? null))
        );
    }
    if ((params["mask_threshold"] ?? null) !== null) {
        cargs.push(
            "--maskthresh",
            String((params["mask_threshold"] ?? null))
        );
    }
    if ((params["mask_sign"] ?? null) !== null) {
        cargs.push(
            "--masksign",
            (params["mask_sign"] ?? null)
        );
    }
    if ((params["mask_frame"] ?? null) !== null) {
        cargs.push(
            "--maskframe",
            String((params["mask_frame"] ?? null))
        );
    }
    if ((params["invert_mask"] ?? false)) {
        cargs.push("--maskinvert");
    }
    if ((params["mask_erode"] ?? null) !== null) {
        cargs.push(
            "--maskerode",
            String((params["mask_erode"] ?? null))
        );
    }
    if ((params["brain_vol_seg"] ?? false)) {
        cargs.push("--brain-vol-from-seg");
    }
    if ((params["brain_mask_vol"] ?? null) !== null) {
        cargs.push(
            "--brainmask",
            execution.inputFile((params["brain_mask_vol"] ?? null))
        );
    }
    if ((params["subcortical_gray"] ?? false)) {
        cargs.push("--subcortgray");
    }
    if ((params["total_gray"] ?? false)) {
        cargs.push("--totalgray");
    }
    if ((params["intracranial_volume"] ?? false)) {
        cargs.push("--etiv");
    }
    if ((params["intracranial_volume_only"] ?? false)) {
        cargs.push("--etiv-only");
    }
    if ((params["old_intracranial_volume_only"] ?? false)) {
        cargs.push("--old-etiv-only");
    }
    if ((params["talairach_transform"] ?? null) !== null) {
        cargs.push(
            "--talxfm",
            execution.inputFile((params["talairach_transform"] ?? null))
        );
    }
    if ((params["xfm_to_etiv"] ?? null) !== null) {
        cargs.push(
            "--xfm2etiv",
            (params["xfm_to_etiv"] ?? null)
        );
    }
    if ((params["euler_hole_count"] ?? false)) {
        cargs.push("--euler");
    }
    if ((params["avg_waveform"] ?? null) !== null) {
        cargs.push(
            "--avgwf",
            (params["avg_waveform"] ?? null)
        );
    }
    if ((params["sum_waveform"] ?? null) !== null) {
        cargs.push(
            "--sumwf",
            (params["sum_waveform"] ?? null)
        );
    }
    if ((params["avg_waveform_vol"] ?? null) !== null) {
        cargs.push(
            "--avgwfvol",
            (params["avg_waveform_vol"] ?? null)
        );
    }
    if ((params["remove_avgwf_mean"] ?? false)) {
        cargs.push("--avgwf-remove-mean");
    }
    if ((params["spatial_frame_avg"] ?? null) !== null) {
        cargs.push(
            "--sfavg",
            (params["spatial_frame_avg"] ?? null)
        );
    }
    if ((params["voxel_crs"] ?? null) !== null) {
        cargs.push(
            "--vox",
            (params["voxel_crs"] ?? null)
        );
    }
    if ((params["replace_ids"] ?? null) !== null) {
        cargs.push(
            "--replace",
            (params["replace_ids"] ?? null)
        );
    }
    if ((params["replace_ids_file"] ?? null) !== null) {
        cargs.push(
            "--replace-file",
            execution.inputFile((params["replace_ids_file"] ?? null))
        );
    }
    if ((params["gtm_default_seg_merge"] ?? false)) {
        cargs.push("--gtm-default-seg-merge");
    }
    if ((params["gtm_default_seg_merge_choroid"] ?? false)) {
        cargs.push("--gtm-default-seg-merge-choroid");
    }
    if ((params["qa_stats_file"] ?? null) !== null) {
        cargs.push(
            "--qa-stats",
            (params["qa_stats_file"] ?? null)
        );
    }
    if ((params["subjects_dir"] ?? null) !== null) {
        cargs.push(
            "--sd",
            (params["subjects_dir"] ?? null)
        );
    }
    if ((params["random_seed"] ?? null) !== null) {
        cargs.push(
            "--seed",
            String((params["random_seed"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mri_segstats_outputs(
    params: MriSegstatsParameters,
    execution: Execution,
): MriSegstatsOutputs {
    const ret: MriSegstatsOutputs = {
        root: execution.outputFile("."),
        summary_output_file: execution.outputFile([(params["output_file"] ?? null)].join('')),
        avg_waveform_output: ((params["avg_waveform"] ?? null) !== null) ? execution.outputFile([(params["avg_waveform"] ?? null)].join('')) : null,
        sum_waveform_output: ((params["sum_waveform"] ?? null) !== null) ? execution.outputFile([(params["sum_waveform"] ?? null)].join('')) : null,
        avg_waveform_vol_output: ((params["avg_waveform_vol"] ?? null) !== null) ? execution.outputFile([(params["avg_waveform_vol"] ?? null)].join('')) : null,
        spatial_frame_avg_output: ((params["spatial_frame_avg"] ?? null) !== null) ? execution.outputFile([(params["spatial_frame_avg"] ?? null)].join('')) : null,
        ctab_output_file: ((params["ctab_output"] ?? null) !== null) ? execution.outputFile([(params["ctab_output"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * mri_segstats
 *
 * Calculates measures and stats derived from brain segmentation data.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MriSegstatsOutputs`).
 */
function mri_segstats_execute(
    params: MriSegstatsParameters,
    runner: Runner | null = null,
): MriSegstatsOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRI_SEGSTATS_METADATA);
    params = execution.params(params)
    const cargs = mri_segstats_cargs(params, execution)
    const ret = mri_segstats_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * mri_segstats
 *
 * Calculates measures and stats derived from brain segmentation data.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param segvol Input segmentation volume. This volume's voxel values indicate a segmentation or class.
 * @param output_file ASCII file in which summary statistics are saved.
 * @param annot_subject Create a segmentation from hemi.parc.annot. Subject is the name of the subject.
 * @param slabel_subject Create a segmentation from the given surface label. The points in the label are given a value of 1; 0 for outside.
 * @param partial_vol_comp Use pvvol to compensate for partial voluming, resulting in more accurate volumes.
 * @param input_volume Input volume from which to compute more statistics.
 * @param seg_erode Erode segmentation boundaries by Nerodes.
 * @param frame Report statistics of the input volume at the specified 0-based frame number.
 * @param robust Compute stats after excluding a percentage of high and low values.
 * @param square_input Compute the square of the input before computing stats.
 * @param sqrt_input Compute the square root of the input before computing stats.
 * @param multiply_input Multiply input by value.
 * @param divide_input Divide input by value.
 * @param snr_column Save mean/std as extra column in output table.
 * @param absolute_value Compute absolute value of input before spatial average.
 * @param accumulate_mean Save mean*nvoxels instead of mean.
 * @param color_table FreeSurfer color table file to specify how each segmentation index is mapped to a segmentation name and color.
 * @param default_color_table Use default color table from FreeSurferColorLUT.txt.
 * @param gca_color_table Get color table from the given GCA file.
 * @param ids Specify numeric segmentation ids.
 * @param exclude_ids Exclude the given segmentation id(s) from report.
 * @param exclude_gm_wm Exclude cortical gray and white matter based on predefined IDs.
 * @param surf_wm_vol Compute cortical matter volume based on the white surface volume.
 * @param surf_ctx_vol Compute cortical volumes from surface.
 * @param no_global_stats Turns off computation of global stats.
 * @param empty_segments Report on segmentations listed in the color table even if they are not found in the segmentation volume.
 * @param ctab_output Create an output color table with just the segmentations reported.
 * @param mask_volume Exclude voxels that are not in the mask. Voxels to be excluded are assigned a segid of 0.
 * @param mask_threshold Exclude voxels that are below thresh, above -thresh, or between -thresh and +thresh.
 * @param mask_sign Specify sign for masking threshold. Choices are abs, pos, and neg.
 * @param mask_frame Derive the mask volume from the specified 0-based frame.
 * @param invert_mask After applying all the masking criteria, invert the mask.
 * @param mask_erode Erode mask by specified number of iterations.
 * @param brain_vol_seg Get volume of brain as the sum of the volumes of the segmentations that are in the brain.
 * @param brain_mask_vol Load brain mask and compute brain volume from non-zero voxels.
 * @param subcortical_gray Compute volume of subcortical gray matter.
 * @param total_gray Compute volume of total gray matter.
 * @param intracranial_volume Compute intracranial volume from talairach.xfm.
 * @param intracranial_volume_only Compute intracranial volume from talairach.xfm and exit.
 * @param old_intracranial_volume_only Compute intracranial volume from talairach_with_skull.lta and exit.
 * @param talairach_transform Specify path to talairach.xfm file for eTIV.
 * @param xfm_to_etiv Convert xfm to eTIV and write to output file.
 * @param euler_hole_count Write out number of defect holes based on the Euler number.
 * @param avg_waveform Compute the average waveform and save to text file.
 * @param sum_waveform Compute the sum waveform and save to text file.
 * @param avg_waveform_vol Compute average waveform and save to MRI volume.
 * @param remove_avgwf_mean Remove temporal mean from avgwf and avgwfvol.
 * @param spatial_frame_avg Save mean across space and frame.
 * @param voxel_crs Replace segmentation with all 0s except at specified voxel.
 * @param replace_ids Replace segmentation ID1 with ID2.
 * @param replace_ids_file Replace segmentations based on pairs in file.
 * @param gtm_default_seg_merge Replace segmentations based on GTM default.
 * @param gtm_default_seg_merge_choroid Replace segmentations based on GTM default excluding choroid.
 * @param qa_stats_file Compute stats useful for quality control.
 * @param subjects_dir Set SUBJECTS_DIR environment variable.
 * @param random_seed Set random number generator seed value.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MriSegstatsOutputs`).
 */
function mri_segstats(
    segvol: InputPathType,
    output_file: string,
    annot_subject: string | null = null,
    annot_hemisphere: string | null = null,
    annot_parcellation: string | null = null,
    slabel_subject: string | null = null,
    slabel_hemisphere: string | null = null,
    slabel_label: InputPathType | null = null,
    partial_vol_comp: InputPathType | null = null,
    input_volume: InputPathType | null = null,
    seg_erode: number | null = null,
    frame: number | null = null,
    robust: number | null = null,
    square_input: boolean = false,
    sqrt_input: boolean = false,
    multiply_input: number | null = null,
    divide_input: number | null = null,
    snr_column: boolean = false,
    absolute_value: boolean = false,
    accumulate_mean: boolean = false,
    color_table: InputPathType | null = null,
    default_color_table: boolean = false,
    gca_color_table: InputPathType | null = null,
    ids: string | null = null,
    exclude_ids: string | null = null,
    exclude_gm_wm: boolean = false,
    surf_wm_vol: boolean = false,
    surf_ctx_vol: boolean = false,
    no_global_stats: boolean = false,
    empty_segments: boolean = false,
    ctab_output: string | null = null,
    mask_volume: InputPathType | null = null,
    mask_threshold: number | null = null,
    mask_sign: string | null = null,
    mask_frame: number | null = null,
    invert_mask: boolean = false,
    mask_erode: number | null = null,
    brain_vol_seg: boolean = false,
    brain_mask_vol: InputPathType | null = null,
    subcortical_gray: boolean = false,
    total_gray: boolean = false,
    intracranial_volume: boolean = false,
    intracranial_volume_only: boolean = false,
    old_intracranial_volume_only: boolean = false,
    talairach_transform: InputPathType | null = null,
    xfm_to_etiv: string | null = null,
    euler_hole_count: boolean = false,
    avg_waveform: string | null = null,
    sum_waveform: string | null = null,
    avg_waveform_vol: string | null = null,
    remove_avgwf_mean: boolean = false,
    spatial_frame_avg: string | null = null,
    voxel_crs: string | null = null,
    replace_ids: string | null = null,
    replace_ids_file: InputPathType | null = null,
    gtm_default_seg_merge: boolean = false,
    gtm_default_seg_merge_choroid: boolean = false,
    qa_stats_file: string | null = null,
    subjects_dir: string | null = null,
    random_seed: number | null = null,
    runner: Runner | null = null,
): MriSegstatsOutputs {
    const params = mri_segstats_params(segvol, output_file, annot_subject, annot_hemisphere, annot_parcellation, slabel_subject, slabel_hemisphere, slabel_label, partial_vol_comp, input_volume, seg_erode, frame, robust, square_input, sqrt_input, multiply_input, divide_input, snr_column, absolute_value, accumulate_mean, color_table, default_color_table, gca_color_table, ids, exclude_ids, exclude_gm_wm, surf_wm_vol, surf_ctx_vol, no_global_stats, empty_segments, ctab_output, mask_volume, mask_threshold, mask_sign, mask_frame, invert_mask, mask_erode, brain_vol_seg, brain_mask_vol, subcortical_gray, total_gray, intracranial_volume, intracranial_volume_only, old_intracranial_volume_only, talairach_transform, xfm_to_etiv, euler_hole_count, avg_waveform, sum_waveform, avg_waveform_vol, remove_avgwf_mean, spatial_frame_avg, voxel_crs, replace_ids, replace_ids_file, gtm_default_seg_merge, gtm_default_seg_merge_choroid, qa_stats_file, subjects_dir, random_seed)
    return mri_segstats_execute(params, runner);
}


export {
      MRI_SEGSTATS_METADATA,
      MriSegstatsOutputs,
      mri_segstats,
      mri_segstats_execute,
      mri_segstats_params,
};
