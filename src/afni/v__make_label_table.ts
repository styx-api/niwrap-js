// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V__MAKE_LABEL_TABLE_METADATA: Metadata = {
    id: "287075a9705f1e3aa4609a67bab5671fa4e1d6b9.boutiques",
    name: "@MakeLabelTable",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface VMakeLabelTableParameters {
    "__STYXTYPE__": "@MakeLabelTable";
    "labeltable": string;
    "atlas_pointlist"?: string | null | undefined;
    "lab_r"?: Array<string> | null | undefined;
    "lab_v"?: Array<string> | null | undefined;
    "lab_file_delim"?: string | null | undefined;
    "lab_file"?: Array<string> | null | undefined;
    "dset"?: InputPathType | null | undefined;
    "longnames"?: number | null | undefined;
    "last_longname_col"?: number | null | undefined;
    "centers": boolean;
    "centertype"?: string | null | undefined;
    "centermask"?: string | null | undefined;
    "skip_novoxels": boolean;
    "all_labels": boolean;
    "all_keys": boolean;
    "lkeys"?: string | null | undefined;
    "rkeys"?: string | null | undefined;
    "klabel"?: string | null | undefined;
    "match_label"?: string | null | undefined;
    "labeltable_of_dset"?: InputPathType | null | undefined;
    "word_label_match": boolean;
    "quiet_death": boolean;
    "lt_to_atlas_pl"?: string | null | undefined;
    "dset_lt_to_atlas_pl"?: Array<InputPathType> | null | undefined;
    "lt_to_csv"?: InputPathType | null | undefined;
    "atlasize_labeled_dset"?: InputPathType | null | undefined;
    "atlas_file"?: string | null | undefined;
    "atlas_name"?: string | null | undefined;
    "atlas_description"?: string | null | undefined;
    "replace": boolean;
    "add_atlas_dset"?: InputPathType | null | undefined;
    "h_web": boolean;
    "h_view": boolean;
    "all_opts": boolean;
    "h_find"?: string | null | undefined;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "@MakeLabelTable": v__make_label_table_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "@MakeLabelTable": v__make_label_table_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `v__make_label_table(...)`.
 *
 * @interface
 */
interface VMakeLabelTableOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output label table file
     */
    output_labeltable: OutputPathType;
    /**
     * Output atlas point list file
     */
    output_atlas_pointlist: OutputPathType | null;
    /**
     * Output CSV file from label table
     */
    output_csv: OutputPathType | null;
    /**
     * Output NIML file after atlasizing labeled dataset
     */
    output_niml_atlas: OutputPathType | null;
}


function v__make_label_table_params(
    labeltable: string,
    atlas_pointlist: string | null = null,
    lab_r: Array<string> | null = null,
    lab_v: Array<string> | null = null,
    lab_file_delim: string | null = null,
    lab_file: Array<string> | null = null,
    dset: InputPathType | null = null,
    longnames: number | null = null,
    last_longname_col: number | null = null,
    centers: boolean = false,
    centertype: string | null = null,
    centermask: string | null = null,
    skip_novoxels: boolean = false,
    all_labels: boolean = false,
    all_keys: boolean = false,
    lkeys: string | null = null,
    rkeys: string | null = null,
    klabel: string | null = null,
    match_label: string | null = null,
    labeltable_of_dset: InputPathType | null = null,
    word_label_match: boolean = false,
    quiet_death: boolean = false,
    lt_to_atlas_pl: string | null = null,
    dset_lt_to_atlas_pl: Array<InputPathType> | null = null,
    lt_to_csv: InputPathType | null = null,
    atlasize_labeled_dset: InputPathType | null = null,
    atlas_file: string | null = null,
    atlas_name: string | null = null,
    atlas_description: string | null = null,
    replace: boolean = false,
    add_atlas_dset: InputPathType | null = null,
    h_web: boolean = false,
    h_view: boolean = false,
    all_opts: boolean = false,
    h_find: string | null = null,
): VMakeLabelTableParameters {
    /**
     * Build parameters.
    
     * @param labeltable Name of output label table
     * @param atlas_pointlist Instead of a label table, produce an atlas point list
     * @param lab_r Define a label with its minimum and maximum key values
     * @param lab_v Define a label and its value
     * @param lab_file_delim Set column delimiter for -lab_file option
     * @param lab_file Specify labels and keys from a text file
     * @param dset Attach the label table (or atlas point list) to dataset
     * @param longnames Allow for another column of long names for regions
     * @param last_longname_col Limit long names to nth column
     * @param centers Compute center of mass location for each ROI
     * @param centertype Different ways to compute centers (Icent, Dcent, cm)
     * @param centermask Calculate center of mass locations using a subset of voxels
     * @param skip_novoxels Skip regions without voxels
     * @param all_labels Return a listing of all labels
     * @param all_keys Return a listing of all keys
     * @param lkeys Return the keys whose labels match a given label
     * @param rkeys Return the range (min max) of keys whose labels match a given label
     * @param klabel Return the label associated with a given key
     * @param match_label Return labels matching a given label
     * @param labeltable_of_dset Dump the labeltable from a dataset
     * @param word_label_match Use word matching for labels
     * @param quiet_death Do not give error messages when failing
     * @param lt_to_atlas_pl Transform Label Table to Atlas Point List
     * @param dset_lt_to_atlas_pl Get Label Table in dataset and write as an Atlas Point List
     * @param lt_to_csv Transform Label Table to CSV format
     * @param atlasize_labeled_dset Transform a labeled ROI dataset into an atlas
     * @param atlas_file Specify the name of the NIML file where atlas attributes are stored
     * @param atlas_name Name of the Atlas
     * @param atlas_description Description of the Atlas, which appears in AFNI's whereami window
     * @param replace Replace existing Atlas if the name already exists in the NIML file
     * @param add_atlas_dset Add an existing atlas to an atlas file
     * @param h_web Open webpage with help for this program
     * @param h_view Open -help output in a GUI editor
     * @param all_opts List all of the options for this script
     * @param h_find Search for lines containing a specific word in the help output
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "@MakeLabelTable" as const,
        "labeltable": labeltable,
        "centers": centers,
        "skip_novoxels": skip_novoxels,
        "all_labels": all_labels,
        "all_keys": all_keys,
        "word_label_match": word_label_match,
        "quiet_death": quiet_death,
        "replace": replace,
        "h_web": h_web,
        "h_view": h_view,
        "all_opts": all_opts,
    };
    if (atlas_pointlist !== null) {
        params["atlas_pointlist"] = atlas_pointlist;
    }
    if (lab_r !== null) {
        params["lab_r"] = lab_r;
    }
    if (lab_v !== null) {
        params["lab_v"] = lab_v;
    }
    if (lab_file_delim !== null) {
        params["lab_file_delim"] = lab_file_delim;
    }
    if (lab_file !== null) {
        params["lab_file"] = lab_file;
    }
    if (dset !== null) {
        params["dset"] = dset;
    }
    if (longnames !== null) {
        params["longnames"] = longnames;
    }
    if (last_longname_col !== null) {
        params["last_longname_col"] = last_longname_col;
    }
    if (centertype !== null) {
        params["centertype"] = centertype;
    }
    if (centermask !== null) {
        params["centermask"] = centermask;
    }
    if (lkeys !== null) {
        params["lkeys"] = lkeys;
    }
    if (rkeys !== null) {
        params["rkeys"] = rkeys;
    }
    if (klabel !== null) {
        params["klabel"] = klabel;
    }
    if (match_label !== null) {
        params["match_label"] = match_label;
    }
    if (labeltable_of_dset !== null) {
        params["labeltable_of_dset"] = labeltable_of_dset;
    }
    if (lt_to_atlas_pl !== null) {
        params["lt_to_atlas_pl"] = lt_to_atlas_pl;
    }
    if (dset_lt_to_atlas_pl !== null) {
        params["dset_lt_to_atlas_pl"] = dset_lt_to_atlas_pl;
    }
    if (lt_to_csv !== null) {
        params["lt_to_csv"] = lt_to_csv;
    }
    if (atlasize_labeled_dset !== null) {
        params["atlasize_labeled_dset"] = atlasize_labeled_dset;
    }
    if (atlas_file !== null) {
        params["atlas_file"] = atlas_file;
    }
    if (atlas_name !== null) {
        params["atlas_name"] = atlas_name;
    }
    if (atlas_description !== null) {
        params["atlas_description"] = atlas_description;
    }
    if (add_atlas_dset !== null) {
        params["add_atlas_dset"] = add_atlas_dset;
    }
    if (h_find !== null) {
        params["h_find"] = h_find;
    }
    return params;
}


function v__make_label_table_cargs(
    params: VMakeLabelTableParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("@MakeLabelTable");
    cargs.push(
        "-labeltable",
        (params["labeltable"] ?? null)
    );
    if ((params["atlas_pointlist"] ?? null) !== null) {
        cargs.push(
            "-atlas_pointlist",
            (params["atlas_pointlist"] ?? null)
        );
    }
    if ((params["lab_r"] ?? null) !== null) {
        cargs.push(
            "-lab_r",
            ...(params["lab_r"] ?? null)
        );
    }
    if ((params["lab_v"] ?? null) !== null) {
        cargs.push(
            "-lab_v",
            ...(params["lab_v"] ?? null)
        );
    }
    if ((params["lab_file_delim"] ?? null) !== null) {
        cargs.push(
            "-lab_file_delim",
            (params["lab_file_delim"] ?? null)
        );
    }
    if ((params["lab_file"] ?? null) !== null) {
        cargs.push(
            "-lab_file",
            ...(params["lab_file"] ?? null)
        );
    }
    if ((params["dset"] ?? null) !== null) {
        cargs.push(
            "-dset",
            execution.inputFile((params["dset"] ?? null))
        );
    }
    if ((params["longnames"] ?? null) !== null) {
        cargs.push(
            "-longnames",
            String((params["longnames"] ?? null))
        );
    }
    if ((params["last_longname_col"] ?? null) !== null) {
        cargs.push(
            "-last_longname_col",
            String((params["last_longname_col"] ?? null))
        );
    }
    if ((params["centers"] ?? null)) {
        cargs.push("-centers");
    }
    if ((params["centertype"] ?? null) !== null) {
        cargs.push(
            "-centertype",
            (params["centertype"] ?? null)
        );
    }
    if ((params["centermask"] ?? null) !== null) {
        cargs.push(
            "-centermask",
            (params["centermask"] ?? null)
        );
    }
    if ((params["skip_novoxels"] ?? null)) {
        cargs.push("-skip_novoxels");
    }
    if ((params["all_labels"] ?? null)) {
        cargs.push("-all_labels");
    }
    if ((params["all_keys"] ?? null)) {
        cargs.push("-all_keys");
    }
    if ((params["lkeys"] ?? null) !== null) {
        cargs.push(
            "-lkeys",
            (params["lkeys"] ?? null)
        );
    }
    if ((params["rkeys"] ?? null) !== null) {
        cargs.push(
            "-rkeys",
            (params["rkeys"] ?? null)
        );
    }
    if ((params["klabel"] ?? null) !== null) {
        cargs.push(
            "-klabel",
            (params["klabel"] ?? null)
        );
    }
    if ((params["match_label"] ?? null) !== null) {
        cargs.push(
            "-match_label",
            (params["match_label"] ?? null)
        );
    }
    if ((params["labeltable_of_dset"] ?? null) !== null) {
        cargs.push(
            "-labeltable_of_dset",
            execution.inputFile((params["labeltable_of_dset"] ?? null))
        );
    }
    if ((params["word_label_match"] ?? null)) {
        cargs.push("-word_label_match");
    }
    if ((params["quiet_death"] ?? null)) {
        cargs.push("-quiet_death");
    }
    if ((params["lt_to_atlas_pl"] ?? null) !== null) {
        cargs.push(
            "-LT_to_atlas_PL",
            (params["lt_to_atlas_pl"] ?? null)
        );
    }
    if ((params["dset_lt_to_atlas_pl"] ?? null) !== null) {
        cargs.push(
            "-dset_LT_to_atlas_PL",
            ...(params["dset_lt_to_atlas_pl"] ?? null).map(f => execution.inputFile(f))
        );
    }
    if ((params["lt_to_csv"] ?? null) !== null) {
        cargs.push(
            "-LT_to_CSV",
            execution.inputFile((params["lt_to_csv"] ?? null))
        );
    }
    if ((params["atlasize_labeled_dset"] ?? null) !== null) {
        cargs.push(
            "-atlasize_labeled_dset",
            execution.inputFile((params["atlasize_labeled_dset"] ?? null))
        );
    }
    if ((params["atlas_file"] ?? null) !== null) {
        cargs.push(
            "-atlas_file",
            (params["atlas_file"] ?? null)
        );
    }
    if ((params["atlas_name"] ?? null) !== null) {
        cargs.push(
            "-atlas_name",
            (params["atlas_name"] ?? null)
        );
    }
    if ((params["atlas_description"] ?? null) !== null) {
        cargs.push(
            "-atlas_description",
            (params["atlas_description"] ?? null)
        );
    }
    if ((params["replace"] ?? null)) {
        cargs.push("-replace");
    }
    if ((params["add_atlas_dset"] ?? null) !== null) {
        cargs.push(
            "-add_atlas_dset",
            execution.inputFile((params["add_atlas_dset"] ?? null))
        );
    }
    if ((params["h_web"] ?? null)) {
        cargs.push("-h_web");
    }
    if ((params["h_view"] ?? null)) {
        cargs.push("-h_view");
    }
    if ((params["all_opts"] ?? null)) {
        cargs.push("-all_opts");
    }
    if ((params["h_find"] ?? null) !== null) {
        cargs.push(
            "-h_find",
            (params["h_find"] ?? null)
        );
    }
    return cargs;
}


function v__make_label_table_outputs(
    params: VMakeLabelTableParameters,
    execution: Execution,
): VMakeLabelTableOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: VMakeLabelTableOutputs = {
        root: execution.outputFile("."),
        output_labeltable: execution.outputFile([(params["labeltable"] ?? null), ".niml.lt"].join('')),
        output_atlas_pointlist: ((params["atlas_pointlist"] ?? null) !== null) ? execution.outputFile([(params["atlas_pointlist"] ?? null), ".niml.atlas"].join('')) : null,
        output_csv: ((params["lt_to_csv"] ?? null) !== null) ? execution.outputFile([path.basename((params["lt_to_csv"] ?? null)), ".csv"].join('')) : null,
        output_niml_atlas: ((params["atlasize_labeled_dset"] ?? null) !== null) ? execution.outputFile([path.basename((params["atlasize_labeled_dset"] ?? null)), ".niml"].join('')) : null,
    };
    return ret;
}


function v__make_label_table_execute(
    params: VMakeLabelTableParameters,
    execution: Execution,
): VMakeLabelTableOutputs {
    /**
     * Script used to create, modify, and transform label tables.
     * 
     * Author: AFNI Developers
     * 
     * URL: https://afni.nimh.nih.gov/
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `VMakeLabelTableOutputs`).
     */
    params = execution.params(params)
    const cargs = v__make_label_table_cargs(params, execution)
    const ret = v__make_label_table_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function v__make_label_table(
    labeltable: string,
    atlas_pointlist: string | null = null,
    lab_r: Array<string> | null = null,
    lab_v: Array<string> | null = null,
    lab_file_delim: string | null = null,
    lab_file: Array<string> | null = null,
    dset: InputPathType | null = null,
    longnames: number | null = null,
    last_longname_col: number | null = null,
    centers: boolean = false,
    centertype: string | null = null,
    centermask: string | null = null,
    skip_novoxels: boolean = false,
    all_labels: boolean = false,
    all_keys: boolean = false,
    lkeys: string | null = null,
    rkeys: string | null = null,
    klabel: string | null = null,
    match_label: string | null = null,
    labeltable_of_dset: InputPathType | null = null,
    word_label_match: boolean = false,
    quiet_death: boolean = false,
    lt_to_atlas_pl: string | null = null,
    dset_lt_to_atlas_pl: Array<InputPathType> | null = null,
    lt_to_csv: InputPathType | null = null,
    atlasize_labeled_dset: InputPathType | null = null,
    atlas_file: string | null = null,
    atlas_name: string | null = null,
    atlas_description: string | null = null,
    replace: boolean = false,
    add_atlas_dset: InputPathType | null = null,
    h_web: boolean = false,
    h_view: boolean = false,
    all_opts: boolean = false,
    h_find: string | null = null,
    runner: Runner | null = null,
): VMakeLabelTableOutputs {
    /**
     * Script used to create, modify, and transform label tables.
     * 
     * Author: AFNI Developers
     * 
     * URL: https://afni.nimh.nih.gov/
    
     * @param labeltable Name of output label table
     * @param atlas_pointlist Instead of a label table, produce an atlas point list
     * @param lab_r Define a label with its minimum and maximum key values
     * @param lab_v Define a label and its value
     * @param lab_file_delim Set column delimiter for -lab_file option
     * @param lab_file Specify labels and keys from a text file
     * @param dset Attach the label table (or atlas point list) to dataset
     * @param longnames Allow for another column of long names for regions
     * @param last_longname_col Limit long names to nth column
     * @param centers Compute center of mass location for each ROI
     * @param centertype Different ways to compute centers (Icent, Dcent, cm)
     * @param centermask Calculate center of mass locations using a subset of voxels
     * @param skip_novoxels Skip regions without voxels
     * @param all_labels Return a listing of all labels
     * @param all_keys Return a listing of all keys
     * @param lkeys Return the keys whose labels match a given label
     * @param rkeys Return the range (min max) of keys whose labels match a given label
     * @param klabel Return the label associated with a given key
     * @param match_label Return labels matching a given label
     * @param labeltable_of_dset Dump the labeltable from a dataset
     * @param word_label_match Use word matching for labels
     * @param quiet_death Do not give error messages when failing
     * @param lt_to_atlas_pl Transform Label Table to Atlas Point List
     * @param dset_lt_to_atlas_pl Get Label Table in dataset and write as an Atlas Point List
     * @param lt_to_csv Transform Label Table to CSV format
     * @param atlasize_labeled_dset Transform a labeled ROI dataset into an atlas
     * @param atlas_file Specify the name of the NIML file where atlas attributes are stored
     * @param atlas_name Name of the Atlas
     * @param atlas_description Description of the Atlas, which appears in AFNI's whereami window
     * @param replace Replace existing Atlas if the name already exists in the NIML file
     * @param add_atlas_dset Add an existing atlas to an atlas file
     * @param h_web Open webpage with help for this program
     * @param h_view Open -help output in a GUI editor
     * @param all_opts List all of the options for this script
     * @param h_find Search for lines containing a specific word in the help output
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `VMakeLabelTableOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V__MAKE_LABEL_TABLE_METADATA);
    const params = v__make_label_table_params(labeltable, atlas_pointlist, lab_r, lab_v, lab_file_delim, lab_file, dset, longnames, last_longname_col, centers, centertype, centermask, skip_novoxels, all_labels, all_keys, lkeys, rkeys, klabel, match_label, labeltable_of_dset, word_label_match, quiet_death, lt_to_atlas_pl, dset_lt_to_atlas_pl, lt_to_csv, atlasize_labeled_dset, atlas_file, atlas_name, atlas_description, replace, add_atlas_dset, h_web, h_view, all_opts, h_find)
    return v__make_label_table_execute(params, execution);
}


export {
      VMakeLabelTableOutputs,
      VMakeLabelTableParameters,
      V__MAKE_LABEL_TABLE_METADATA,
      v__make_label_table,
      v__make_label_table_params,
};
