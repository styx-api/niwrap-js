// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const REG_RESAMPLE_METADATA: Metadata = {
    id: "2ccb8532ef070b252ef142cb969c94469f490a69.boutiques",
    name: "reg_resample",
    package: "niftyreg",
    container_image_tag: "vnmd/niftyreg_1.4.0:20220819",
};


interface RegResampleParameters {
    "__STYXTYPE__": "reg_resample";
    "reference_image": InputPathType;
    "floating_image": InputPathType;
    "affine_transform"?: InputPathType | null | undefined;
    "flirt_affine_transform"?: InputPathType | null | undefined;
    "control_point_grid"?: InputPathType | null | undefined;
    "deformation_field"?: InputPathType | null | undefined;
    "resampled_image"?: string | null | undefined;
    "resampled_blank"?: string | null | undefined;
    "nearest_neighbor": boolean;
    "linear_interpolation": boolean;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "reg_resample": reg_resample_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "reg_resample": reg_resample_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `reg_resample(...)`.
 *
 * @interface
 */
interface RegResampleOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * File containing the resampled image
     */
    output_resampled_image: OutputPathType | null;
    /**
     * File containing the resampled blank grid
     */
    output_resampled_blank: OutputPathType | null;
}


function reg_resample_params(
    reference_image: InputPathType,
    floating_image: InputPathType,
    affine_transform: InputPathType | null = null,
    flirt_affine_transform: InputPathType | null = null,
    control_point_grid: InputPathType | null = null,
    deformation_field: InputPathType | null = null,
    resampled_image: string | null = null,
    resampled_blank: string | null = null,
    nearest_neighbor: boolean = false,
    linear_interpolation: boolean = false,
): RegResampleParameters {
    /**
     * Build parameters.
    
     * @param reference_image Filename of the reference image
     * @param floating_image Filename of the floating image
     * @param affine_transform Filename which contains an affine transformation (Affine*Reference=Floating)
     * @param flirt_affine_transform Filename which contains a radiological flirt affine transformation
     * @param control_point_grid Filename of the control point grid image (from reg_f3d)
     * @param deformation_field Filename of the deformation field image (from reg_transform)
     * @param resampled_image Filename of the resampled image
     * @param resampled_blank Filename of the resampled blank grid
     * @param nearest_neighbor Use a Nearest Neighbor interpolation for the source resampling (cubic spline by default)
     * @param linear_interpolation Use a Linear interpolation for the source resampling (cubic spline by default)
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "reg_resample" as const,
        "reference_image": reference_image,
        "floating_image": floating_image,
        "nearest_neighbor": nearest_neighbor,
        "linear_interpolation": linear_interpolation,
    };
    if (affine_transform !== null) {
        params["affine_transform"] = affine_transform;
    }
    if (flirt_affine_transform !== null) {
        params["flirt_affine_transform"] = flirt_affine_transform;
    }
    if (control_point_grid !== null) {
        params["control_point_grid"] = control_point_grid;
    }
    if (deformation_field !== null) {
        params["deformation_field"] = deformation_field;
    }
    if (resampled_image !== null) {
        params["resampled_image"] = resampled_image;
    }
    if (resampled_blank !== null) {
        params["resampled_blank"] = resampled_blank;
    }
    return params;
}


function reg_resample_cargs(
    params: RegResampleParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("reg_resample");
    cargs.push(
        "-ref",
        execution.inputFile((params["reference_image"] ?? null))
    );
    cargs.push(
        "-flo",
        execution.inputFile((params["floating_image"] ?? null))
    );
    if ((params["affine_transform"] ?? null) !== null) {
        cargs.push(
            "-aff",
            execution.inputFile((params["affine_transform"] ?? null))
        );
    }
    if ((params["flirt_affine_transform"] ?? null) !== null) {
        cargs.push(
            "-affFlirt",
            execution.inputFile((params["flirt_affine_transform"] ?? null))
        );
    }
    if ((params["control_point_grid"] ?? null) !== null) {
        cargs.push(
            "-cpp",
            execution.inputFile((params["control_point_grid"] ?? null))
        );
    }
    if ((params["deformation_field"] ?? null) !== null) {
        cargs.push(
            "-def",
            execution.inputFile((params["deformation_field"] ?? null))
        );
    }
    if ((params["resampled_image"] ?? null) !== null) {
        cargs.push(
            "-res",
            (params["resampled_image"] ?? null)
        );
    }
    if ((params["resampled_blank"] ?? null) !== null) {
        cargs.push(
            "-blank",
            (params["resampled_blank"] ?? null)
        );
    }
    if ((params["nearest_neighbor"] ?? null)) {
        cargs.push("-NN");
    }
    if ((params["linear_interpolation"] ?? null)) {
        cargs.push("-LIN");
    }
    return cargs;
}


function reg_resample_outputs(
    params: RegResampleParameters,
    execution: Execution,
): RegResampleOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: RegResampleOutputs = {
        root: execution.outputFile("."),
        output_resampled_image: ((params["resampled_image"] ?? null) !== null) ? execution.outputFile([(params["resampled_image"] ?? null)].join('')) : null,
        output_resampled_blank: ((params["resampled_blank"] ?? null) !== null) ? execution.outputFile([(params["resampled_blank"] ?? null)].join('')) : null,
    };
    return ret;
}


function reg_resample_execute(
    params: RegResampleParameters,
    execution: Execution,
): RegResampleOutputs {
    /**
     * Tool for resampling floating images to the reference image space using different transformations.
     * 
     * Author: NiftyReg Developers
     * 
     * URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `RegResampleOutputs`).
     */
    params = execution.params(params)
    const cargs = reg_resample_cargs(params, execution)
    const ret = reg_resample_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function reg_resample(
    reference_image: InputPathType,
    floating_image: InputPathType,
    affine_transform: InputPathType | null = null,
    flirt_affine_transform: InputPathType | null = null,
    control_point_grid: InputPathType | null = null,
    deformation_field: InputPathType | null = null,
    resampled_image: string | null = null,
    resampled_blank: string | null = null,
    nearest_neighbor: boolean = false,
    linear_interpolation: boolean = false,
    runner: Runner | null = null,
): RegResampleOutputs {
    /**
     * Tool for resampling floating images to the reference image space using different transformations.
     * 
     * Author: NiftyReg Developers
     * 
     * URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
    
     * @param reference_image Filename of the reference image
     * @param floating_image Filename of the floating image
     * @param affine_transform Filename which contains an affine transformation (Affine*Reference=Floating)
     * @param flirt_affine_transform Filename which contains a radiological flirt affine transformation
     * @param control_point_grid Filename of the control point grid image (from reg_f3d)
     * @param deformation_field Filename of the deformation field image (from reg_transform)
     * @param resampled_image Filename of the resampled image
     * @param resampled_blank Filename of the resampled blank grid
     * @param nearest_neighbor Use a Nearest Neighbor interpolation for the source resampling (cubic spline by default)
     * @param linear_interpolation Use a Linear interpolation for the source resampling (cubic spline by default)
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `RegResampleOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(REG_RESAMPLE_METADATA);
    const params = reg_resample_params(reference_image, floating_image, affine_transform, flirt_affine_transform, control_point_grid, deformation_field, resampled_image, resampled_blank, nearest_neighbor, linear_interpolation)
    return reg_resample_execute(params, execution);
}


export {
      REG_RESAMPLE_METADATA,
      RegResampleOutputs,
      RegResampleParameters,
      reg_resample,
      reg_resample_params,
};
