// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRI_VOL2VOL_METADATA: Metadata = {
    id: "df2a9ac6d2e2ad5c34a591a24f332e429c95ce0c.boutiques",
    name: "mri_vol2vol",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface MriVol2volParameters {
    "@type"?: "freesurfer/mri_vol2vol";
    "movvol": InputPathType;
    "targvol": InputPathType;
    "outvol": InputPathType;
    "dispvol"?: InputPathType | null | undefined;
    "downsample"?: Array<number> | null | undefined;
    "register_dat"?: InputPathType | null | undefined;
    "lta"?: InputPathType | null | undefined;
    "lta_inv"?: InputPathType | null | undefined;
    "fsl"?: InputPathType | null | undefined;
    "xfm"?: InputPathType | null | undefined;
    "inv": boolean;
    "tal": boolean;
    "talres"?: number | null | undefined;
    "talxfm"?: InputPathType | null | undefined;
    "m3z"?: InputPathType | null | undefined;
    "inv_morph": boolean;
    "fstarg"?: string | null | undefined;
    "crop"?: number | null | undefined;
    "slice_crop"?: Array<number> | null | undefined;
    "slice_reverse": boolean;
    "slice_bias"?: number | null | undefined;
    "interp"?: string | null | undefined;
    "fill_average": boolean;
    "fill_conserve": boolean;
    "fill_up"?: number | null | undefined;
    "mul"?: number | null | undefined;
    "precision"?: string | null | undefined;
    "keep_precision": boolean;
    "kernel": boolean;
    "copy_ctab": boolean;
    "gcam"?: string | null | undefined;
    "spm_warp"?: string | null | undefined;
    "map_point"?: string | null | undefined;
    "map_point_inv_lta"?: string | null | undefined;
    "no_resample": boolean;
    "rot"?: Array<number> | null | undefined;
    "trans"?: Array<number> | null | undefined;
    "shear"?: Array<number> | null | undefined;
    "reg_final"?: InputPathType | null | undefined;
    "synth": boolean;
    "seed"?: number | null | undefined;
    "save_reg": boolean;
    "debug": boolean;
    "version": boolean;
}
type MriVol2volParametersTagged = Required<Pick<MriVol2volParameters, '@type'>> & MriVol2volParameters;


/**
 * Output object returned when calling `MriVol2volParameters(...)`.
 *
 * @interface
 */
interface MriVol2volOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Resampled output volume.
     */
    output_volume: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param movvol Input volume (or output template with --inv)
 * @param targvol Output template (or input with --inv)
 * @param outvol Output volume
 * @param dispvol Displacement volume
 * @param downsample Downsample factor (e.g., 2) (do not include a targ or registration)
 * @param register_dat tkRAS-to-tkRAS matrix (tkregister2 format)
 * @param lta Linear Transform Array (usually only 1 transform)
 * @param lta_inv LTA, invert (may not be the same as --lta --inv with --fstal)
 * @param fsl fslRAS-to-fslRAS matrix (FSL format)
 * @param xfm ScannerRAS-to-ScannerRAS matrix (MNI format)
 * @param inv Sample from targ to mov
 * @param tal Map to a sub FOV of MNI305 (with --reg only)
 * @param talres Set voxel size 1mm or 2mm (default is 1)
 * @param talxfm Path to the talairach transformation file. Default is talairach.xfm (looks in mri/transforms)
 * @param m3z Non-linear morph encoded in the m3z format
 * @param inv_morph Compute and use the inverse of the m3z morph
 * @param fstarg Optionally use the specified volume from the subject in --reg as target. Default is orig.mgz
 * @param crop Crop and change voxel size
 * @param slice_crop Crop output slices to be within specified start and end indices
 * @param slice_reverse Reverse order of slices, update vox2ras
 * @param slice_bias Apply half-cosine bias field
 * @param interp Interpolation method: cubic, trilin, or nearest (default is trilin)
 * @param fill_average Compute mean of all source voxels in a given target voxel
 * @param fill_conserve Compute sum of all source voxels in a given target voxel
 * @param fill_up Source upsampling factor for --fill-{avg,cons} (default is 2)
 * @param mul Multiply output by the specified value
 * @param precision Output precision (default is float)
 * @param keep_precision Set output precision to that of the input
 * @param kernel Save the trilinear interpolation kernel at each voxel instead of the interpolated image
 * @param copy_ctab Setenv FS_COPY_HEADER_CTAB to copy any ctab in the mov header
 * @param gcam GCAM warp procedure
 * @param spm_warp SPM warp procedure
 * @param map_point Standalone option to map a point to another space
 * @param map_point_inv_lta Same as --map-point but inverts the LTA
 * @param no_resample Do not resample, just change vox2ras matrix
 * @param rot Rotation angles (degrees) to apply to registration matrix
 * @param trans Translation (mm) to apply to registration matrix
 * @param shear Shearing factors. Sxy Sxz Syz with xz as in-plane
 * @param reg_final Final registration matrix after rotation and translation (but not inversion)
 * @param synth Replace input with white Gaussian noise
 * @param seed Seed for synth (default is to set from time of day)
 * @param save_reg Write out output volume registration matrix
 * @param debug Turn on debugging output
 * @param version Print out version string and exit
 *
 * @returns Parameter dictionary
 */
function mri_vol2vol_params(
    movvol: InputPathType,
    targvol: InputPathType,
    outvol: InputPathType,
    dispvol: InputPathType | null = null,
    downsample: Array<number> | null = null,
    register_dat: InputPathType | null = null,
    lta: InputPathType | null = null,
    lta_inv: InputPathType | null = null,
    fsl: InputPathType | null = null,
    xfm: InputPathType | null = null,
    inv: boolean = false,
    tal: boolean = false,
    talres: number | null = null,
    talxfm: InputPathType | null = null,
    m3z: InputPathType | null = null,
    inv_morph: boolean = false,
    fstarg: string | null = null,
    crop: number | null = null,
    slice_crop: Array<number> | null = null,
    slice_reverse: boolean = false,
    slice_bias: number | null = null,
    interp: string | null = null,
    fill_average: boolean = false,
    fill_conserve: boolean = false,
    fill_up: number | null = null,
    mul: number | null = null,
    precision: string | null = null,
    keep_precision: boolean = false,
    kernel: boolean = false,
    copy_ctab: boolean = false,
    gcam: string | null = null,
    spm_warp: string | null = null,
    map_point: string | null = null,
    map_point_inv_lta: string | null = null,
    no_resample: boolean = false,
    rot: Array<number> | null = null,
    trans: Array<number> | null = null,
    shear: Array<number> | null = null,
    reg_final: InputPathType | null = null,
    synth: boolean = false,
    seed: number | null = null,
    save_reg: boolean = false,
    debug: boolean = false,
    version: boolean = false,
): MriVol2volParametersTagged {
    const params = {
        "@type": "freesurfer/mri_vol2vol" as const,
        "movvol": movvol,
        "targvol": targvol,
        "outvol": outvol,
        "inv": inv,
        "tal": tal,
        "inv_morph": inv_morph,
        "slice_reverse": slice_reverse,
        "fill_average": fill_average,
        "fill_conserve": fill_conserve,
        "keep_precision": keep_precision,
        "kernel": kernel,
        "copy_ctab": copy_ctab,
        "no_resample": no_resample,
        "synth": synth,
        "save_reg": save_reg,
        "debug": debug,
        "version": version,
    };
    if (dispvol !== null) {
        params["dispvol"] = dispvol;
    }
    if (downsample !== null) {
        params["downsample"] = downsample;
    }
    if (register_dat !== null) {
        params["register_dat"] = register_dat;
    }
    if (lta !== null) {
        params["lta"] = lta;
    }
    if (lta_inv !== null) {
        params["lta_inv"] = lta_inv;
    }
    if (fsl !== null) {
        params["fsl"] = fsl;
    }
    if (xfm !== null) {
        params["xfm"] = xfm;
    }
    if (talres !== null) {
        params["talres"] = talres;
    }
    if (talxfm !== null) {
        params["talxfm"] = talxfm;
    }
    if (m3z !== null) {
        params["m3z"] = m3z;
    }
    if (fstarg !== null) {
        params["fstarg"] = fstarg;
    }
    if (crop !== null) {
        params["crop"] = crop;
    }
    if (slice_crop !== null) {
        params["slice_crop"] = slice_crop;
    }
    if (slice_bias !== null) {
        params["slice_bias"] = slice_bias;
    }
    if (interp !== null) {
        params["interp"] = interp;
    }
    if (fill_up !== null) {
        params["fill_up"] = fill_up;
    }
    if (mul !== null) {
        params["mul"] = mul;
    }
    if (precision !== null) {
        params["precision"] = precision;
    }
    if (gcam !== null) {
        params["gcam"] = gcam;
    }
    if (spm_warp !== null) {
        params["spm_warp"] = spm_warp;
    }
    if (map_point !== null) {
        params["map_point"] = map_point;
    }
    if (map_point_inv_lta !== null) {
        params["map_point_inv_lta"] = map_point_inv_lta;
    }
    if (rot !== null) {
        params["rot"] = rot;
    }
    if (trans !== null) {
        params["trans"] = trans;
    }
    if (shear !== null) {
        params["shear"] = shear;
    }
    if (reg_final !== null) {
        params["reg_final"] = reg_final;
    }
    if (seed !== null) {
        params["seed"] = seed;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mri_vol2vol_cargs(
    params: MriVol2volParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mri_vol2vol");
    cargs.push(execution.inputFile((params["movvol"] ?? null)));
    cargs.push(execution.inputFile((params["targvol"] ?? null)));
    cargs.push(execution.inputFile((params["outvol"] ?? null)));
    if ((params["dispvol"] ?? null) !== null) {
        cargs.push(
            "--disp",
            execution.inputFile((params["dispvol"] ?? null))
        );
    }
    if ((params["downsample"] ?? null) !== null) {
        cargs.push(
            "--downsample",
            ...(params["downsample"] ?? null).map(String)
        );
    }
    if ((params["register_dat"] ?? null) !== null) {
        cargs.push(
            "--reg",
            execution.inputFile((params["register_dat"] ?? null))
        );
    }
    if ((params["lta"] ?? null) !== null) {
        cargs.push(
            "--lta",
            execution.inputFile((params["lta"] ?? null))
        );
    }
    if ((params["lta_inv"] ?? null) !== null) {
        cargs.push(
            "--lta-inv",
            execution.inputFile((params["lta_inv"] ?? null))
        );
    }
    if ((params["fsl"] ?? null) !== null) {
        cargs.push(
            "--fsl",
            execution.inputFile((params["fsl"] ?? null))
        );
    }
    if ((params["xfm"] ?? null) !== null) {
        cargs.push(
            "--xfm",
            execution.inputFile((params["xfm"] ?? null))
        );
    }
    if ((params["inv"] ?? false)) {
        cargs.push("--inv");
    }
    if ((params["tal"] ?? false)) {
        cargs.push("--tal");
    }
    if ((params["talres"] ?? null) !== null) {
        cargs.push(
            "--talres",
            String((params["talres"] ?? null))
        );
    }
    if ((params["talxfm"] ?? null) !== null) {
        cargs.push(
            "--talxfm",
            execution.inputFile((params["talxfm"] ?? null))
        );
    }
    if ((params["m3z"] ?? null) !== null) {
        cargs.push(
            "--m3z",
            execution.inputFile((params["m3z"] ?? null))
        );
    }
    if ((params["inv_morph"] ?? false)) {
        cargs.push("--inv-morph");
    }
    if ((params["fstarg"] ?? null) !== null) {
        cargs.push(
            "--fstarg",
            (params["fstarg"] ?? null)
        );
    }
    if ((params["crop"] ?? null) !== null) {
        cargs.push(
            "--crop",
            String((params["crop"] ?? null))
        );
    }
    if ((params["slice_crop"] ?? null) !== null) {
        cargs.push(
            "--slice-crop",
            ...(params["slice_crop"] ?? null).map(String)
        );
    }
    if ((params["slice_reverse"] ?? false)) {
        cargs.push("--slice-reverse");
    }
    if ((params["slice_bias"] ?? null) !== null) {
        cargs.push(
            "--slice-bias",
            String((params["slice_bias"] ?? null))
        );
    }
    if ((params["interp"] ?? null) !== null) {
        cargs.push(
            "--interp",
            (params["interp"] ?? null)
        );
    }
    if ((params["fill_average"] ?? false)) {
        cargs.push("--fill-average");
    }
    if ((params["fill_conserve"] ?? false)) {
        cargs.push("--fill-conserve");
    }
    if ((params["fill_up"] ?? null) !== null) {
        cargs.push(
            "--fill-upsample",
            String((params["fill_up"] ?? null))
        );
    }
    if ((params["mul"] ?? null) !== null) {
        cargs.push(
            "--mul",
            String((params["mul"] ?? null))
        );
    }
    if ((params["precision"] ?? null) !== null) {
        cargs.push(
            "--precision",
            (params["precision"] ?? null)
        );
    }
    if ((params["keep_precision"] ?? false)) {
        cargs.push("--keep-precision");
    }
    if ((params["kernel"] ?? false)) {
        cargs.push("--kernel");
    }
    if ((params["copy_ctab"] ?? false)) {
        cargs.push("--copy-ctab");
    }
    if ((params["gcam"] ?? null) !== null) {
        cargs.push(
            "--gcam",
            (params["gcam"] ?? null)
        );
    }
    if ((params["spm_warp"] ?? null) !== null) {
        cargs.push(
            "--spm-warp",
            (params["spm_warp"] ?? null)
        );
    }
    if ((params["map_point"] ?? null) !== null) {
        cargs.push(
            "--map-point",
            (params["map_point"] ?? null)
        );
    }
    if ((params["map_point_inv_lta"] ?? null) !== null) {
        cargs.push(
            "--map-point-inv-lta",
            (params["map_point_inv_lta"] ?? null)
        );
    }
    if ((params["no_resample"] ?? false)) {
        cargs.push("--no-resample");
    }
    if ((params["rot"] ?? null) !== null) {
        cargs.push(
            "--rot",
            ...(params["rot"] ?? null).map(String)
        );
    }
    if ((params["trans"] ?? null) !== null) {
        cargs.push(
            "--trans",
            ...(params["trans"] ?? null).map(String)
        );
    }
    if ((params["shear"] ?? null) !== null) {
        cargs.push(
            "--shear",
            ...(params["shear"] ?? null).map(String)
        );
    }
    if ((params["reg_final"] ?? null) !== null) {
        cargs.push(
            "--reg-final",
            execution.inputFile((params["reg_final"] ?? null))
        );
    }
    if ((params["synth"] ?? false)) {
        cargs.push("--synth");
    }
    if ((params["seed"] ?? null) !== null) {
        cargs.push(
            "--seed",
            String((params["seed"] ?? null))
        );
    }
    if ((params["save_reg"] ?? false)) {
        cargs.push("--save-reg");
    }
    if ((params["debug"] ?? false)) {
        cargs.push("--debug");
    }
    if ((params["version"] ?? false)) {
        cargs.push("--version");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mri_vol2vol_outputs(
    params: MriVol2volParameters,
    execution: Execution,
): MriVol2volOutputs {
    const ret: MriVol2volOutputs = {
        root: execution.outputFile("."),
        output_volume: execution.outputFile([path.basename((params["outvol"] ?? null))].join('')),
    };
    return ret;
}


/**
 * mri_vol2vol
 *
 * Resamples a volume into another field-of-view using various types of matrices (FreeSurfer, FSL, SPM, and MNI).
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MriVol2volOutputs`).
 */
function mri_vol2vol_execute(
    params: MriVol2volParameters,
    runner: Runner | null = null,
): MriVol2volOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRI_VOL2VOL_METADATA);
    params = execution.params(params)
    const cargs = mri_vol2vol_cargs(params, execution)
    const ret = mri_vol2vol_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * mri_vol2vol
 *
 * Resamples a volume into another field-of-view using various types of matrices (FreeSurfer, FSL, SPM, and MNI).
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param movvol Input volume (or output template with --inv)
 * @param targvol Output template (or input with --inv)
 * @param outvol Output volume
 * @param dispvol Displacement volume
 * @param downsample Downsample factor (e.g., 2) (do not include a targ or registration)
 * @param register_dat tkRAS-to-tkRAS matrix (tkregister2 format)
 * @param lta Linear Transform Array (usually only 1 transform)
 * @param lta_inv LTA, invert (may not be the same as --lta --inv with --fstal)
 * @param fsl fslRAS-to-fslRAS matrix (FSL format)
 * @param xfm ScannerRAS-to-ScannerRAS matrix (MNI format)
 * @param inv Sample from targ to mov
 * @param tal Map to a sub FOV of MNI305 (with --reg only)
 * @param talres Set voxel size 1mm or 2mm (default is 1)
 * @param talxfm Path to the talairach transformation file. Default is talairach.xfm (looks in mri/transforms)
 * @param m3z Non-linear morph encoded in the m3z format
 * @param inv_morph Compute and use the inverse of the m3z morph
 * @param fstarg Optionally use the specified volume from the subject in --reg as target. Default is orig.mgz
 * @param crop Crop and change voxel size
 * @param slice_crop Crop output slices to be within specified start and end indices
 * @param slice_reverse Reverse order of slices, update vox2ras
 * @param slice_bias Apply half-cosine bias field
 * @param interp Interpolation method: cubic, trilin, or nearest (default is trilin)
 * @param fill_average Compute mean of all source voxels in a given target voxel
 * @param fill_conserve Compute sum of all source voxels in a given target voxel
 * @param fill_up Source upsampling factor for --fill-{avg,cons} (default is 2)
 * @param mul Multiply output by the specified value
 * @param precision Output precision (default is float)
 * @param keep_precision Set output precision to that of the input
 * @param kernel Save the trilinear interpolation kernel at each voxel instead of the interpolated image
 * @param copy_ctab Setenv FS_COPY_HEADER_CTAB to copy any ctab in the mov header
 * @param gcam GCAM warp procedure
 * @param spm_warp SPM warp procedure
 * @param map_point Standalone option to map a point to another space
 * @param map_point_inv_lta Same as --map-point but inverts the LTA
 * @param no_resample Do not resample, just change vox2ras matrix
 * @param rot Rotation angles (degrees) to apply to registration matrix
 * @param trans Translation (mm) to apply to registration matrix
 * @param shear Shearing factors. Sxy Sxz Syz with xz as in-plane
 * @param reg_final Final registration matrix after rotation and translation (but not inversion)
 * @param synth Replace input with white Gaussian noise
 * @param seed Seed for synth (default is to set from time of day)
 * @param save_reg Write out output volume registration matrix
 * @param debug Turn on debugging output
 * @param version Print out version string and exit
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MriVol2volOutputs`).
 */
function mri_vol2vol(
    movvol: InputPathType,
    targvol: InputPathType,
    outvol: InputPathType,
    dispvol: InputPathType | null = null,
    downsample: Array<number> | null = null,
    register_dat: InputPathType | null = null,
    lta: InputPathType | null = null,
    lta_inv: InputPathType | null = null,
    fsl: InputPathType | null = null,
    xfm: InputPathType | null = null,
    inv: boolean = false,
    tal: boolean = false,
    talres: number | null = null,
    talxfm: InputPathType | null = null,
    m3z: InputPathType | null = null,
    inv_morph: boolean = false,
    fstarg: string | null = null,
    crop: number | null = null,
    slice_crop: Array<number> | null = null,
    slice_reverse: boolean = false,
    slice_bias: number | null = null,
    interp: string | null = null,
    fill_average: boolean = false,
    fill_conserve: boolean = false,
    fill_up: number | null = null,
    mul: number | null = null,
    precision: string | null = null,
    keep_precision: boolean = false,
    kernel: boolean = false,
    copy_ctab: boolean = false,
    gcam: string | null = null,
    spm_warp: string | null = null,
    map_point: string | null = null,
    map_point_inv_lta: string | null = null,
    no_resample: boolean = false,
    rot: Array<number> | null = null,
    trans: Array<number> | null = null,
    shear: Array<number> | null = null,
    reg_final: InputPathType | null = null,
    synth: boolean = false,
    seed: number | null = null,
    save_reg: boolean = false,
    debug: boolean = false,
    version: boolean = false,
    runner: Runner | null = null,
): MriVol2volOutputs {
    const params = mri_vol2vol_params(movvol, targvol, outvol, dispvol, downsample, register_dat, lta, lta_inv, fsl, xfm, inv, tal, talres, talxfm, m3z, inv_morph, fstarg, crop, slice_crop, slice_reverse, slice_bias, interp, fill_average, fill_conserve, fill_up, mul, precision, keep_precision, kernel, copy_ctab, gcam, spm_warp, map_point, map_point_inv_lta, no_resample, rot, trans, shear, reg_final, synth, seed, save_reg, debug, version)
    return mri_vol2vol_execute(params, runner);
}


export {
      MRI_VOL2VOL_METADATA,
      MriVol2volOutputs,
      mri_vol2vol,
      mri_vol2vol_execute,
      mri_vol2vol_params,
};
