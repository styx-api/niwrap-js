// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const QBOOT_METADATA: Metadata = {
    id: "0cf193296c9ce8e8e9a825681ecddad1366ae2e7.boutiques",
    name: "qboot",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface QbootParameters {
    "@type"?: "fsl/qboot";
    "data_file": InputPathType;
    "mask_file": InputPathType;
    "bvecs_file": InputPathType;
    "bvals_file": InputPathType;
    "log_dir"?: string | null | undefined;
    "forcedir_flag": boolean;
    "q_file"?: InputPathType | null | undefined;
    "model_type"?: number | null | undefined;
    "lmax_order"?: number | null | undefined;
    "npeaks"?: number | null | undefined;
    "threshold"?: number | null | undefined;
    "num_samples"?: number | null | undefined;
    "lambda_param"?: number | null | undefined;
    "delta_param"?: number | null | undefined;
    "alpha_param"?: number | null | undefined;
    "seed_param"?: number | null | undefined;
    "gfa_flag": boolean;
    "savecoeff_flag": boolean;
    "savemeancoeff_flag": boolean;
    "verbose_flag": boolean;
    "help_flag": boolean;
}
type QbootParametersTagged = Required<Pick<QbootParameters, '@type'>> & QbootParameters;


/**
 * Output object returned when calling `QbootParameters(...)`.
 *
 * @interface
 */
interface QbootOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Specified log directory with saved output files.
     */
    log_directory: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param data_file Data file
 * @param mask_file Mask file
 * @param bvecs_file b vectors file
 * @param bvals_file b values file
 * @param log_dir Output directory (default is logdir)
 * @param forcedir_flag Use the actual directory name given - i.e. don't add + to make a new directory
 * @param q_file File provided with multi-shell data. Indicates the number of directions for each shell
 * @param model_type Which model to use. 1=Tuch's ODFs, 2=CSA ODFs (default), 3=multi-shell CSA ODFs
 * @param lmax_order Maximum spherical harmonic order employed (must be even, default=4)
 * @param npeaks Maximum number of ODF peaks to be detected (default 2)
 * @param threshold Minimum threshold for a local maxima to be considered an ODF peak. Expressed as a fraction of the maximum ODF value (default 0.4)
 * @param num_samples Number of bootstrap samples (default is 50)
 * @param lambda_param Laplace-Beltrami regularization parameter (default is 0)
 * @param delta_param Signal attenuation regularization parameter for models=2,3 (default is 0.01)
 * @param alpha_param Laplacian sharpening parameter for model=1 (default is 0, should be smaller than 1)
 * @param seed_param Seed for pseudo-random number generator
 * @param gfa_flag Compute a generalised FA, using the mean ODF in each voxel
 * @param savecoeff_flag Save the ODF coefficients instead of the peaks. WARNING: These can be huge files, please use a few bootstrap samples and a low lmax!
 * @param savemeancoeff_flag Save the mean ODF coefficients across all samples
 * @param verbose_flag Switch on diagnostic messages
 * @param help_flag Display this help message
 *
 * @returns Parameter dictionary
 */
function qboot_params(
    data_file: InputPathType,
    mask_file: InputPathType,
    bvecs_file: InputPathType,
    bvals_file: InputPathType,
    log_dir: string | null = null,
    forcedir_flag: boolean = false,
    q_file: InputPathType | null = null,
    model_type: number | null = null,
    lmax_order: number | null = null,
    npeaks: number | null = null,
    threshold: number | null = null,
    num_samples: number | null = null,
    lambda_param: number | null = null,
    delta_param: number | null = null,
    alpha_param: number | null = null,
    seed_param: number | null = null,
    gfa_flag: boolean = false,
    savecoeff_flag: boolean = false,
    savemeancoeff_flag: boolean = false,
    verbose_flag: boolean = false,
    help_flag: boolean = false,
): QbootParametersTagged {
    const params = {
        "@type": "fsl/qboot" as const,
        "data_file": data_file,
        "mask_file": mask_file,
        "bvecs_file": bvecs_file,
        "bvals_file": bvals_file,
        "forcedir_flag": forcedir_flag,
        "gfa_flag": gfa_flag,
        "savecoeff_flag": savecoeff_flag,
        "savemeancoeff_flag": savemeancoeff_flag,
        "verbose_flag": verbose_flag,
        "help_flag": help_flag,
    };
    if (log_dir !== null) {
        params["log_dir"] = log_dir;
    }
    if (q_file !== null) {
        params["q_file"] = q_file;
    }
    if (model_type !== null) {
        params["model_type"] = model_type;
    }
    if (lmax_order !== null) {
        params["lmax_order"] = lmax_order;
    }
    if (npeaks !== null) {
        params["npeaks"] = npeaks;
    }
    if (threshold !== null) {
        params["threshold"] = threshold;
    }
    if (num_samples !== null) {
        params["num_samples"] = num_samples;
    }
    if (lambda_param !== null) {
        params["lambda_param"] = lambda_param;
    }
    if (delta_param !== null) {
        params["delta_param"] = delta_param;
    }
    if (alpha_param !== null) {
        params["alpha_param"] = alpha_param;
    }
    if (seed_param !== null) {
        params["seed_param"] = seed_param;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function qboot_cargs(
    params: QbootParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("qboot");
    cargs.push(
        "-k",
        execution.inputFile((params["data_file"] ?? null))
    );
    cargs.push(
        "-m",
        execution.inputFile((params["mask_file"] ?? null))
    );
    cargs.push(
        "-r",
        execution.inputFile((params["bvecs_file"] ?? null))
    );
    cargs.push(
        "-b",
        execution.inputFile((params["bvals_file"] ?? null))
    );
    if ((params["log_dir"] ?? null) !== null) {
        cargs.push(
            "--ld",
            (params["log_dir"] ?? null)
        );
    }
    if ((params["forcedir_flag"] ?? false)) {
        cargs.push("--forcedir");
    }
    if ((params["q_file"] ?? null) !== null) {
        cargs.push(
            "--q",
            execution.inputFile((params["q_file"] ?? null))
        );
    }
    if ((params["model_type"] ?? null) !== null) {
        cargs.push(
            "--model",
            String((params["model_type"] ?? null))
        );
    }
    if ((params["lmax_order"] ?? null) !== null) {
        cargs.push(
            "--lmax",
            String((params["lmax_order"] ?? null))
        );
    }
    if ((params["npeaks"] ?? null) !== null) {
        cargs.push(
            "--npeaks",
            String((params["npeaks"] ?? null))
        );
    }
    if ((params["threshold"] ?? null) !== null) {
        cargs.push(
            "--thr",
            String((params["threshold"] ?? null))
        );
    }
    if ((params["num_samples"] ?? null) !== null) {
        cargs.push(
            "--ns",
            String((params["num_samples"] ?? null))
        );
    }
    if ((params["lambda_param"] ?? null) !== null) {
        cargs.push(
            "--lambda",
            String((params["lambda_param"] ?? null))
        );
    }
    if ((params["delta_param"] ?? null) !== null) {
        cargs.push(
            "--delta",
            String((params["delta_param"] ?? null))
        );
    }
    if ((params["alpha_param"] ?? null) !== null) {
        cargs.push(
            "--alpha",
            String((params["alpha_param"] ?? null))
        );
    }
    if ((params["seed_param"] ?? null) !== null) {
        cargs.push(
            "--seed",
            String((params["seed_param"] ?? null))
        );
    }
    if ((params["gfa_flag"] ?? false)) {
        cargs.push("--gfa");
    }
    if ((params["savecoeff_flag"] ?? false)) {
        cargs.push("--savecoeff");
    }
    if ((params["savemeancoeff_flag"] ?? false)) {
        cargs.push("--savemeancoeff");
    }
    if ((params["verbose_flag"] ?? false)) {
        cargs.push("-V");
    }
    if ((params["help_flag"] ?? false)) {
        cargs.push("-h");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function qboot_outputs(
    params: QbootParameters,
    execution: Execution,
): QbootOutputs {
    const ret: QbootOutputs = {
        root: execution.outputFile("."),
        log_directory: execution.outputFile(["logdir"].join('')),
    };
    return ret;
}


/**
 * qboot
 *
 * Tool for computing q-ball ODFs using bootstrap samples.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `QbootOutputs`).
 */
function qboot_execute(
    params: QbootParameters,
    runner: Runner | null = null,
): QbootOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(QBOOT_METADATA);
    params = execution.params(params)
    const cargs = qboot_cargs(params, execution)
    const ret = qboot_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * qboot
 *
 * Tool for computing q-ball ODFs using bootstrap samples.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param data_file Data file
 * @param mask_file Mask file
 * @param bvecs_file b vectors file
 * @param bvals_file b values file
 * @param log_dir Output directory (default is logdir)
 * @param forcedir_flag Use the actual directory name given - i.e. don't add + to make a new directory
 * @param q_file File provided with multi-shell data. Indicates the number of directions for each shell
 * @param model_type Which model to use. 1=Tuch's ODFs, 2=CSA ODFs (default), 3=multi-shell CSA ODFs
 * @param lmax_order Maximum spherical harmonic order employed (must be even, default=4)
 * @param npeaks Maximum number of ODF peaks to be detected (default 2)
 * @param threshold Minimum threshold for a local maxima to be considered an ODF peak. Expressed as a fraction of the maximum ODF value (default 0.4)
 * @param num_samples Number of bootstrap samples (default is 50)
 * @param lambda_param Laplace-Beltrami regularization parameter (default is 0)
 * @param delta_param Signal attenuation regularization parameter for models=2,3 (default is 0.01)
 * @param alpha_param Laplacian sharpening parameter for model=1 (default is 0, should be smaller than 1)
 * @param seed_param Seed for pseudo-random number generator
 * @param gfa_flag Compute a generalised FA, using the mean ODF in each voxel
 * @param savecoeff_flag Save the ODF coefficients instead of the peaks. WARNING: These can be huge files, please use a few bootstrap samples and a low lmax!
 * @param savemeancoeff_flag Save the mean ODF coefficients across all samples
 * @param verbose_flag Switch on diagnostic messages
 * @param help_flag Display this help message
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `QbootOutputs`).
 */
function qboot(
    data_file: InputPathType,
    mask_file: InputPathType,
    bvecs_file: InputPathType,
    bvals_file: InputPathType,
    log_dir: string | null = null,
    forcedir_flag: boolean = false,
    q_file: InputPathType | null = null,
    model_type: number | null = null,
    lmax_order: number | null = null,
    npeaks: number | null = null,
    threshold: number | null = null,
    num_samples: number | null = null,
    lambda_param: number | null = null,
    delta_param: number | null = null,
    alpha_param: number | null = null,
    seed_param: number | null = null,
    gfa_flag: boolean = false,
    savecoeff_flag: boolean = false,
    savemeancoeff_flag: boolean = false,
    verbose_flag: boolean = false,
    help_flag: boolean = false,
    runner: Runner | null = null,
): QbootOutputs {
    const params = qboot_params(data_file, mask_file, bvecs_file, bvals_file, log_dir, forcedir_flag, q_file, model_type, lmax_order, npeaks, threshold, num_samples, lambda_param, delta_param, alpha_param, seed_param, gfa_flag, savecoeff_flag, savemeancoeff_flag, verbose_flag, help_flag)
    return qboot_execute(params, runner);
}


export {
      QBOOT_METADATA,
      QbootOutputs,
      qboot,
      qboot_execute,
      qboot_params,
};
