// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const WAVER_METADATA: Metadata = {
    id: "87f8c0d04d3c90a12e2c0e2447ae75e4bde1b7e0.boutiques",
    name: "waver",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface WaverParameters {
    "@type"?: "afni/waver";
    "wav": boolean;
    "gam": boolean;
    "expr"?: string | null | undefined;
    "file_opt"?: string | null | undefined;
    "delay_time"?: number | null | undefined;
    "rise_time"?: number | null | undefined;
    "fall_time"?: number | null | undefined;
    "undershoot"?: number | null | undefined;
    "restore_time"?: number | null | undefined;
    "gamb"?: number | null | undefined;
    "gamc"?: number | null | undefined;
    "gamd"?: number | null | undefined;
    "peak"?: number | null | undefined;
    "dt"?: number | null | undefined;
    "tr"?: number | null | undefined;
    "xyout": boolean;
    "input_file"?: InputPathType | null | undefined;
    "inline_data"?: string | null | undefined;
    "tstim_data"?: string | null | undefined;
    "when_data"?: string | null | undefined;
    "numout"?: number | null | undefined;
    "ver_flag": boolean;
}
type WaverParametersTagged = Required<Pick<WaverParameters, '@type'>> & WaverParameters;


/**
 * Output object returned when calling `WaverParameters(...)`.
 *
 * @interface
 */
interface WaverOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output filename for the result of the waveform.
     */
    output_filename: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param wav Sets waveform to Cox special [default]
 * @param gam Sets waveform to form t^b * exp(-t/c) (cf. Mark Cohen)
 * @param expr Sets waveform to the expression given, which should depend on the variable 't'.
 * @param file_opt Sets waveform to the values read from the file wname, which should be a single column .1D file. The dt value is the time step (in seconds) between lines in wname.
 * @param delay_time Sets delay time to # seconds [2]
 * @param rise_time Sets rise time to # seconds [4]
 * @param fall_time Sets fall time to # seconds [6]
 * @param undershoot Sets undershoot to # times the peak [0.2]
 * @param restore_time Sets time to restore from undershoot [2]
 * @param gamb Sets the parameter 'b' to # [8.6]
 * @param gamc Sets the parameter 'c' to # [0.547]
 * @param gamd Sets the delay time to # seconds [0.0]
 * @param peak Sets peak value to # [100]
 * @param dt Sets time step of output AND input [0.1]
 * @param tr '-TR' is equivalent to '-dt'
 * @param xyout Output data in 2 columns: 1=time 2=waveform (useful for graphing) [default is 1 column=waveform]
 * @param input_file Read timeseries from *.1D formatted 'infile'; convolve with waveform to produce output
 * @param inline_data Read timeseries from command line DATA; convolve with waveform to produce output
 * @param tstim_data Read discrete stimulation times from the command line and convolve the waveform with delta-functions at those times.
 * @param when_data Read time blocks when stimulus is 'on' (=1) from the command line and convolve the waveform with with a zero-one input.
 * @param numout Output a timeseries with NN points; if this option is not given, then enough points are output to let the result tail back down to zero.
 * @param ver_flag Output version information and exit.
 *
 * @returns Parameter dictionary
 */
function waver_params(
    wav: boolean = false,
    gam: boolean = false,
    expr: string | null = null,
    file_opt: string | null = null,
    delay_time: number | null = null,
    rise_time: number | null = null,
    fall_time: number | null = null,
    undershoot: number | null = null,
    restore_time: number | null = null,
    gamb: number | null = null,
    gamc: number | null = null,
    gamd: number | null = null,
    peak: number | null = null,
    dt: number | null = null,
    tr: number | null = null,
    xyout: boolean = false,
    input_file: InputPathType | null = null,
    inline_data: string | null = null,
    tstim_data: string | null = null,
    when_data: string | null = null,
    numout: number | null = null,
    ver_flag: boolean = false,
): WaverParametersTagged {
    const params = {
        "@type": "afni/waver" as const,
        "wav": wav,
        "gam": gam,
        "xyout": xyout,
        "ver_flag": ver_flag,
    };
    if (expr !== null) {
        params["expr"] = expr;
    }
    if (file_opt !== null) {
        params["file_opt"] = file_opt;
    }
    if (delay_time !== null) {
        params["delay_time"] = delay_time;
    }
    if (rise_time !== null) {
        params["rise_time"] = rise_time;
    }
    if (fall_time !== null) {
        params["fall_time"] = fall_time;
    }
    if (undershoot !== null) {
        params["undershoot"] = undershoot;
    }
    if (restore_time !== null) {
        params["restore_time"] = restore_time;
    }
    if (gamb !== null) {
        params["gamb"] = gamb;
    }
    if (gamc !== null) {
        params["gamc"] = gamc;
    }
    if (gamd !== null) {
        params["gamd"] = gamd;
    }
    if (peak !== null) {
        params["peak"] = peak;
    }
    if (dt !== null) {
        params["dt"] = dt;
    }
    if (tr !== null) {
        params["tr"] = tr;
    }
    if (input_file !== null) {
        params["input_file"] = input_file;
    }
    if (inline_data !== null) {
        params["inline_data"] = inline_data;
    }
    if (tstim_data !== null) {
        params["tstim_data"] = tstim_data;
    }
    if (when_data !== null) {
        params["when_data"] = when_data;
    }
    if (numout !== null) {
        params["numout"] = numout;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function waver_cargs(
    params: WaverParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("waver");
    if ((params["wav"] ?? false)) {
        cargs.push("-WAV");
    }
    if ((params["gam"] ?? false)) {
        cargs.push("-GAM");
    }
    if ((params["expr"] ?? null) !== null) {
        cargs.push(
            "-EXPR",
            (params["expr"] ?? null)
        );
    }
    if ((params["file_opt"] ?? null) !== null) {
        cargs.push(
            "-FILE",
            (params["file_opt"] ?? null)
        );
    }
    if ((params["delay_time"] ?? null) !== null) {
        cargs.push(
            "-delaytime",
            String((params["delay_time"] ?? null))
        );
    }
    if ((params["rise_time"] ?? null) !== null) {
        cargs.push(
            "-risetime",
            String((params["rise_time"] ?? null))
        );
    }
    if ((params["fall_time"] ?? null) !== null) {
        cargs.push(
            "-falltime",
            String((params["fall_time"] ?? null))
        );
    }
    if ((params["undershoot"] ?? null) !== null) {
        cargs.push(
            "-undershoot",
            String((params["undershoot"] ?? null))
        );
    }
    if ((params["restore_time"] ?? null) !== null) {
        cargs.push(
            "-restoretime",
            String((params["restore_time"] ?? null))
        );
    }
    if ((params["gamb"] ?? null) !== null) {
        cargs.push(
            "-gamb",
            String((params["gamb"] ?? null))
        );
    }
    if ((params["gamc"] ?? null) !== null) {
        cargs.push(
            "-gamc",
            String((params["gamc"] ?? null))
        );
    }
    if ((params["gamd"] ?? null) !== null) {
        cargs.push(
            "-gamd",
            String((params["gamd"] ?? null))
        );
    }
    if ((params["peak"] ?? null) !== null) {
        cargs.push(
            "-peak",
            String((params["peak"] ?? null))
        );
    }
    if ((params["dt"] ?? null) !== null) {
        cargs.push(
            "-dt",
            String((params["dt"] ?? null))
        );
    }
    if ((params["tr"] ?? null) !== null) {
        cargs.push(
            "-TR",
            String((params["tr"] ?? null))
        );
    }
    if ((params["xyout"] ?? false)) {
        cargs.push("-xyout");
    }
    if ((params["input_file"] ?? null) !== null) {
        cargs.push(
            "-input",
            execution.inputFile((params["input_file"] ?? null))
        );
    }
    if ((params["inline_data"] ?? null) !== null) {
        cargs.push(
            "-inline",
            (params["inline_data"] ?? null)
        );
    }
    if ((params["tstim_data"] ?? null) !== null) {
        cargs.push(
            "-tstim",
            (params["tstim_data"] ?? null)
        );
    }
    if ((params["when_data"] ?? null) !== null) {
        cargs.push(
            "-when",
            (params["when_data"] ?? null)
        );
    }
    if ((params["numout"] ?? null) !== null) {
        cargs.push(
            "-numout",
            String((params["numout"] ?? null))
        );
    }
    if ((params["ver_flag"] ?? false)) {
        cargs.push("-ver");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function waver_outputs(
    params: WaverParameters,
    execution: Execution,
): WaverOutputs {
    const ret: WaverOutputs = {
        root: execution.outputFile("."),
        output_filename: execution.outputFile(["output_filename"].join('')),
    };
    return ret;
}


/**
 * waver
 *
 * Creates an ideal waveform timeseries file.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `WaverOutputs`).
 */
function waver_execute(
    params: WaverParameters,
    runner: Runner | null = null,
): WaverOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(WAVER_METADATA);
    params = execution.params(params)
    const cargs = waver_cargs(params, execution)
    const ret = waver_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * waver
 *
 * Creates an ideal waveform timeseries file.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param wav Sets waveform to Cox special [default]
 * @param gam Sets waveform to form t^b * exp(-t/c) (cf. Mark Cohen)
 * @param expr Sets waveform to the expression given, which should depend on the variable 't'.
 * @param file_opt Sets waveform to the values read from the file wname, which should be a single column .1D file. The dt value is the time step (in seconds) between lines in wname.
 * @param delay_time Sets delay time to # seconds [2]
 * @param rise_time Sets rise time to # seconds [4]
 * @param fall_time Sets fall time to # seconds [6]
 * @param undershoot Sets undershoot to # times the peak [0.2]
 * @param restore_time Sets time to restore from undershoot [2]
 * @param gamb Sets the parameter 'b' to # [8.6]
 * @param gamc Sets the parameter 'c' to # [0.547]
 * @param gamd Sets the delay time to # seconds [0.0]
 * @param peak Sets peak value to # [100]
 * @param dt Sets time step of output AND input [0.1]
 * @param tr '-TR' is equivalent to '-dt'
 * @param xyout Output data in 2 columns: 1=time 2=waveform (useful for graphing) [default is 1 column=waveform]
 * @param input_file Read timeseries from *.1D formatted 'infile'; convolve with waveform to produce output
 * @param inline_data Read timeseries from command line DATA; convolve with waveform to produce output
 * @param tstim_data Read discrete stimulation times from the command line and convolve the waveform with delta-functions at those times.
 * @param when_data Read time blocks when stimulus is 'on' (=1) from the command line and convolve the waveform with with a zero-one input.
 * @param numout Output a timeseries with NN points; if this option is not given, then enough points are output to let the result tail back down to zero.
 * @param ver_flag Output version information and exit.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `WaverOutputs`).
 */
function waver(
    wav: boolean = false,
    gam: boolean = false,
    expr: string | null = null,
    file_opt: string | null = null,
    delay_time: number | null = null,
    rise_time: number | null = null,
    fall_time: number | null = null,
    undershoot: number | null = null,
    restore_time: number | null = null,
    gamb: number | null = null,
    gamc: number | null = null,
    gamd: number | null = null,
    peak: number | null = null,
    dt: number | null = null,
    tr: number | null = null,
    xyout: boolean = false,
    input_file: InputPathType | null = null,
    inline_data: string | null = null,
    tstim_data: string | null = null,
    when_data: string | null = null,
    numout: number | null = null,
    ver_flag: boolean = false,
    runner: Runner | null = null,
): WaverOutputs {
    const params = waver_params(wav, gam, expr, file_opt, delay_time, rise_time, fall_time, undershoot, restore_time, gamb, gamc, gamd, peak, dt, tr, xyout, input_file, inline_data, tstim_data, when_data, numout, ver_flag)
    return waver_execute(params, runner);
}


export {
      WAVER_METADATA,
      WaverOutputs,
      waver,
      waver_execute,
      waver_params,
};
