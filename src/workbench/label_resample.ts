// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const LABEL_RESAMPLE_METADATA: Metadata = {
    id: "28df6b0f67a83e5c7adcd10a2b3d660dee037bc0.boutiques",
    name: "label-resample",
    package: "workbench",
    container_image_tag: "brainlife/connectome_workbench:1.5.0-freesurfer-update",
};


interface LabelResampleAreaSurfsParameters {
    "@type": "workbench.label-resample.area_surfs";
    "current_area": InputPathType;
    "new_area": InputPathType;
}


interface LabelResampleAreaMetricsParameters {
    "@type": "workbench.label-resample.area_metrics";
    "current_area": InputPathType;
    "new_area": InputPathType;
}


interface LabelResampleParameters {
    "@type": "workbench.label-resample";
    "label_in": InputPathType;
    "current_sphere": InputPathType;
    "new_sphere": InputPathType;
    "method": string;
    "label_out": string;
    "area_surfs"?: LabelResampleAreaSurfsParameters | null | undefined;
    "area_metrics"?: LabelResampleAreaMetricsParameters | null | undefined;
    "opt_current_roi_roi_metric"?: InputPathType | null | undefined;
    "opt_valid_roi_out_roi_out"?: string | null | undefined;
    "opt_largest": boolean;
    "opt_bypass_sphere_check": boolean;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "workbench.label-resample": label_resample_cargs,
        "workbench.label-resample.area_surfs": label_resample_area_surfs_cargs,
        "workbench.label-resample.area_metrics": label_resample_area_metrics_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "workbench.label-resample": label_resample_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @param current_area a relevant anatomical surface with <current-sphere> mesh
 * @param new_area a relevant anatomical surface with <new-sphere> mesh
 *
 * @returns Parameter dictionary
 */
function label_resample_area_surfs_params(
    current_area: InputPathType,
    new_area: InputPathType,
): LabelResampleAreaSurfsParameters {
    const params = {
        "@type": "workbench.label-resample.area_surfs" as const,
        "current_area": current_area,
        "new_area": new_area,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function label_resample_area_surfs_cargs(
    params: LabelResampleAreaSurfsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-area-surfs");
    cargs.push(execution.inputFile((params["current_area"] ?? null)));
    cargs.push(execution.inputFile((params["new_area"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param current_area a metric file with vertex areas for <current-sphere> mesh
 * @param new_area a metric file with vertex areas for <new-sphere> mesh
 *
 * @returns Parameter dictionary
 */
function label_resample_area_metrics_params(
    current_area: InputPathType,
    new_area: InputPathType,
): LabelResampleAreaMetricsParameters {
    const params = {
        "@type": "workbench.label-resample.area_metrics" as const,
        "current_area": current_area,
        "new_area": new_area,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function label_resample_area_metrics_cargs(
    params: LabelResampleAreaMetricsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-area-metrics");
    cargs.push(execution.inputFile((params["current_area"] ?? null)));
    cargs.push(execution.inputFile((params["new_area"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `label_resample(...)`.
 *
 * @interface
 */
interface LabelResampleOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output label file
     */
    label_out: OutputPathType;
    /**
     * output the ROI of vertices that got data from valid source vertices: the output roi as a metric
     */
    opt_valid_roi_out_roi_out: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param label_in the label file to resample
 * @param current_sphere a sphere surface with the mesh that the label file is currently on
 * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
 * @param method the method name
 * @param label_out the output label file
 * @param area_surfs specify surfaces to do vertex area correction based on
 * @param area_metrics specify vertex area metrics to do area correction based on
 * @param opt_current_roi_roi_metric use an input roi on the current mesh to exclude non-data vertices: the roi, as a metric file
 * @param opt_valid_roi_out_roi_out output the ROI of vertices that got data from valid source vertices: the output roi as a metric
 * @param opt_largest use only the label of the vertex with the largest weight
 * @param opt_bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
 *
 * @returns Parameter dictionary
 */
function label_resample_params(
    label_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    label_out: string,
    area_surfs: LabelResampleAreaSurfsParameters | null = null,
    area_metrics: LabelResampleAreaMetricsParameters | null = null,
    opt_current_roi_roi_metric: InputPathType | null = null,
    opt_valid_roi_out_roi_out: string | null = null,
    opt_largest: boolean = false,
    opt_bypass_sphere_check: boolean = false,
): LabelResampleParameters {
    const params = {
        "@type": "workbench.label-resample" as const,
        "label_in": label_in,
        "current_sphere": current_sphere,
        "new_sphere": new_sphere,
        "method": method,
        "label_out": label_out,
        "opt_largest": opt_largest,
        "opt_bypass_sphere_check": opt_bypass_sphere_check,
    };
    if (area_surfs !== null) {
        params["area_surfs"] = area_surfs;
    }
    if (area_metrics !== null) {
        params["area_metrics"] = area_metrics;
    }
    if (opt_current_roi_roi_metric !== null) {
        params["opt_current_roi_roi_metric"] = opt_current_roi_roi_metric;
    }
    if (opt_valid_roi_out_roi_out !== null) {
        params["opt_valid_roi_out_roi_out"] = opt_valid_roi_out_roi_out;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function label_resample_cargs(
    params: LabelResampleParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("wb_command");
    cargs.push("-label-resample");
    cargs.push(execution.inputFile((params["label_in"] ?? null)));
    cargs.push(execution.inputFile((params["current_sphere"] ?? null)));
    cargs.push(execution.inputFile((params["new_sphere"] ?? null)));
    cargs.push((params["method"] ?? null));
    cargs.push((params["label_out"] ?? null));
    if ((params["area_surfs"] ?? null) !== null) {
        cargs.push(...dynCargs((params["area_surfs"] ?? null)["@type"])((params["area_surfs"] ?? null), execution));
    }
    if ((params["area_metrics"] ?? null) !== null) {
        cargs.push(...dynCargs((params["area_metrics"] ?? null)["@type"])((params["area_metrics"] ?? null), execution));
    }
    if ((params["opt_current_roi_roi_metric"] ?? null) !== null) {
        cargs.push(
            "-current-roi",
            execution.inputFile((params["opt_current_roi_roi_metric"] ?? null))
        );
    }
    if ((params["opt_valid_roi_out_roi_out"] ?? null) !== null) {
        cargs.push(
            "-valid-roi-out",
            (params["opt_valid_roi_out_roi_out"] ?? null)
        );
    }
    if ((params["opt_largest"] ?? null)) {
        cargs.push("-largest");
    }
    if ((params["opt_bypass_sphere_check"] ?? null)) {
        cargs.push("-bypass-sphere-check");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function label_resample_outputs(
    params: LabelResampleParameters,
    execution: Execution,
): LabelResampleOutputs {
    const ret: LabelResampleOutputs = {
        root: execution.outputFile("."),
        label_out: execution.outputFile([(params["label_out"] ?? null)].join('')),
        opt_valid_roi_out_roi_out: ((params["opt_valid_roi_out_roi_out"] ?? null) !== null) ? execution.outputFile([(params["opt_valid_roi_out_roi_out"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * Resample a label file to a different mesh.
 *
 * Resamples a label file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
 *
 * The ADAP_BARY_AREA method is recommended for label data, because it should be better at resolving vertices that are near multiple labels, or in case of downsampling.  Midthickness surfaces are recommended for the vertex areas for most data.
 *
 * The -largest option results in nearest vertex behavior when used with BARYCENTRIC, as it uses the value of the source vertex that has the largest weight.
 *
 * When -largest is not specified, the vertex weights are summed according to which label they correspond to, and the label with the largest sum is used.
 *
 * The <method> argument must be one of the following:
 *
 * ADAP_BARY_AREA
 * BARYCENTRIC
 * .
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `LabelResampleOutputs`).
 */
function label_resample_execute(
    params: LabelResampleParameters,
    runner: Runner | null = null,
): LabelResampleOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(LABEL_RESAMPLE_METADATA);
    params = execution.params(params)
    const cargs = label_resample_cargs(params, execution)
    const ret = label_resample_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * Resample a label file to a different mesh.
 *
 * Resamples a label file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
 *
 * The ADAP_BARY_AREA method is recommended for label data, because it should be better at resolving vertices that are near multiple labels, or in case of downsampling.  Midthickness surfaces are recommended for the vertex areas for most data.
 *
 * The -largest option results in nearest vertex behavior when used with BARYCENTRIC, as it uses the value of the source vertex that has the largest weight.
 *
 * When -largest is not specified, the vertex weights are summed according to which label they correspond to, and the label with the largest sum is used.
 *
 * The <method> argument must be one of the following:
 *
 * ADAP_BARY_AREA
 * BARYCENTRIC
 * .
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param label_in the label file to resample
 * @param current_sphere a sphere surface with the mesh that the label file is currently on
 * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
 * @param method the method name
 * @param label_out the output label file
 * @param area_surfs specify surfaces to do vertex area correction based on
 * @param area_metrics specify vertex area metrics to do area correction based on
 * @param opt_current_roi_roi_metric use an input roi on the current mesh to exclude non-data vertices: the roi, as a metric file
 * @param opt_valid_roi_out_roi_out output the ROI of vertices that got data from valid source vertices: the output roi as a metric
 * @param opt_largest use only the label of the vertex with the largest weight
 * @param opt_bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `LabelResampleOutputs`).
 */
function label_resample(
    label_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    label_out: string,
    area_surfs: LabelResampleAreaSurfsParameters | null = null,
    area_metrics: LabelResampleAreaMetricsParameters | null = null,
    opt_current_roi_roi_metric: InputPathType | null = null,
    opt_valid_roi_out_roi_out: string | null = null,
    opt_largest: boolean = false,
    opt_bypass_sphere_check: boolean = false,
    runner: Runner | null = null,
): LabelResampleOutputs {
    const params = label_resample_params(label_in, current_sphere, new_sphere, method, label_out, area_surfs, area_metrics, opt_current_roi_roi_metric, opt_valid_roi_out_roi_out, opt_largest, opt_bypass_sphere_check)
    return label_resample_execute(params, runner);
}


export {
      LABEL_RESAMPLE_METADATA,
      LabelResampleAreaMetricsParameters,
      LabelResampleAreaSurfsParameters,
      LabelResampleOutputs,
      LabelResampleParameters,
      label_resample,
      label_resample_area_metrics_params,
      label_resample_area_surfs_params,
      label_resample_execute,
      label_resample_params,
};
