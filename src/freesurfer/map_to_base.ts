// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MAP_TO_BASE_METADATA: Metadata = {
    id: "9b2dd3e9ec97c3554ea3c04d77396bf3aabbcebf.boutiques",
    name: "map_to_base",
    package: "freesurfer",
    container_image_tag: "freesurfer/freesurfer:7.4.1",
};


interface MapToBaseParameters {
    "@type"?: "freesurfer/map_to_base";
    "baseid": string;
    "tpid": string;
    "input_image": string;
    "resample_type": string;
    "cross"?: string | null | undefined;
}
type MapToBaseParametersTagged = Required<Pick<MapToBaseParameters, '@type'>> & MapToBaseParameters;


/**
 * Output object returned when calling `MapToBaseParameters(...)`.
 *
 * @interface
 */
interface MapToBaseOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output in base/mri directory when mapped from a longitudinal directory.
     */
    output_long_mri: OutputPathType;
    /**
     * Output in base/surf directory when mapped from a longitudinal directory.
     */
    output_long_surf: OutputPathType;
    /**
     * Output in base/mri directory when mapped from a cross-sectional directory.
     */
    output_cross_mri: OutputPathType;
    /**
     * Output in base/surf directory when mapped from a cross-sectional directory.
     */
    output_cross_surf: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param baseid Identifier of the base.
 * @param tpid Identifier of the time point, without the '.long.baseid' suffix.
 * @param input_image Input image, e.g., norm.mgz, aseg.mgz, lh.white.
 * @param resample_type Resample type. 'interpolate' for norm, T1, orig; 'nearest' for aseg; 'surface' for surfaces.
 * @param cross If '1', input is from cross sectionals; default is to use longitudinal directories.
 *
 * @returns Parameter dictionary
 */
function map_to_base_params(
    baseid: string,
    tpid: string,
    input_image: string,
    resample_type: string,
    cross: string | null = null,
): MapToBaseParametersTagged {
    const params = {
        "@type": "freesurfer/map_to_base" as const,
        "baseid": baseid,
        "tpid": tpid,
        "input_image": input_image,
        "resample_type": resample_type,
    };
    if (cross !== null) {
        params["cross"] = cross;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function map_to_base_cargs(
    params: MapToBaseParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("map_to_base");
    cargs.push((params["baseid"] ?? null));
    cargs.push((params["tpid"] ?? null));
    cargs.push((params["input_image"] ?? null));
    cargs.push((params["resample_type"] ?? null));
    if ((params["cross"] ?? null) !== null) {
        cargs.push((params["cross"] ?? null));
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function map_to_base_outputs(
    params: MapToBaseParameters,
    execution: Execution,
): MapToBaseOutputs {
    const ret: MapToBaseOutputs = {
        root: execution.outputFile("."),
        output_long_mri: execution.outputFile([(params["baseid"] ?? null), "/mri/", (params["tpid"] ?? null), "-long.", (params["input_image"] ?? null)].join('')),
        output_long_surf: execution.outputFile([(params["baseid"] ?? null), "/surf/", (params["tpid"] ?? null), "-long.", (params["input_image"] ?? null)].join('')),
        output_cross_mri: execution.outputFile([(params["baseid"] ?? null), "/mri/", (params["tpid"] ?? null), "-cross.", (params["input_image"] ?? null)].join('')),
        output_cross_surf: execution.outputFile([(params["baseid"] ?? null), "/surf/", (params["tpid"] ?? null), "-cross.", (params["input_image"] ?? null)].join('')),
    };
    return ret;
}


/**
 * map_to_base
 *
 * Maps an image or surface from a time point directory (either cross-sectional or longitudinal) to the base space and outputs it in the appropriate base directory.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MapToBaseOutputs`).
 */
function map_to_base_execute(
    params: MapToBaseParameters,
    runner: Runner | null = null,
): MapToBaseOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MAP_TO_BASE_METADATA);
    params = execution.params(params)
    const cargs = map_to_base_cargs(params, execution)
    const ret = map_to_base_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * map_to_base
 *
 * Maps an image or surface from a time point directory (either cross-sectional or longitudinal) to the base space and outputs it in the appropriate base directory.
 *
 * Author: FreeSurfer Developers
 *
 * URL: https://github.com/freesurfer/freesurfer
 *
 * @param baseid Identifier of the base.
 * @param tpid Identifier of the time point, without the '.long.baseid' suffix.
 * @param input_image Input image, e.g., norm.mgz, aseg.mgz, lh.white.
 * @param resample_type Resample type. 'interpolate' for norm, T1, orig; 'nearest' for aseg; 'surface' for surfaces.
 * @param cross If '1', input is from cross sectionals; default is to use longitudinal directories.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MapToBaseOutputs`).
 */
function map_to_base(
    baseid: string,
    tpid: string,
    input_image: string,
    resample_type: string,
    cross: string | null = null,
    runner: Runner | null = null,
): MapToBaseOutputs {
    const params = map_to_base_params(baseid, tpid, input_image, resample_type, cross)
    return map_to_base_execute(params, runner);
}


export {
      MAP_TO_BASE_METADATA,
      MapToBaseOutputs,
      map_to_base,
      map_to_base_execute,
      map_to_base_params,
};
