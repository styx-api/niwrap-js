// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const FAST_METADATA: Metadata = {
    id: "71882fb7c4050cfbb372686192607f9f7bd8489d.boutiques",
    name: "fast",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface FastParameters {
    "@type"?: "fsl/fast";
    "number_classes"?: number | null | undefined;
    "bias_iters"?: number | null | undefined;
    "bias_lowpass"?: number | null | undefined;
    "img_type"?: 1 | 2 | 3 | null | undefined;
    "init_seg_smooth"?: number | null | undefined;
    "segments": boolean;
    "init_transform"?: InputPathType | null | undefined;
    "other_priors"?: Array<InputPathType> | null | undefined;
    "output_biasfield": boolean;
    "output_biascorrected": boolean;
    "no_bias": boolean;
    "channels"?: number | null | undefined;
    "out_basename"?: string | null | undefined;
    "use_priors": boolean;
    "no_pve": boolean;
    "segment_iters"?: number | null | undefined;
    "mixel_smooth"?: number | null | undefined;
    "hyper"?: number | null | undefined;
    "verbose": boolean;
    "manual_seg"?: InputPathType | null | undefined;
    "iters_afterbias"?: number | null | undefined;
    "in_files": Array<InputPathType>;
}
type FastParametersTagged = Required<Pick<FastParameters, '@type'>> & FastParameters;


/**
 * Output object returned when calling `FastParameters(...)`.
 *
 * @interface
 */
interface FastOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Path/name of mixeltype volume file _mixeltype.
     */
    mixeltype: OutputPathType | null;
    /**
     * No description provided.
     */
    bias_field: OutputPathType | null;
    /**
     * Path/name of partial volume file _pveseg.
     */
    partial_volume_map: OutputPathType | null;
    /**
     * No description provided.
     */
    restored_image: OutputPathType | null;
    /**
     * Path/name of binary segmented volume file one val for each class  _seg.
     */
    tissue_class_map: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param in_files Image, or multi-channel set of images, to be segmented.
 * @param number_classes number of tissue-type classes; default=3
 * @param bias_iters number of main-loop iterations during bias-field removal; default=4
 * @param bias_lowpass bias field smoothing extent (FWHM) in mm; default=20
 * @param img_type type of image 1=T1, 2=T2, 3=PD; default=T1
 * @param init_seg_smooth initial segmentation spatial smoothness (during bias field estimation); default=0.02
 * @param segments outputs a separate binary image for each tissue type
 * @param init_transform initialise using priors; you must supply a FLIRT transform
 * @param other_priors Alternative prior images.
 * @param output_biasfield Output estimated bias field.
 * @param output_biascorrected Output restored image (bias-corrected image).
 * @param no_bias Do not remove bias field.
 * @param channels number of input images (channels); default 1
 * @param out_basename Base name of output files.
 * @param use_priors Use priors throughout.
 * @param no_pve Turn off pve (partial volume estimation).
 * @param segment_iters number of segmentation-initialisation iterations; default=15
 * @param mixel_smooth spatial smoothness for mixeltype; default=0.3
 * @param hyper 0.0 <= a floating point number <= 1.0. segmentation spatial smoothness; default=0.1
 * @param verbose Switch on diagnostic messages.
 * @param manual_seg Filename containing intensities.
 * @param iters_afterbias number of main-loop iterations after bias-field removal; default=4
 *
 * @returns Parameter dictionary
 */
function fast_params(
    in_files: Array<InputPathType>,
    number_classes: number | null = null,
    bias_iters: number | null = null,
    bias_lowpass: number | null = null,
    img_type: 1 | 2 | 3 | null = null,
    init_seg_smooth: number | null = null,
    segments: boolean = false,
    init_transform: InputPathType | null = null,
    other_priors: Array<InputPathType> | null = null,
    output_biasfield: boolean = false,
    output_biascorrected: boolean = false,
    no_bias: boolean = false,
    channels: number | null = null,
    out_basename: string | null = null,
    use_priors: boolean = false,
    no_pve: boolean = false,
    segment_iters: number | null = null,
    mixel_smooth: number | null = null,
    hyper: number | null = null,
    verbose: boolean = false,
    manual_seg: InputPathType | null = null,
    iters_afterbias: number | null = null,
): FastParametersTagged {
    const params = {
        "@type": "fsl/fast" as const,
        "segments": segments,
        "output_biasfield": output_biasfield,
        "output_biascorrected": output_biascorrected,
        "no_bias": no_bias,
        "use_priors": use_priors,
        "no_pve": no_pve,
        "verbose": verbose,
        "in_files": in_files,
    };
    if (number_classes !== null) {
        params["number_classes"] = number_classes;
    }
    if (bias_iters !== null) {
        params["bias_iters"] = bias_iters;
    }
    if (bias_lowpass !== null) {
        params["bias_lowpass"] = bias_lowpass;
    }
    if (img_type !== null) {
        params["img_type"] = img_type;
    }
    if (init_seg_smooth !== null) {
        params["init_seg_smooth"] = init_seg_smooth;
    }
    if (init_transform !== null) {
        params["init_transform"] = init_transform;
    }
    if (other_priors !== null) {
        params["other_priors"] = other_priors;
    }
    if (channels !== null) {
        params["channels"] = channels;
    }
    if (out_basename !== null) {
        params["out_basename"] = out_basename;
    }
    if (segment_iters !== null) {
        params["segment_iters"] = segment_iters;
    }
    if (mixel_smooth !== null) {
        params["mixel_smooth"] = mixel_smooth;
    }
    if (hyper !== null) {
        params["hyper"] = hyper;
    }
    if (manual_seg !== null) {
        params["manual_seg"] = manual_seg;
    }
    if (iters_afterbias !== null) {
        params["iters_afterbias"] = iters_afterbias;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function fast_cargs(
    params: FastParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("fast");
    if ((params["number_classes"] ?? null) !== null) {
        cargs.push(
            "-n",
            String((params["number_classes"] ?? null))
        );
    }
    if ((params["bias_iters"] ?? null) !== null) {
        cargs.push(
            "-I",
            String((params["bias_iters"] ?? null))
        );
    }
    if ((params["bias_lowpass"] ?? null) !== null) {
        cargs.push(
            "-l",
            String((params["bias_lowpass"] ?? null))
        );
    }
    if ((params["img_type"] ?? null) !== null) {
        cargs.push(
            "-t",
            String((params["img_type"] ?? null))
        );
    }
    if ((params["init_seg_smooth"] ?? null) !== null) {
        cargs.push(
            "-f",
            String((params["init_seg_smooth"] ?? null))
        );
    }
    if ((params["segments"] ?? false)) {
        cargs.push("-g");
    }
    if ((params["init_transform"] ?? null) !== null) {
        cargs.push(
            "-a",
            execution.inputFile((params["init_transform"] ?? null))
        );
    }
    if ((params["other_priors"] ?? null) !== null) {
        cargs.push(
            "-A",
            ...(params["other_priors"] ?? null).map(f => execution.inputFile(f))
        );
    }
    if ((params["output_biasfield"] ?? false)) {
        cargs.push("-b");
    }
    if ((params["output_biascorrected"] ?? false)) {
        cargs.push("-B");
    }
    if ((params["no_bias"] ?? false)) {
        cargs.push("-N");
    }
    if ((params["channels"] ?? null) !== null) {
        cargs.push(
            "-S",
            String((params["channels"] ?? null))
        );
    }
    if ((params["out_basename"] ?? null) !== null) {
        cargs.push(
            "-o",
            (params["out_basename"] ?? null)
        );
    }
    if ((params["use_priors"] ?? false)) {
        cargs.push("-P");
    }
    if ((params["no_pve"] ?? false)) {
        cargs.push("--nopve");
    }
    if ((params["segment_iters"] ?? null) !== null) {
        cargs.push(
            "-W",
            String((params["segment_iters"] ?? null))
        );
    }
    if ((params["mixel_smooth"] ?? null) !== null) {
        cargs.push(
            "-R",
            String((params["mixel_smooth"] ?? null))
        );
    }
    if ((params["hyper"] ?? null) !== null) {
        cargs.push(
            "-H",
            String((params["hyper"] ?? null))
        );
    }
    if ((params["verbose"] ?? false)) {
        cargs.push("-v");
    }
    if ((params["manual_seg"] ?? null) !== null) {
        cargs.push(
            "-s",
            execution.inputFile((params["manual_seg"] ?? null))
        );
    }
    if ((params["iters_afterbias"] ?? null) !== null) {
        cargs.push(
            "-O",
            String((params["iters_afterbias"] ?? null))
        );
    }
    cargs.push(...(params["in_files"] ?? null).map(f => execution.inputFile(f)));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function fast_outputs(
    params: FastParameters,
    execution: Execution,
): FastOutputs {
    const ret: FastOutputs = {
        root: execution.outputFile("."),
        mixeltype: ((params["out_basename"] ?? null) !== null) ? execution.outputFile([(params["out_basename"] ?? null), "_mixeltype.nii.gz"].join('')) : null,
        bias_field: ((params["out_basename"] ?? null) !== null) ? execution.outputFile([(params["out_basename"] ?? null), "_bias.nii.gz"].join('')) : null,
        partial_volume_map: ((params["out_basename"] ?? null) !== null) ? execution.outputFile([(params["out_basename"] ?? null), "_pveseg.nii.gz"].join('')) : null,
        restored_image: ((params["out_basename"] ?? null) !== null) ? execution.outputFile([(params["out_basename"] ?? null), "_restore.nii.gz"].join('')) : null,
        tissue_class_map: ((params["out_basename"] ?? null) !== null) ? execution.outputFile([(params["out_basename"] ?? null), "_seg.nii.gz"].join('')) : null,
    };
    return ret;
}


/**
 * fast
 *
 * FAST (FMRIB's Automated Segmentation Tool) segments a 3D image of the brain into different tissue types (Grey Matter, White Matter, CSF, etc.), whilst also correcting for spatial intensity variations (also known as bias field or RF inhomogeneities). The underlying method is based on a hidden Markov random field model and an associated Expectation-Maximization algorithm. The whole process is fully automated and can also produce a bias field-corrected input image and a probabilistic and/or partial volume tissue segmentation. It is robust and reliable, compared to most finite mixture model-based methods, which are sensitive to noise.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FastOutputs`).
 */
function fast_execute(
    params: FastParameters,
    runner: Runner | null = null,
): FastOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(FAST_METADATA);
    params = execution.params(params)
    const cargs = fast_cargs(params, execution)
    const ret = fast_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * fast
 *
 * FAST (FMRIB's Automated Segmentation Tool) segments a 3D image of the brain into different tissue types (Grey Matter, White Matter, CSF, etc.), whilst also correcting for spatial intensity variations (also known as bias field or RF inhomogeneities). The underlying method is based on a hidden Markov random field model and an associated Expectation-Maximization algorithm. The whole process is fully automated and can also produce a bias field-corrected input image and a probabilistic and/or partial volume tissue segmentation. It is robust and reliable, compared to most finite mixture model-based methods, which are sensitive to noise.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param in_files Image, or multi-channel set of images, to be segmented.
 * @param number_classes number of tissue-type classes; default=3
 * @param bias_iters number of main-loop iterations during bias-field removal; default=4
 * @param bias_lowpass bias field smoothing extent (FWHM) in mm; default=20
 * @param img_type type of image 1=T1, 2=T2, 3=PD; default=T1
 * @param init_seg_smooth initial segmentation spatial smoothness (during bias field estimation); default=0.02
 * @param segments outputs a separate binary image for each tissue type
 * @param init_transform initialise using priors; you must supply a FLIRT transform
 * @param other_priors Alternative prior images.
 * @param output_biasfield Output estimated bias field.
 * @param output_biascorrected Output restored image (bias-corrected image).
 * @param no_bias Do not remove bias field.
 * @param channels number of input images (channels); default 1
 * @param out_basename Base name of output files.
 * @param use_priors Use priors throughout.
 * @param no_pve Turn off pve (partial volume estimation).
 * @param segment_iters number of segmentation-initialisation iterations; default=15
 * @param mixel_smooth spatial smoothness for mixeltype; default=0.3
 * @param hyper 0.0 <= a floating point number <= 1.0. segmentation spatial smoothness; default=0.1
 * @param verbose Switch on diagnostic messages.
 * @param manual_seg Filename containing intensities.
 * @param iters_afterbias number of main-loop iterations after bias-field removal; default=4
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FastOutputs`).
 */
function fast(
    in_files: Array<InputPathType>,
    number_classes: number | null = null,
    bias_iters: number | null = null,
    bias_lowpass: number | null = null,
    img_type: 1 | 2 | 3 | null = null,
    init_seg_smooth: number | null = null,
    segments: boolean = false,
    init_transform: InputPathType | null = null,
    other_priors: Array<InputPathType> | null = null,
    output_biasfield: boolean = false,
    output_biascorrected: boolean = false,
    no_bias: boolean = false,
    channels: number | null = null,
    out_basename: string | null = null,
    use_priors: boolean = false,
    no_pve: boolean = false,
    segment_iters: number | null = null,
    mixel_smooth: number | null = null,
    hyper: number | null = null,
    verbose: boolean = false,
    manual_seg: InputPathType | null = null,
    iters_afterbias: number | null = null,
    runner: Runner | null = null,
): FastOutputs {
    const params = fast_params(in_files, number_classes, bias_iters, bias_lowpass, img_type, init_seg_smooth, segments, init_transform, other_priors, output_biasfield, output_biascorrected, no_bias, channels, out_basename, use_priors, no_pve, segment_iters, mixel_smooth, hyper, verbose, manual_seg, iters_afterbias)
    return fast_execute(params, runner);
}


export {
      FAST_METADATA,
      FastOutputs,
      fast,
      fast_execute,
      fast_params,
};
