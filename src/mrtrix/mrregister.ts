// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRREGISTER_METADATA: Metadata = {
    id: "8b9c1c18dd4e1792249b2b0db264ebab8365011a.boutiques",
    name: "mrregister",
    package: "mrtrix",
    container_image_tag: "mrtrix3/mrtrix3:3.0.4",
};


interface MrregisterTransformedParameters {
    "@type": "mrtrix.mrregister.transformed";
    "image": string;
}


interface MrregisterTransformedMidwayParameters {
    "@type": "mrtrix.mrregister.transformed_midway";
    "image1_transformed": string;
    "image2_transformed": string;
}


interface MrregisterNlWarpParameters {
    "@type": "mrtrix.mrregister.nl_warp";
    "warp1": string;
    "warp2": string;
}


interface MrregisterConfigParameters {
    "@type": "mrtrix.mrregister.config";
    "key": string;
    "value": string;
}


interface MrregisterParameters {
    "@type": "mrtrix.mrregister";
    "type"?: string | null | undefined;
    "transformed"?: Array<MrregisterTransformedParameters> | null | undefined;
    "transformed_midway"?: Array<MrregisterTransformedMidwayParameters> | null | undefined;
    "mask1"?: InputPathType | null | undefined;
    "mask2"?: InputPathType | null | undefined;
    "nan": boolean;
    "rigid"?: string | null | undefined;
    "rigid_1tomidway"?: string | null | undefined;
    "rigid_2tomidway"?: string | null | undefined;
    "rigid_init_translation"?: string | null | undefined;
    "rigid_init_rotation"?: string | null | undefined;
    "rigid_init_matrix"?: InputPathType | null | undefined;
    "rigid_scale"?: Array<number> | null | undefined;
    "rigid_niter"?: Array<number> | null | undefined;
    "rigid_metric"?: string | null | undefined;
    "rigid_metric_diff_estimator"?: string | null | undefined;
    "rigid_lmax"?: Array<number> | null | undefined;
    "rigid_log"?: string | null | undefined;
    "affine"?: string | null | undefined;
    "affine_1tomidway"?: string | null | undefined;
    "affine_2tomidway"?: string | null | undefined;
    "affine_init_translation"?: string | null | undefined;
    "affine_init_rotation"?: string | null | undefined;
    "affine_init_matrix"?: InputPathType | null | undefined;
    "affine_scale"?: Array<number> | null | undefined;
    "affine_niter"?: Array<number> | null | undefined;
    "affine_metric"?: string | null | undefined;
    "affine_metric_diff_estimator"?: string | null | undefined;
    "affine_lmax"?: Array<number> | null | undefined;
    "affine_log"?: string | null | undefined;
    "init_translation_unmasked1": boolean;
    "init_translation_unmasked2": boolean;
    "init_rotation_unmasked1": boolean;
    "init_rotation_unmasked2": boolean;
    "init_rotation_search_angles"?: Array<number> | null | undefined;
    "init_rotation_search_scale"?: number | null | undefined;
    "init_rotation_search_directions"?: number | null | undefined;
    "init_rotation_search_run_global": boolean;
    "init_rotation_search_global_iterations"?: number | null | undefined;
    "linstage_iterations"?: Array<number> | null | undefined;
    "linstage_optimiser_first"?: string | null | undefined;
    "linstage_optimiser_last"?: string | null | undefined;
    "linstage_optimiser_default"?: string | null | undefined;
    "linstage_diagnostics_prefix"?: string | null | undefined;
    "nl_warp"?: MrregisterNlWarpParameters | null | undefined;
    "nl_warp_full"?: string | null | undefined;
    "nl_init"?: InputPathType | null | undefined;
    "nl_scale"?: Array<number> | null | undefined;
    "nl_niter"?: Array<number> | null | undefined;
    "nl_update_smooth"?: number | null | undefined;
    "nl_disp_smooth"?: number | null | undefined;
    "nl_grad_step"?: number | null | undefined;
    "nl_lmax"?: Array<number> | null | undefined;
    "diagnostics_image"?: string | null | undefined;
    "directions"?: InputPathType | null | undefined;
    "noreorientation": boolean;
    "mc_weights"?: Array<number> | null | undefined;
    "datatype"?: string | null | undefined;
    "info": boolean;
    "quiet": boolean;
    "debug": boolean;
    "force": boolean;
    "nthreads"?: number | null | undefined;
    "config"?: Array<MrregisterConfigParameters> | null | undefined;
    "help": boolean;
    "version": boolean;
    "image1_image2": InputPathType;
    "contrast1_contrast2"?: Array<InputPathType> | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "mrtrix.mrregister": mrregister_cargs,
        "mrtrix.mrregister.transformed": mrregister_transformed_cargs,
        "mrtrix.mrregister.transformed_midway": mrregister_transformed_midway_cargs,
        "mrtrix.mrregister.nl_warp": mrregister_nl_warp_cargs,
        "mrtrix.mrregister.config": mrregister_config_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "mrtrix.mrregister": mrregister_outputs,
        "mrtrix.mrregister.transformed": mrregister_transformed_outputs,
        "mrtrix.mrregister.transformed_midway": mrregister_transformed_midway_outputs,
        "mrtrix.mrregister.nl_warp": mrregister_nl_warp_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `Array<MrregisterTransformedParameters> | null(...)`.
 *
 * @interface
 */
interface MrregisterTransformedOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * image1 after registration transformed and regridded to the space of image2. Note that -transformed needs to be repeated for each contrast if multi-contrast registration is used.
     */
    image: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param image image1 after registration transformed and regridded to the space of image2. Note that -transformed needs to be repeated for each contrast if multi-contrast registration is used.
 *
 * @returns Parameter dictionary
 */
function mrregister_transformed_params(
    image: string,
): MrregisterTransformedParameters {
    const params = {
        "@type": "mrtrix.mrregister.transformed" as const,
        "image": image,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrregister_transformed_cargs(
    params: MrregisterTransformedParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-transformed");
    cargs.push((params["image"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mrregister_transformed_outputs(
    params: MrregisterTransformedParameters,
    execution: Execution,
): MrregisterTransformedOutputs {
    const ret: MrregisterTransformedOutputs = {
        root: execution.outputFile("."),
        image: execution.outputFile([(params["image"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `Array<MrregisterTransformedMidwayParameters> | null(...)`.
 *
 * @interface
 */
interface MrregisterTransformedMidwayOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * image1 and image2 after registration transformed and regridded to the midway space. Note that -transformed_midway needs to be repeated for each contrast if multi-contrast registration is used.
     */
    image1_transformed: OutputPathType;
    /**
     * image1 and image2 after registration transformed and regridded to the midway space. Note that -transformed_midway needs to be repeated for each contrast if multi-contrast registration is used.
     */
    image2_transformed: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param image1_transformed image1 and image2 after registration transformed and regridded to the midway space. Note that -transformed_midway needs to be repeated for each contrast if multi-contrast registration is used.
 * @param image2_transformed image1 and image2 after registration transformed and regridded to the midway space. Note that -transformed_midway needs to be repeated for each contrast if multi-contrast registration is used.
 *
 * @returns Parameter dictionary
 */
function mrregister_transformed_midway_params(
    image1_transformed: string,
    image2_transformed: string,
): MrregisterTransformedMidwayParameters {
    const params = {
        "@type": "mrtrix.mrregister.transformed_midway" as const,
        "image1_transformed": image1_transformed,
        "image2_transformed": image2_transformed,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrregister_transformed_midway_cargs(
    params: MrregisterTransformedMidwayParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-transformed_midway");
    cargs.push((params["image1_transformed"] ?? null));
    cargs.push((params["image2_transformed"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mrregister_transformed_midway_outputs(
    params: MrregisterTransformedMidwayParameters,
    execution: Execution,
): MrregisterTransformedMidwayOutputs {
    const ret: MrregisterTransformedMidwayOutputs = {
        root: execution.outputFile("."),
        image1_transformed: execution.outputFile([(params["image1_transformed"] ?? null)].join('')),
        image2_transformed: execution.outputFile([(params["image2_transformed"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Output object returned when calling `MrregisterNlWarpParameters | null(...)`.
 *
 * @interface
 */
interface MrregisterNlWarpOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the non-linear warp output defined as two deformation fields, where warp1 can be used to transform image1->image2 and warp2 to transform image2->image1. The deformation fields also encapsulate any linear transformation estimated prior to non-linear registration.
     */
    warp1: OutputPathType;
    /**
     * the non-linear warp output defined as two deformation fields, where warp1 can be used to transform image1->image2 and warp2 to transform image2->image1. The deformation fields also encapsulate any linear transformation estimated prior to non-linear registration.
     */
    warp2: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param warp1 the non-linear warp output defined as two deformation fields, where warp1 can be used to transform image1->image2 and warp2 to transform image2->image1. The deformation fields also encapsulate any linear transformation estimated prior to non-linear registration.
 * @param warp2 the non-linear warp output defined as two deformation fields, where warp1 can be used to transform image1->image2 and warp2 to transform image2->image1. The deformation fields also encapsulate any linear transformation estimated prior to non-linear registration.
 *
 * @returns Parameter dictionary
 */
function mrregister_nl_warp_params(
    warp1: string,
    warp2: string,
): MrregisterNlWarpParameters {
    const params = {
        "@type": "mrtrix.mrregister.nl_warp" as const,
        "warp1": warp1,
        "warp2": warp2,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrregister_nl_warp_cargs(
    params: MrregisterNlWarpParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-nl_warp");
    cargs.push((params["warp1"] ?? null));
    cargs.push((params["warp2"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mrregister_nl_warp_outputs(
    params: MrregisterNlWarpParameters,
    execution: Execution,
): MrregisterNlWarpOutputs {
    const ret: MrregisterNlWarpOutputs = {
        root: execution.outputFile("."),
        warp1: execution.outputFile([(params["warp1"] ?? null)].join('')),
        warp2: execution.outputFile([(params["warp2"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @param key temporarily set the value of an MRtrix config file entry.
 * @param value temporarily set the value of an MRtrix config file entry.
 *
 * @returns Parameter dictionary
 */
function mrregister_config_params(
    key: string,
    value: string,
): MrregisterConfigParameters {
    const params = {
        "@type": "mrtrix.mrregister.config" as const,
        "key": key,
        "value": value,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrregister_config_cargs(
    params: MrregisterConfigParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-config");
    cargs.push((params["key"] ?? null));
    cargs.push((params["value"] ?? null));
    return cargs;
}


/**
 * Output object returned when calling `mrregister(...)`.
 *
 * @interface
 */
interface MrregisterOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output text file containing the rigid transformation as a 4x4 matrix 
     */
    rigid: OutputPathType | null;
    /**
     * the output text file containing the rigid transformation that aligns image1 to image2 in their common midway space as a 4x4 matrix 
     */
    rigid_1tomidway: OutputPathType | null;
    /**
     * the output text file containing the rigid transformation that aligns image2 to image1 in their common midway space as a 4x4 matrix 
     */
    rigid_2tomidway: OutputPathType | null;
    /**
     * write gradient descent parameter evolution to log file 
     */
    rigid_log: OutputPathType | null;
    /**
     * the output text file containing the affine transformation as a 4x4 matrix 
     */
    affine: OutputPathType | null;
    /**
     * the output text file containing the affine transformation that aligns image1 to image2 in their common midway space as a 4x4 matrix 
     */
    affine_1tomidway: OutputPathType | null;
    /**
     * the output text file containing the affine transformation that aligns image2 to image1 in their common midway space as a 4x4 matrix 
     */
    affine_2tomidway: OutputPathType | null;
    /**
     * write gradient descent parameter evolution to log file 
     */
    affine_log: OutputPathType | null;
    /**
     * output all warps used during registration. This saves four different warps that map each image to a midway space and their inverses in a single 5D image file. The 4th image dimension indexes the x,y,z component of the deformation vector and the 5th dimension indexes the field in this order: image1->midway, midway->image1, image2->midway, midway->image2. Where image1->midway defines the field that maps image1 onto the midway space using the reverse convention When linear registration is performed first, the estimated linear transform will be included in the comments of the image header, and therefore the entire linear and non-linear transform can be applied (in either direction) using this output warp file with mrtransform 
     */
    nl_warp_full: OutputPathType | null;
    /**
     * Outputs from `mrregister_transformed_outputs`.This is a list of outputs with the same length and order as the inputs.
     */
    transformed: Array<MrregisterTransformedOutputs> | null;
    /**
     * Outputs from `mrregister_transformed_midway_outputs`.This is a list of outputs with the same length and order as the inputs.
     */
    transformed_midway: Array<MrregisterTransformedMidwayOutputs> | null;
    /**
     * Outputs from `mrregister_nl_warp_outputs`.
     */
    nl_warp: MrregisterNlWarpOutputs | null;
}


/**
 * Build parameters.
 *
 * @param image1_image2 input image 1 ('moving') and input image 2 ('template')
 * @param type_ the registration type. Valid choices are: rigid, affine, nonlinear, rigid_affine, rigid_nonlinear, affine_nonlinear, rigid_affine_nonlinear (Default: affine_nonlinear)
 * @param transformed image1 after registration transformed and regridded to the space of image2. Note that -transformed needs to be repeated for each contrast if multi-contrast registration is used.
 * @param transformed_midway image1 and image2 after registration transformed and regridded to the midway space. Note that -transformed_midway needs to be repeated for each contrast if multi-contrast registration is used.
 * @param mask1 a mask to define the region of image1 to use for optimisation.
 * @param mask2 a mask to define the region of image2 to use for optimisation.
 * @param nan use NaN as out of bounds value. (Default: 0.0)
 * @param rigid the output text file containing the rigid transformation as a 4x4 matrix
 * @param rigid_1tomidway the output text file containing the rigid transformation that aligns image1 to image2 in their common midway space as a 4x4 matrix
 * @param rigid_2tomidway the output text file containing the rigid transformation that aligns image2 to image1 in their common midway space as a 4x4 matrix
 * @param rigid_init_translation initialise the translation and centre of rotation 
Valid choices are: 
mass (aligns the centers of mass of both images, default), 
geometric (aligns geometric image centres) and none.
 * @param rigid_init_rotation initialise the rotation Valid choices are: 
search (search for the best rotation using mean squared residuals), 
moments (rotation based on directions of intensity variance with respect to centre of mass), 
none (default).
 * @param rigid_init_matrix initialise either the rigid, affine, or syn registration with the supplied rigid transformation (as a 4x4 matrix in scanner coordinates). Note that this overrides rigid_init_translation and rigid_init_rotation initialisation 
 * @param rigid_scale use a multi-resolution scheme by defining a scale factor for each level using comma separated values (Default: 0.25,0.5,1.0)
 * @param rigid_niter the maximum number of gradient descent iterations per stage. This can be specified either as a single number for all multi-resolution levels, or a single value for each level. (Default: 1000)
 * @param rigid_metric valid choices are: diff (intensity differences), Default: diff
 * @param rigid_metric_diff_estimator Valid choices are: l1 (least absolute: |x|), l2 (ordinary least squares), lp (least powers: |x|^1.2), Default: l2
 * @param rigid_lmax explicitly set the lmax to be used per scale factor in rigid FOD registration. By default FOD registration will use lmax 0,2,4 with default scale factors 0.25,0.5,1.0 respectively. Note that no reorientation will be performed with lmax = 0.
 * @param rigid_log write gradient descent parameter evolution to log file
 * @param affine the output text file containing the affine transformation as a 4x4 matrix
 * @param affine_1tomidway the output text file containing the affine transformation that aligns image1 to image2 in their common midway space as a 4x4 matrix
 * @param affine_2tomidway the output text file containing the affine transformation that aligns image2 to image1 in their common midway space as a 4x4 matrix
 * @param affine_init_translation initialise the translation and centre of rotation 
Valid choices are: 
mass (aligns the centers of mass of both images), 
geometric (aligns geometric image centres) and none. (Default: mass)
 * @param affine_init_rotation initialise the rotation Valid choices are: 
search (search for the best rotation using mean squared residuals), 
moments (rotation based on directions of intensity variance with respect to centre of mass), 
none (Default: none).
 * @param affine_init_matrix initialise either the affine, or syn registration with the supplied affine transformation (as a 4x4 matrix in scanner coordinates). Note that this overrides affine_init_translation and affine_init_rotation initialisation 
 * @param affine_scale use a multi-resolution scheme by defining a scale factor for each level using comma separated values (Default: 0.25,0.5,1.0)
 * @param affine_niter the maximum number of gradient descent iterations per stage. This can be specified either as a single number for all multi-resolution levels, or a single value for each level. (Default: 1000)
 * @param affine_metric valid choices are: diff (intensity differences), Default: diff
 * @param affine_metric_diff_estimator Valid choices are: l1 (least absolute: |x|), l2 (ordinary least squares), lp (least powers: |x|^1.2), Default: l2
 * @param affine_lmax explicitly set the lmax to be used per scale factor in affine FOD registration. By default FOD registration will use lmax 0,2,4 with default scale factors 0.25,0.5,1.0 respectively. Note that no reorientation will be performed with lmax = 0.
 * @param affine_log write gradient descent parameter evolution to log file
 * @param init_translation_unmasked1 disregard mask1 for the translation initialisation (affects 'mass')
 * @param init_translation_unmasked2 disregard mask2 for the translation initialisation (affects 'mass')
 * @param init_rotation_unmasked1 disregard mask1 for the rotation initialisation (affects 'search' and 'moments')
 * @param init_rotation_unmasked2 disregard mask2 for the rotation initialisation (affects 'search' and 'moments')
 * @param init_rotation_search_angles rotation angles for the local search in degrees between 0 and 180. (Default: 2,5,10,15,20)
 * @param init_rotation_search_scale relative size of the images used for the rotation search. (Default: 0.15)
 * @param init_rotation_search_directions number of rotation axis for local search. (Default: 250)
 * @param init_rotation_search_run_global perform a global search. (Default: local)
 * @param init_rotation_search_global_iterations number of rotations to investigate (Default: 10000)
 * @param linstage_iterations number of iterations for each registration stage, not to be confused with -rigid_niter or -affine_niter. This can be used to generate intermediate diagnostics images (-linstage.diagnostics.prefix) or to change the cost function optimiser during registration (without the need to repeatedly resize the images). (Default: 1 == no repetition)
 * @param linstage_optimiser_first Cost function optimisation algorithm to use at first iteration of all stages. Valid choices: bbgd (Barzilai-Borwein gradient descent) or gd (simple gradient descent). (Default: bbgd)
 * @param linstage_optimiser_last Cost function optimisation algorithm to use at last iteration of all stages (if there are more than one). Valid choices: bbgd (Barzilai-Borwein gradient descent) or gd (simple gradient descent). (Default: bbgd)
 * @param linstage_optimiser_default Cost function optimisation algorithm to use at any stage iteration other than first or last iteration. Valid choices: bbgd (Barzilai-Borwein gradient descent) or gd (simple gradient descent). (Default: bbgd)
 * @param linstage_diagnostics_prefix generate diagnostics images after every registration stage
 * @param nl_warp the non-linear warp output defined as two deformation fields, where warp1 can be used to transform image1->image2 and warp2 to transform image2->image1. The deformation fields also encapsulate any linear transformation estimated prior to non-linear registration.
 * @param nl_warp_full output all warps used during registration. This saves four different warps that map each image to a midway space and their inverses in a single 5D image file. The 4th image dimension indexes the x,y,z component of the deformation vector and the 5th dimension indexes the field in this order: image1->midway, midway->image1, image2->midway, midway->image2. Where image1->midway defines the field that maps image1 onto the midway space using the reverse convention When linear registration is performed first, the estimated linear transform will be included in the comments of the image header, and therefore the entire linear and non-linear transform can be applied (in either direction) using this output warp file with mrtransform
 * @param nl_init initialise the non-linear registration with the supplied warp image. The supplied warp must be in the same format as output using the -nl_warp_full option (i.e. have 4 deformation fields with the linear transforms in the image header)
 * @param nl_scale use a multi-resolution scheme by defining a scale factor for each level using comma separated values (Default: 0.25,0.5,1.0)
 * @param nl_niter the maximum number of iterations. This can be specified either as a single number for all multi-resolution levels, or a single value for each level. (Default: 50)
 * @param nl_update_smooth regularise the gradient update field with Gaussian smoothing (standard deviation in voxel units, Default 2.0)
 * @param nl_disp_smooth regularise the displacement field with Gaussian smoothing (standard deviation in voxel units, Default 1.0)
 * @param nl_grad_step the gradient step size for non-linear registration (Default: 0.5)
 * @param nl_lmax explicitly set the lmax to be used per scale factor in non-linear FOD registration. By default FOD registration will use lmax 0,2,4 with default scale factors 0.25,0.5,1.0 respectively. Note that no reorientation will be performed with lmax = 0.
 * @param diagnostics_image write intermediate images for diagnostics purposes
 * @param directions the directions used for FOD reorientation using apodised point spread functions (Default: 60 directions)
 * @param noreorientation turn off FOD reorientation. Reorientation is on by default if the number of volumes in the 4th dimension corresponds to the number of coefficients in an antipodally symmetric spherical harmonic series (i.e. 6, 15, 28, 45, 66 etc)
 * @param mc_weights relative weight of images used for multi-contrast registration. Default: 1.0 (equal weighting)
 * @param datatype specify output image data type. Valid choices are: float32, float32le, float32be, float64, float64le, float64be, int64, uint64, int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le, int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be, cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be, int8, uint8, bit.
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 * @param contrast1_contrast2 optional list of additional input images used as additional contrasts. Can be used multiple times. contrastX and imageX must share the same coordinate system. 
 *
 * @returns Parameter dictionary
 */
function mrregister_params(
    image1_image2: InputPathType,
    type_: string | null = null,
    transformed: Array<MrregisterTransformedParameters> | null = null,
    transformed_midway: Array<MrregisterTransformedMidwayParameters> | null = null,
    mask1: InputPathType | null = null,
    mask2: InputPathType | null = null,
    nan: boolean = false,
    rigid: string | null = null,
    rigid_1tomidway: string | null = null,
    rigid_2tomidway: string | null = null,
    rigid_init_translation: string | null = null,
    rigid_init_rotation: string | null = null,
    rigid_init_matrix: InputPathType | null = null,
    rigid_scale: Array<number> | null = null,
    rigid_niter: Array<number> | null = null,
    rigid_metric: string | null = null,
    rigid_metric_diff_estimator: string | null = null,
    rigid_lmax: Array<number> | null = null,
    rigid_log: string | null = null,
    affine: string | null = null,
    affine_1tomidway: string | null = null,
    affine_2tomidway: string | null = null,
    affine_init_translation: string | null = null,
    affine_init_rotation: string | null = null,
    affine_init_matrix: InputPathType | null = null,
    affine_scale: Array<number> | null = null,
    affine_niter: Array<number> | null = null,
    affine_metric: string | null = null,
    affine_metric_diff_estimator: string | null = null,
    affine_lmax: Array<number> | null = null,
    affine_log: string | null = null,
    init_translation_unmasked1: boolean = false,
    init_translation_unmasked2: boolean = false,
    init_rotation_unmasked1: boolean = false,
    init_rotation_unmasked2: boolean = false,
    init_rotation_search_angles: Array<number> | null = null,
    init_rotation_search_scale: number | null = null,
    init_rotation_search_directions: number | null = null,
    init_rotation_search_run_global: boolean = false,
    init_rotation_search_global_iterations: number | null = null,
    linstage_iterations: Array<number> | null = null,
    linstage_optimiser_first: string | null = null,
    linstage_optimiser_last: string | null = null,
    linstage_optimiser_default: string | null = null,
    linstage_diagnostics_prefix: string | null = null,
    nl_warp: MrregisterNlWarpParameters | null = null,
    nl_warp_full: string | null = null,
    nl_init: InputPathType | null = null,
    nl_scale: Array<number> | null = null,
    nl_niter: Array<number> | null = null,
    nl_update_smooth: number | null = null,
    nl_disp_smooth: number | null = null,
    nl_grad_step: number | null = null,
    nl_lmax: Array<number> | null = null,
    diagnostics_image: string | null = null,
    directions: InputPathType | null = null,
    noreorientation: boolean = false,
    mc_weights: Array<number> | null = null,
    datatype: string | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<MrregisterConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
    contrast1_contrast2: Array<InputPathType> | null = null,
): MrregisterParameters {
    const params = {
        "@type": "mrtrix.mrregister" as const,
        "nan": nan,
        "init_translation_unmasked1": init_translation_unmasked1,
        "init_translation_unmasked2": init_translation_unmasked2,
        "init_rotation_unmasked1": init_rotation_unmasked1,
        "init_rotation_unmasked2": init_rotation_unmasked2,
        "init_rotation_search_run_global": init_rotation_search_run_global,
        "noreorientation": noreorientation,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help,
        "version": version,
        "image1_image2": image1_image2,
    };
    if (type_ !== null) {
        params["type"] = type_;
    }
    if (transformed !== null) {
        params["transformed"] = transformed;
    }
    if (transformed_midway !== null) {
        params["transformed_midway"] = transformed_midway;
    }
    if (mask1 !== null) {
        params["mask1"] = mask1;
    }
    if (mask2 !== null) {
        params["mask2"] = mask2;
    }
    if (rigid !== null) {
        params["rigid"] = rigid;
    }
    if (rigid_1tomidway !== null) {
        params["rigid_1tomidway"] = rigid_1tomidway;
    }
    if (rigid_2tomidway !== null) {
        params["rigid_2tomidway"] = rigid_2tomidway;
    }
    if (rigid_init_translation !== null) {
        params["rigid_init_translation"] = rigid_init_translation;
    }
    if (rigid_init_rotation !== null) {
        params["rigid_init_rotation"] = rigid_init_rotation;
    }
    if (rigid_init_matrix !== null) {
        params["rigid_init_matrix"] = rigid_init_matrix;
    }
    if (rigid_scale !== null) {
        params["rigid_scale"] = rigid_scale;
    }
    if (rigid_niter !== null) {
        params["rigid_niter"] = rigid_niter;
    }
    if (rigid_metric !== null) {
        params["rigid_metric"] = rigid_metric;
    }
    if (rigid_metric_diff_estimator !== null) {
        params["rigid_metric_diff_estimator"] = rigid_metric_diff_estimator;
    }
    if (rigid_lmax !== null) {
        params["rigid_lmax"] = rigid_lmax;
    }
    if (rigid_log !== null) {
        params["rigid_log"] = rigid_log;
    }
    if (affine !== null) {
        params["affine"] = affine;
    }
    if (affine_1tomidway !== null) {
        params["affine_1tomidway"] = affine_1tomidway;
    }
    if (affine_2tomidway !== null) {
        params["affine_2tomidway"] = affine_2tomidway;
    }
    if (affine_init_translation !== null) {
        params["affine_init_translation"] = affine_init_translation;
    }
    if (affine_init_rotation !== null) {
        params["affine_init_rotation"] = affine_init_rotation;
    }
    if (affine_init_matrix !== null) {
        params["affine_init_matrix"] = affine_init_matrix;
    }
    if (affine_scale !== null) {
        params["affine_scale"] = affine_scale;
    }
    if (affine_niter !== null) {
        params["affine_niter"] = affine_niter;
    }
    if (affine_metric !== null) {
        params["affine_metric"] = affine_metric;
    }
    if (affine_metric_diff_estimator !== null) {
        params["affine_metric_diff_estimator"] = affine_metric_diff_estimator;
    }
    if (affine_lmax !== null) {
        params["affine_lmax"] = affine_lmax;
    }
    if (affine_log !== null) {
        params["affine_log"] = affine_log;
    }
    if (init_rotation_search_angles !== null) {
        params["init_rotation_search_angles"] = init_rotation_search_angles;
    }
    if (init_rotation_search_scale !== null) {
        params["init_rotation_search_scale"] = init_rotation_search_scale;
    }
    if (init_rotation_search_directions !== null) {
        params["init_rotation_search_directions"] = init_rotation_search_directions;
    }
    if (init_rotation_search_global_iterations !== null) {
        params["init_rotation_search_global_iterations"] = init_rotation_search_global_iterations;
    }
    if (linstage_iterations !== null) {
        params["linstage_iterations"] = linstage_iterations;
    }
    if (linstage_optimiser_first !== null) {
        params["linstage_optimiser_first"] = linstage_optimiser_first;
    }
    if (linstage_optimiser_last !== null) {
        params["linstage_optimiser_last"] = linstage_optimiser_last;
    }
    if (linstage_optimiser_default !== null) {
        params["linstage_optimiser_default"] = linstage_optimiser_default;
    }
    if (linstage_diagnostics_prefix !== null) {
        params["linstage_diagnostics_prefix"] = linstage_diagnostics_prefix;
    }
    if (nl_warp !== null) {
        params["nl_warp"] = nl_warp;
    }
    if (nl_warp_full !== null) {
        params["nl_warp_full"] = nl_warp_full;
    }
    if (nl_init !== null) {
        params["nl_init"] = nl_init;
    }
    if (nl_scale !== null) {
        params["nl_scale"] = nl_scale;
    }
    if (nl_niter !== null) {
        params["nl_niter"] = nl_niter;
    }
    if (nl_update_smooth !== null) {
        params["nl_update_smooth"] = nl_update_smooth;
    }
    if (nl_disp_smooth !== null) {
        params["nl_disp_smooth"] = nl_disp_smooth;
    }
    if (nl_grad_step !== null) {
        params["nl_grad_step"] = nl_grad_step;
    }
    if (nl_lmax !== null) {
        params["nl_lmax"] = nl_lmax;
    }
    if (diagnostics_image !== null) {
        params["diagnostics_image"] = diagnostics_image;
    }
    if (directions !== null) {
        params["directions"] = directions;
    }
    if (mc_weights !== null) {
        params["mc_weights"] = mc_weights;
    }
    if (datatype !== null) {
        params["datatype"] = datatype;
    }
    if (nthreads !== null) {
        params["nthreads"] = nthreads;
    }
    if (config !== null) {
        params["config"] = config;
    }
    if (contrast1_contrast2 !== null) {
        params["contrast1_contrast2"] = contrast1_contrast2;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrregister_cargs(
    params: MrregisterParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mrregister");
    if ((params["type"] ?? null) !== null) {
        cargs.push(
            "-type",
            (params["type"] ?? null)
        );
    }
    if ((params["transformed"] ?? null) !== null) {
        cargs.push(...(params["transformed"] ?? null).map(s => dynCargs(s["@type"])(s, execution)).flat());
    }
    if ((params["transformed_midway"] ?? null) !== null) {
        cargs.push(...(params["transformed_midway"] ?? null).map(s => dynCargs(s["@type"])(s, execution)).flat());
    }
    if ((params["mask1"] ?? null) !== null) {
        cargs.push(
            "-mask1",
            execution.inputFile((params["mask1"] ?? null))
        );
    }
    if ((params["mask2"] ?? null) !== null) {
        cargs.push(
            "-mask2",
            execution.inputFile((params["mask2"] ?? null))
        );
    }
    if ((params["nan"] ?? null)) {
        cargs.push("-nan");
    }
    if ((params["rigid"] ?? null) !== null) {
        cargs.push(
            "-rigid",
            (params["rigid"] ?? null)
        );
    }
    if ((params["rigid_1tomidway"] ?? null) !== null) {
        cargs.push(
            "-rigid_1tomidway",
            (params["rigid_1tomidway"] ?? null)
        );
    }
    if ((params["rigid_2tomidway"] ?? null) !== null) {
        cargs.push(
            "-rigid_2tomidway",
            (params["rigid_2tomidway"] ?? null)
        );
    }
    if ((params["rigid_init_translation"] ?? null) !== null) {
        cargs.push(
            "-rigid_init_translation",
            (params["rigid_init_translation"] ?? null)
        );
    }
    if ((params["rigid_init_rotation"] ?? null) !== null) {
        cargs.push(
            "-rigid_init_rotation",
            (params["rigid_init_rotation"] ?? null)
        );
    }
    if ((params["rigid_init_matrix"] ?? null) !== null) {
        cargs.push(
            "-rigid_init_matrix",
            execution.inputFile((params["rigid_init_matrix"] ?? null))
        );
    }
    if ((params["rigid_scale"] ?? null) !== null) {
        cargs.push(
            "-rigid_scale",
            ...(params["rigid_scale"] ?? null).map(String)
        );
    }
    if ((params["rigid_niter"] ?? null) !== null) {
        cargs.push(
            "-rigid_niter",
            ...(params["rigid_niter"] ?? null).map(String)
        );
    }
    if ((params["rigid_metric"] ?? null) !== null) {
        cargs.push(
            "-rigid_metric",
            (params["rigid_metric"] ?? null)
        );
    }
    if ((params["rigid_metric_diff_estimator"] ?? null) !== null) {
        cargs.push(
            "-rigid_metric.diff.estimator",
            (params["rigid_metric_diff_estimator"] ?? null)
        );
    }
    if ((params["rigid_lmax"] ?? null) !== null) {
        cargs.push(
            "-rigid_lmax",
            ...(params["rigid_lmax"] ?? null).map(String)
        );
    }
    if ((params["rigid_log"] ?? null) !== null) {
        cargs.push(
            "-rigid_log",
            (params["rigid_log"] ?? null)
        );
    }
    if ((params["affine"] ?? null) !== null) {
        cargs.push(
            "-affine",
            (params["affine"] ?? null)
        );
    }
    if ((params["affine_1tomidway"] ?? null) !== null) {
        cargs.push(
            "-affine_1tomidway",
            (params["affine_1tomidway"] ?? null)
        );
    }
    if ((params["affine_2tomidway"] ?? null) !== null) {
        cargs.push(
            "-affine_2tomidway",
            (params["affine_2tomidway"] ?? null)
        );
    }
    if ((params["affine_init_translation"] ?? null) !== null) {
        cargs.push(
            "-affine_init_translation",
            (params["affine_init_translation"] ?? null)
        );
    }
    if ((params["affine_init_rotation"] ?? null) !== null) {
        cargs.push(
            "-affine_init_rotation",
            (params["affine_init_rotation"] ?? null)
        );
    }
    if ((params["affine_init_matrix"] ?? null) !== null) {
        cargs.push(
            "-affine_init_matrix",
            execution.inputFile((params["affine_init_matrix"] ?? null))
        );
    }
    if ((params["affine_scale"] ?? null) !== null) {
        cargs.push(
            "-affine_scale",
            ...(params["affine_scale"] ?? null).map(String)
        );
    }
    if ((params["affine_niter"] ?? null) !== null) {
        cargs.push(
            "-affine_niter",
            ...(params["affine_niter"] ?? null).map(String)
        );
    }
    if ((params["affine_metric"] ?? null) !== null) {
        cargs.push(
            "-affine_metric",
            (params["affine_metric"] ?? null)
        );
    }
    if ((params["affine_metric_diff_estimator"] ?? null) !== null) {
        cargs.push(
            "-affine_metric.diff.estimator",
            (params["affine_metric_diff_estimator"] ?? null)
        );
    }
    if ((params["affine_lmax"] ?? null) !== null) {
        cargs.push(
            "-affine_lmax",
            ...(params["affine_lmax"] ?? null).map(String)
        );
    }
    if ((params["affine_log"] ?? null) !== null) {
        cargs.push(
            "-affine_log",
            (params["affine_log"] ?? null)
        );
    }
    if ((params["init_translation_unmasked1"] ?? null)) {
        cargs.push("-init_translation.unmasked1");
    }
    if ((params["init_translation_unmasked2"] ?? null)) {
        cargs.push("-init_translation.unmasked2");
    }
    if ((params["init_rotation_unmasked1"] ?? null)) {
        cargs.push("-init_rotation.unmasked1");
    }
    if ((params["init_rotation_unmasked2"] ?? null)) {
        cargs.push("-init_rotation.unmasked2");
    }
    if ((params["init_rotation_search_angles"] ?? null) !== null) {
        cargs.push(
            "-init_rotation.search.angles",
            ...(params["init_rotation_search_angles"] ?? null).map(String)
        );
    }
    if ((params["init_rotation_search_scale"] ?? null) !== null) {
        cargs.push(
            "-init_rotation.search.scale",
            String((params["init_rotation_search_scale"] ?? null))
        );
    }
    if ((params["init_rotation_search_directions"] ?? null) !== null) {
        cargs.push(
            "-init_rotation.search.directions",
            String((params["init_rotation_search_directions"] ?? null))
        );
    }
    if ((params["init_rotation_search_run_global"] ?? null)) {
        cargs.push("-init_rotation.search.run_global");
    }
    if ((params["init_rotation_search_global_iterations"] ?? null) !== null) {
        cargs.push(
            "-init_rotation.search.global.iterations",
            String((params["init_rotation_search_global_iterations"] ?? null))
        );
    }
    if ((params["linstage_iterations"] ?? null) !== null) {
        cargs.push(
            "-linstage.iterations",
            ...(params["linstage_iterations"] ?? null).map(String)
        );
    }
    if ((params["linstage_optimiser_first"] ?? null) !== null) {
        cargs.push(
            "-linstage.optimiser.first",
            (params["linstage_optimiser_first"] ?? null)
        );
    }
    if ((params["linstage_optimiser_last"] ?? null) !== null) {
        cargs.push(
            "-linstage.optimiser.last",
            (params["linstage_optimiser_last"] ?? null)
        );
    }
    if ((params["linstage_optimiser_default"] ?? null) !== null) {
        cargs.push(
            "-linstage.optimiser.default",
            (params["linstage_optimiser_default"] ?? null)
        );
    }
    if ((params["linstage_diagnostics_prefix"] ?? null) !== null) {
        cargs.push(
            "-linstage.diagnostics.prefix",
            (params["linstage_diagnostics_prefix"] ?? null)
        );
    }
    if ((params["nl_warp"] ?? null) !== null) {
        cargs.push(...dynCargs((params["nl_warp"] ?? null)["@type"])((params["nl_warp"] ?? null), execution));
    }
    if ((params["nl_warp_full"] ?? null) !== null) {
        cargs.push(
            "-nl_warp_full",
            (params["nl_warp_full"] ?? null)
        );
    }
    if ((params["nl_init"] ?? null) !== null) {
        cargs.push(
            "-nl_init",
            execution.inputFile((params["nl_init"] ?? null))
        );
    }
    if ((params["nl_scale"] ?? null) !== null) {
        cargs.push(
            "-nl_scale",
            ...(params["nl_scale"] ?? null).map(String)
        );
    }
    if ((params["nl_niter"] ?? null) !== null) {
        cargs.push(
            "-nl_niter",
            ...(params["nl_niter"] ?? null).map(String)
        );
    }
    if ((params["nl_update_smooth"] ?? null) !== null) {
        cargs.push(
            "-nl_update_smooth",
            String((params["nl_update_smooth"] ?? null))
        );
    }
    if ((params["nl_disp_smooth"] ?? null) !== null) {
        cargs.push(
            "-nl_disp_smooth",
            String((params["nl_disp_smooth"] ?? null))
        );
    }
    if ((params["nl_grad_step"] ?? null) !== null) {
        cargs.push(
            "-nl_grad_step",
            String((params["nl_grad_step"] ?? null))
        );
    }
    if ((params["nl_lmax"] ?? null) !== null) {
        cargs.push(
            "-nl_lmax",
            ...(params["nl_lmax"] ?? null).map(String)
        );
    }
    if ((params["diagnostics_image"] ?? null) !== null) {
        cargs.push(
            "-diagnostics_image",
            (params["diagnostics_image"] ?? null)
        );
    }
    if ((params["directions"] ?? null) !== null) {
        cargs.push(
            "-directions",
            execution.inputFile((params["directions"] ?? null))
        );
    }
    if ((params["noreorientation"] ?? null)) {
        cargs.push("-noreorientation");
    }
    if ((params["mc_weights"] ?? null) !== null) {
        cargs.push(
            "-mc_weights",
            ...(params["mc_weights"] ?? null).map(String)
        );
    }
    if ((params["datatype"] ?? null) !== null) {
        cargs.push(
            "-datatype",
            (params["datatype"] ?? null)
        );
    }
    if ((params["info"] ?? null)) {
        cargs.push("-info");
    }
    if ((params["quiet"] ?? null)) {
        cargs.push("-quiet");
    }
    if ((params["debug"] ?? null)) {
        cargs.push("-debug");
    }
    if ((params["force"] ?? null)) {
        cargs.push("-force");
    }
    if ((params["nthreads"] ?? null) !== null) {
        cargs.push(
            "-nthreads",
            String((params["nthreads"] ?? null))
        );
    }
    if ((params["config"] ?? null) !== null) {
        cargs.push(...(params["config"] ?? null).map(s => dynCargs(s["@type"])(s, execution)).flat());
    }
    if ((params["help"] ?? null)) {
        cargs.push("-help");
    }
    if ((params["version"] ?? null)) {
        cargs.push("-version");
    }
    cargs.push(execution.inputFile((params["image1_image2"] ?? null)));
    if ((params["contrast1_contrast2"] ?? null) !== null) {
        cargs.push(...(params["contrast1_contrast2"] ?? null).map(f => execution.inputFile(f)));
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mrregister_outputs(
    params: MrregisterParameters,
    execution: Execution,
): MrregisterOutputs {
    const ret: MrregisterOutputs = {
        root: execution.outputFile("."),
        rigid: ((params["rigid"] ?? null) !== null) ? execution.outputFile([(params["rigid"] ?? null)].join('')) : null,
        rigid_1tomidway: ((params["rigid_1tomidway"] ?? null) !== null) ? execution.outputFile([(params["rigid_1tomidway"] ?? null)].join('')) : null,
        rigid_2tomidway: ((params["rigid_2tomidway"] ?? null) !== null) ? execution.outputFile([(params["rigid_2tomidway"] ?? null)].join('')) : null,
        rigid_log: ((params["rigid_log"] ?? null) !== null) ? execution.outputFile([(params["rigid_log"] ?? null)].join('')) : null,
        affine: ((params["affine"] ?? null) !== null) ? execution.outputFile([(params["affine"] ?? null)].join('')) : null,
        affine_1tomidway: ((params["affine_1tomidway"] ?? null) !== null) ? execution.outputFile([(params["affine_1tomidway"] ?? null)].join('')) : null,
        affine_2tomidway: ((params["affine_2tomidway"] ?? null) !== null) ? execution.outputFile([(params["affine_2tomidway"] ?? null)].join('')) : null,
        affine_log: ((params["affine_log"] ?? null) !== null) ? execution.outputFile([(params["affine_log"] ?? null)].join('')) : null,
        nl_warp_full: ((params["nl_warp_full"] ?? null) !== null) ? execution.outputFile([(params["nl_warp_full"] ?? null)].join('')) : null,
        transformed: ((params["transformed"] ?? null).map(i => dynOutputs(i["@type"])?.(i, execution) ?? null) ?? null),
        transformed_midway: ((params["transformed_midway"] ?? null).map(i => dynOutputs(i["@type"])?.(i, execution) ?? null) ?? null),
        nl_warp: (dynOutputs((params["nl_warp"] ?? null)["@type"])?.((params["nl_warp"] ?? null), execution) ?? null),
    };
    return ret;
}


/**
 * Register two images together using a symmetric rigid, affine or non-linear transformation model.
 *
 * By default this application will perform an affine, followed by non-linear registration.
 *
 * FOD registration (with apodised point spread reorientation) will be performed by default if the number of volumes in the 4th dimension equals the number of coefficients in an antipodally symmetric spherical harmonic series (e.g. 6, 15, 28 etc). The -no_reorientation option can be used to force reorientation off if required.
 *
 * Non-linear registration computes warps to map from both image1->image2 and image2->image1. Similar to Avants (2008) Med Image Anal. 12(1): 26â€“41, registration is performed by matching both the image1 and image2 in a 'midway space'. Warps can be saved as two deformation fields that map directly between image1->image2 and image2->image1, or if using -nl_warp_full as a single 5D file that stores all 4 warps image1->mid->image2, and image2->mid->image1. The 5D warp format stores x,y,z deformations in the 4th dimension, and uses the 5th dimension to index the 4 warps. The affine transforms estimated (to midway space) are also stored as comments in the image header. The 5D warp file can be used to reinitialise subsequent registrations, in addition to transforming images to midway space (e.g. for intra-subject alignment in a 2-time-point longitudinal analysis).
 *
 * References:
 *
 * * If FOD registration is being performed:
 * Raffelt, D.; Tournier, J.-D.; Fripp, J; Crozier, S.; Connelly, A. & Salvado, O. Symmetric diffeomorphic registration of fibre orientation distributions. NeuroImage, 2011, 56(3), 1171-1180
 *
 * Raffelt, D.; Tournier, J.-D.; Crozier, S.; Connelly, A. & Salvado, O. Reorientation of fiber orientation distributions using apodized point spread functions. Magnetic Resonance in Medicine, 2012, 67, 844-855.
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param params The parameters.
 * @param execution The execution object.
 *
 * @returns NamedTuple of outputs (described in `MrregisterOutputs`).
 */
function mrregister_execute(
    params: MrregisterParameters,
    execution: Execution,
): MrregisterOutputs {
    params = execution.params(params)
    const cargs = mrregister_cargs(params, execution)
    const ret = mrregister_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * Register two images together using a symmetric rigid, affine or non-linear transformation model.
 *
 * By default this application will perform an affine, followed by non-linear registration.
 *
 * FOD registration (with apodised point spread reorientation) will be performed by default if the number of volumes in the 4th dimension equals the number of coefficients in an antipodally symmetric spherical harmonic series (e.g. 6, 15, 28 etc). The -no_reorientation option can be used to force reorientation off if required.
 *
 * Non-linear registration computes warps to map from both image1->image2 and image2->image1. Similar to Avants (2008) Med Image Anal. 12(1): 26â€“41, registration is performed by matching both the image1 and image2 in a 'midway space'. Warps can be saved as two deformation fields that map directly between image1->image2 and image2->image1, or if using -nl_warp_full as a single 5D file that stores all 4 warps image1->mid->image2, and image2->mid->image1. The 5D warp format stores x,y,z deformations in the 4th dimension, and uses the 5th dimension to index the 4 warps. The affine transforms estimated (to midway space) are also stored as comments in the image header. The 5D warp file can be used to reinitialise subsequent registrations, in addition to transforming images to midway space (e.g. for intra-subject alignment in a 2-time-point longitudinal analysis).
 *
 * References:
 *
 * * If FOD registration is being performed:
 * Raffelt, D.; Tournier, J.-D.; Fripp, J; Crozier, S.; Connelly, A. & Salvado, O. Symmetric diffeomorphic registration of fibre orientation distributions. NeuroImage, 2011, 56(3), 1171-1180
 *
 * Raffelt, D.; Tournier, J.-D.; Crozier, S.; Connelly, A. & Salvado, O. Reorientation of fiber orientation distributions using apodized point spread functions. Magnetic Resonance in Medicine, 2012, 67, 844-855.
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param image1_image2 input image 1 ('moving') and input image 2 ('template')
 * @param type_ the registration type. Valid choices are: rigid, affine, nonlinear, rigid_affine, rigid_nonlinear, affine_nonlinear, rigid_affine_nonlinear (Default: affine_nonlinear)
 * @param transformed image1 after registration transformed and regridded to the space of image2. Note that -transformed needs to be repeated for each contrast if multi-contrast registration is used.
 * @param transformed_midway image1 and image2 after registration transformed and regridded to the midway space. Note that -transformed_midway needs to be repeated for each contrast if multi-contrast registration is used.
 * @param mask1 a mask to define the region of image1 to use for optimisation.
 * @param mask2 a mask to define the region of image2 to use for optimisation.
 * @param nan use NaN as out of bounds value. (Default: 0.0)
 * @param rigid the output text file containing the rigid transformation as a 4x4 matrix
 * @param rigid_1tomidway the output text file containing the rigid transformation that aligns image1 to image2 in their common midway space as a 4x4 matrix
 * @param rigid_2tomidway the output text file containing the rigid transformation that aligns image2 to image1 in their common midway space as a 4x4 matrix
 * @param rigid_init_translation initialise the translation and centre of rotation 
Valid choices are: 
mass (aligns the centers of mass of both images, default), 
geometric (aligns geometric image centres) and none.
 * @param rigid_init_rotation initialise the rotation Valid choices are: 
search (search for the best rotation using mean squared residuals), 
moments (rotation based on directions of intensity variance with respect to centre of mass), 
none (default).
 * @param rigid_init_matrix initialise either the rigid, affine, or syn registration with the supplied rigid transformation (as a 4x4 matrix in scanner coordinates). Note that this overrides rigid_init_translation and rigid_init_rotation initialisation 
 * @param rigid_scale use a multi-resolution scheme by defining a scale factor for each level using comma separated values (Default: 0.25,0.5,1.0)
 * @param rigid_niter the maximum number of gradient descent iterations per stage. This can be specified either as a single number for all multi-resolution levels, or a single value for each level. (Default: 1000)
 * @param rigid_metric valid choices are: diff (intensity differences), Default: diff
 * @param rigid_metric_diff_estimator Valid choices are: l1 (least absolute: |x|), l2 (ordinary least squares), lp (least powers: |x|^1.2), Default: l2
 * @param rigid_lmax explicitly set the lmax to be used per scale factor in rigid FOD registration. By default FOD registration will use lmax 0,2,4 with default scale factors 0.25,0.5,1.0 respectively. Note that no reorientation will be performed with lmax = 0.
 * @param rigid_log write gradient descent parameter evolution to log file
 * @param affine the output text file containing the affine transformation as a 4x4 matrix
 * @param affine_1tomidway the output text file containing the affine transformation that aligns image1 to image2 in their common midway space as a 4x4 matrix
 * @param affine_2tomidway the output text file containing the affine transformation that aligns image2 to image1 in their common midway space as a 4x4 matrix
 * @param affine_init_translation initialise the translation and centre of rotation 
Valid choices are: 
mass (aligns the centers of mass of both images), 
geometric (aligns geometric image centres) and none. (Default: mass)
 * @param affine_init_rotation initialise the rotation Valid choices are: 
search (search for the best rotation using mean squared residuals), 
moments (rotation based on directions of intensity variance with respect to centre of mass), 
none (Default: none).
 * @param affine_init_matrix initialise either the affine, or syn registration with the supplied affine transformation (as a 4x4 matrix in scanner coordinates). Note that this overrides affine_init_translation and affine_init_rotation initialisation 
 * @param affine_scale use a multi-resolution scheme by defining a scale factor for each level using comma separated values (Default: 0.25,0.5,1.0)
 * @param affine_niter the maximum number of gradient descent iterations per stage. This can be specified either as a single number for all multi-resolution levels, or a single value for each level. (Default: 1000)
 * @param affine_metric valid choices are: diff (intensity differences), Default: diff
 * @param affine_metric_diff_estimator Valid choices are: l1 (least absolute: |x|), l2 (ordinary least squares), lp (least powers: |x|^1.2), Default: l2
 * @param affine_lmax explicitly set the lmax to be used per scale factor in affine FOD registration. By default FOD registration will use lmax 0,2,4 with default scale factors 0.25,0.5,1.0 respectively. Note that no reorientation will be performed with lmax = 0.
 * @param affine_log write gradient descent parameter evolution to log file
 * @param init_translation_unmasked1 disregard mask1 for the translation initialisation (affects 'mass')
 * @param init_translation_unmasked2 disregard mask2 for the translation initialisation (affects 'mass')
 * @param init_rotation_unmasked1 disregard mask1 for the rotation initialisation (affects 'search' and 'moments')
 * @param init_rotation_unmasked2 disregard mask2 for the rotation initialisation (affects 'search' and 'moments')
 * @param init_rotation_search_angles rotation angles for the local search in degrees between 0 and 180. (Default: 2,5,10,15,20)
 * @param init_rotation_search_scale relative size of the images used for the rotation search. (Default: 0.15)
 * @param init_rotation_search_directions number of rotation axis for local search. (Default: 250)
 * @param init_rotation_search_run_global perform a global search. (Default: local)
 * @param init_rotation_search_global_iterations number of rotations to investigate (Default: 10000)
 * @param linstage_iterations number of iterations for each registration stage, not to be confused with -rigid_niter or -affine_niter. This can be used to generate intermediate diagnostics images (-linstage.diagnostics.prefix) or to change the cost function optimiser during registration (without the need to repeatedly resize the images). (Default: 1 == no repetition)
 * @param linstage_optimiser_first Cost function optimisation algorithm to use at first iteration of all stages. Valid choices: bbgd (Barzilai-Borwein gradient descent) or gd (simple gradient descent). (Default: bbgd)
 * @param linstage_optimiser_last Cost function optimisation algorithm to use at last iteration of all stages (if there are more than one). Valid choices: bbgd (Barzilai-Borwein gradient descent) or gd (simple gradient descent). (Default: bbgd)
 * @param linstage_optimiser_default Cost function optimisation algorithm to use at any stage iteration other than first or last iteration. Valid choices: bbgd (Barzilai-Borwein gradient descent) or gd (simple gradient descent). (Default: bbgd)
 * @param linstage_diagnostics_prefix generate diagnostics images after every registration stage
 * @param nl_warp the non-linear warp output defined as two deformation fields, where warp1 can be used to transform image1->image2 and warp2 to transform image2->image1. The deformation fields also encapsulate any linear transformation estimated prior to non-linear registration.
 * @param nl_warp_full output all warps used during registration. This saves four different warps that map each image to a midway space and their inverses in a single 5D image file. The 4th image dimension indexes the x,y,z component of the deformation vector and the 5th dimension indexes the field in this order: image1->midway, midway->image1, image2->midway, midway->image2. Where image1->midway defines the field that maps image1 onto the midway space using the reverse convention When linear registration is performed first, the estimated linear transform will be included in the comments of the image header, and therefore the entire linear and non-linear transform can be applied (in either direction) using this output warp file with mrtransform
 * @param nl_init initialise the non-linear registration with the supplied warp image. The supplied warp must be in the same format as output using the -nl_warp_full option (i.e. have 4 deformation fields with the linear transforms in the image header)
 * @param nl_scale use a multi-resolution scheme by defining a scale factor for each level using comma separated values (Default: 0.25,0.5,1.0)
 * @param nl_niter the maximum number of iterations. This can be specified either as a single number for all multi-resolution levels, or a single value for each level. (Default: 50)
 * @param nl_update_smooth regularise the gradient update field with Gaussian smoothing (standard deviation in voxel units, Default 2.0)
 * @param nl_disp_smooth regularise the displacement field with Gaussian smoothing (standard deviation in voxel units, Default 1.0)
 * @param nl_grad_step the gradient step size for non-linear registration (Default: 0.5)
 * @param nl_lmax explicitly set the lmax to be used per scale factor in non-linear FOD registration. By default FOD registration will use lmax 0,2,4 with default scale factors 0.25,0.5,1.0 respectively. Note that no reorientation will be performed with lmax = 0.
 * @param diagnostics_image write intermediate images for diagnostics purposes
 * @param directions the directions used for FOD reorientation using apodised point spread functions (Default: 60 directions)
 * @param noreorientation turn off FOD reorientation. Reorientation is on by default if the number of volumes in the 4th dimension corresponds to the number of coefficients in an antipodally symmetric spherical harmonic series (i.e. 6, 15, 28, 45, 66 etc)
 * @param mc_weights relative weight of images used for multi-contrast registration. Default: 1.0 (equal weighting)
 * @param datatype specify output image data type. Valid choices are: float32, float32le, float32be, float64, float64le, float64be, int64, uint64, int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le, int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be, cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be, int8, uint8, bit.
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 * @param contrast1_contrast2 optional list of additional input images used as additional contrasts. Can be used multiple times. contrastX and imageX must share the same coordinate system. 
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrregisterOutputs`).
 */
function mrregister(
    image1_image2: InputPathType,
    type_: string | null = null,
    transformed: Array<MrregisterTransformedParameters> | null = null,
    transformed_midway: Array<MrregisterTransformedMidwayParameters> | null = null,
    mask1: InputPathType | null = null,
    mask2: InputPathType | null = null,
    nan: boolean = false,
    rigid: string | null = null,
    rigid_1tomidway: string | null = null,
    rigid_2tomidway: string | null = null,
    rigid_init_translation: string | null = null,
    rigid_init_rotation: string | null = null,
    rigid_init_matrix: InputPathType | null = null,
    rigid_scale: Array<number> | null = null,
    rigid_niter: Array<number> | null = null,
    rigid_metric: string | null = null,
    rigid_metric_diff_estimator: string | null = null,
    rigid_lmax: Array<number> | null = null,
    rigid_log: string | null = null,
    affine: string | null = null,
    affine_1tomidway: string | null = null,
    affine_2tomidway: string | null = null,
    affine_init_translation: string | null = null,
    affine_init_rotation: string | null = null,
    affine_init_matrix: InputPathType | null = null,
    affine_scale: Array<number> | null = null,
    affine_niter: Array<number> | null = null,
    affine_metric: string | null = null,
    affine_metric_diff_estimator: string | null = null,
    affine_lmax: Array<number> | null = null,
    affine_log: string | null = null,
    init_translation_unmasked1: boolean = false,
    init_translation_unmasked2: boolean = false,
    init_rotation_unmasked1: boolean = false,
    init_rotation_unmasked2: boolean = false,
    init_rotation_search_angles: Array<number> | null = null,
    init_rotation_search_scale: number | null = null,
    init_rotation_search_directions: number | null = null,
    init_rotation_search_run_global: boolean = false,
    init_rotation_search_global_iterations: number | null = null,
    linstage_iterations: Array<number> | null = null,
    linstage_optimiser_first: string | null = null,
    linstage_optimiser_last: string | null = null,
    linstage_optimiser_default: string | null = null,
    linstage_diagnostics_prefix: string | null = null,
    nl_warp: MrregisterNlWarpParameters | null = null,
    nl_warp_full: string | null = null,
    nl_init: InputPathType | null = null,
    nl_scale: Array<number> | null = null,
    nl_niter: Array<number> | null = null,
    nl_update_smooth: number | null = null,
    nl_disp_smooth: number | null = null,
    nl_grad_step: number | null = null,
    nl_lmax: Array<number> | null = null,
    diagnostics_image: string | null = null,
    directions: InputPathType | null = null,
    noreorientation: boolean = false,
    mc_weights: Array<number> | null = null,
    datatype: string | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<MrregisterConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
    contrast1_contrast2: Array<InputPathType> | null = null,
    runner: Runner | null = null,
): MrregisterOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRREGISTER_METADATA);
    const params = mrregister_params(image1_image2, type_, transformed, transformed_midway, mask1, mask2, nan, rigid, rigid_1tomidway, rigid_2tomidway, rigid_init_translation, rigid_init_rotation, rigid_init_matrix, rigid_scale, rigid_niter, rigid_metric, rigid_metric_diff_estimator, rigid_lmax, rigid_log, affine, affine_1tomidway, affine_2tomidway, affine_init_translation, affine_init_rotation, affine_init_matrix, affine_scale, affine_niter, affine_metric, affine_metric_diff_estimator, affine_lmax, affine_log, init_translation_unmasked1, init_translation_unmasked2, init_rotation_unmasked1, init_rotation_unmasked2, init_rotation_search_angles, init_rotation_search_scale, init_rotation_search_directions, init_rotation_search_run_global, init_rotation_search_global_iterations, linstage_iterations, linstage_optimiser_first, linstage_optimiser_last, linstage_optimiser_default, linstage_diagnostics_prefix, nl_warp, nl_warp_full, nl_init, nl_scale, nl_niter, nl_update_smooth, nl_disp_smooth, nl_grad_step, nl_lmax, diagnostics_image, directions, noreorientation, mc_weights, datatype, info, quiet, debug, force, nthreads, config, help, version, contrast1_contrast2)
    return mrregister_execute(params, execution);
}


export {
      MRREGISTER_METADATA,
      MrregisterConfigParameters,
      MrregisterNlWarpOutputs,
      MrregisterNlWarpParameters,
      MrregisterOutputs,
      MrregisterParameters,
      MrregisterTransformedMidwayOutputs,
      MrregisterTransformedMidwayParameters,
      MrregisterTransformedOutputs,
      MrregisterTransformedParameters,
      mrregister,
      mrregister_cargs,
      mrregister_config_cargs,
      mrregister_config_params,
      mrregister_execute,
      mrregister_nl_warp_cargs,
      mrregister_nl_warp_outputs,
      mrregister_nl_warp_params,
      mrregister_outputs,
      mrregister_params,
      mrregister_transformed_cargs,
      mrregister_transformed_midway_cargs,
      mrregister_transformed_midway_outputs,
      mrregister_transformed_midway_params,
      mrregister_transformed_outputs,
      mrregister_transformed_params,
};
