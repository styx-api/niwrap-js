// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const CREATE_TILED_MOSAIC_METADATA: Metadata = {
    id: "3d9613f574ee8ff2d48c4509a9a508bfd56f8d3d.boutiques",
    name: "CreateTiledMosaic",
    package: "ants",
    container_image_tag: "antsx/ants:v2.5.3",
};


interface CreateTiledMosaicParameters {
    "@type": "ants.CreateTiledMosaic";
    "input_image": InputPathType;
    "rgb_image"?: InputPathType | null | undefined;
    "mask_image"?: InputPathType | null | undefined;
    "alpha"?: number | null | undefined;
    "functional_overlay"?: string | null | undefined;
    "output": string;
    "tile_geometry"?: string | null | undefined;
    "direction"?: "0" | "1" | "2" | "x" | "y" | "z" | null | undefined;
    "pad_or_crop"?: string | null | undefined;
    "slices"?: string | null | undefined;
    "flip_slice"?: string | null | undefined;
    "permute_axes"?: 0 | 1 | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "ants.CreateTiledMosaic": create_tiled_mosaic_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "ants.CreateTiledMosaic": create_tiled_mosaic_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `create_tiled_mosaic(...)`.
 *
 * @interface
 */
interface CreateTiledMosaicOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * The output is the tiled mosaic image.
     */
    tiled_mosaic_image: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param input_image Main input is a 3-D grayscale image.
 * @param output The output is the tiled mosaic image. The format must support the specific data type: floating point images without RGB overlays, Rgb images with intensities scaled to [0,255] if overlays are present.
 * @param rgb_image An optional Rgb image can be added as an overlay. It must have the same image geometry as the input grayscale image.
 * @param mask_image Specifies the ROI of the RGB voxels used.
 * @param alpha If an Rgb image is provided, render the overlay using the specified alpha parameter.
 * @param functional_overlay A functional overlay can be specified using both and rgb image and a mask specifying where that rgb image should be applied. Both images must have the same image geometry as the input image. Optionally, an alpha parameter can be specified.
 * @param tile_geometry The tile geometry specifies the number of rows and columns in the output image. For example, specifying '5x10' renders 5 rows by 10 columns of slices.
 * @param direction Specifies the direction of the slices. Can be based on image storage in memory or aligned physical space. Defaults to z-direction if unspecified.
 * @param pad_or_crop Specify padding or cropping with a voxel-width boundary for each slice. Padding uses a specified constant value. Cropping pads with negative voxel-widths.
 * @param slices Control over which slices to render. Specify slices directly or incrementally with optional start and end slices.
 * @param flip_slice Flip individual slice images horizontally and/or vertically.
 * @param permute_axes Permute (or swap) the axes of the individual slice images.
 *
 * @returns Parameter dictionary
 */
function create_tiled_mosaic_params(
    input_image: InputPathType,
    output: string,
    rgb_image: InputPathType | null = null,
    mask_image: InputPathType | null = null,
    alpha: number | null = null,
    functional_overlay: string | null = null,
    tile_geometry: string | null = null,
    direction: "0" | "1" | "2" | "x" | "y" | "z" | null = null,
    pad_or_crop: string | null = null,
    slices: string | null = null,
    flip_slice: string | null = null,
    permute_axes: 0 | 1 | null = null,
): CreateTiledMosaicParameters {
    const params = {
        "@type": "ants.CreateTiledMosaic" as const,
        "input_image": input_image,
        "output": output,
    };
    if (rgb_image !== null) {
        params["rgb_image"] = rgb_image;
    }
    if (mask_image !== null) {
        params["mask_image"] = mask_image;
    }
    if (alpha !== null) {
        params["alpha"] = alpha;
    }
    if (functional_overlay !== null) {
        params["functional_overlay"] = functional_overlay;
    }
    if (tile_geometry !== null) {
        params["tile_geometry"] = tile_geometry;
    }
    if (direction !== null) {
        params["direction"] = direction;
    }
    if (pad_or_crop !== null) {
        params["pad_or_crop"] = pad_or_crop;
    }
    if (slices !== null) {
        params["slices"] = slices;
    }
    if (flip_slice !== null) {
        params["flip_slice"] = flip_slice;
    }
    if (permute_axes !== null) {
        params["permute_axes"] = permute_axes;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function create_tiled_mosaic_cargs(
    params: CreateTiledMosaicParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("CreateTiledMosaic");
    cargs.push(
        "-i",
        execution.inputFile((params["input_image"] ?? null))
    );
    if ((params["rgb_image"] ?? null) !== null) {
        cargs.push(
            "-r",
            execution.inputFile((params["rgb_image"] ?? null))
        );
    }
    if ((params["mask_image"] ?? null) !== null) {
        cargs.push(
            "-x",
            execution.inputFile((params["mask_image"] ?? null))
        );
    }
    if ((params["alpha"] ?? null) !== null) {
        cargs.push(
            "-a",
            String((params["alpha"] ?? null))
        );
    }
    if ((params["functional_overlay"] ?? null) !== null) {
        cargs.push(
            "-e",
            (params["functional_overlay"] ?? null)
        );
    }
    cargs.push(
        "-o",
        (params["output"] ?? null)
    );
    if ((params["tile_geometry"] ?? null) !== null) {
        cargs.push(
            "-t",
            (params["tile_geometry"] ?? null)
        );
    }
    if ((params["direction"] ?? null) !== null) {
        cargs.push(
            "-d",
            (params["direction"] ?? null)
        );
    }
    if ((params["pad_or_crop"] ?? null) !== null) {
        cargs.push(
            "-p",
            (params["pad_or_crop"] ?? null)
        );
    }
    if ((params["slices"] ?? null) !== null) {
        cargs.push(
            "-s",
            (params["slices"] ?? null)
        );
    }
    if ((params["flip_slice"] ?? null) !== null) {
        cargs.push(
            "-f",
            (params["flip_slice"] ?? null)
        );
    }
    if ((params["permute_axes"] ?? null) !== null) {
        cargs.push(
            "-g",
            String((params["permute_axes"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function create_tiled_mosaic_outputs(
    params: CreateTiledMosaicParameters,
    execution: Execution,
): CreateTiledMosaicOutputs {
    const ret: CreateTiledMosaicOutputs = {
        root: execution.outputFile("."),
        tiled_mosaic_image: execution.outputFile([(params["output"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Render a 3-D image volume with optional Rgb overlay.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param params The parameters.
 * @param execution The execution object.
 *
 * @returns NamedTuple of outputs (described in `CreateTiledMosaicOutputs`).
 */
function create_tiled_mosaic_execute(
    params: CreateTiledMosaicParameters,
    execution: Execution,
): CreateTiledMosaicOutputs {
    params = execution.params(params)
    const cargs = create_tiled_mosaic_cargs(params, execution)
    const ret = create_tiled_mosaic_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * Render a 3-D image volume with optional Rgb overlay.
 *
 * Author: ANTs Developers
 *
 * URL: https://github.com/ANTsX/ANTs
 *
 * @param input_image Main input is a 3-D grayscale image.
 * @param output The output is the tiled mosaic image. The format must support the specific data type: floating point images without RGB overlays, Rgb images with intensities scaled to [0,255] if overlays are present.
 * @param rgb_image An optional Rgb image can be added as an overlay. It must have the same image geometry as the input grayscale image.
 * @param mask_image Specifies the ROI of the RGB voxels used.
 * @param alpha If an Rgb image is provided, render the overlay using the specified alpha parameter.
 * @param functional_overlay A functional overlay can be specified using both and rgb image and a mask specifying where that rgb image should be applied. Both images must have the same image geometry as the input image. Optionally, an alpha parameter can be specified.
 * @param tile_geometry The tile geometry specifies the number of rows and columns in the output image. For example, specifying '5x10' renders 5 rows by 10 columns of slices.
 * @param direction Specifies the direction of the slices. Can be based on image storage in memory or aligned physical space. Defaults to z-direction if unspecified.
 * @param pad_or_crop Specify padding or cropping with a voxel-width boundary for each slice. Padding uses a specified constant value. Cropping pads with negative voxel-widths.
 * @param slices Control over which slices to render. Specify slices directly or incrementally with optional start and end slices.
 * @param flip_slice Flip individual slice images horizontally and/or vertically.
 * @param permute_axes Permute (or swap) the axes of the individual slice images.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `CreateTiledMosaicOutputs`).
 */
function create_tiled_mosaic(
    input_image: InputPathType,
    output: string,
    rgb_image: InputPathType | null = null,
    mask_image: InputPathType | null = null,
    alpha: number | null = null,
    functional_overlay: string | null = null,
    tile_geometry: string | null = null,
    direction: "0" | "1" | "2" | "x" | "y" | "z" | null = null,
    pad_or_crop: string | null = null,
    slices: string | null = null,
    flip_slice: string | null = null,
    permute_axes: 0 | 1 | null = null,
    runner: Runner | null = null,
): CreateTiledMosaicOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(CREATE_TILED_MOSAIC_METADATA);
    const params = create_tiled_mosaic_params(input_image, output, rgb_image, mask_image, alpha, functional_overlay, tile_geometry, direction, pad_or_crop, slices, flip_slice, permute_axes)
    return create_tiled_mosaic_execute(params, execution);
}


export {
      CREATE_TILED_MOSAIC_METADATA,
      CreateTiledMosaicOutputs,
      CreateTiledMosaicParameters,
      create_tiled_mosaic,
      create_tiled_mosaic_cargs,
      create_tiled_mosaic_execute,
      create_tiled_mosaic_outputs,
      create_tiled_mosaic_params,
};
