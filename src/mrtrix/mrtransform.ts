// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRTRANSFORM_METADATA: Metadata = {
    id: "3eb2d0d1d0da497152ef0293f2b94667de8b3275.boutiques",
    name: "mrtransform",
    package: "mrtrix",
    container_image_tag: "mrtrix3/mrtrix3:3.0.4",
};


interface MrtransformFslgradParameters {
    "@type"?: "fslgrad";
    "bvecs": InputPathType;
    "bvals": InputPathType;
}
type MrtransformFslgradParametersTagged = Required<Pick<MrtransformFslgradParameters, '@type'>> & MrtransformFslgradParameters;


interface MrtransformExportGradFslParameters {
    "@type"?: "export_grad_fsl";
    "bvecs_path": string;
    "bvals_path": string;
}
type MrtransformExportGradFslParametersTagged = Required<Pick<MrtransformExportGradFslParameters, '@type'>> & MrtransformExportGradFslParameters;


interface MrtransformVariousStringParameters {
    "@type"?: "VariousString";
    "obj": string;
}
type MrtransformVariousStringParametersTagged = Required<Pick<MrtransformVariousStringParameters, '@type'>> & MrtransformVariousStringParameters;


interface MrtransformVariousFileParameters {
    "@type"?: "VariousFile";
    "obj": InputPathType;
}
type MrtransformVariousFileParametersTagged = Required<Pick<MrtransformVariousFileParameters, '@type'>> & MrtransformVariousFileParameters;


interface MrtransformConfigParameters {
    "@type"?: "config";
    "key": string;
    "value": string;
}
type MrtransformConfigParametersTagged = Required<Pick<MrtransformConfigParameters, '@type'>> & MrtransformConfigParameters;


interface MrtransformParameters {
    "@type"?: "mrtrix/mrtransform";
    "linear"?: InputPathType | null | undefined;
    "flip"?: Array<number> | null | undefined;
    "inverse": boolean;
    "half": boolean;
    "replace"?: InputPathType | null | undefined;
    "identity": boolean;
    "template"?: InputPathType | null | undefined;
    "midway_space": boolean;
    "interp"?: string | null | undefined;
    "oversample"?: Array<number> | null | undefined;
    "warp"?: InputPathType | null | undefined;
    "warp_full"?: InputPathType | null | undefined;
    "from"?: number | null | undefined;
    "modulate"?: string | null | undefined;
    "directions"?: InputPathType | null | undefined;
    "reorient_fod"?: string | null | undefined;
    "grad"?: InputPathType | null | undefined;
    "fslgrad"?: MrtransformFslgradParameters | null | undefined;
    "export_grad_mrtrix"?: string | null | undefined;
    "export_grad_fsl"?: MrtransformExportGradFslParameters | null | undefined;
    "datatype"?: string | null | undefined;
    "strides"?: MrtransformVariousStringParametersTagged | MrtransformVariousFileParametersTagged | null | undefined;
    "nan": boolean;
    "no_reorientation": boolean;
    "info": boolean;
    "quiet": boolean;
    "debug": boolean;
    "force": boolean;
    "nthreads"?: number | null | undefined;
    "config"?: Array<MrtransformConfigParameters> | null | undefined;
    "help": boolean;
    "version": boolean;
    "input": InputPathType;
    "output": string;
}
type MrtransformParametersTagged = Required<Pick<MrtransformParameters, '@type'>> & MrtransformParameters;


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function mrtransform_strides_cargs_dyn_fn(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "VariousString": mrtransform_various_string_cargs,
        "VariousFile": mrtransform_various_file_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function mrtransform_strides_outputs_dyn_fn(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @param bvecs Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param bvals Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 *
 * @returns Parameter dictionary
 */
function mrtransform_fslgrad_params(
    bvecs: InputPathType,
    bvals: InputPathType,
): MrtransformFslgradParametersTagged {
    const params = {
        "@type": "fslgrad" as const,
        "bvecs": bvecs,
        "bvals": bvals,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrtransform_fslgrad_cargs(
    params: MrtransformFslgradParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-fslgrad");
    cargs.push(execution.inputFile((params["bvecs"] ?? null)));
    cargs.push(execution.inputFile((params["bvals"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `MrtransformExportGradFslParameters | null(...)`.
 *
 * @interface
 */
interface MrtransformExportGradFslOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * export the diffusion-weighted gradient table to files in FSL (bvecs / bvals) format
     */
    bvecs_path: OutputPathType;
    /**
     * export the diffusion-weighted gradient table to files in FSL (bvecs / bvals) format
     */
    bvals_path: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param bvecs_path export the diffusion-weighted gradient table to files in FSL (bvecs / bvals) format
 * @param bvals_path export the diffusion-weighted gradient table to files in FSL (bvecs / bvals) format
 *
 * @returns Parameter dictionary
 */
function mrtransform_export_grad_fsl_params(
    bvecs_path: string,
    bvals_path: string,
): MrtransformExportGradFslParametersTagged {
    const params = {
        "@type": "export_grad_fsl" as const,
        "bvecs_path": bvecs_path,
        "bvals_path": bvals_path,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrtransform_export_grad_fsl_cargs(
    params: MrtransformExportGradFslParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-export_grad_fsl");
    cargs.push((params["bvecs_path"] ?? null));
    cargs.push((params["bvals_path"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mrtransform_export_grad_fsl_outputs(
    params: MrtransformExportGradFslParameters,
    execution: Execution,
): MrtransformExportGradFslOutputs {
    const ret: MrtransformExportGradFslOutputs = {
        root: execution.outputFile("."),
        bvecs_path: execution.outputFile([(params["bvecs_path"] ?? null)].join('')),
        bvals_path: execution.outputFile([(params["bvals_path"] ?? null)].join('')),
    };
    return ret;
}


/**
 * Build parameters.
 *
 * @param obj String object.
 *
 * @returns Parameter dictionary
 */
function mrtransform_various_string_params(
    obj: string,
): MrtransformVariousStringParametersTagged {
    const params = {
        "@type": "VariousString" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrtransform_various_string_cargs(
    params: MrtransformVariousStringParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["obj"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj File object.
 *
 * @returns Parameter dictionary
 */
function mrtransform_various_file_params(
    obj: InputPathType,
): MrtransformVariousFileParametersTagged {
    const params = {
        "@type": "VariousFile" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrtransform_various_file_cargs(
    params: MrtransformVariousFileParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["obj"] ?? null)));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param key temporarily set the value of an MRtrix config file entry.
 * @param value temporarily set the value of an MRtrix config file entry.
 *
 * @returns Parameter dictionary
 */
function mrtransform_config_params(
    key: string,
    value: string,
): MrtransformConfigParametersTagged {
    const params = {
        "@type": "config" as const,
        "key": key,
        "value": value,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrtransform_config_cargs(
    params: MrtransformConfigParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-config");
    cargs.push((params["key"] ?? null));
    cargs.push((params["value"] ?? null));
    return cargs;
}


/**
 * Output object returned when calling `MrtransformParameters(...)`.
 *
 * @interface
 */
interface MrtransformOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output image.
     */
    output: OutputPathType;
    /**
     * export the diffusion-weighted gradient table to file in MRtrix format 
     */
    export_grad_mrtrix: OutputPathType | null;
    /**
     * Outputs from `mrtransform_export_grad_fsl_outputs`.
     */
    export_grad_fsl: MrtransformExportGradFslOutputs | null;
}


/**
 * Build parameters.
 *
 * @param input input image to be transformed.
 * @param output the output image.
 * @param linear specify a linear transform to apply, in the form of a 3x4 or 4x4 ascii file. Note the standard 'reverse' convention is used, where the transform maps points in the template image to the moving image. Note that the reverse convention is still assumed even if no -template image is supplied
 * @param flip flip the specified axes, provided as a comma-separated list of indices (0:x, 1:y, 2:z).
 * @param inverse apply the inverse transformation
 * @param half apply the matrix square root of the transformation. This can be combined with the inverse option.
 * @param replace replace the linear transform of the original image by that specified, rather than applying it to the original image. The specified transform can be either a template image, or a 3x4 or 4x4 ascii file.
 * @param identity set the header transform of the image to the identity matrix
 * @param template reslice the input image to match the specified template image grid.
 * @param midway_space reslice the input image to the midway space. Requires either the -template or -warp option. If used with -template and -linear option the input image will be resliced onto the grid halfway between the input and template. If used with the -warp option the input will be warped to the midway space defined by the grid of the input warp (i.e. half way between image1 and image2)
 * @param interp set the interpolation method to use when reslicing (choices: nearest, linear, cubic, sinc. Default: cubic).
 * @param oversample set the amount of over-sampling (in the target space) to perform when regridding. This is particularly relevant when downsamping a high-resolution image to a low-resolution image, to avoid aliasing artefacts. This can consist of a single integer, or a comma-separated list of 3 integers if different oversampling factors are desired along the different axes. Default is determined from ratio of voxel dimensions (disabled for nearest-neighbour interpolation).
 * @param warp apply a non-linear 4D deformation field to warp the input image. Each voxel in the deformation field must define the scanner space position that will be used to interpolate the input image during warping (i.e. pull-back/reverse warp convention). If the -template image is also supplied the deformation field will be resliced first to the template image grid. If no -template option is supplied then the output image will have the same image grid as the deformation field. This option can be used in combination with the -affine option, in which case the affine will be applied first)
 * @param warp_full warp the input image using a 5D warp file output from mrregister. Any linear transforms in the warp image header will also be applied. The -warp_full option must be used in combination with either the -template option or the -midway_space option. If a -template image is supplied then the full warp will be used. By default the image1->image2 transform will be applied, however the -from 2 option can be used to apply the image2->image1 transform. Use the -midway_space option to warp the input image to the midway space. The -from option can also be used to define which warp to use when transforming to midway space
 * @param from_ used to define which space the input image is when using the -warp_mid option. Use -from 1 to warp from image1 or -from 2 to warp from image2
 * @param modulate Valid choices are: fod and jac. 
fod: modulate FODs during reorientation to preserve the apparent fibre density across fibre bundle widths before and after the transformation. 
jac: modulate the image intensity with the determinant of the Jacobian of the warp of linear transformation to preserve the total intensity before and after the transformation.
 * @param directions directions defining the number and orientation of the apodised point spread functions used in FOD reorientation (Default: 300 directions)
 * @param reorient_fod specify whether to perform FOD reorientation. This is required if the number of volumes in the 4th dimension corresponds to the number of coefficients in an antipodally symmetric spherical harmonic series with lmax >= 2 (i.e. 6, 15, 28, 45, 66 volumes).
 * @param grad Provide the diffusion-weighted gradient scheme used in the acquisition in a text file. This should be supplied as a 4xN text file with each line is in the format [ X Y Z b ], where [ X Y Z ] describe the direction of the applied gradient, and b gives the b-value in units of s/mm^2. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param fslgrad Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param export_grad_mrtrix export the diffusion-weighted gradient table to file in MRtrix format
 * @param export_grad_fsl export the diffusion-weighted gradient table to files in FSL (bvecs / bvals) format
 * @param datatype specify output image data type. Valid choices are: float32, float32le, float32be, float64, float64le, float64be, int64, uint64, int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le, int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be, cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be, int8, uint8, bit.
 * @param strides specify the strides of the output data in memory; either as a comma-separated list of (signed) integers, or as a template image from which the strides shall be extracted and used. The actual strides produced will depend on whether the output image format can support it.
 * @param nan Use NaN as the out of bounds value (Default: 0.0)
 * @param no_reorientation deprecated, use -reorient_fod instead
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 *
 * @returns Parameter dictionary
 */
function mrtransform_params(
    input: InputPathType,
    output: string,
    linear: InputPathType | null = null,
    flip: Array<number> | null = null,
    inverse: boolean = false,
    half: boolean = false,
    replace: InputPathType | null = null,
    identity: boolean = false,
    template: InputPathType | null = null,
    midway_space: boolean = false,
    interp: string | null = null,
    oversample: Array<number> | null = null,
    warp: InputPathType | null = null,
    warp_full: InputPathType | null = null,
    from_: number | null = null,
    modulate: string | null = null,
    directions: InputPathType | null = null,
    reorient_fod: string | null = null,
    grad: InputPathType | null = null,
    fslgrad: MrtransformFslgradParameters | null = null,
    export_grad_mrtrix: string | null = null,
    export_grad_fsl: MrtransformExportGradFslParameters | null = null,
    datatype: string | null = null,
    strides: MrtransformVariousStringParametersTagged | MrtransformVariousFileParametersTagged | null = null,
    nan: boolean = false,
    no_reorientation: boolean = false,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<MrtransformConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
): MrtransformParametersTagged {
    const params = {
        "@type": "mrtrix/mrtransform" as const,
        "inverse": inverse,
        "half": half,
        "identity": identity,
        "midway_space": midway_space,
        "nan": nan,
        "no_reorientation": no_reorientation,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help,
        "version": version,
        "input": input,
        "output": output,
    };
    if (linear !== null) {
        params["linear"] = linear;
    }
    if (flip !== null) {
        params["flip"] = flip;
    }
    if (replace !== null) {
        params["replace"] = replace;
    }
    if (template !== null) {
        params["template"] = template;
    }
    if (interp !== null) {
        params["interp"] = interp;
    }
    if (oversample !== null) {
        params["oversample"] = oversample;
    }
    if (warp !== null) {
        params["warp"] = warp;
    }
    if (warp_full !== null) {
        params["warp_full"] = warp_full;
    }
    if (from_ !== null) {
        params["from"] = from_;
    }
    if (modulate !== null) {
        params["modulate"] = modulate;
    }
    if (directions !== null) {
        params["directions"] = directions;
    }
    if (reorient_fod !== null) {
        params["reorient_fod"] = reorient_fod;
    }
    if (grad !== null) {
        params["grad"] = grad;
    }
    if (fslgrad !== null) {
        params["fslgrad"] = fslgrad;
    }
    if (export_grad_mrtrix !== null) {
        params["export_grad_mrtrix"] = export_grad_mrtrix;
    }
    if (export_grad_fsl !== null) {
        params["export_grad_fsl"] = export_grad_fsl;
    }
    if (datatype !== null) {
        params["datatype"] = datatype;
    }
    if (strides !== null) {
        params["strides"] = strides;
    }
    if (nthreads !== null) {
        params["nthreads"] = nthreads;
    }
    if (config !== null) {
        params["config"] = config;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrtransform_cargs(
    params: MrtransformParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mrtransform");
    if ((params["linear"] ?? null) !== null) {
        cargs.push(
            "-linear",
            execution.inputFile((params["linear"] ?? null))
        );
    }
    if ((params["flip"] ?? null) !== null) {
        cargs.push(
            "-flip",
            (params["flip"] ?? null).map(String).join(",")
        );
    }
    if ((params["inverse"] ?? false)) {
        cargs.push("-inverse");
    }
    if ((params["half"] ?? false)) {
        cargs.push("-half");
    }
    if ((params["replace"] ?? null) !== null) {
        cargs.push(
            "-replace",
            execution.inputFile((params["replace"] ?? null))
        );
    }
    if ((params["identity"] ?? false)) {
        cargs.push("-identity");
    }
    if ((params["template"] ?? null) !== null) {
        cargs.push(
            "-template",
            execution.inputFile((params["template"] ?? null))
        );
    }
    if ((params["midway_space"] ?? false)) {
        cargs.push("-midway_space");
    }
    if ((params["interp"] ?? null) !== null) {
        cargs.push(
            "-interp",
            (params["interp"] ?? null)
        );
    }
    if ((params["oversample"] ?? null) !== null) {
        cargs.push(
            "-oversample",
            (params["oversample"] ?? null).map(String).join(",")
        );
    }
    if ((params["warp"] ?? null) !== null) {
        cargs.push(
            "-warp",
            execution.inputFile((params["warp"] ?? null))
        );
    }
    if ((params["warp_full"] ?? null) !== null) {
        cargs.push(
            "-warp_full",
            execution.inputFile((params["warp_full"] ?? null))
        );
    }
    if ((params["from"] ?? null) !== null) {
        cargs.push(
            "-from",
            String((params["from"] ?? null))
        );
    }
    if ((params["modulate"] ?? null) !== null) {
        cargs.push(
            "-modulate",
            (params["modulate"] ?? null)
        );
    }
    if ((params["directions"] ?? null) !== null) {
        cargs.push(
            "-directions",
            execution.inputFile((params["directions"] ?? null))
        );
    }
    if ((params["reorient_fod"] ?? null) !== null) {
        cargs.push(
            "-reorient_fod",
            (params["reorient_fod"] ?? null)
        );
    }
    if ((params["grad"] ?? null) !== null) {
        cargs.push(
            "-grad",
            execution.inputFile((params["grad"] ?? null))
        );
    }
    if ((params["fslgrad"] ?? null) !== null) {
        cargs.push(...mrtransform_fslgrad_cargs((params["fslgrad"] ?? null), execution));
    }
    if ((params["export_grad_mrtrix"] ?? null) !== null) {
        cargs.push(
            "-export_grad_mrtrix",
            (params["export_grad_mrtrix"] ?? null)
        );
    }
    if ((params["export_grad_fsl"] ?? null) !== null) {
        cargs.push(...mrtransform_export_grad_fsl_cargs((params["export_grad_fsl"] ?? null), execution));
    }
    if ((params["datatype"] ?? null) !== null) {
        cargs.push(
            "-datatype",
            (params["datatype"] ?? null)
        );
    }
    if ((params["strides"] ?? null) !== null) {
        cargs.push(
            "-strides",
            ...mrtransform_strides_cargs_dyn_fn((params["strides"] ?? null)["@type"])((params["strides"] ?? null), execution)
        );
    }
    if ((params["nan"] ?? false)) {
        cargs.push("-nan");
    }
    if ((params["no_reorientation"] ?? false)) {
        cargs.push("-no_reorientation");
    }
    if ((params["info"] ?? false)) {
        cargs.push("-info");
    }
    if ((params["quiet"] ?? false)) {
        cargs.push("-quiet");
    }
    if ((params["debug"] ?? false)) {
        cargs.push("-debug");
    }
    if ((params["force"] ?? false)) {
        cargs.push("-force");
    }
    if ((params["nthreads"] ?? null) !== null) {
        cargs.push(
            "-nthreads",
            String((params["nthreads"] ?? null))
        );
    }
    if ((params["config"] ?? null) !== null) {
        cargs.push(...(params["config"] ?? null).map(s => mrtransform_config_cargs(s, execution)).flat());
    }
    if ((params["help"] ?? false)) {
        cargs.push("-help");
    }
    if ((params["version"] ?? false)) {
        cargs.push("-version");
    }
    cargs.push(execution.inputFile((params["input"] ?? null)));
    cargs.push((params["output"] ?? null));
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mrtransform_outputs(
    params: MrtransformParameters,
    execution: Execution,
): MrtransformOutputs {
    const ret: MrtransformOutputs = {
        root: execution.outputFile("."),
        output: execution.outputFile([(params["output"] ?? null)].join('')),
        export_grad_mrtrix: ((params["export_grad_mrtrix"] ?? null) !== null) ? execution.outputFile([(params["export_grad_mrtrix"] ?? null)].join('')) : null,
        export_grad_fsl: (params["export_grad_fsl"] ?? null) ? (mrtransform_export_grad_fsl_outputs((params["export_grad_fsl"] ?? null), execution) ?? null) : null,
    };
    return ret;
}


/**
 * mrtransform
 *
 * Apply spatial transformations to an image.
 *
 * If a linear transform is applied without a template image the command will modify the image header transform matrix
 *
 * FOD reorientation (with apodised point spread functions) can be performed if the number of volumes in the 4th dimension equals the number of coefficients in an antipodally symmetric spherical harmonic series (e.g. 6, 15, 28 etc). For such data, the -reorient_fod yes/no option must be used to specify if reorientation is required.
 *
 * The output image intensity can be modulated using the (local or global) volume change if a linear or nonlinear transformation is applied. 'FOD' modulation preserves the apparent fibre density across the fibre bundle width and can only be applied if FOD reorientation is used. Alternatively, non-directional scaling by the Jacobian determinant can be applied to any image type. 
 *
 * If a DW scheme is contained in the header (or specified separately), and the number of directions matches the number of volumes in the images, any transformation applied using the -linear option will also be applied to the directions.
 *
 * When the -template option is used to specify the target image grid, the image provided via this option will not influence the axis data strides of the output image; these are determined based on the input image, or the input to the -strides option.
 *
 * References:
 *
 * * If FOD reorientation is being performed:
 * Raffelt, D.; Tournier, J.-D.; Crozier, S.; Connelly, A. & Salvado, O. Reorientation of fiber orientation distributions using apodized point spread functions. Magnetic Resonance in Medicine, 2012, 67, 844-855
 *
 * * If FOD modulation is being performed:
 * Raffelt, D.; Tournier, J.-D.; Rose, S.; Ridgway, G.R.; Henderson, R.; Crozier, S.; Salvado, O.; Connelly, A.; Apparent Fibre Density: a novel measure for the analysis of diffusion-weighted magnetic resonance images. NeuroImage, 2012, 15;59(4), 3976-94.
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrtransformOutputs`).
 */
function mrtransform_execute(
    params: MrtransformParameters,
    runner: Runner | null = null,
): MrtransformOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRTRANSFORM_METADATA);
    params = execution.params(params)
    const cargs = mrtransform_cargs(params, execution)
    const ret = mrtransform_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * mrtransform
 *
 * Apply spatial transformations to an image.
 *
 * If a linear transform is applied without a template image the command will modify the image header transform matrix
 *
 * FOD reorientation (with apodised point spread functions) can be performed if the number of volumes in the 4th dimension equals the number of coefficients in an antipodally symmetric spherical harmonic series (e.g. 6, 15, 28 etc). For such data, the -reorient_fod yes/no option must be used to specify if reorientation is required.
 *
 * The output image intensity can be modulated using the (local or global) volume change if a linear or nonlinear transformation is applied. 'FOD' modulation preserves the apparent fibre density across the fibre bundle width and can only be applied if FOD reorientation is used. Alternatively, non-directional scaling by the Jacobian determinant can be applied to any image type. 
 *
 * If a DW scheme is contained in the header (or specified separately), and the number of directions matches the number of volumes in the images, any transformation applied using the -linear option will also be applied to the directions.
 *
 * When the -template option is used to specify the target image grid, the image provided via this option will not influence the axis data strides of the output image; these are determined based on the input image, or the input to the -strides option.
 *
 * References:
 *
 * * If FOD reorientation is being performed:
 * Raffelt, D.; Tournier, J.-D.; Crozier, S.; Connelly, A. & Salvado, O. Reorientation of fiber orientation distributions using apodized point spread functions. Magnetic Resonance in Medicine, 2012, 67, 844-855
 *
 * * If FOD modulation is being performed:
 * Raffelt, D.; Tournier, J.-D.; Rose, S.; Ridgway, G.R.; Henderson, R.; Crozier, S.; Salvado, O.; Connelly, A.; Apparent Fibre Density: a novel measure for the analysis of diffusion-weighted magnetic resonance images. NeuroImage, 2012, 15;59(4), 3976-94.
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param input input image to be transformed.
 * @param output the output image.
 * @param linear specify a linear transform to apply, in the form of a 3x4 or 4x4 ascii file. Note the standard 'reverse' convention is used, where the transform maps points in the template image to the moving image. Note that the reverse convention is still assumed even if no -template image is supplied
 * @param flip flip the specified axes, provided as a comma-separated list of indices (0:x, 1:y, 2:z).
 * @param inverse apply the inverse transformation
 * @param half apply the matrix square root of the transformation. This can be combined with the inverse option.
 * @param replace replace the linear transform of the original image by that specified, rather than applying it to the original image. The specified transform can be either a template image, or a 3x4 or 4x4 ascii file.
 * @param identity set the header transform of the image to the identity matrix
 * @param template reslice the input image to match the specified template image grid.
 * @param midway_space reslice the input image to the midway space. Requires either the -template or -warp option. If used with -template and -linear option the input image will be resliced onto the grid halfway between the input and template. If used with the -warp option the input will be warped to the midway space defined by the grid of the input warp (i.e. half way between image1 and image2)
 * @param interp set the interpolation method to use when reslicing (choices: nearest, linear, cubic, sinc. Default: cubic).
 * @param oversample set the amount of over-sampling (in the target space) to perform when regridding. This is particularly relevant when downsamping a high-resolution image to a low-resolution image, to avoid aliasing artefacts. This can consist of a single integer, or a comma-separated list of 3 integers if different oversampling factors are desired along the different axes. Default is determined from ratio of voxel dimensions (disabled for nearest-neighbour interpolation).
 * @param warp apply a non-linear 4D deformation field to warp the input image. Each voxel in the deformation field must define the scanner space position that will be used to interpolate the input image during warping (i.e. pull-back/reverse warp convention). If the -template image is also supplied the deformation field will be resliced first to the template image grid. If no -template option is supplied then the output image will have the same image grid as the deformation field. This option can be used in combination with the -affine option, in which case the affine will be applied first)
 * @param warp_full warp the input image using a 5D warp file output from mrregister. Any linear transforms in the warp image header will also be applied. The -warp_full option must be used in combination with either the -template option or the -midway_space option. If a -template image is supplied then the full warp will be used. By default the image1->image2 transform will be applied, however the -from 2 option can be used to apply the image2->image1 transform. Use the -midway_space option to warp the input image to the midway space. The -from option can also be used to define which warp to use when transforming to midway space
 * @param from_ used to define which space the input image is when using the -warp_mid option. Use -from 1 to warp from image1 or -from 2 to warp from image2
 * @param modulate Valid choices are: fod and jac. 
fod: modulate FODs during reorientation to preserve the apparent fibre density across fibre bundle widths before and after the transformation. 
jac: modulate the image intensity with the determinant of the Jacobian of the warp of linear transformation to preserve the total intensity before and after the transformation.
 * @param directions directions defining the number and orientation of the apodised point spread functions used in FOD reorientation (Default: 300 directions)
 * @param reorient_fod specify whether to perform FOD reorientation. This is required if the number of volumes in the 4th dimension corresponds to the number of coefficients in an antipodally symmetric spherical harmonic series with lmax >= 2 (i.e. 6, 15, 28, 45, 66 volumes).
 * @param grad Provide the diffusion-weighted gradient scheme used in the acquisition in a text file. This should be supplied as a 4xN text file with each line is in the format [ X Y Z b ], where [ X Y Z ] describe the direction of the applied gradient, and b gives the b-value in units of s/mm^2. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param fslgrad Provide the diffusion-weighted gradient scheme used in the acquisition in FSL bvecs/bvals format files. If a diffusion gradient scheme is present in the input image header, the data provided with this option will be instead used.
 * @param export_grad_mrtrix export the diffusion-weighted gradient table to file in MRtrix format
 * @param export_grad_fsl export the diffusion-weighted gradient table to files in FSL (bvecs / bvals) format
 * @param datatype specify output image data type. Valid choices are: float32, float32le, float32be, float64, float64le, float64be, int64, uint64, int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le, int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be, cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be, int8, uint8, bit.
 * @param strides specify the strides of the output data in memory; either as a comma-separated list of (signed) integers, or as a template image from which the strides shall be extracted and used. The actual strides produced will depend on whether the output image format can support it.
 * @param nan Use NaN as the out of bounds value (Default: 0.0)
 * @param no_reorientation deprecated, use -reorient_fod instead
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrtransformOutputs`).
 */
function mrtransform(
    input: InputPathType,
    output: string,
    linear: InputPathType | null = null,
    flip: Array<number> | null = null,
    inverse: boolean = false,
    half: boolean = false,
    replace: InputPathType | null = null,
    identity: boolean = false,
    template: InputPathType | null = null,
    midway_space: boolean = false,
    interp: string | null = null,
    oversample: Array<number> | null = null,
    warp: InputPathType | null = null,
    warp_full: InputPathType | null = null,
    from_: number | null = null,
    modulate: string | null = null,
    directions: InputPathType | null = null,
    reorient_fod: string | null = null,
    grad: InputPathType | null = null,
    fslgrad: MrtransformFslgradParameters | null = null,
    export_grad_mrtrix: string | null = null,
    export_grad_fsl: MrtransformExportGradFslParameters | null = null,
    datatype: string | null = null,
    strides: MrtransformVariousStringParametersTagged | MrtransformVariousFileParametersTagged | null = null,
    nan: boolean = false,
    no_reorientation: boolean = false,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<MrtransformConfigParameters> | null = null,
    help: boolean = false,
    version: boolean = false,
    runner: Runner | null = null,
): MrtransformOutputs {
    const params = mrtransform_params(input, output, linear, flip, inverse, half, replace, identity, template, midway_space, interp, oversample, warp, warp_full, from_, modulate, directions, reorient_fod, grad, fslgrad, export_grad_mrtrix, export_grad_fsl, datatype, strides, nan, no_reorientation, info, quiet, debug, force, nthreads, config, help, version)
    return mrtransform_execute(params, runner);
}


export {
      MRTRANSFORM_METADATA,
      MrtransformExportGradFslOutputs,
      MrtransformOutputs,
      mrtransform,
      mrtransform_config_params,
      mrtransform_execute,
      mrtransform_export_grad_fsl_params,
      mrtransform_fslgrad_params,
      mrtransform_params,
      mrtransform_various_file_params,
      mrtransform_various_string_params,
};
