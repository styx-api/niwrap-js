// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const BIANCA_METADATA: Metadata = {
    id: "faece12893f9764ba2ed673c9b5a6791f2ed9a43.boutiques",
    name: "bianca",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface BiancaParameters {
    "__STYXTYPE__": "bianca";
    "master_file": InputPathType;
    "label_feature_num": number;
    "brain_mask_feature_num": number;
    "query_subject_num": number;
    "feature_subset"?: string | null | undefined;
    "mat_feature_num"?: number | null | undefined;
    "spatial_weight"?: number | null | undefined;
    "patch_sizes"?: string | null | undefined;
    "patch_3d": boolean;
    "select_pts"?: string | null | undefined;
    "training_pts"?: string | null | undefined;
    "non_les_pts"?: string | null | undefined;
    "save_classifier_data"?: string | null | undefined;
    "verbose_flag": boolean;
    "out_name"?: string | null | undefined;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "bianca": bianca_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "bianca": bianca_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `bianca(...)`.
 *
 * @interface
 */
interface BiancaOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Base output file generated by BIANCA
     */
    base_output: OutputPathType | null;
}


function bianca_params(
    master_file: InputPathType,
    label_feature_num: number,
    brain_mask_feature_num: number,
    query_subject_num: number,
    feature_subset: string | null = null,
    mat_feature_num: number | null = null,
    spatial_weight: number | null = 1,
    patch_sizes: string | null = null,
    patch_3d: boolean = false,
    select_pts: string | null = "any",
    training_pts: string | null = null,
    non_les_pts: string | null = null,
    save_classifier_data: string | null = null,
    verbose_flag: boolean = false,
    out_name: string | null = "output_bianca",
): BiancaParameters {
    /**
     * Build parameters.
    
     * @param master_file Name of the master file
     * @param label_feature_num Column number (in the master file) of the manual masks (or any placeholder name for query subjects)
     * @param brain_mask_feature_num Column number (in the master file) of images to derive non-zero mask from
     * @param query_subject_num Row number of query subject (in masterlistfile)
     * @param feature_subset Set of column numbers (comma separated and no spaces) for features/images to use (default: use all available modalities as intensity features). The image used to derive non-zero mask from must be part of the features subset
     * @param mat_feature_num Column number of matrix files (in masterlistfile). Needed to extract spatial features (MNI coordinates)
     * @param spatial_weight Weighting for spatial coordinates (default = 1, i.e., variance-normalized MNI coordinates). Requires --matfeaturenum to be specified
     * @param patch_sizes List of patch sizes for local averaging
     * @param patch_3d Use 3D patches (default is 2D)
     * @param select_pts "any" (default) or "surround" or "noborder"
     * @param training_pts Number (max) of (lesion) points to use (per training subject) or "equalpoints" to select all lesion points and equal number of non-lesion points
     * @param non_les_pts Number (max) of non-lesion points to use. If not specified will be set to the same amount of lesion points
     * @param save_classifier_data Save training data to file
     * @param verbose_flag Use verbose mode
     * @param out_name Specify (base) output name of files
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "bianca" as const,
        "master_file": master_file,
        "label_feature_num": label_feature_num,
        "brain_mask_feature_num": brain_mask_feature_num,
        "query_subject_num": query_subject_num,
        "patch_3d": patch_3d,
        "verbose_flag": verbose_flag,
    };
    if (feature_subset !== null) {
        params["feature_subset"] = feature_subset;
    }
    if (mat_feature_num !== null) {
        params["mat_feature_num"] = mat_feature_num;
    }
    if (spatial_weight !== null) {
        params["spatial_weight"] = spatial_weight;
    }
    if (patch_sizes !== null) {
        params["patch_sizes"] = patch_sizes;
    }
    if (select_pts !== null) {
        params["select_pts"] = select_pts;
    }
    if (training_pts !== null) {
        params["training_pts"] = training_pts;
    }
    if (non_les_pts !== null) {
        params["non_les_pts"] = non_les_pts;
    }
    if (save_classifier_data !== null) {
        params["save_classifier_data"] = save_classifier_data;
    }
    if (out_name !== null) {
        params["out_name"] = out_name;
    }
    return params;
}


function bianca_cargs(
    params: BiancaParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("bianca");
    cargs.push(["--singlefile=", execution.inputFile((params["master_file"] ?? null))].join(''));
    cargs.push(["--labelfeaturenum=", String((params["label_feature_num"] ?? null))].join(''));
    cargs.push(["--brainmaskfeaturenum=", String((params["brain_mask_feature_num"] ?? null))].join(''));
    cargs.push(["--querysubjectnum=", String((params["query_subject_num"] ?? null))].join(''));
    if ((params["feature_subset"] ?? null) !== null) {
        cargs.push(
            "--featuresubset",
            (params["feature_subset"] ?? null)
        );
    }
    if ((params["mat_feature_num"] ?? null) !== null) {
        cargs.push(
            "--matfeaturenum",
            String((params["mat_feature_num"] ?? null))
        );
    }
    if ((params["spatial_weight"] ?? null) !== null) {
        cargs.push(
            "--spatialweight",
            String((params["spatial_weight"] ?? null))
        );
    }
    if ((params["patch_sizes"] ?? null) !== null) {
        cargs.push(
            "--patchsizes",
            (params["patch_sizes"] ?? null)
        );
    }
    if ((params["patch_3d"] ?? null)) {
        cargs.push("--patch3D");
    }
    if ((params["select_pts"] ?? null) !== null) {
        cargs.push(
            "--selectpts",
            (params["select_pts"] ?? null)
        );
    }
    if ((params["training_pts"] ?? null) !== null) {
        cargs.push(
            "--trainingpts",
            (params["training_pts"] ?? null)
        );
    }
    if ((params["non_les_pts"] ?? null) !== null) {
        cargs.push(
            "--nonlespts",
            (params["non_les_pts"] ?? null)
        );
    }
    if ((params["save_classifier_data"] ?? null) !== null) {
        cargs.push(
            "--saveclassifierdata",
            (params["save_classifier_data"] ?? null)
        );
    }
    if ((params["verbose_flag"] ?? null)) {
        cargs.push("-v");
    }
    if ((params["out_name"] ?? null) !== null) {
        cargs.push(
            "-o",
            (params["out_name"] ?? null)
        );
    }
    return cargs;
}


function bianca_outputs(
    params: BiancaParameters,
    execution: Execution,
): BiancaOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: BiancaOutputs = {
        root: execution.outputFile("."),
        base_output: ((params["out_name"] ?? null) !== null) ? execution.outputFile([(params["out_name"] ?? null), "_bianca"].join('')) : null,
    };
    return ret;
}


function bianca_execute(
    params: BiancaParameters,
    execution: Execution,
): BiancaOutputs {
    /**
     * BIANCA: Brain Intensity AbNormality Classification Algorithm.
     * 
     * Author: FMRIB Analysis Group, University of Oxford
     * 
     * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `BiancaOutputs`).
     */
    params = execution.params(params)
    const cargs = bianca_cargs(params, execution)
    const ret = bianca_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function bianca(
    master_file: InputPathType,
    label_feature_num: number,
    brain_mask_feature_num: number,
    query_subject_num: number,
    feature_subset: string | null = null,
    mat_feature_num: number | null = null,
    spatial_weight: number | null = 1,
    patch_sizes: string | null = null,
    patch_3d: boolean = false,
    select_pts: string | null = "any",
    training_pts: string | null = null,
    non_les_pts: string | null = null,
    save_classifier_data: string | null = null,
    verbose_flag: boolean = false,
    out_name: string | null = "output_bianca",
    runner: Runner | null = null,
): BiancaOutputs {
    /**
     * BIANCA: Brain Intensity AbNormality Classification Algorithm.
     * 
     * Author: FMRIB Analysis Group, University of Oxford
     * 
     * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
     * @param master_file Name of the master file
     * @param label_feature_num Column number (in the master file) of the manual masks (or any placeholder name for query subjects)
     * @param brain_mask_feature_num Column number (in the master file) of images to derive non-zero mask from
     * @param query_subject_num Row number of query subject (in masterlistfile)
     * @param feature_subset Set of column numbers (comma separated and no spaces) for features/images to use (default: use all available modalities as intensity features). The image used to derive non-zero mask from must be part of the features subset
     * @param mat_feature_num Column number of matrix files (in masterlistfile). Needed to extract spatial features (MNI coordinates)
     * @param spatial_weight Weighting for spatial coordinates (default = 1, i.e., variance-normalized MNI coordinates). Requires --matfeaturenum to be specified
     * @param patch_sizes List of patch sizes for local averaging
     * @param patch_3d Use 3D patches (default is 2D)
     * @param select_pts "any" (default) or "surround" or "noborder"
     * @param training_pts Number (max) of (lesion) points to use (per training subject) or "equalpoints" to select all lesion points and equal number of non-lesion points
     * @param non_les_pts Number (max) of non-lesion points to use. If not specified will be set to the same amount of lesion points
     * @param save_classifier_data Save training data to file
     * @param verbose_flag Use verbose mode
     * @param out_name Specify (base) output name of files
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `BiancaOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(BIANCA_METADATA);
    const params = bianca_params(master_file, label_feature_num, brain_mask_feature_num, query_subject_num, feature_subset, mat_feature_num, spatial_weight, patch_sizes, patch_3d, select_pts, training_pts, non_les_pts, save_classifier_data, verbose_flag, out_name)
    return bianca_execute(params, execution);
}


export {
      BIANCA_METADATA,
      BiancaOutputs,
      BiancaParameters,
      bianca,
      bianca_params,
};
