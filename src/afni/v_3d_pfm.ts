// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_3D_PFM_METADATA: Metadata = {
    id: "d084aee5c4e75cf817ad2d01aebd36c373c18a2d.boutiques",
    name: "3dPFM",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V3dPfmParameters {
    "__STYXTYPE__": "3dPFM";
    "input": InputPathType;
    "mask"?: InputPathType | null | undefined;
    "algorithm"?: string | null | undefined;
    "criteria"?: string | null | undefined;
    "nonzeros"?: number | null | undefined;
    "maxiter"?: number | null | undefined;
    "maxiterfactor"?: number | null | undefined;
    "tr"?: number | null | undefined;
    "hrf"?: string | null | undefined;
    "hrf_vol"?: InputPathType | null | undefined;
    "idx_hrf"?: InputPathType | null | undefined;
    "LHS"?: Array<InputPathType> | null | undefined;
    "jobs"?: number | null | undefined;
    "nSeg"?: number | null | undefined;
    "verb"?: number | null | undefined;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "3dPFM": v_3d_pfm_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "3dPFM": v_3d_pfm_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `v_3d_pfm(...)`.
 *
 * @interface
 */
interface V3dPfmOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Prefix for the neuronal-related (i.e. deconvolved) time series.
     */
    beta: OutputPathType;
    /**
     * Prefix of the convolved neuronal-related time series.
     */
    betafitts: OutputPathType;
    /**
     * Prefix for the fitted time series.
     */
    fitts: OutputPathType;
    /**
     * Prefix for the residuals of the fit to the data.
     */
    resid: OutputPathType;
    /**
     * Prefix for the intercept of the model.
     */
    mean: OutputPathType;
    /**
     * Prefix for the estimates of the LHS parameters.
     */
    lhsest: OutputPathType;
    /**
     * Prefix for the fitted time series of the LHS parameters.
     */
    lhsfitts: OutputPathType;
    /**
     * Prefix for output volume with the regularization parameter of the deconvolution of each voxel.
     */
    lambda: OutputPathType;
    /**
     * Prefix for output volume of the cost function used to select the regularization parameter according to the selected criteria.
     */
    costs: OutputPathType;
    /**
     * Prefix for the T-statistics of beta at each time point.
     */
    tstats_beta: OutputPathType;
    /**
     * Prefix for degrees of freedom of the T-statistics of beta.
     */
    tdf_beta: OutputPathType;
    /**
     * Prefix for (normalized) z-scores of the T-statistics of beta.
     */
    z_tstats_beta: OutputPathType;
    /**
     * Prefix for the F-statistics of the deconvolved component.
     */
    fstats_beta: OutputPathType;
    /**
     * Prefix for degrees of freedom of Fstats_beta.
     */
    fdf_beta: OutputPathType;
    /**
     * Prefix for (normalized) z-scores of the Fstats_beta.
     */
    z_fstats_beta: OutputPathType;
    /**
     * Prefix for T-statistics of LHS regressors at each time point.
     */
    tstats_lhs: OutputPathType;
    /**
     * Prefix for degrees of freedom of the Tstats_LHS.
     */
    tdf_lhs: OutputPathType;
    /**
     * Prefix for (normalized) z-scores of the Tstats_LHS.
     */
    z_tstats_lhs: OutputPathType;
    /**
     * Prefix for the F-statistics of the LHS regressors.
     */
    fstats_lhs: OutputPathType;
    /**
     * Prefix for degrees of freedom of Fstats_LHS.
     */
    fdf_lhs: OutputPathType;
    /**
     * Prefix for (normalized) z-scores of Fstats_LHS.
     */
    z_fstats_lhs: OutputPathType;
    /**
     * Prefix for the F-statistics of the full model.
     */
    fstats_full: OutputPathType;
    /**
     * Prefix for degrees of freedom of Fstats_full.
     */
    fdf_full: OutputPathType;
    /**
     * Prefix for (normalized) z-scores of Fstats_full.
     */
    z_fstats_full: OutputPathType;
    /**
     * Prefix for R² (coefficient of determination) of the full model.
     */
    r2_full: OutputPathType;
    /**
     * Prefix for Adjusted R² coefficient for the full model.
     */
    r2adj_full: OutputPathType;
}


function v_3d_pfm_params(
    input: InputPathType,
    mask: InputPathType | null = null,
    algorithm: string | null = null,
    criteria: string | null = null,
    nonzeros: number | null = null,
    maxiter: number | null = null,
    maxiterfactor: number | null = null,
    tr: number | null = null,
    hrf: string | null = null,
    hrf_vol: InputPathType | null = null,
    idx_hrf: InputPathType | null = null,
    lhs: Array<InputPathType> | null = null,
    jobs: number | null = null,
    n_seg: number | null = null,
    verb: number | null = null,
): V3dPfmParameters {
    /**
     * Build parameters.
    
     * @param input Specify the dataset to analyze (e.g., epi.nii).
     * @param mask Process voxels inside this mask only. Default is no masking.
     * @param algorithm Regularization function used for HRF deconvolution (dantzig or lasso).
     * @param criteria Model selection criterion for HRF deconvolution (BIC or AIC).
     * @param nonzeros Choose estimate with a fixed number of nonzero coefficients.
     * @param maxiter Maximum number of iterations in the homotopy procedure (absolute value).
     * @param maxiterfactor Maximum number of iterations relative to the number of volumes.
     * @param tr Repetition time or sampling period of the input data.
     * @param hrf Haemodynamic response function used for deconvolution.
     * @param hrf_vol 3D+time dataset with voxel/nodes/vertex -dependent HRFs.
     * @param idx_hrf 3D dataset with voxel-dependent indexes for HRF.
     * @param lhs Additional regressors to be fitted to the dataset.
     * @param jobs Number of parallel jobs to use in processing.
     * @param n_seg Divide into segments to report progress.
     * @param verb Verbosity level (0 for quiet, 1 for talkative).
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "3dPFM" as const,
        "input": input,
    };
    if (mask !== null) {
        params["mask"] = mask;
    }
    if (algorithm !== null) {
        params["algorithm"] = algorithm;
    }
    if (criteria !== null) {
        params["criteria"] = criteria;
    }
    if (nonzeros !== null) {
        params["nonzeros"] = nonzeros;
    }
    if (maxiter !== null) {
        params["maxiter"] = maxiter;
    }
    if (maxiterfactor !== null) {
        params["maxiterfactor"] = maxiterfactor;
    }
    if (tr !== null) {
        params["tr"] = tr;
    }
    if (hrf !== null) {
        params["hrf"] = hrf;
    }
    if (hrf_vol !== null) {
        params["hrf_vol"] = hrf_vol;
    }
    if (idx_hrf !== null) {
        params["idx_hrf"] = idx_hrf;
    }
    if (lhs !== null) {
        params["LHS"] = lhs;
    }
    if (jobs !== null) {
        params["jobs"] = jobs;
    }
    if (n_seg !== null) {
        params["nSeg"] = n_seg;
    }
    if (verb !== null) {
        params["verb"] = verb;
    }
    return params;
}


function v_3d_pfm_cargs(
    params: V3dPfmParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("3dPFM");
    cargs.push(
        "-input",
        execution.inputFile((params["input"] ?? null))
    );
    if ((params["mask"] ?? null) !== null) {
        cargs.push(
            "-mask",
            execution.inputFile((params["mask"] ?? null))
        );
    }
    if ((params["algorithm"] ?? null) !== null) {
        cargs.push(
            "-algorithm",
            (params["algorithm"] ?? null)
        );
    }
    if ((params["criteria"] ?? null) !== null) {
        cargs.push(
            "-criteria",
            (params["criteria"] ?? null)
        );
    }
    if ((params["nonzeros"] ?? null) !== null) {
        cargs.push(
            "-nonzeros",
            String((params["nonzeros"] ?? null))
        );
    }
    if ((params["maxiter"] ?? null) !== null) {
        cargs.push(
            "-maxiter",
            String((params["maxiter"] ?? null))
        );
    }
    if ((params["maxiterfactor"] ?? null) !== null) {
        cargs.push(
            "-maxiterfactor",
            String((params["maxiterfactor"] ?? null))
        );
    }
    if ((params["tr"] ?? null) !== null) {
        cargs.push(
            "-TR",
            String((params["tr"] ?? null))
        );
    }
    if ((params["hrf"] ?? null) !== null) {
        cargs.push(
            "-hrf",
            (params["hrf"] ?? null)
        );
    }
    if ((params["hrf_vol"] ?? null) !== null) {
        cargs.push(
            "-hrf_vol",
            execution.inputFile((params["hrf_vol"] ?? null))
        );
    }
    if ((params["idx_hrf"] ?? null) !== null) {
        cargs.push(
            "-idx_hrf",
            execution.inputFile((params["idx_hrf"] ?? null))
        );
    }
    if ((params["LHS"] ?? null) !== null) {
        cargs.push(
            "-LHS",
            ...(params["LHS"] ?? null).map(f => execution.inputFile(f))
        );
    }
    if ((params["jobs"] ?? null) !== null) {
        cargs.push(
            "-jobs",
            String((params["jobs"] ?? null))
        );
    }
    if ((params["nSeg"] ?? null) !== null) {
        cargs.push(
            "-nSeg",
            String((params["nSeg"] ?? null))
        );
    }
    if ((params["verb"] ?? null) !== null) {
        cargs.push(
            "-verb",
            String((params["verb"] ?? null))
        );
    }
    return cargs;
}


function v_3d_pfm_outputs(
    params: V3dPfmParameters,
    execution: Execution,
): V3dPfmOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: V3dPfmOutputs = {
        root: execution.outputFile("."),
        beta: execution.outputFile(["[BETA]"].join('')),
        betafitts: execution.outputFile(["[BETAFITTS]"].join('')),
        fitts: execution.outputFile(["[FITTS]"].join('')),
        resid: execution.outputFile(["[RESID]"].join('')),
        mean: execution.outputFile(["[MEAN]"].join('')),
        lhsest: execution.outputFile(["[LHSEST]"].join('')),
        lhsfitts: execution.outputFile(["[LHSFITTS]"].join('')),
        lambda: execution.outputFile(["[LAMBDA]"].join('')),
        costs: execution.outputFile(["[COSTS]"].join('')),
        tstats_beta: execution.outputFile(["[TSTATS_BETA]"].join('')),
        tdf_beta: execution.outputFile(["[TDF_BETA]"].join('')),
        z_tstats_beta: execution.outputFile(["[Z_TSTATS_BETA]"].join('')),
        fstats_beta: execution.outputFile(["[FSTATS_BETA]"].join('')),
        fdf_beta: execution.outputFile(["[FDF_BETA]"].join('')),
        z_fstats_beta: execution.outputFile(["[Z_FSTATS_BETA]"].join('')),
        tstats_lhs: execution.outputFile(["[TSTATS_LHS]"].join('')),
        tdf_lhs: execution.outputFile(["[TDF_LHS]"].join('')),
        z_tstats_lhs: execution.outputFile(["[Z_TSTATS_LHS]"].join('')),
        fstats_lhs: execution.outputFile(["[FSTATS_LHS]"].join('')),
        fdf_lhs: execution.outputFile(["[FDF_LHS]"].join('')),
        z_fstats_lhs: execution.outputFile(["[Z_FSTATS_LHS]"].join('')),
        fstats_full: execution.outputFile(["[FSTATS_FULL]"].join('')),
        fdf_full: execution.outputFile(["[FDF_FULL]"].join('')),
        z_fstats_full: execution.outputFile(["[Z_FSTATS_FULL]"].join('')),
        r2_full: execution.outputFile(["[R2_FULL]"].join('')),
        r2adj_full: execution.outputFile(["[R2ADJ_FULL]"].join('')),
    };
    return ret;
}


function v_3d_pfm_execute(
    params: V3dPfmParameters,
    execution: Execution,
): V3dPfmOutputs {
    /**
     * Program for identifying brief BOLD events in fMRI time series using Paradigm Free Mapping.
     * 
     * Author: AFNI Developers
     * 
     * URL: https://afni.nimh.nih.gov/
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `V3dPfmOutputs`).
     */
    params = execution.params(params)
    const cargs = v_3d_pfm_cargs(params, execution)
    const ret = v_3d_pfm_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function v_3d_pfm(
    input: InputPathType,
    mask: InputPathType | null = null,
    algorithm: string | null = null,
    criteria: string | null = null,
    nonzeros: number | null = null,
    maxiter: number | null = null,
    maxiterfactor: number | null = null,
    tr: number | null = null,
    hrf: string | null = null,
    hrf_vol: InputPathType | null = null,
    idx_hrf: InputPathType | null = null,
    lhs: Array<InputPathType> | null = null,
    jobs: number | null = null,
    n_seg: number | null = null,
    verb: number | null = null,
    runner: Runner | null = null,
): V3dPfmOutputs {
    /**
     * Program for identifying brief BOLD events in fMRI time series using Paradigm Free Mapping.
     * 
     * Author: AFNI Developers
     * 
     * URL: https://afni.nimh.nih.gov/
    
     * @param input Specify the dataset to analyze (e.g., epi.nii).
     * @param mask Process voxels inside this mask only. Default is no masking.
     * @param algorithm Regularization function used for HRF deconvolution (dantzig or lasso).
     * @param criteria Model selection criterion for HRF deconvolution (BIC or AIC).
     * @param nonzeros Choose estimate with a fixed number of nonzero coefficients.
     * @param maxiter Maximum number of iterations in the homotopy procedure (absolute value).
     * @param maxiterfactor Maximum number of iterations relative to the number of volumes.
     * @param tr Repetition time or sampling period of the input data.
     * @param hrf Haemodynamic response function used for deconvolution.
     * @param hrf_vol 3D+time dataset with voxel/nodes/vertex -dependent HRFs.
     * @param idx_hrf 3D dataset with voxel-dependent indexes for HRF.
     * @param lhs Additional regressors to be fitted to the dataset.
     * @param jobs Number of parallel jobs to use in processing.
     * @param n_seg Divide into segments to report progress.
     * @param verb Verbosity level (0 for quiet, 1 for talkative).
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `V3dPfmOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_3D_PFM_METADATA);
    const params = v_3d_pfm_params(input, mask, algorithm, criteria, nonzeros, maxiter, maxiterfactor, tr, hrf, hrf_vol, idx_hrf, lhs, jobs, n_seg, verb)
    return v_3d_pfm_execute(params, execution);
}


export {
      V3dPfmOutputs,
      V3dPfmParameters,
      V_3D_PFM_METADATA,
      v_3d_pfm,
      v_3d_pfm_params,
};
