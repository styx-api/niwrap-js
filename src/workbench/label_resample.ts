// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const LABEL_RESAMPLE_METADATA: Metadata = {
    id: "695b221832d5527bc6d781edaf957f7b83318aa6.boutiques",
    name: "label-resample",
    package: "workbench",
    container_image_tag: "brainlife/connectome_workbench:1.5.0-freesurfer-update",
};


interface LabelResampleAreaSurfsParameters {
    "__STYXTYPE__": "area_surfs";
    "current_area": InputPathType;
    "new_area": InputPathType;
}


interface LabelResampleAreaMetricsParameters {
    "__STYXTYPE__": "area_metrics";
    "current_area": InputPathType;
    "new_area": InputPathType;
}


interface LabelResampleParameters {
    "__STYXTYPE__": "label-resample";
    "label_in": InputPathType;
    "current_sphere": InputPathType;
    "new_sphere": InputPathType;
    "method": string;
    "label_out": string;
    "area_surfs"?: LabelResampleAreaSurfsParameters | null | undefined;
    "area_metrics"?: LabelResampleAreaMetricsParameters | null | undefined;
    "opt_current_roi_roi_metric"?: InputPathType | null | undefined;
    "opt_valid_roi_out_roi_out"?: string | null | undefined;
    "opt_largest": boolean;
    "opt_bypass_sphere_check": boolean;
}


function dynCargs(
    t: string,
): Function | undefined {
    /**
     * Get build cargs function by command type.
    
     * @param t Command type
    
     * @returns Build cargs function.
     */
    const cargsFuncs = {
        "label-resample": label_resample_cargs,
        "area_surfs": label_resample_area_surfs_cargs,
        "area_metrics": label_resample_area_metrics_cargs,
    };
    return cargsFuncs[t];
}


function dynOutputs(
    t: string,
): Function | undefined {
    /**
     * Get build outputs function by command type.
    
     * @param t Command type
    
     * @returns Build outputs function.
     */
    const outputsFuncs = {
        "label-resample": label_resample_outputs,
    };
    return outputsFuncs[t];
}


function label_resample_area_surfs_params(
    current_area: InputPathType,
    new_area: InputPathType,
): LabelResampleAreaSurfsParameters {
    /**
     * Build parameters.
    
     * @param current_area a relevant anatomical surface with <current-sphere> mesh
     * @param new_area a relevant anatomical surface with <new-sphere> mesh
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "area_surfs" as const,
        "current_area": current_area,
        "new_area": new_area,
    };
    return params;
}


function label_resample_area_surfs_cargs(
    params: LabelResampleAreaSurfsParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("-area-surfs");
    cargs.push(execution.inputFile((params["current_area"] ?? null)));
    cargs.push(execution.inputFile((params["new_area"] ?? null)));
    return cargs;
}


function label_resample_area_metrics_params(
    current_area: InputPathType,
    new_area: InputPathType,
): LabelResampleAreaMetricsParameters {
    /**
     * Build parameters.
    
     * @param current_area a metric file with vertex areas for <current-sphere> mesh
     * @param new_area a metric file with vertex areas for <new-sphere> mesh
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "area_metrics" as const,
        "current_area": current_area,
        "new_area": new_area,
    };
    return params;
}


function label_resample_area_metrics_cargs(
    params: LabelResampleAreaMetricsParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("-area-metrics");
    cargs.push(execution.inputFile((params["current_area"] ?? null)));
    cargs.push(execution.inputFile((params["new_area"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `label_resample(...)`.
 *
 * @interface
 */
interface LabelResampleOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * the output label file
     */
    label_out: OutputPathType;
    /**
     * output the ROI of vertices that got data from valid source vertices: the output roi as a metric
     */
    opt_valid_roi_out_roi_out: OutputPathType | null;
}


function label_resample_params(
    label_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    label_out: string,
    area_surfs: LabelResampleAreaSurfsParameters | null = null,
    area_metrics: LabelResampleAreaMetricsParameters | null = null,
    opt_current_roi_roi_metric: InputPathType | null = null,
    opt_valid_roi_out_roi_out: string | null = null,
    opt_largest: boolean = false,
    opt_bypass_sphere_check: boolean = false,
): LabelResampleParameters {
    /**
     * Build parameters.
    
     * @param label_in the label file to resample
     * @param current_sphere a sphere surface with the mesh that the label file is currently on
     * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
     * @param method the method name
     * @param label_out the output label file
     * @param area_surfs specify surfaces to do vertex area correction based on
     * @param area_metrics specify vertex area metrics to do area correction based on
     * @param opt_current_roi_roi_metric use an input roi on the current mesh to exclude non-data vertices: the roi, as a metric file
     * @param opt_valid_roi_out_roi_out output the ROI of vertices that got data from valid source vertices: the output roi as a metric
     * @param opt_largest use only the label of the vertex with the largest weight
     * @param opt_bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
    
     * @returns Parameter dictionary
     */
    const params = {
        "__STYXTYPE__": "label-resample" as const,
        "label_in": label_in,
        "current_sphere": current_sphere,
        "new_sphere": new_sphere,
        "method": method,
        "label_out": label_out,
        "opt_largest": opt_largest,
        "opt_bypass_sphere_check": opt_bypass_sphere_check,
    };
    if (area_surfs !== null) {
        params["area_surfs"] = area_surfs;
    }
    if (area_metrics !== null) {
        params["area_metrics"] = area_metrics;
    }
    if (opt_current_roi_roi_metric !== null) {
        params["opt_current_roi_roi_metric"] = opt_current_roi_roi_metric;
    }
    if (opt_valid_roi_out_roi_out !== null) {
        params["opt_valid_roi_out_roi_out"] = opt_valid_roi_out_roi_out;
    }
    return params;
}


function label_resample_cargs(
    params: LabelResampleParameters,
    execution: Execution,
): string[] {
    /**
     * Build command-line arguments from parameters.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Command-line arguments.
     */
    const cargs: string[] = [];
    cargs.push("wb_command");
    cargs.push("-label-resample");
    cargs.push(execution.inputFile((params["label_in"] ?? null)));
    cargs.push(execution.inputFile((params["current_sphere"] ?? null)));
    cargs.push(execution.inputFile((params["new_sphere"] ?? null)));
    cargs.push((params["method"] ?? null));
    cargs.push((params["label_out"] ?? null));
    if ((params["area_surfs"] ?? null) !== null) {
        cargs.push(...dynCargs((params["area_surfs"] ?? null).__STYXTYPE__)((params["area_surfs"] ?? null), execution));
    }
    if ((params["area_metrics"] ?? null) !== null) {
        cargs.push(...dynCargs((params["area_metrics"] ?? null).__STYXTYPE__)((params["area_metrics"] ?? null), execution));
    }
    if ((params["opt_current_roi_roi_metric"] ?? null) !== null) {
        cargs.push(
            "-current-roi",
            execution.inputFile((params["opt_current_roi_roi_metric"] ?? null))
        );
    }
    if ((params["opt_valid_roi_out_roi_out"] ?? null) !== null) {
        cargs.push(
            "-valid-roi-out",
            (params["opt_valid_roi_out_roi_out"] ?? null)
        );
    }
    if ((params["opt_largest"] ?? null)) {
        cargs.push("-largest");
    }
    if ((params["opt_bypass_sphere_check"] ?? null)) {
        cargs.push("-bypass-sphere-check");
    }
    return cargs;
}


function label_resample_outputs(
    params: LabelResampleParameters,
    execution: Execution,
): LabelResampleOutputs {
    /**
     * Build outputs object containing output file paths and possibly stdout/stderr.
    
     * @param params The parameters.
     * @param execution The execution object for resolving input paths.
    
     * @returns Outputs object.
     */
    const ret: LabelResampleOutputs = {
        root: execution.outputFile("."),
        label_out: execution.outputFile([(params["label_out"] ?? null)].join('')),
        opt_valid_roi_out_roi_out: ((params["opt_valid_roi_out_roi_out"] ?? null) !== null) ? execution.outputFile([(params["opt_valid_roi_out_roi_out"] ?? null)].join('')) : null,
    };
    return ret;
}


function label_resample_execute(
    params: LabelResampleParameters,
    execution: Execution,
): LabelResampleOutputs {
    /**
     * Resample a label file to a different mesh.
     * 
     * Resamples a label file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
     * 
     * The ADAP_BARY_AREA method is recommended for label data, because it should be better at resolving vertices that are near multiple labels, or in case of downsampling.  Midthickness surfaces are recommended for the vertex areas for most data.
     * 
     * The -largest option results in nearest vertex behavior when used with BARYCENTRIC, as it uses the value of the source vertex that has the largest weight.
     * 
     * When -largest is not specified, the vertex weights are summed according to which label they correspond to, and the label with the largest sum is used.
     * 
     * The <method> argument must be one of the following:
     * 
     * ADAP_BARY_AREA
     * BARYCENTRIC
     * .
     * 
     * Author: Connectome Workbench Developers
     * 
     * URL: https://github.com/Washington-University/workbench
    
     * @param params The parameters.
     * @param execution The execution object.
    
     * @returns NamedTuple of outputs (described in `LabelResampleOutputs`).
     */
    params = execution.params(params)
    const cargs = label_resample_cargs(params, execution)
    const ret = label_resample_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


function label_resample(
    label_in: InputPathType,
    current_sphere: InputPathType,
    new_sphere: InputPathType,
    method: string,
    label_out: string,
    area_surfs: LabelResampleAreaSurfsParameters | null = null,
    area_metrics: LabelResampleAreaMetricsParameters | null = null,
    opt_current_roi_roi_metric: InputPathType | null = null,
    opt_valid_roi_out_roi_out: string | null = null,
    opt_largest: boolean = false,
    opt_bypass_sphere_check: boolean = false,
    runner: Runner | null = null,
): LabelResampleOutputs {
    /**
     * Resample a label file to a different mesh.
     * 
     * Resamples a label file, given two spherical surfaces that are in register.  If ADAP_BARY_AREA is used, exactly one of -area-surfs or -area-metrics must be specified.
     * 
     * The ADAP_BARY_AREA method is recommended for label data, because it should be better at resolving vertices that are near multiple labels, or in case of downsampling.  Midthickness surfaces are recommended for the vertex areas for most data.
     * 
     * The -largest option results in nearest vertex behavior when used with BARYCENTRIC, as it uses the value of the source vertex that has the largest weight.
     * 
     * When -largest is not specified, the vertex weights are summed according to which label they correspond to, and the label with the largest sum is used.
     * 
     * The <method> argument must be one of the following:
     * 
     * ADAP_BARY_AREA
     * BARYCENTRIC
     * .
     * 
     * Author: Connectome Workbench Developers
     * 
     * URL: https://github.com/Washington-University/workbench
    
     * @param label_in the label file to resample
     * @param current_sphere a sphere surface with the mesh that the label file is currently on
     * @param new_sphere a sphere surface that is in register with <current-sphere> and has the desired output mesh
     * @param method the method name
     * @param label_out the output label file
     * @param area_surfs specify surfaces to do vertex area correction based on
     * @param area_metrics specify vertex area metrics to do area correction based on
     * @param opt_current_roi_roi_metric use an input roi on the current mesh to exclude non-data vertices: the roi, as a metric file
     * @param opt_valid_roi_out_roi_out output the ROI of vertices that got data from valid source vertices: the output roi as a metric
     * @param opt_largest use only the label of the vertex with the largest weight
     * @param opt_bypass_sphere_check ADVANCED: allow the current and new 'spheres' to have arbitrary shape as long as they follow the same contour
     * @param runner Command runner
    
     * @returns NamedTuple of outputs (described in `LabelResampleOutputs`).
     */
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(LABEL_RESAMPLE_METADATA);
    const params = label_resample_params(label_in, current_sphere, new_sphere, method, label_out, area_surfs, area_metrics, opt_current_roi_roi_metric, opt_valid_roi_out_roi_out, opt_largest, opt_bypass_sphere_check)
    return label_resample_execute(params, execution);
}


export {
      LABEL_RESAMPLE_METADATA,
      LabelResampleAreaMetricsParameters,
      LabelResampleAreaSurfsParameters,
      LabelResampleOutputs,
      LabelResampleParameters,
      label_resample,
      label_resample_area_metrics_params,
      label_resample_area_surfs_params,
      label_resample_params,
};
