// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const RUN_FASTSURFER_SH_METADATA: Metadata = {
    id: "4c7357e7f50f364b75dcb59c1f217148dea45614.boutiques",
    name: "run_fastsurfer.sh",
    package: "fastsurfer",
    container_image_tag: "deepmi/fastsurfer:cpu-v2.3.3",
};


interface RunFastsurferShParameters {
    "@type"?: "fastsurfer/run_fastsurfer.sh";
    "sid": string;
    "subjects_dir": string;
    "t1_input": InputPathType;
    "fs_license"?: InputPathType | null | undefined;
    "asegdkt_segfile"?: string | null | undefined;
    "vox_size"?: string | null | undefined;
    "seg_only": boolean;
    "seg_log"?: string | null | undefined;
    "conformed_name"?: string | null | undefined;
    "norm_name"?: string | null | undefined;
    "t2_input"?: InputPathType | null | undefined;
    "reg_mode"?: "none" | "coreg" | "robust" | null | undefined;
    "threads"?: number | null | undefined;
    "device"?: string | null | undefined;
    "viewagg_device"?: string | null | undefined;
    "batch_size"?: number | null | undefined;
    "python_cmd"?: string | null | undefined;
    "surf_only": boolean;
    "no_biasfield": boolean;
    "tal_reg": boolean;
    "no_asegdkt": boolean;
    "no_cereb": boolean;
    "cereb_segfile"?: string | null | undefined;
    "no_hypothal": boolean;
    "qc_snap": boolean;
    "three_t": boolean;
    "parallel": boolean;
    "ignore_fs_version": boolean;
    "fstess": boolean;
    "fsqsphere": boolean;
    "fsaparc": boolean;
    "no_fs_t1": boolean;
    "no_surfreg": boolean;
    "allow_root": boolean;
    "version"?: string | null | undefined;
}
type RunFastsurferShParametersTagged = Required<Pick<RunFastsurferShParameters, '@type'>> & RunFastsurferShParameters;


/**
 * Output object returned when calling `RunFastsurferShParameters(...)`.
 *
 * @interface
 */
interface RunFastsurferShOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * FastSurferVINN segmentation output
     */
    segmentation: OutputPathType;
    /**
     * Generated surface files
     */
    surface_files: OutputPathType;
    /**
     * Cerebellum segmentation output
     */
    cerebellum_seg: OutputPathType;
    /**
     * Quality control snapshot images
     */
    qc_snapshots: OutputPathType;
    /**
     * Bias field corrected image
     */
    bias_corrected: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param sid Subject ID to create directory inside SUBJECTS_DIR
 * @param subjects_dir Output directory SUBJECTS_DIR
 * @param t1_input T1 full head input (not bias corrected). Requires an ABSOLUTE Path!
 * @param fs_license Path to FreeSurfer license key file
 * @param asegdkt_segfile Name of the segmentation file including aparc+DKTatlas-aseg segmentations
 * @param vox_size Forces processing at a specific voxel size (0.7-1 or 'min')
 * @param seg_only Run only FastSurferVINN
 * @param seg_log Log-file for the segmentation
 * @param conformed_name Name of the file for the conformed input image
 * @param norm_name Name of the biasfield corrected image
 * @param t2_input Optional T2 full head input
 * @param reg_mode Registration method for T1 and T2 images
 * @param threads Set openMP and ITK threads
 * @param device Device for inference (cpu/cuda)
 * @param viewagg_device Device for view aggregation
 * @param batch_size Batch size for inference
 * @param python_cmd Command for python
 * @param surf_only Run surface pipeline only
 * @param no_biasfield Deactivate bias field correction and partial volume-corrected stats
 * @param tal_reg Perform talairach registration for eTIV estimates
 * @param no_asegdkt Skip the asegdkt segmentation
 * @param no_cereb Skip the cerebellum segmentation
 * @param cereb_segfile Name of DL-based segmentation file of the cerebellum
 * @param no_hypothal Skip the hypothalamus segmentation
 * @param qc_snap Create QC snapshots in subjects directory
 * @param three_t Use the 3T atlas for talairach registration
 * @param parallel Run both hemispheres in parallel
 * @param ignore_fs_version Switch on to avoid check for FreeSurfer version
 * @param fstess Switch on mri_tesselate for surface creation
 * @param fsqsphere Use FreeSurfer iterative inflation for qsphere
 * @param fsaparc Additionally create FS aparc segmentations and ribbon
 * @param no_fs_t1 Do not generate T1.mgz
 * @param no_surfreg Do not run Surface registration with FreeSurfer
 * @param allow_root Allow execution as root user
 * @param version Print version information
 *
 * @returns Parameter dictionary
 */
function run_fastsurfer_sh_params(
    sid: string,
    subjects_dir: string,
    t1_input: InputPathType,
    fs_license: InputPathType | null = null,
    asegdkt_segfile: string | null = null,
    vox_size: string | null = null,
    seg_only: boolean = false,
    seg_log: string | null = null,
    conformed_name: string | null = null,
    norm_name: string | null = null,
    t2_input: InputPathType | null = null,
    reg_mode: "none" | "coreg" | "robust" | null = null,
    threads: number | null = null,
    device: string | null = null,
    viewagg_device: string | null = null,
    batch_size: number | null = null,
    python_cmd: string | null = null,
    surf_only: boolean = false,
    no_biasfield: boolean = false,
    tal_reg: boolean = false,
    no_asegdkt: boolean = false,
    no_cereb: boolean = false,
    cereb_segfile: string | null = null,
    no_hypothal: boolean = false,
    qc_snap: boolean = false,
    three_t: boolean = false,
    parallel: boolean = false,
    ignore_fs_version: boolean = false,
    fstess: boolean = false,
    fsqsphere: boolean = false,
    fsaparc: boolean = false,
    no_fs_t1: boolean = false,
    no_surfreg: boolean = false,
    allow_root: boolean = false,
    version: string | null = null,
): RunFastsurferShParametersTagged {
    const params = {
        "@type": "fastsurfer/run_fastsurfer.sh" as const,
        "sid": sid,
        "subjects_dir": subjects_dir,
        "t1_input": t1_input,
        "seg_only": seg_only,
        "surf_only": surf_only,
        "no_biasfield": no_biasfield,
        "tal_reg": tal_reg,
        "no_asegdkt": no_asegdkt,
        "no_cereb": no_cereb,
        "no_hypothal": no_hypothal,
        "qc_snap": qc_snap,
        "three_t": three_t,
        "parallel": parallel,
        "ignore_fs_version": ignore_fs_version,
        "fstess": fstess,
        "fsqsphere": fsqsphere,
        "fsaparc": fsaparc,
        "no_fs_t1": no_fs_t1,
        "no_surfreg": no_surfreg,
        "allow_root": allow_root,
    };
    if (fs_license !== null) {
        params["fs_license"] = fs_license;
    }
    if (asegdkt_segfile !== null) {
        params["asegdkt_segfile"] = asegdkt_segfile;
    }
    if (vox_size !== null) {
        params["vox_size"] = vox_size;
    }
    if (seg_log !== null) {
        params["seg_log"] = seg_log;
    }
    if (conformed_name !== null) {
        params["conformed_name"] = conformed_name;
    }
    if (norm_name !== null) {
        params["norm_name"] = norm_name;
    }
    if (t2_input !== null) {
        params["t2_input"] = t2_input;
    }
    if (reg_mode !== null) {
        params["reg_mode"] = reg_mode;
    }
    if (threads !== null) {
        params["threads"] = threads;
    }
    if (device !== null) {
        params["device"] = device;
    }
    if (viewagg_device !== null) {
        params["viewagg_device"] = viewagg_device;
    }
    if (batch_size !== null) {
        params["batch_size"] = batch_size;
    }
    if (python_cmd !== null) {
        params["python_cmd"] = python_cmd;
    }
    if (cereb_segfile !== null) {
        params["cereb_segfile"] = cereb_segfile;
    }
    if (version !== null) {
        params["version"] = version;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function run_fastsurfer_sh_cargs(
    params: RunFastsurferShParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("run_fastsurfer.sh");
    cargs.push(
        "--sid",
        (params["sid"] ?? null)
    );
    cargs.push(
        "--sd",
        (params["subjects_dir"] ?? null)
    );
    cargs.push(
        "--t1",
        execution.inputFile((params["t1_input"] ?? null))
    );
    if ((params["fs_license"] ?? null) !== null) {
        cargs.push(
            "--fs_license",
            execution.inputFile((params["fs_license"] ?? null))
        );
    }
    if ((params["asegdkt_segfile"] ?? null) !== null) {
        cargs.push(
            "--asegdkt_segfile",
            (params["asegdkt_segfile"] ?? null)
        );
    }
    if ((params["vox_size"] ?? null) !== null) {
        cargs.push(
            "--vox_size",
            (params["vox_size"] ?? null)
        );
    }
    if ((params["seg_only"] ?? false)) {
        cargs.push("--seg_only");
    }
    if ((params["seg_log"] ?? null) !== null) {
        cargs.push(
            "--seg_log",
            (params["seg_log"] ?? null)
        );
    }
    if ((params["conformed_name"] ?? null) !== null) {
        cargs.push(
            "--conformed_name",
            (params["conformed_name"] ?? null)
        );
    }
    if ((params["norm_name"] ?? null) !== null) {
        cargs.push(
            "--norm_name",
            (params["norm_name"] ?? null)
        );
    }
    if ((params["t2_input"] ?? null) !== null) {
        cargs.push(
            "--t2",
            execution.inputFile((params["t2_input"] ?? null))
        );
    }
    if ((params["reg_mode"] ?? null) !== null) {
        cargs.push(
            "--reg_mode",
            (params["reg_mode"] ?? null)
        );
    }
    if ((params["threads"] ?? null) !== null) {
        cargs.push(
            "--threads",
            String((params["threads"] ?? null))
        );
    }
    if ((params["device"] ?? null) !== null) {
        cargs.push(
            "--device",
            (params["device"] ?? null)
        );
    }
    if ((params["viewagg_device"] ?? null) !== null) {
        cargs.push(
            "--viewagg_device",
            (params["viewagg_device"] ?? null)
        );
    }
    if ((params["batch_size"] ?? null) !== null) {
        cargs.push(
            "--batch",
            String((params["batch_size"] ?? null))
        );
    }
    if ((params["python_cmd"] ?? null) !== null) {
        cargs.push(
            "--py",
            (params["python_cmd"] ?? null)
        );
    }
    if ((params["surf_only"] ?? false)) {
        cargs.push("--surf_only");
    }
    if ((params["no_biasfield"] ?? false)) {
        cargs.push("--no_biasfield");
    }
    if ((params["tal_reg"] ?? false)) {
        cargs.push("--tal_reg");
    }
    if ((params["no_asegdkt"] ?? false)) {
        cargs.push("--no_asegdkt");
    }
    if ((params["no_cereb"] ?? false)) {
        cargs.push("--no_cereb");
    }
    if ((params["cereb_segfile"] ?? null) !== null) {
        cargs.push(
            "--cereb_segfile",
            (params["cereb_segfile"] ?? null)
        );
    }
    if ((params["no_hypothal"] ?? false)) {
        cargs.push("--no_hypothal");
    }
    if ((params["qc_snap"] ?? false)) {
        cargs.push("--qc_snap");
    }
    if ((params["three_t"] ?? false)) {
        cargs.push("--3T");
    }
    if ((params["parallel"] ?? false)) {
        cargs.push("--parallel");
    }
    if ((params["ignore_fs_version"] ?? false)) {
        cargs.push("--ignore_fs_version");
    }
    if ((params["fstess"] ?? false)) {
        cargs.push("--fstess");
    }
    if ((params["fsqsphere"] ?? false)) {
        cargs.push("--fsqsphere");
    }
    if ((params["fsaparc"] ?? false)) {
        cargs.push("--fsaparc");
    }
    if ((params["no_fs_t1"] ?? false)) {
        cargs.push("--no_fs_T1");
    }
    if ((params["no_surfreg"] ?? false)) {
        cargs.push("--no_surfreg");
    }
    if ((params["allow_root"] ?? false)) {
        cargs.push("--allow_root");
    }
    if ((params["version"] ?? null) !== null) {
        cargs.push(
            "--version",
            (params["version"] ?? null)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function run_fastsurfer_sh_outputs(
    params: RunFastsurferShParameters,
    execution: Execution,
): RunFastsurferShOutputs {
    const ret: RunFastsurferShOutputs = {
        root: execution.outputFile("."),
        segmentation: execution.outputFile([(params["subjects_dir"] ?? null), "/", (params["sid"] ?? null), "/mri/aparc.DKTatlas+aseg.deep.mgz"].join('')),
        surface_files: execution.outputFile([(params["subjects_dir"] ?? null), "/", (params["sid"] ?? null), "/surf/"].join('')),
        cerebellum_seg: execution.outputFile([(params["subjects_dir"] ?? null), "/", (params["sid"] ?? null), "/mri/cerebellum.CerebNet.nii.gz"].join('')),
        qc_snapshots: execution.outputFile([(params["subjects_dir"] ?? null), "/", (params["sid"] ?? null), "/qc_snapshots/"].join('')),
        bias_corrected: execution.outputFile([(params["subjects_dir"] ?? null), "/", (params["sid"] ?? null), "/mri/orig_nu.mgz"].join('')),
    };
    return ret;
}


/**
 * run_fastsurfer.sh
 *
 * run_fastsurfer.sh takes a T1 full head image and creates segmentation using FastSurferVINN and surfaces using recon-surf.
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `RunFastsurferShOutputs`).
 */
function run_fastsurfer_sh_execute(
    params: RunFastsurferShParameters,
    runner: Runner | null = null,
): RunFastsurferShOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(RUN_FASTSURFER_SH_METADATA);
    params = execution.params(params)
    const cargs = run_fastsurfer_sh_cargs(params, execution)
    const ret = run_fastsurfer_sh_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * run_fastsurfer.sh
 *
 * run_fastsurfer.sh takes a T1 full head image and creates segmentation using FastSurferVINN and surfaces using recon-surf.
 *
 * @param sid Subject ID to create directory inside SUBJECTS_DIR
 * @param subjects_dir Output directory SUBJECTS_DIR
 * @param t1_input T1 full head input (not bias corrected). Requires an ABSOLUTE Path!
 * @param fs_license Path to FreeSurfer license key file
 * @param asegdkt_segfile Name of the segmentation file including aparc+DKTatlas-aseg segmentations
 * @param vox_size Forces processing at a specific voxel size (0.7-1 or 'min')
 * @param seg_only Run only FastSurferVINN
 * @param seg_log Log-file for the segmentation
 * @param conformed_name Name of the file for the conformed input image
 * @param norm_name Name of the biasfield corrected image
 * @param t2_input Optional T2 full head input
 * @param reg_mode Registration method for T1 and T2 images
 * @param threads Set openMP and ITK threads
 * @param device Device for inference (cpu/cuda)
 * @param viewagg_device Device for view aggregation
 * @param batch_size Batch size for inference
 * @param python_cmd Command for python
 * @param surf_only Run surface pipeline only
 * @param no_biasfield Deactivate bias field correction and partial volume-corrected stats
 * @param tal_reg Perform talairach registration for eTIV estimates
 * @param no_asegdkt Skip the asegdkt segmentation
 * @param no_cereb Skip the cerebellum segmentation
 * @param cereb_segfile Name of DL-based segmentation file of the cerebellum
 * @param no_hypothal Skip the hypothalamus segmentation
 * @param qc_snap Create QC snapshots in subjects directory
 * @param three_t Use the 3T atlas for talairach registration
 * @param parallel Run both hemispheres in parallel
 * @param ignore_fs_version Switch on to avoid check for FreeSurfer version
 * @param fstess Switch on mri_tesselate for surface creation
 * @param fsqsphere Use FreeSurfer iterative inflation for qsphere
 * @param fsaparc Additionally create FS aparc segmentations and ribbon
 * @param no_fs_t1 Do not generate T1.mgz
 * @param no_surfreg Do not run Surface registration with FreeSurfer
 * @param allow_root Allow execution as root user
 * @param version Print version information
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `RunFastsurferShOutputs`).
 */
function run_fastsurfer_sh(
    sid: string,
    subjects_dir: string,
    t1_input: InputPathType,
    fs_license: InputPathType | null = null,
    asegdkt_segfile: string | null = null,
    vox_size: string | null = null,
    seg_only: boolean = false,
    seg_log: string | null = null,
    conformed_name: string | null = null,
    norm_name: string | null = null,
    t2_input: InputPathType | null = null,
    reg_mode: "none" | "coreg" | "robust" | null = null,
    threads: number | null = null,
    device: string | null = null,
    viewagg_device: string | null = null,
    batch_size: number | null = null,
    python_cmd: string | null = null,
    surf_only: boolean = false,
    no_biasfield: boolean = false,
    tal_reg: boolean = false,
    no_asegdkt: boolean = false,
    no_cereb: boolean = false,
    cereb_segfile: string | null = null,
    no_hypothal: boolean = false,
    qc_snap: boolean = false,
    three_t: boolean = false,
    parallel: boolean = false,
    ignore_fs_version: boolean = false,
    fstess: boolean = false,
    fsqsphere: boolean = false,
    fsaparc: boolean = false,
    no_fs_t1: boolean = false,
    no_surfreg: boolean = false,
    allow_root: boolean = false,
    version: string | null = null,
    runner: Runner | null = null,
): RunFastsurferShOutputs {
    const params = run_fastsurfer_sh_params(sid, subjects_dir, t1_input, fs_license, asegdkt_segfile, vox_size, seg_only, seg_log, conformed_name, norm_name, t2_input, reg_mode, threads, device, viewagg_device, batch_size, python_cmd, surf_only, no_biasfield, tal_reg, no_asegdkt, no_cereb, cereb_segfile, no_hypothal, qc_snap, three_t, parallel, ignore_fs_version, fstess, fsqsphere, fsaparc, no_fs_t1, no_surfreg, allow_root, version)
    return run_fastsurfer_sh_execute(params, runner);
}


export {
      RUN_FASTSURFER_SH_METADATA,
      RunFastsurferShOutputs,
      run_fastsurfer_sh,
      run_fastsurfer_sh_execute,
      run_fastsurfer_sh_params,
};
