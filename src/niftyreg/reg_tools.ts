// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const REG_TOOLS_METADATA: Metadata = {
    id: "8f3436a7108b088b760d79ddd861028e7d7e59ca.boutiques",
    name: "reg_tools",
    package: "niftyreg",
    container_image_tag: "vnmd/niftyreg_1.4.0:20220819",
};


interface RegToolsParameters {
    "@type"?: "niftyreg/reg_tools";
    "input_image": InputPathType;
    "output_image"?: string | null | undefined;
    "add_value_or_image"?: string | null | undefined;
    "sub_value_or_image"?: string | null | undefined;
    "mul_value_or_image"?: string | null | undefined;
    "div_value_or_image"?: string | null | undefined;
    "smooth_value"?: number | null | undefined;
    "smooth_gaussian"?: Array<number> | null | undefined;
    "rms_image"?: InputPathType | null | undefined;
    "binarize": boolean;
    "threshold_value"?: number | null | undefined;
    "nan_mask_image"?: InputPathType | null | undefined;
}
type RegToolsParametersTagged = Required<Pick<RegToolsParameters, '@type'>> & RegToolsParameters;


/**
 * Output object returned when calling `RegToolsParameters(...)`.
 *
 * @interface
 */
interface RegToolsOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * File containing the output image
     */
    output_image_file: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param input_image Filename of the input image
 * @param output_image Filename of the output image
 * @param add_value_or_image This image (or value) is added to the input
 * @param sub_value_or_image This image (or value) is subtracted from the input
 * @param mul_value_or_image This image (or value) is multiplied with the input
 * @param div_value_or_image This image (or value) is divided by the input
 * @param smooth_value The input image is smoothed using a B-spline curve
 * @param smooth_gaussian The input image is smoothed using a Gaussian kernel
 * @param rms_image Compute the mean RMS between the input image and this image
 * @param binarize Binarize the input image (val!=0?val=1:val=0)
 * @param threshold_value Threshold the input image (val<thr?val=0:val=1)
 * @param nan_mask_image This image is used to mask the input image. Voxels outside of the mask are set to NaN
 *
 * @returns Parameter dictionary
 */
function reg_tools_params(
    input_image: InputPathType,
    output_image: string | null = null,
    add_value_or_image: string | null = null,
    sub_value_or_image: string | null = null,
    mul_value_or_image: string | null = null,
    div_value_or_image: string | null = null,
    smooth_value: number | null = null,
    smooth_gaussian: Array<number> | null = null,
    rms_image: InputPathType | null = null,
    binarize: boolean = false,
    threshold_value: number | null = null,
    nan_mask_image: InputPathType | null = null,
): RegToolsParametersTagged {
    const params = {
        "@type": "niftyreg/reg_tools" as const,
        "input_image": input_image,
        "binarize": binarize,
    };
    if (output_image !== null) {
        params["output_image"] = output_image;
    }
    if (add_value_or_image !== null) {
        params["add_value_or_image"] = add_value_or_image;
    }
    if (sub_value_or_image !== null) {
        params["sub_value_or_image"] = sub_value_or_image;
    }
    if (mul_value_or_image !== null) {
        params["mul_value_or_image"] = mul_value_or_image;
    }
    if (div_value_or_image !== null) {
        params["div_value_or_image"] = div_value_or_image;
    }
    if (smooth_value !== null) {
        params["smooth_value"] = smooth_value;
    }
    if (smooth_gaussian !== null) {
        params["smooth_gaussian"] = smooth_gaussian;
    }
    if (rms_image !== null) {
        params["rms_image"] = rms_image;
    }
    if (threshold_value !== null) {
        params["threshold_value"] = threshold_value;
    }
    if (nan_mask_image !== null) {
        params["nan_mask_image"] = nan_mask_image;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function reg_tools_cargs(
    params: RegToolsParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("reg_tools");
    cargs.push(
        "-in",
        execution.inputFile((params["input_image"] ?? null))
    );
    if ((params["output_image"] ?? null) !== null) {
        cargs.push(
            "-out",
            (params["output_image"] ?? null)
        );
    }
    if ((params["add_value_or_image"] ?? null) !== null) {
        cargs.push(
            "-add",
            (params["add_value_or_image"] ?? null)
        );
    }
    if ((params["sub_value_or_image"] ?? null) !== null) {
        cargs.push(
            "-sub",
            (params["sub_value_or_image"] ?? null)
        );
    }
    if ((params["mul_value_or_image"] ?? null) !== null) {
        cargs.push(
            "-mul",
            (params["mul_value_or_image"] ?? null)
        );
    }
    if ((params["div_value_or_image"] ?? null) !== null) {
        cargs.push(
            "-div",
            (params["div_value_or_image"] ?? null)
        );
    }
    if ((params["smooth_value"] ?? null) !== null) {
        cargs.push(
            "-smo",
            String((params["smooth_value"] ?? null))
        );
    }
    if ((params["smooth_gaussian"] ?? null) !== null) {
        cargs.push(
            "-smoG",
            ...(params["smooth_gaussian"] ?? null).map(String)
        );
    }
    if ((params["rms_image"] ?? null) !== null) {
        cargs.push(
            "-rms",
            execution.inputFile((params["rms_image"] ?? null))
        );
    }
    if ((params["binarize"] ?? false)) {
        cargs.push("-bin");
    }
    if ((params["threshold_value"] ?? null) !== null) {
        cargs.push(
            "-thr",
            String((params["threshold_value"] ?? null))
        );
    }
    if ((params["nan_mask_image"] ?? null) !== null) {
        cargs.push(
            "-nan",
            execution.inputFile((params["nan_mask_image"] ?? null))
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function reg_tools_outputs(
    params: RegToolsParameters,
    execution: Execution,
): RegToolsOutputs {
    const ret: RegToolsOutputs = {
        root: execution.outputFile("."),
        output_image_file: ((params["output_image"] ?? null) !== null) ? execution.outputFile([(params["output_image"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * reg_tools
 *
 * A versatile tool for manipulating and processing medical images.
 *
 * Author: NiftyReg Developers
 *
 * URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `RegToolsOutputs`).
 */
function reg_tools_execute(
    params: RegToolsParameters,
    runner: Runner | null = null,
): RegToolsOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(REG_TOOLS_METADATA);
    params = execution.params(params)
    const cargs = reg_tools_cargs(params, execution)
    const ret = reg_tools_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * reg_tools
 *
 * A versatile tool for manipulating and processing medical images.
 *
 * Author: NiftyReg Developers
 *
 * URL: http://cmictig.cs.ucl.ac.uk/wiki/index.php/NiftyReg
 *
 * @param input_image Filename of the input image
 * @param output_image Filename of the output image
 * @param add_value_or_image This image (or value) is added to the input
 * @param sub_value_or_image This image (or value) is subtracted from the input
 * @param mul_value_or_image This image (or value) is multiplied with the input
 * @param div_value_or_image This image (or value) is divided by the input
 * @param smooth_value The input image is smoothed using a B-spline curve
 * @param smooth_gaussian The input image is smoothed using a Gaussian kernel
 * @param rms_image Compute the mean RMS between the input image and this image
 * @param binarize Binarize the input image (val!=0?val=1:val=0)
 * @param threshold_value Threshold the input image (val<thr?val=0:val=1)
 * @param nan_mask_image This image is used to mask the input image. Voxels outside of the mask are set to NaN
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `RegToolsOutputs`).
 */
function reg_tools(
    input_image: InputPathType,
    output_image: string | null = null,
    add_value_or_image: string | null = null,
    sub_value_or_image: string | null = null,
    mul_value_or_image: string | null = null,
    div_value_or_image: string | null = null,
    smooth_value: number | null = null,
    smooth_gaussian: Array<number> | null = null,
    rms_image: InputPathType | null = null,
    binarize: boolean = false,
    threshold_value: number | null = null,
    nan_mask_image: InputPathType | null = null,
    runner: Runner | null = null,
): RegToolsOutputs {
    const params = reg_tools_params(input_image, output_image, add_value_or_image, sub_value_or_image, mul_value_or_image, div_value_or_image, smooth_value, smooth_gaussian, rms_image, binarize, threshold_value, nan_mask_image)
    return reg_tools_execute(params, runner);
}


export {
      REG_TOOLS_METADATA,
      RegToolsOutputs,
      reg_tools,
      reg_tools_execute,
      reg_tools_params,
};
