// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const MRCALC_METADATA: Metadata = {
    id: "653dbc736bd2e23e6344aa23f92d7d2506dd4a3a.boutiques",
    name: "mrcalc",
    package: "mrtrix",
    container_image_tag: "mrtrix3/mrtrix3:3.0.4",
};


interface MrcalcAbsParamsDict {
    "@type"?: "abs";
}
type MrcalcAbsParamsDictTagged = Required<Pick<MrcalcAbsParamsDict, '@type'>> & MrcalcAbsParamsDict;


interface MrcalcNegParamsDict {
    "@type"?: "neg";
}
type MrcalcNegParamsDictTagged = Required<Pick<MrcalcNegParamsDict, '@type'>> & MrcalcNegParamsDict;


interface MrcalcAddParamsDict {
    "@type"?: "add";
}
type MrcalcAddParamsDictTagged = Required<Pick<MrcalcAddParamsDict, '@type'>> & MrcalcAddParamsDict;


interface MrcalcSubtractParamsDict {
    "@type"?: "subtract";
}
type MrcalcSubtractParamsDictTagged = Required<Pick<MrcalcSubtractParamsDict, '@type'>> & MrcalcSubtractParamsDict;


interface MrcalcMultiplyParamsDict {
    "@type"?: "multiply";
}
type MrcalcMultiplyParamsDictTagged = Required<Pick<MrcalcMultiplyParamsDict, '@type'>> & MrcalcMultiplyParamsDict;


interface MrcalcDivideParamsDict {
    "@type"?: "divide";
}
type MrcalcDivideParamsDictTagged = Required<Pick<MrcalcDivideParamsDict, '@type'>> & MrcalcDivideParamsDict;


interface MrcalcMinParamsDict {
    "@type"?: "min";
}
type MrcalcMinParamsDictTagged = Required<Pick<MrcalcMinParamsDict, '@type'>> & MrcalcMinParamsDict;


interface MrcalcMaxParamsDict {
    "@type"?: "max";
}
type MrcalcMaxParamsDictTagged = Required<Pick<MrcalcMaxParamsDict, '@type'>> & MrcalcMaxParamsDict;


interface MrcalcLtParamsDict {
    "@type"?: "lt";
}
type MrcalcLtParamsDictTagged = Required<Pick<MrcalcLtParamsDict, '@type'>> & MrcalcLtParamsDict;


interface MrcalcGtParamsDict {
    "@type"?: "gt";
}
type MrcalcGtParamsDictTagged = Required<Pick<MrcalcGtParamsDict, '@type'>> & MrcalcGtParamsDict;


interface MrcalcLeParamsDict {
    "@type"?: "le";
}
type MrcalcLeParamsDictTagged = Required<Pick<MrcalcLeParamsDict, '@type'>> & MrcalcLeParamsDict;


interface MrcalcGeParamsDict {
    "@type"?: "ge";
}
type MrcalcGeParamsDictTagged = Required<Pick<MrcalcGeParamsDict, '@type'>> & MrcalcGeParamsDict;


interface MrcalcEqParamsDict {
    "@type"?: "eq";
}
type MrcalcEqParamsDictTagged = Required<Pick<MrcalcEqParamsDict, '@type'>> & MrcalcEqParamsDict;


interface MrcalcNeqParamsDict {
    "@type"?: "neq";
}
type MrcalcNeqParamsDictTagged = Required<Pick<MrcalcNeqParamsDict, '@type'>> & MrcalcNeqParamsDict;


interface MrcalcIfParamsDict {
    "@type"?: "if";
}
type MrcalcIfParamsDictTagged = Required<Pick<MrcalcIfParamsDict, '@type'>> & MrcalcIfParamsDict;


interface MrcalcReplaceParamsDict {
    "@type"?: "replace";
}
type MrcalcReplaceParamsDictTagged = Required<Pick<MrcalcReplaceParamsDict, '@type'>> & MrcalcReplaceParamsDict;


interface MrcalcSqrtParamsDict {
    "@type"?: "sqrt";
}
type MrcalcSqrtParamsDictTagged = Required<Pick<MrcalcSqrtParamsDict, '@type'>> & MrcalcSqrtParamsDict;


interface MrcalcPowParamsDict {
    "@type"?: "pow";
}
type MrcalcPowParamsDictTagged = Required<Pick<MrcalcPowParamsDict, '@type'>> & MrcalcPowParamsDict;


interface MrcalcRoundParamsDict {
    "@type"?: "round";
}
type MrcalcRoundParamsDictTagged = Required<Pick<MrcalcRoundParamsDict, '@type'>> & MrcalcRoundParamsDict;


interface MrcalcCeilParamsDict {
    "@type"?: "ceil";
}
type MrcalcCeilParamsDictTagged = Required<Pick<MrcalcCeilParamsDict, '@type'>> & MrcalcCeilParamsDict;


interface MrcalcFloorParamsDict {
    "@type"?: "floor";
}
type MrcalcFloorParamsDictTagged = Required<Pick<MrcalcFloorParamsDict, '@type'>> & MrcalcFloorParamsDict;


interface MrcalcNotParamsDict {
    "@type"?: "not";
}
type MrcalcNotParamsDictTagged = Required<Pick<MrcalcNotParamsDict, '@type'>> & MrcalcNotParamsDict;


interface MrcalcAndParamsDict {
    "@type"?: "and";
}
type MrcalcAndParamsDictTagged = Required<Pick<MrcalcAndParamsDict, '@type'>> & MrcalcAndParamsDict;


interface MrcalcOrParamsDict {
    "@type"?: "or";
}
type MrcalcOrParamsDictTagged = Required<Pick<MrcalcOrParamsDict, '@type'>> & MrcalcOrParamsDict;


interface MrcalcXorParamsDict {
    "@type"?: "xor";
}
type MrcalcXorParamsDictTagged = Required<Pick<MrcalcXorParamsDict, '@type'>> & MrcalcXorParamsDict;


interface MrcalcIsnanParamsDict {
    "@type"?: "isnan";
}
type MrcalcIsnanParamsDictTagged = Required<Pick<MrcalcIsnanParamsDict, '@type'>> & MrcalcIsnanParamsDict;


interface MrcalcIsinfParamsDict {
    "@type"?: "isinf";
}
type MrcalcIsinfParamsDictTagged = Required<Pick<MrcalcIsinfParamsDict, '@type'>> & MrcalcIsinfParamsDict;


interface MrcalcFiniteParamsDict {
    "@type"?: "finite";
}
type MrcalcFiniteParamsDictTagged = Required<Pick<MrcalcFiniteParamsDict, '@type'>> & MrcalcFiniteParamsDict;


interface MrcalcComplexParamsDict {
    "@type"?: "complex";
}
type MrcalcComplexParamsDictTagged = Required<Pick<MrcalcComplexParamsDict, '@type'>> & MrcalcComplexParamsDict;


interface MrcalcPolarParamsDict {
    "@type"?: "polar";
}
type MrcalcPolarParamsDictTagged = Required<Pick<MrcalcPolarParamsDict, '@type'>> & MrcalcPolarParamsDict;


interface MrcalcRealParamsDict {
    "@type"?: "real";
}
type MrcalcRealParamsDictTagged = Required<Pick<MrcalcRealParamsDict, '@type'>> & MrcalcRealParamsDict;


interface MrcalcImagParamsDict {
    "@type"?: "imag";
}
type MrcalcImagParamsDictTagged = Required<Pick<MrcalcImagParamsDict, '@type'>> & MrcalcImagParamsDict;


interface MrcalcPhaseParamsDict {
    "@type"?: "phase";
}
type MrcalcPhaseParamsDictTagged = Required<Pick<MrcalcPhaseParamsDict, '@type'>> & MrcalcPhaseParamsDict;


interface MrcalcConjParamsDict {
    "@type"?: "conj";
}
type MrcalcConjParamsDictTagged = Required<Pick<MrcalcConjParamsDict, '@type'>> & MrcalcConjParamsDict;


interface MrcalcProjParamsDict {
    "@type"?: "proj";
}
type MrcalcProjParamsDictTagged = Required<Pick<MrcalcProjParamsDict, '@type'>> & MrcalcProjParamsDict;


interface MrcalcExpParamsDict {
    "@type"?: "exp";
}
type MrcalcExpParamsDictTagged = Required<Pick<MrcalcExpParamsDict, '@type'>> & MrcalcExpParamsDict;


interface MrcalcLogParamsDict {
    "@type"?: "log";
}
type MrcalcLogParamsDictTagged = Required<Pick<MrcalcLogParamsDict, '@type'>> & MrcalcLogParamsDict;


interface MrcalcLog10ParamsDict {
    "@type"?: "log10";
}
type MrcalcLog10ParamsDictTagged = Required<Pick<MrcalcLog10ParamsDict, '@type'>> & MrcalcLog10ParamsDict;


interface MrcalcCosParamsDict {
    "@type"?: "cos";
}
type MrcalcCosParamsDictTagged = Required<Pick<MrcalcCosParamsDict, '@type'>> & MrcalcCosParamsDict;


interface MrcalcSinParamsDict {
    "@type"?: "sin";
}
type MrcalcSinParamsDictTagged = Required<Pick<MrcalcSinParamsDict, '@type'>> & MrcalcSinParamsDict;


interface MrcalcTanParamsDict {
    "@type"?: "tan";
}
type MrcalcTanParamsDictTagged = Required<Pick<MrcalcTanParamsDict, '@type'>> & MrcalcTanParamsDict;


interface MrcalcAcosParamsDict {
    "@type"?: "acos";
}
type MrcalcAcosParamsDictTagged = Required<Pick<MrcalcAcosParamsDict, '@type'>> & MrcalcAcosParamsDict;


interface MrcalcAsinParamsDict {
    "@type"?: "asin";
}
type MrcalcAsinParamsDictTagged = Required<Pick<MrcalcAsinParamsDict, '@type'>> & MrcalcAsinParamsDict;


interface MrcalcAtanParamsDict {
    "@type"?: "atan";
}
type MrcalcAtanParamsDictTagged = Required<Pick<MrcalcAtanParamsDict, '@type'>> & MrcalcAtanParamsDict;


interface MrcalcCoshParamsDict {
    "@type"?: "cosh";
}
type MrcalcCoshParamsDictTagged = Required<Pick<MrcalcCoshParamsDict, '@type'>> & MrcalcCoshParamsDict;


interface MrcalcSinhParamsDict {
    "@type"?: "sinh";
}
type MrcalcSinhParamsDictTagged = Required<Pick<MrcalcSinhParamsDict, '@type'>> & MrcalcSinhParamsDict;


interface MrcalcTanhParamsDict {
    "@type"?: "tanh";
}
type MrcalcTanhParamsDictTagged = Required<Pick<MrcalcTanhParamsDict, '@type'>> & MrcalcTanhParamsDict;


interface MrcalcAcoshParamsDict {
    "@type"?: "acosh";
}
type MrcalcAcoshParamsDictTagged = Required<Pick<MrcalcAcoshParamsDict, '@type'>> & MrcalcAcoshParamsDict;


interface MrcalcAsinhParamsDict {
    "@type"?: "asinh";
}
type MrcalcAsinhParamsDictTagged = Required<Pick<MrcalcAsinhParamsDict, '@type'>> & MrcalcAsinhParamsDict;


interface MrcalcAtanhParamsDict {
    "@type"?: "atanh";
}
type MrcalcAtanhParamsDictTagged = Required<Pick<MrcalcAtanhParamsDict, '@type'>> & MrcalcAtanhParamsDict;


interface MrcalcConfigParamsDict {
    "@type"?: "config";
    "key": string;
    "value": string;
}
type MrcalcConfigParamsDictTagged = Required<Pick<MrcalcConfigParamsDict, '@type'>> & MrcalcConfigParamsDict;


interface MrcalcVariousStringParamsDict {
    "@type"?: "VariousString";
    "obj": string;
}
type MrcalcVariousStringParamsDictTagged = Required<Pick<MrcalcVariousStringParamsDict, '@type'>> & MrcalcVariousStringParamsDict;


interface MrcalcVariousFileParamsDict {
    "@type"?: "VariousFile";
    "obj": InputPathType;
}
type MrcalcVariousFileParamsDictTagged = Required<Pick<MrcalcVariousFileParamsDict, '@type'>> & MrcalcVariousFileParamsDict;


interface MrcalcParamsDict {
    "@type"?: "mrtrix/mrcalc";
    "abs"?: Array<MrcalcAbsParamsDict> | null | undefined;
    "neg"?: Array<MrcalcNegParamsDict> | null | undefined;
    "add"?: Array<MrcalcAddParamsDict> | null | undefined;
    "subtract"?: Array<MrcalcSubtractParamsDict> | null | undefined;
    "multiply"?: Array<MrcalcMultiplyParamsDict> | null | undefined;
    "divide"?: Array<MrcalcDivideParamsDict> | null | undefined;
    "min"?: Array<MrcalcMinParamsDict> | null | undefined;
    "max"?: Array<MrcalcMaxParamsDict> | null | undefined;
    "lt"?: Array<MrcalcLtParamsDict> | null | undefined;
    "gt"?: Array<MrcalcGtParamsDict> | null | undefined;
    "le"?: Array<MrcalcLeParamsDict> | null | undefined;
    "ge"?: Array<MrcalcGeParamsDict> | null | undefined;
    "eq"?: Array<MrcalcEqParamsDict> | null | undefined;
    "neq"?: Array<MrcalcNeqParamsDict> | null | undefined;
    "if"?: Array<MrcalcIfParamsDict> | null | undefined;
    "replace"?: Array<MrcalcReplaceParamsDict> | null | undefined;
    "sqrt"?: Array<MrcalcSqrtParamsDict> | null | undefined;
    "pow"?: Array<MrcalcPowParamsDict> | null | undefined;
    "round"?: Array<MrcalcRoundParamsDict> | null | undefined;
    "ceil"?: Array<MrcalcCeilParamsDict> | null | undefined;
    "floor"?: Array<MrcalcFloorParamsDict> | null | undefined;
    "not"?: Array<MrcalcNotParamsDict> | null | undefined;
    "and"?: Array<MrcalcAndParamsDict> | null | undefined;
    "or"?: Array<MrcalcOrParamsDict> | null | undefined;
    "xor"?: Array<MrcalcXorParamsDict> | null | undefined;
    "isnan"?: Array<MrcalcIsnanParamsDict> | null | undefined;
    "isinf"?: Array<MrcalcIsinfParamsDict> | null | undefined;
    "finite"?: Array<MrcalcFiniteParamsDict> | null | undefined;
    "complex"?: Array<MrcalcComplexParamsDict> | null | undefined;
    "polar"?: Array<MrcalcPolarParamsDict> | null | undefined;
    "real"?: Array<MrcalcRealParamsDict> | null | undefined;
    "imag"?: Array<MrcalcImagParamsDict> | null | undefined;
    "phase"?: Array<MrcalcPhaseParamsDict> | null | undefined;
    "conj"?: Array<MrcalcConjParamsDict> | null | undefined;
    "proj"?: Array<MrcalcProjParamsDict> | null | undefined;
    "exp"?: Array<MrcalcExpParamsDict> | null | undefined;
    "log"?: Array<MrcalcLogParamsDict> | null | undefined;
    "log10"?: Array<MrcalcLog10ParamsDict> | null | undefined;
    "cos"?: Array<MrcalcCosParamsDict> | null | undefined;
    "sin"?: Array<MrcalcSinParamsDict> | null | undefined;
    "tan"?: Array<MrcalcTanParamsDict> | null | undefined;
    "acos"?: Array<MrcalcAcosParamsDict> | null | undefined;
    "asin"?: Array<MrcalcAsinParamsDict> | null | undefined;
    "atan"?: Array<MrcalcAtanParamsDict> | null | undefined;
    "cosh"?: Array<MrcalcCoshParamsDict> | null | undefined;
    "sinh"?: Array<MrcalcSinhParamsDict> | null | undefined;
    "tanh"?: Array<MrcalcTanhParamsDict> | null | undefined;
    "acosh"?: Array<MrcalcAcoshParamsDict> | null | undefined;
    "asinh"?: Array<MrcalcAsinhParamsDict> | null | undefined;
    "atanh"?: Array<MrcalcAtanhParamsDict> | null | undefined;
    "datatype"?: string | null | undefined;
    "info": boolean;
    "quiet": boolean;
    "debug": boolean;
    "force": boolean;
    "nthreads"?: number | null | undefined;
    "config"?: Array<MrcalcConfigParamsDict> | null | undefined;
    "help": boolean;
    "version": boolean;
    "operand": Array<MrcalcVariousStringParamsDictTagged | MrcalcVariousFileParamsDictTagged>;
}
type MrcalcParamsDictTagged = Required<Pick<MrcalcParamsDict, '@type'>> & MrcalcParamsDict;


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function mrcalc_operand_cargs_dyn_fn(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "VariousString": mrcalc_various_string_cargs,
        "VariousFile": mrcalc_various_file_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function mrcalc_operand_outputs_dyn_fn(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_abs(
): MrcalcAbsParamsDictTagged {
    const params = {
        "@type": "abs" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_abs_cargs(
    params: MrcalcAbsParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-abs");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_neg(
): MrcalcNegParamsDictTagged {
    const params = {
        "@type": "neg" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_neg_cargs(
    params: MrcalcNegParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-neg");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_add(
): MrcalcAddParamsDictTagged {
    const params = {
        "@type": "add" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_add_cargs(
    params: MrcalcAddParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-add");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_subtract(
): MrcalcSubtractParamsDictTagged {
    const params = {
        "@type": "subtract" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_subtract_cargs(
    params: MrcalcSubtractParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-subtract");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_multiply(
): MrcalcMultiplyParamsDictTagged {
    const params = {
        "@type": "multiply" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_multiply_cargs(
    params: MrcalcMultiplyParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-multiply");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_divide(
): MrcalcDivideParamsDictTagged {
    const params = {
        "@type": "divide" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_divide_cargs(
    params: MrcalcDivideParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-divide");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_min(
): MrcalcMinParamsDictTagged {
    const params = {
        "@type": "min" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_min_cargs(
    params: MrcalcMinParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-min");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_max(
): MrcalcMaxParamsDictTagged {
    const params = {
        "@type": "max" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_max_cargs(
    params: MrcalcMaxParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-max");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_lt(
): MrcalcLtParamsDictTagged {
    const params = {
        "@type": "lt" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_lt_cargs(
    params: MrcalcLtParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-lt");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_gt(
): MrcalcGtParamsDictTagged {
    const params = {
        "@type": "gt" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_gt_cargs(
    params: MrcalcGtParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-gt");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_le(
): MrcalcLeParamsDictTagged {
    const params = {
        "@type": "le" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_le_cargs(
    params: MrcalcLeParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-le");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_ge(
): MrcalcGeParamsDictTagged {
    const params = {
        "@type": "ge" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_ge_cargs(
    params: MrcalcGeParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-ge");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_eq(
): MrcalcEqParamsDictTagged {
    const params = {
        "@type": "eq" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_eq_cargs(
    params: MrcalcEqParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-eq");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_neq(
): MrcalcNeqParamsDictTagged {
    const params = {
        "@type": "neq" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_neq_cargs(
    params: MrcalcNeqParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-neq");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_if(
): MrcalcIfParamsDictTagged {
    const params = {
        "@type": "if" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_if_cargs(
    params: MrcalcIfParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-if");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_replace(
): MrcalcReplaceParamsDictTagged {
    const params = {
        "@type": "replace" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_replace_cargs(
    params: MrcalcReplaceParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-replace");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_sqrt(
): MrcalcSqrtParamsDictTagged {
    const params = {
        "@type": "sqrt" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_sqrt_cargs(
    params: MrcalcSqrtParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-sqrt");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_pow(
): MrcalcPowParamsDictTagged {
    const params = {
        "@type": "pow" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_pow_cargs(
    params: MrcalcPowParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-pow");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_round(
): MrcalcRoundParamsDictTagged {
    const params = {
        "@type": "round" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_round_cargs(
    params: MrcalcRoundParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-round");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_ceil(
): MrcalcCeilParamsDictTagged {
    const params = {
        "@type": "ceil" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_ceil_cargs(
    params: MrcalcCeilParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-ceil");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_floor(
): MrcalcFloorParamsDictTagged {
    const params = {
        "@type": "floor" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_floor_cargs(
    params: MrcalcFloorParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-floor");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_not(
): MrcalcNotParamsDictTagged {
    const params = {
        "@type": "not" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_not_cargs(
    params: MrcalcNotParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-not");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_and(
): MrcalcAndParamsDictTagged {
    const params = {
        "@type": "and" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_and_cargs(
    params: MrcalcAndParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-and");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_or(
): MrcalcOrParamsDictTagged {
    const params = {
        "@type": "or" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_or_cargs(
    params: MrcalcOrParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-or");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_xor(
): MrcalcXorParamsDictTagged {
    const params = {
        "@type": "xor" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_xor_cargs(
    params: MrcalcXorParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-xor");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_isnan(
): MrcalcIsnanParamsDictTagged {
    const params = {
        "@type": "isnan" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_isnan_cargs(
    params: MrcalcIsnanParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-isnan");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_isinf(
): MrcalcIsinfParamsDictTagged {
    const params = {
        "@type": "isinf" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_isinf_cargs(
    params: MrcalcIsinfParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-isinf");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_finite(
): MrcalcFiniteParamsDictTagged {
    const params = {
        "@type": "finite" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_finite_cargs(
    params: MrcalcFiniteParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-finite");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_complex(
): MrcalcComplexParamsDictTagged {
    const params = {
        "@type": "complex" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_complex_cargs(
    params: MrcalcComplexParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-complex");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_polar(
): MrcalcPolarParamsDictTagged {
    const params = {
        "@type": "polar" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_polar_cargs(
    params: MrcalcPolarParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-polar");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_real(
): MrcalcRealParamsDictTagged {
    const params = {
        "@type": "real" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_real_cargs(
    params: MrcalcRealParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-real");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_imag(
): MrcalcImagParamsDictTagged {
    const params = {
        "@type": "imag" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_imag_cargs(
    params: MrcalcImagParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-imag");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_phase(
): MrcalcPhaseParamsDictTagged {
    const params = {
        "@type": "phase" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_phase_cargs(
    params: MrcalcPhaseParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-phase");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_conj(
): MrcalcConjParamsDictTagged {
    const params = {
        "@type": "conj" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_conj_cargs(
    params: MrcalcConjParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-conj");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_proj(
): MrcalcProjParamsDictTagged {
    const params = {
        "@type": "proj" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_proj_cargs(
    params: MrcalcProjParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-proj");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_exp(
): MrcalcExpParamsDictTagged {
    const params = {
        "@type": "exp" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_exp_cargs(
    params: MrcalcExpParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-exp");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_log(
): MrcalcLogParamsDictTagged {
    const params = {
        "@type": "log" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_log_cargs(
    params: MrcalcLogParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-log");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_log10(
): MrcalcLog10ParamsDictTagged {
    const params = {
        "@type": "log10" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_log10_cargs(
    params: MrcalcLog10ParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-log10");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_cos(
): MrcalcCosParamsDictTagged {
    const params = {
        "@type": "cos" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_cos_cargs(
    params: MrcalcCosParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-cos");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_sin(
): MrcalcSinParamsDictTagged {
    const params = {
        "@type": "sin" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_sin_cargs(
    params: MrcalcSinParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-sin");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_tan(
): MrcalcTanParamsDictTagged {
    const params = {
        "@type": "tan" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_tan_cargs(
    params: MrcalcTanParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-tan");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_acos(
): MrcalcAcosParamsDictTagged {
    const params = {
        "@type": "acos" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_acos_cargs(
    params: MrcalcAcosParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-acos");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_asin(
): MrcalcAsinParamsDictTagged {
    const params = {
        "@type": "asin" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_asin_cargs(
    params: MrcalcAsinParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-asin");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_atan(
): MrcalcAtanParamsDictTagged {
    const params = {
        "@type": "atan" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_atan_cargs(
    params: MrcalcAtanParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-atan");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_cosh(
): MrcalcCoshParamsDictTagged {
    const params = {
        "@type": "cosh" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_cosh_cargs(
    params: MrcalcCoshParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-cosh");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_sinh(
): MrcalcSinhParamsDictTagged {
    const params = {
        "@type": "sinh" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_sinh_cargs(
    params: MrcalcSinhParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-sinh");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_tanh(
): MrcalcTanhParamsDictTagged {
    const params = {
        "@type": "tanh" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_tanh_cargs(
    params: MrcalcTanhParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-tanh");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_acosh(
): MrcalcAcoshParamsDictTagged {
    const params = {
        "@type": "acosh" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_acosh_cargs(
    params: MrcalcAcoshParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-acosh");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_asinh(
): MrcalcAsinhParamsDictTagged {
    const params = {
        "@type": "asinh" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_asinh_cargs(
    params: MrcalcAsinhParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-asinh");
    return cargs;
}


/**
 * Build parameters.
 *
 * @returns Parameter dictionary
 */
function mrcalc_atanh(
): MrcalcAtanhParamsDictTagged {
    const params = {
        "@type": "atanh" as const,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_atanh_cargs(
    params: MrcalcAtanhParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-atanh");
    return cargs;
}


/**
 * Build parameters.
 *
 * @param key temporarily set the value of an MRtrix config file entry.
 * @param value temporarily set the value of an MRtrix config file entry.
 *
 * @returns Parameter dictionary
 */
function mrcalc_config(
    key: string,
    value: string,
): MrcalcConfigParamsDictTagged {
    const params = {
        "@type": "config" as const,
        "key": key,
        "value": value,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_config_cargs(
    params: MrcalcConfigParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("-config");
    cargs.push((params["key"] ?? null));
    cargs.push((params["value"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj String object.
 *
 * @returns Parameter dictionary
 */
function mrcalc_various_string(
    obj: string,
): MrcalcVariousStringParamsDictTagged {
    const params = {
        "@type": "VariousString" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_various_string_cargs(
    params: MrcalcVariousStringParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push((params["obj"] ?? null));
    return cargs;
}


/**
 * Build parameters.
 *
 * @param obj File object.
 *
 * @returns Parameter dictionary
 */
function mrcalc_various_file(
    obj: InputPathType,
): MrcalcVariousFileParamsDictTagged {
    const params = {
        "@type": "VariousFile" as const,
        "obj": obj,
    };
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_various_file_cargs(
    params: MrcalcVariousFileParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push(execution.inputFile((params["obj"] ?? null)));
    return cargs;
}


/**
 * Output object returned when calling `MrcalcParamsDict(...)`.
 *
 * @interface
 */
interface MrcalcOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param operand an input image, intensity value, or the special keywords 'rand' (random number between 0 and 1) or 'randn' (random number from unit std.dev. normal distribution) or the mathematical constants 'e' and 'pi'.
 * @param abs |%1| : return absolute value (magnitude) of real or complex number
 * @param neg -%1 : negative value
 * @param add (%1 + %2) : add values
 * @param subtract (%1 - %2) : subtract nth operand from (n-1)th
 * @param multiply (%1 * %2) : multiply values
 * @param divide (%1 / %2) : divide (n-1)th operand by nth
 * @param min min (%1, %2) : smallest of last two operands
 * @param max max (%1, %2) : greatest of last two operands
 * @param lt (%1 < %2) : less-than operator (true=1, false=0)
 * @param gt (%1 > %2) : greater-than operator (true=1, false=0)
 * @param le (%1 <= %2) : less-than-or-equal-to operator (true=1, false=0)
 * @param ge (%1 >= %2) : greater-than-or-equal-to operator (true=1, false=0)
 * @param eq (%1 == %2) : equal-to operator (true=1, false=0)
 * @param neq (%1 != %2) : not-equal-to operator (true=1, false=0)
 * @param if_ (%1 ? %2 : %3) : if first operand is true (non-zero), return second operand, otherwise return third operand
 * @param replace (%1, %2 -> %3) : Wherever first operand is equal to the second operand, replace with third operand
 * @param sqrt sqrt (%1) : square root
 * @param pow %1^%2 : raise (n-1)th operand to nth power
 * @param round round (%1) : round to nearest integer
 * @param ceil ceil (%1) : round up to nearest integer
 * @param floor floor (%1) : round down to nearest integer
 * @param not !%1 : NOT operator: true (1) if operand is false (i.e. zero)
 * @param and (%1 && %2) : AND operator: true (1) if both operands are true (i.e. non-zero)
 * @param or (%1 || %2) : OR operator: true (1) if either operand is true (i.e. non-zero)
 * @param xor (%1 ^^ %2) : XOR operator: true (1) if only one of the operands is true (i.e. non-zero)
 * @param isnan isnan (%1) : true (1) if operand is not-a-number (NaN)
 * @param isinf isinf (%1) : true (1) if operand is infinite (Inf)
 * @param finite finite (%1) : true (1) if operand is finite (i.e. not NaN or Inf)
 * @param complex (%1 + %2 i) : create complex number using the last two operands as real,imaginary components
 * @param polar (%1 /_ %2) : create complex number using the last two operands as magnitude,phase components (phase in radians)
 * @param real real (%1) : real part of complex number
 * @param imag imag (%1) : imaginary part of complex number
 * @param phase phase (%1) : phase of complex number (use -abs for magnitude)
 * @param conj conj (%1) : complex conjugate
 * @param proj proj (%1) : projection onto the Riemann sphere
 * @param exp exp (%1) : exponential function
 * @param log log (%1) : natural logarithm
 * @param log10 log10 (%1) : common logarithm
 * @param cos cos (%1) : cosine
 * @param sin sin (%1) : sine
 * @param tan tan (%1) : tangent
 * @param acos acos (%1) : inverse cosine
 * @param asin asin (%1) : inverse sine
 * @param atan atan (%1) : inverse tangent
 * @param cosh cosh (%1) : hyperbolic cosine
 * @param sinh sinh (%1) : hyperbolic sine
 * @param tanh tanh (%1) : hyperbolic tangent
 * @param acosh acosh (%1) : inverse hyperbolic cosine
 * @param asinh asinh (%1) : inverse hyperbolic sine
 * @param atanh atanh (%1) : inverse hyperbolic tangent
 * @param datatype specify output image data type. Valid choices are: float32, float32le, float32be, float64, float64le, float64be, int64, uint64, int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le, int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be, cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be, int8, uint8, bit.
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 *
 * @returns Parameter dictionary
 */
function mrcalc_params(
    operand: Array<MrcalcVariousStringParamsDictTagged | MrcalcVariousFileParamsDictTagged>,
    abs: Array<MrcalcAbsParamsDict> | null = null,
    neg: Array<MrcalcNegParamsDict> | null = null,
    add: Array<MrcalcAddParamsDict> | null = null,
    subtract: Array<MrcalcSubtractParamsDict> | null = null,
    multiply: Array<MrcalcMultiplyParamsDict> | null = null,
    divide: Array<MrcalcDivideParamsDict> | null = null,
    min: Array<MrcalcMinParamsDict> | null = null,
    max: Array<MrcalcMaxParamsDict> | null = null,
    lt: Array<MrcalcLtParamsDict> | null = null,
    gt: Array<MrcalcGtParamsDict> | null = null,
    le: Array<MrcalcLeParamsDict> | null = null,
    ge: Array<MrcalcGeParamsDict> | null = null,
    eq: Array<MrcalcEqParamsDict> | null = null,
    neq: Array<MrcalcNeqParamsDict> | null = null,
    if_: Array<MrcalcIfParamsDict> | null = null,
    replace: Array<MrcalcReplaceParamsDict> | null = null,
    sqrt: Array<MrcalcSqrtParamsDict> | null = null,
    pow: Array<MrcalcPowParamsDict> | null = null,
    round: Array<MrcalcRoundParamsDict> | null = null,
    ceil: Array<MrcalcCeilParamsDict> | null = null,
    floor: Array<MrcalcFloorParamsDict> | null = null,
    not: Array<MrcalcNotParamsDict> | null = null,
    and: Array<MrcalcAndParamsDict> | null = null,
    or: Array<MrcalcOrParamsDict> | null = null,
    xor: Array<MrcalcXorParamsDict> | null = null,
    isnan: Array<MrcalcIsnanParamsDict> | null = null,
    isinf: Array<MrcalcIsinfParamsDict> | null = null,
    finite: Array<MrcalcFiniteParamsDict> | null = null,
    complex: Array<MrcalcComplexParamsDict> | null = null,
    polar: Array<MrcalcPolarParamsDict> | null = null,
    real: Array<MrcalcRealParamsDict> | null = null,
    imag: Array<MrcalcImagParamsDict> | null = null,
    phase: Array<MrcalcPhaseParamsDict> | null = null,
    conj: Array<MrcalcConjParamsDict> | null = null,
    proj: Array<MrcalcProjParamsDict> | null = null,
    exp: Array<MrcalcExpParamsDict> | null = null,
    log: Array<MrcalcLogParamsDict> | null = null,
    log10: Array<MrcalcLog10ParamsDict> | null = null,
    cos: Array<MrcalcCosParamsDict> | null = null,
    sin: Array<MrcalcSinParamsDict> | null = null,
    tan: Array<MrcalcTanParamsDict> | null = null,
    acos: Array<MrcalcAcosParamsDict> | null = null,
    asin: Array<MrcalcAsinParamsDict> | null = null,
    atan: Array<MrcalcAtanParamsDict> | null = null,
    cosh: Array<MrcalcCoshParamsDict> | null = null,
    sinh: Array<MrcalcSinhParamsDict> | null = null,
    tanh: Array<MrcalcTanhParamsDict> | null = null,
    acosh: Array<MrcalcAcoshParamsDict> | null = null,
    asinh: Array<MrcalcAsinhParamsDict> | null = null,
    atanh: Array<MrcalcAtanhParamsDict> | null = null,
    datatype: string | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<MrcalcConfigParamsDict> | null = null,
    help: boolean = false,
    version: boolean = false,
): MrcalcParamsDictTagged {
    const params = {
        "@type": "mrtrix/mrcalc" as const,
        "info": info,
        "quiet": quiet,
        "debug": debug,
        "force": force,
        "help": help,
        "version": version,
        "operand": operand,
    };
    if (abs !== null) {
        params["abs"] = abs;
    }
    if (neg !== null) {
        params["neg"] = neg;
    }
    if (add !== null) {
        params["add"] = add;
    }
    if (subtract !== null) {
        params["subtract"] = subtract;
    }
    if (multiply !== null) {
        params["multiply"] = multiply;
    }
    if (divide !== null) {
        params["divide"] = divide;
    }
    if (min !== null) {
        params["min"] = min;
    }
    if (max !== null) {
        params["max"] = max;
    }
    if (lt !== null) {
        params["lt"] = lt;
    }
    if (gt !== null) {
        params["gt"] = gt;
    }
    if (le !== null) {
        params["le"] = le;
    }
    if (ge !== null) {
        params["ge"] = ge;
    }
    if (eq !== null) {
        params["eq"] = eq;
    }
    if (neq !== null) {
        params["neq"] = neq;
    }
    if (if_ !== null) {
        params["if"] = if_;
    }
    if (replace !== null) {
        params["replace"] = replace;
    }
    if (sqrt !== null) {
        params["sqrt"] = sqrt;
    }
    if (pow !== null) {
        params["pow"] = pow;
    }
    if (round !== null) {
        params["round"] = round;
    }
    if (ceil !== null) {
        params["ceil"] = ceil;
    }
    if (floor !== null) {
        params["floor"] = floor;
    }
    if (not !== null) {
        params["not"] = not;
    }
    if (and !== null) {
        params["and"] = and;
    }
    if (or !== null) {
        params["or"] = or;
    }
    if (xor !== null) {
        params["xor"] = xor;
    }
    if (isnan !== null) {
        params["isnan"] = isnan;
    }
    if (isinf !== null) {
        params["isinf"] = isinf;
    }
    if (finite !== null) {
        params["finite"] = finite;
    }
    if (complex !== null) {
        params["complex"] = complex;
    }
    if (polar !== null) {
        params["polar"] = polar;
    }
    if (real !== null) {
        params["real"] = real;
    }
    if (imag !== null) {
        params["imag"] = imag;
    }
    if (phase !== null) {
        params["phase"] = phase;
    }
    if (conj !== null) {
        params["conj"] = conj;
    }
    if (proj !== null) {
        params["proj"] = proj;
    }
    if (exp !== null) {
        params["exp"] = exp;
    }
    if (log !== null) {
        params["log"] = log;
    }
    if (log10 !== null) {
        params["log10"] = log10;
    }
    if (cos !== null) {
        params["cos"] = cos;
    }
    if (sin !== null) {
        params["sin"] = sin;
    }
    if (tan !== null) {
        params["tan"] = tan;
    }
    if (acos !== null) {
        params["acos"] = acos;
    }
    if (asin !== null) {
        params["asin"] = asin;
    }
    if (atan !== null) {
        params["atan"] = atan;
    }
    if (cosh !== null) {
        params["cosh"] = cosh;
    }
    if (sinh !== null) {
        params["sinh"] = sinh;
    }
    if (tanh !== null) {
        params["tanh"] = tanh;
    }
    if (acosh !== null) {
        params["acosh"] = acosh;
    }
    if (asinh !== null) {
        params["asinh"] = asinh;
    }
    if (atanh !== null) {
        params["atanh"] = atanh;
    }
    if (datatype !== null) {
        params["datatype"] = datatype;
    }
    if (nthreads !== null) {
        params["nthreads"] = nthreads;
    }
    if (config !== null) {
        params["config"] = config;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function mrcalc_cargs(
    params: MrcalcParamsDict,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("mrcalc");
    if ((params["abs"] ?? null) !== null) {
        cargs.push(...(params["abs"] ?? null).map(s => mrcalc_abs_cargs(s, execution)).flat());
    }
    if ((params["neg"] ?? null) !== null) {
        cargs.push(...(params["neg"] ?? null).map(s => mrcalc_neg_cargs(s, execution)).flat());
    }
    if ((params["add"] ?? null) !== null) {
        cargs.push(...(params["add"] ?? null).map(s => mrcalc_add_cargs(s, execution)).flat());
    }
    if ((params["subtract"] ?? null) !== null) {
        cargs.push(...(params["subtract"] ?? null).map(s => mrcalc_subtract_cargs(s, execution)).flat());
    }
    if ((params["multiply"] ?? null) !== null) {
        cargs.push(...(params["multiply"] ?? null).map(s => mrcalc_multiply_cargs(s, execution)).flat());
    }
    if ((params["divide"] ?? null) !== null) {
        cargs.push(...(params["divide"] ?? null).map(s => mrcalc_divide_cargs(s, execution)).flat());
    }
    if ((params["min"] ?? null) !== null) {
        cargs.push(...(params["min"] ?? null).map(s => mrcalc_min_cargs(s, execution)).flat());
    }
    if ((params["max"] ?? null) !== null) {
        cargs.push(...(params["max"] ?? null).map(s => mrcalc_max_cargs(s, execution)).flat());
    }
    if ((params["lt"] ?? null) !== null) {
        cargs.push(...(params["lt"] ?? null).map(s => mrcalc_lt_cargs(s, execution)).flat());
    }
    if ((params["gt"] ?? null) !== null) {
        cargs.push(...(params["gt"] ?? null).map(s => mrcalc_gt_cargs(s, execution)).flat());
    }
    if ((params["le"] ?? null) !== null) {
        cargs.push(...(params["le"] ?? null).map(s => mrcalc_le_cargs(s, execution)).flat());
    }
    if ((params["ge"] ?? null) !== null) {
        cargs.push(...(params["ge"] ?? null).map(s => mrcalc_ge_cargs(s, execution)).flat());
    }
    if ((params["eq"] ?? null) !== null) {
        cargs.push(...(params["eq"] ?? null).map(s => mrcalc_eq_cargs(s, execution)).flat());
    }
    if ((params["neq"] ?? null) !== null) {
        cargs.push(...(params["neq"] ?? null).map(s => mrcalc_neq_cargs(s, execution)).flat());
    }
    if ((params["if"] ?? null) !== null) {
        cargs.push(...(params["if"] ?? null).map(s => mrcalc_if_cargs(s, execution)).flat());
    }
    if ((params["replace"] ?? null) !== null) {
        cargs.push(...(params["replace"] ?? null).map(s => mrcalc_replace_cargs(s, execution)).flat());
    }
    if ((params["sqrt"] ?? null) !== null) {
        cargs.push(...(params["sqrt"] ?? null).map(s => mrcalc_sqrt_cargs(s, execution)).flat());
    }
    if ((params["pow"] ?? null) !== null) {
        cargs.push(...(params["pow"] ?? null).map(s => mrcalc_pow_cargs(s, execution)).flat());
    }
    if ((params["round"] ?? null) !== null) {
        cargs.push(...(params["round"] ?? null).map(s => mrcalc_round_cargs(s, execution)).flat());
    }
    if ((params["ceil"] ?? null) !== null) {
        cargs.push(...(params["ceil"] ?? null).map(s => mrcalc_ceil_cargs(s, execution)).flat());
    }
    if ((params["floor"] ?? null) !== null) {
        cargs.push(...(params["floor"] ?? null).map(s => mrcalc_floor_cargs(s, execution)).flat());
    }
    if ((params["not"] ?? null) !== null) {
        cargs.push(...(params["not"] ?? null).map(s => mrcalc_not_cargs(s, execution)).flat());
    }
    if ((params["and"] ?? null) !== null) {
        cargs.push(...(params["and"] ?? null).map(s => mrcalc_and_cargs(s, execution)).flat());
    }
    if ((params["or"] ?? null) !== null) {
        cargs.push(...(params["or"] ?? null).map(s => mrcalc_or_cargs(s, execution)).flat());
    }
    if ((params["xor"] ?? null) !== null) {
        cargs.push(...(params["xor"] ?? null).map(s => mrcalc_xor_cargs(s, execution)).flat());
    }
    if ((params["isnan"] ?? null) !== null) {
        cargs.push(...(params["isnan"] ?? null).map(s => mrcalc_isnan_cargs(s, execution)).flat());
    }
    if ((params["isinf"] ?? null) !== null) {
        cargs.push(...(params["isinf"] ?? null).map(s => mrcalc_isinf_cargs(s, execution)).flat());
    }
    if ((params["finite"] ?? null) !== null) {
        cargs.push(...(params["finite"] ?? null).map(s => mrcalc_finite_cargs(s, execution)).flat());
    }
    if ((params["complex"] ?? null) !== null) {
        cargs.push(...(params["complex"] ?? null).map(s => mrcalc_complex_cargs(s, execution)).flat());
    }
    if ((params["polar"] ?? null) !== null) {
        cargs.push(...(params["polar"] ?? null).map(s => mrcalc_polar_cargs(s, execution)).flat());
    }
    if ((params["real"] ?? null) !== null) {
        cargs.push(...(params["real"] ?? null).map(s => mrcalc_real_cargs(s, execution)).flat());
    }
    if ((params["imag"] ?? null) !== null) {
        cargs.push(...(params["imag"] ?? null).map(s => mrcalc_imag_cargs(s, execution)).flat());
    }
    if ((params["phase"] ?? null) !== null) {
        cargs.push(...(params["phase"] ?? null).map(s => mrcalc_phase_cargs(s, execution)).flat());
    }
    if ((params["conj"] ?? null) !== null) {
        cargs.push(...(params["conj"] ?? null).map(s => mrcalc_conj_cargs(s, execution)).flat());
    }
    if ((params["proj"] ?? null) !== null) {
        cargs.push(...(params["proj"] ?? null).map(s => mrcalc_proj_cargs(s, execution)).flat());
    }
    if ((params["exp"] ?? null) !== null) {
        cargs.push(...(params["exp"] ?? null).map(s => mrcalc_exp_cargs(s, execution)).flat());
    }
    if ((params["log"] ?? null) !== null) {
        cargs.push(...(params["log"] ?? null).map(s => mrcalc_log_cargs(s, execution)).flat());
    }
    if ((params["log10"] ?? null) !== null) {
        cargs.push(...(params["log10"] ?? null).map(s => mrcalc_log10_cargs(s, execution)).flat());
    }
    if ((params["cos"] ?? null) !== null) {
        cargs.push(...(params["cos"] ?? null).map(s => mrcalc_cos_cargs(s, execution)).flat());
    }
    if ((params["sin"] ?? null) !== null) {
        cargs.push(...(params["sin"] ?? null).map(s => mrcalc_sin_cargs(s, execution)).flat());
    }
    if ((params["tan"] ?? null) !== null) {
        cargs.push(...(params["tan"] ?? null).map(s => mrcalc_tan_cargs(s, execution)).flat());
    }
    if ((params["acos"] ?? null) !== null) {
        cargs.push(...(params["acos"] ?? null).map(s => mrcalc_acos_cargs(s, execution)).flat());
    }
    if ((params["asin"] ?? null) !== null) {
        cargs.push(...(params["asin"] ?? null).map(s => mrcalc_asin_cargs(s, execution)).flat());
    }
    if ((params["atan"] ?? null) !== null) {
        cargs.push(...(params["atan"] ?? null).map(s => mrcalc_atan_cargs(s, execution)).flat());
    }
    if ((params["cosh"] ?? null) !== null) {
        cargs.push(...(params["cosh"] ?? null).map(s => mrcalc_cosh_cargs(s, execution)).flat());
    }
    if ((params["sinh"] ?? null) !== null) {
        cargs.push(...(params["sinh"] ?? null).map(s => mrcalc_sinh_cargs(s, execution)).flat());
    }
    if ((params["tanh"] ?? null) !== null) {
        cargs.push(...(params["tanh"] ?? null).map(s => mrcalc_tanh_cargs(s, execution)).flat());
    }
    if ((params["acosh"] ?? null) !== null) {
        cargs.push(...(params["acosh"] ?? null).map(s => mrcalc_acosh_cargs(s, execution)).flat());
    }
    if ((params["asinh"] ?? null) !== null) {
        cargs.push(...(params["asinh"] ?? null).map(s => mrcalc_asinh_cargs(s, execution)).flat());
    }
    if ((params["atanh"] ?? null) !== null) {
        cargs.push(...(params["atanh"] ?? null).map(s => mrcalc_atanh_cargs(s, execution)).flat());
    }
    if ((params["datatype"] ?? null) !== null) {
        cargs.push(
            "-datatype",
            (params["datatype"] ?? null)
        );
    }
    if ((params["info"] ?? false)) {
        cargs.push("-info");
    }
    if ((params["quiet"] ?? false)) {
        cargs.push("-quiet");
    }
    if ((params["debug"] ?? false)) {
        cargs.push("-debug");
    }
    if ((params["force"] ?? false)) {
        cargs.push("-force");
    }
    if ((params["nthreads"] ?? null) !== null) {
        cargs.push(
            "-nthreads",
            String((params["nthreads"] ?? null))
        );
    }
    if ((params["config"] ?? null) !== null) {
        cargs.push(...(params["config"] ?? null).map(s => mrcalc_config_cargs(s, execution)).flat());
    }
    if ((params["help"] ?? false)) {
        cargs.push("-help");
    }
    if ((params["version"] ?? false)) {
        cargs.push("-version");
    }
    cargs.push(...(params["operand"] ?? null).map(s => mrcalc_operand_cargs_dyn_fn(s["@type"])(s, execution)).flat());
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function mrcalc_outputs(
    params: MrcalcParamsDict,
    execution: Execution,
): MrcalcOutputs {
    const ret: MrcalcOutputs = {
        root: execution.outputFile("."),
    };
    return ret;
}


/**
 * mrcalc
 *
 * Apply generic voxel-wise mathematical operations to images.
 *
 * This command will only compute per-voxel operations. Use 'mrmath' to compute summary statistics across images or along image axes.
 *
 * This command uses a stack-based syntax, with operators (specified using options) operating on the top-most entries (i.e. images or values) in the stack. Operands (values or images) are pushed onto the stack in the order they appear (as arguments) on the command-line, and operators (specified as options) operate on and consume the top-most entries in the stack, and push their output as a new entry on the stack.
 *
 * As an additional feature, this command will allow images with different dimensions to be processed, provided they satisfy the following conditions: for each axis, the dimensions match if they are the same size, or one of them has size one. In the latter case, the entire image will be replicated along that axis. This allows for example a 4D image of size [ X Y Z N ] to be added to a 3D image of size [ X Y Z ], as if it consisted of N copies of the 3D image along the 4th axis (the missing dimension is assumed to have size 1). Another example would a single-voxel 4D image of size [ 1 1 1 N ], multiplied by a 3D image of size [ X Y Z ], which would allow the creation of a 4D image where each volume consists of the 3D image scaled by the corresponding value for that volume in the single-voxel image.
 *
 * References:
 *
 * .
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrcalcOutputs`).
 */
function mrcalc_execute(
    params: MrcalcParamsDict,
    runner: Runner | null = null,
): MrcalcOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(MRCALC_METADATA);
    params = execution.params(params)
    const cargs = mrcalc_cargs(params, execution)
    const ret = mrcalc_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * mrcalc
 *
 * Apply generic voxel-wise mathematical operations to images.
 *
 * This command will only compute per-voxel operations. Use 'mrmath' to compute summary statistics across images or along image axes.
 *
 * This command uses a stack-based syntax, with operators (specified using options) operating on the top-most entries (i.e. images or values) in the stack. Operands (values or images) are pushed onto the stack in the order they appear (as arguments) on the command-line, and operators (specified as options) operate on and consume the top-most entries in the stack, and push their output as a new entry on the stack.
 *
 * As an additional feature, this command will allow images with different dimensions to be processed, provided they satisfy the following conditions: for each axis, the dimensions match if they are the same size, or one of them has size one. In the latter case, the entire image will be replicated along that axis. This allows for example a 4D image of size [ X Y Z N ] to be added to a 3D image of size [ X Y Z ], as if it consisted of N copies of the 3D image along the 4th axis (the missing dimension is assumed to have size 1). Another example would a single-voxel 4D image of size [ 1 1 1 N ], multiplied by a 3D image of size [ X Y Z ], which would allow the creation of a 4D image where each volume consists of the 3D image scaled by the corresponding value for that volume in the single-voxel image.
 *
 * References:
 *
 * .
 *
 * Author: MRTrix3 Developers
 *
 * URL: https://www.mrtrix.org/
 *
 * @param operand an input image, intensity value, or the special keywords 'rand' (random number between 0 and 1) or 'randn' (random number from unit std.dev. normal distribution) or the mathematical constants 'e' and 'pi'.
 * @param abs |%1| : return absolute value (magnitude) of real or complex number
 * @param neg -%1 : negative value
 * @param add (%1 + %2) : add values
 * @param subtract (%1 - %2) : subtract nth operand from (n-1)th
 * @param multiply (%1 * %2) : multiply values
 * @param divide (%1 / %2) : divide (n-1)th operand by nth
 * @param min min (%1, %2) : smallest of last two operands
 * @param max max (%1, %2) : greatest of last two operands
 * @param lt (%1 < %2) : less-than operator (true=1, false=0)
 * @param gt (%1 > %2) : greater-than operator (true=1, false=0)
 * @param le (%1 <= %2) : less-than-or-equal-to operator (true=1, false=0)
 * @param ge (%1 >= %2) : greater-than-or-equal-to operator (true=1, false=0)
 * @param eq (%1 == %2) : equal-to operator (true=1, false=0)
 * @param neq (%1 != %2) : not-equal-to operator (true=1, false=0)
 * @param if_ (%1 ? %2 : %3) : if first operand is true (non-zero), return second operand, otherwise return third operand
 * @param replace (%1, %2 -> %3) : Wherever first operand is equal to the second operand, replace with third operand
 * @param sqrt sqrt (%1) : square root
 * @param pow %1^%2 : raise (n-1)th operand to nth power
 * @param round round (%1) : round to nearest integer
 * @param ceil ceil (%1) : round up to nearest integer
 * @param floor floor (%1) : round down to nearest integer
 * @param not !%1 : NOT operator: true (1) if operand is false (i.e. zero)
 * @param and (%1 && %2) : AND operator: true (1) if both operands are true (i.e. non-zero)
 * @param or (%1 || %2) : OR operator: true (1) if either operand is true (i.e. non-zero)
 * @param xor (%1 ^^ %2) : XOR operator: true (1) if only one of the operands is true (i.e. non-zero)
 * @param isnan isnan (%1) : true (1) if operand is not-a-number (NaN)
 * @param isinf isinf (%1) : true (1) if operand is infinite (Inf)
 * @param finite finite (%1) : true (1) if operand is finite (i.e. not NaN or Inf)
 * @param complex (%1 + %2 i) : create complex number using the last two operands as real,imaginary components
 * @param polar (%1 /_ %2) : create complex number using the last two operands as magnitude,phase components (phase in radians)
 * @param real real (%1) : real part of complex number
 * @param imag imag (%1) : imaginary part of complex number
 * @param phase phase (%1) : phase of complex number (use -abs for magnitude)
 * @param conj conj (%1) : complex conjugate
 * @param proj proj (%1) : projection onto the Riemann sphere
 * @param exp exp (%1) : exponential function
 * @param log log (%1) : natural logarithm
 * @param log10 log10 (%1) : common logarithm
 * @param cos cos (%1) : cosine
 * @param sin sin (%1) : sine
 * @param tan tan (%1) : tangent
 * @param acos acos (%1) : inverse cosine
 * @param asin asin (%1) : inverse sine
 * @param atan atan (%1) : inverse tangent
 * @param cosh cosh (%1) : hyperbolic cosine
 * @param sinh sinh (%1) : hyperbolic sine
 * @param tanh tanh (%1) : hyperbolic tangent
 * @param acosh acosh (%1) : inverse hyperbolic cosine
 * @param asinh asinh (%1) : inverse hyperbolic sine
 * @param atanh atanh (%1) : inverse hyperbolic tangent
 * @param datatype specify output image data type. Valid choices are: float32, float32le, float32be, float64, float64le, float64be, int64, uint64, int64le, uint64le, int64be, uint64be, int32, uint32, int32le, uint32le, int32be, uint32be, int16, uint16, int16le, uint16le, int16be, uint16be, cfloat32, cfloat32le, cfloat32be, cfloat64, cfloat64le, cfloat64be, int8, uint8, bit.
 * @param info display information messages.
 * @param quiet do not display information messages or progress status; alternatively, this can be achieved by setting the MRTRIX_QUIET environment variable to a non-empty string.
 * @param debug display debugging messages.
 * @param force force overwrite of output files (caution: using the same file as input and output might cause unexpected behaviour).
 * @param nthreads use this number of threads in multi-threaded applications (set to 0 to disable multi-threading).
 * @param config temporarily set the value of an MRtrix config file entry.
 * @param help display this information page and exit.
 * @param version display version information and exit.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `MrcalcOutputs`).
 */
function mrcalc(
    operand: Array<MrcalcVariousStringParamsDictTagged | MrcalcVariousFileParamsDictTagged>,
    abs: Array<MrcalcAbsParamsDict> | null = null,
    neg: Array<MrcalcNegParamsDict> | null = null,
    add: Array<MrcalcAddParamsDict> | null = null,
    subtract: Array<MrcalcSubtractParamsDict> | null = null,
    multiply: Array<MrcalcMultiplyParamsDict> | null = null,
    divide: Array<MrcalcDivideParamsDict> | null = null,
    min: Array<MrcalcMinParamsDict> | null = null,
    max: Array<MrcalcMaxParamsDict> | null = null,
    lt: Array<MrcalcLtParamsDict> | null = null,
    gt: Array<MrcalcGtParamsDict> | null = null,
    le: Array<MrcalcLeParamsDict> | null = null,
    ge: Array<MrcalcGeParamsDict> | null = null,
    eq: Array<MrcalcEqParamsDict> | null = null,
    neq: Array<MrcalcNeqParamsDict> | null = null,
    if_: Array<MrcalcIfParamsDict> | null = null,
    replace: Array<MrcalcReplaceParamsDict> | null = null,
    sqrt: Array<MrcalcSqrtParamsDict> | null = null,
    pow: Array<MrcalcPowParamsDict> | null = null,
    round: Array<MrcalcRoundParamsDict> | null = null,
    ceil: Array<MrcalcCeilParamsDict> | null = null,
    floor: Array<MrcalcFloorParamsDict> | null = null,
    not: Array<MrcalcNotParamsDict> | null = null,
    and: Array<MrcalcAndParamsDict> | null = null,
    or: Array<MrcalcOrParamsDict> | null = null,
    xor: Array<MrcalcXorParamsDict> | null = null,
    isnan: Array<MrcalcIsnanParamsDict> | null = null,
    isinf: Array<MrcalcIsinfParamsDict> | null = null,
    finite: Array<MrcalcFiniteParamsDict> | null = null,
    complex: Array<MrcalcComplexParamsDict> | null = null,
    polar: Array<MrcalcPolarParamsDict> | null = null,
    real: Array<MrcalcRealParamsDict> | null = null,
    imag: Array<MrcalcImagParamsDict> | null = null,
    phase: Array<MrcalcPhaseParamsDict> | null = null,
    conj: Array<MrcalcConjParamsDict> | null = null,
    proj: Array<MrcalcProjParamsDict> | null = null,
    exp: Array<MrcalcExpParamsDict> | null = null,
    log: Array<MrcalcLogParamsDict> | null = null,
    log10: Array<MrcalcLog10ParamsDict> | null = null,
    cos: Array<MrcalcCosParamsDict> | null = null,
    sin: Array<MrcalcSinParamsDict> | null = null,
    tan: Array<MrcalcTanParamsDict> | null = null,
    acos: Array<MrcalcAcosParamsDict> | null = null,
    asin: Array<MrcalcAsinParamsDict> | null = null,
    atan: Array<MrcalcAtanParamsDict> | null = null,
    cosh: Array<MrcalcCoshParamsDict> | null = null,
    sinh: Array<MrcalcSinhParamsDict> | null = null,
    tanh: Array<MrcalcTanhParamsDict> | null = null,
    acosh: Array<MrcalcAcoshParamsDict> | null = null,
    asinh: Array<MrcalcAsinhParamsDict> | null = null,
    atanh: Array<MrcalcAtanhParamsDict> | null = null,
    datatype: string | null = null,
    info: boolean = false,
    quiet: boolean = false,
    debug: boolean = false,
    force: boolean = false,
    nthreads: number | null = null,
    config: Array<MrcalcConfigParamsDict> | null = null,
    help: boolean = false,
    version: boolean = false,
    runner: Runner | null = null,
): MrcalcOutputs {
    const params = mrcalc_params(operand, abs, neg, add, subtract, multiply, divide, min, max, lt, gt, le, ge, eq, neq, if_, replace, sqrt, pow, round, ceil, floor, not, and, or, xor, isnan, isinf, finite, complex, polar, real, imag, phase, conj, proj, exp, log, log10, cos, sin, tan, acos, asin, atan, cosh, sinh, tanh, acosh, asinh, atanh, datatype, info, quiet, debug, force, nthreads, config, help, version)
    return mrcalc_execute(params, runner);
}


export {
      MRCALC_METADATA,
      MrcalcAbsParamsDict,
      MrcalcAbsParamsDictTagged,
      MrcalcAcosParamsDict,
      MrcalcAcosParamsDictTagged,
      MrcalcAcoshParamsDict,
      MrcalcAcoshParamsDictTagged,
      MrcalcAddParamsDict,
      MrcalcAddParamsDictTagged,
      MrcalcAndParamsDict,
      MrcalcAndParamsDictTagged,
      MrcalcAsinParamsDict,
      MrcalcAsinParamsDictTagged,
      MrcalcAsinhParamsDict,
      MrcalcAsinhParamsDictTagged,
      MrcalcAtanParamsDict,
      MrcalcAtanParamsDictTagged,
      MrcalcAtanhParamsDict,
      MrcalcAtanhParamsDictTagged,
      MrcalcCeilParamsDict,
      MrcalcCeilParamsDictTagged,
      MrcalcComplexParamsDict,
      MrcalcComplexParamsDictTagged,
      MrcalcConfigParamsDict,
      MrcalcConfigParamsDictTagged,
      MrcalcConjParamsDict,
      MrcalcConjParamsDictTagged,
      MrcalcCosParamsDict,
      MrcalcCosParamsDictTagged,
      MrcalcCoshParamsDict,
      MrcalcCoshParamsDictTagged,
      MrcalcDivideParamsDict,
      MrcalcDivideParamsDictTagged,
      MrcalcEqParamsDict,
      MrcalcEqParamsDictTagged,
      MrcalcExpParamsDict,
      MrcalcExpParamsDictTagged,
      MrcalcFiniteParamsDict,
      MrcalcFiniteParamsDictTagged,
      MrcalcFloorParamsDict,
      MrcalcFloorParamsDictTagged,
      MrcalcGeParamsDict,
      MrcalcGeParamsDictTagged,
      MrcalcGtParamsDict,
      MrcalcGtParamsDictTagged,
      MrcalcIfParamsDict,
      MrcalcIfParamsDictTagged,
      MrcalcImagParamsDict,
      MrcalcImagParamsDictTagged,
      MrcalcIsinfParamsDict,
      MrcalcIsinfParamsDictTagged,
      MrcalcIsnanParamsDict,
      MrcalcIsnanParamsDictTagged,
      MrcalcLeParamsDict,
      MrcalcLeParamsDictTagged,
      MrcalcLog10ParamsDict,
      MrcalcLog10ParamsDictTagged,
      MrcalcLogParamsDict,
      MrcalcLogParamsDictTagged,
      MrcalcLtParamsDict,
      MrcalcLtParamsDictTagged,
      MrcalcMaxParamsDict,
      MrcalcMaxParamsDictTagged,
      MrcalcMinParamsDict,
      MrcalcMinParamsDictTagged,
      MrcalcMultiplyParamsDict,
      MrcalcMultiplyParamsDictTagged,
      MrcalcNegParamsDict,
      MrcalcNegParamsDictTagged,
      MrcalcNeqParamsDict,
      MrcalcNeqParamsDictTagged,
      MrcalcNotParamsDict,
      MrcalcNotParamsDictTagged,
      MrcalcOrParamsDict,
      MrcalcOrParamsDictTagged,
      MrcalcOutputs,
      MrcalcParamsDict,
      MrcalcParamsDictTagged,
      MrcalcPhaseParamsDict,
      MrcalcPhaseParamsDictTagged,
      MrcalcPolarParamsDict,
      MrcalcPolarParamsDictTagged,
      MrcalcPowParamsDict,
      MrcalcPowParamsDictTagged,
      MrcalcProjParamsDict,
      MrcalcProjParamsDictTagged,
      MrcalcRealParamsDict,
      MrcalcRealParamsDictTagged,
      MrcalcReplaceParamsDict,
      MrcalcReplaceParamsDictTagged,
      MrcalcRoundParamsDict,
      MrcalcRoundParamsDictTagged,
      MrcalcSinParamsDict,
      MrcalcSinParamsDictTagged,
      MrcalcSinhParamsDict,
      MrcalcSinhParamsDictTagged,
      MrcalcSqrtParamsDict,
      MrcalcSqrtParamsDictTagged,
      MrcalcSubtractParamsDict,
      MrcalcSubtractParamsDictTagged,
      MrcalcTanParamsDict,
      MrcalcTanParamsDictTagged,
      MrcalcTanhParamsDict,
      MrcalcTanhParamsDictTagged,
      MrcalcVariousFileParamsDict,
      MrcalcVariousFileParamsDictTagged,
      MrcalcVariousStringParamsDict,
      MrcalcVariousStringParamsDictTagged,
      MrcalcXorParamsDict,
      MrcalcXorParamsDictTagged,
      mrcalc,
      mrcalc_abs,
      mrcalc_acos,
      mrcalc_acosh,
      mrcalc_add,
      mrcalc_and,
      mrcalc_asin,
      mrcalc_asinh,
      mrcalc_atan,
      mrcalc_atanh,
      mrcalc_ceil,
      mrcalc_complex,
      mrcalc_config,
      mrcalc_conj,
      mrcalc_cos,
      mrcalc_cosh,
      mrcalc_divide,
      mrcalc_eq,
      mrcalc_execute,
      mrcalc_exp,
      mrcalc_finite,
      mrcalc_floor,
      mrcalc_ge,
      mrcalc_gt,
      mrcalc_if,
      mrcalc_imag,
      mrcalc_isinf,
      mrcalc_isnan,
      mrcalc_le,
      mrcalc_log,
      mrcalc_log10,
      mrcalc_lt,
      mrcalc_max,
      mrcalc_min,
      mrcalc_multiply,
      mrcalc_neg,
      mrcalc_neq,
      mrcalc_not,
      mrcalc_or,
      mrcalc_params,
      mrcalc_phase,
      mrcalc_polar,
      mrcalc_pow,
      mrcalc_proj,
      mrcalc_real,
      mrcalc_replace,
      mrcalc_round,
      mrcalc_sin,
      mrcalc_sinh,
      mrcalc_sqrt,
      mrcalc_subtract,
      mrcalc_tan,
      mrcalc_tanh,
      mrcalc_various_file,
      mrcalc_various_string,
      mrcalc_xor,
};
