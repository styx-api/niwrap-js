// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const FEATREGAPPLY_METADATA: Metadata = {
    id: "7aec4712113c7b2c58c6dd718630ad2ad49c1922.boutiques",
    name: "featregapply",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface FeatregapplyParameters {
    "@type"?: "fsl/featregapply";
    "feat_directory": string;
    "force_flag": boolean;
    "cleanup_flag": boolean;
    "upsample_trilinear"?: InputPathType | null | undefined;
    "upsample_spline"?: InputPathType | null | undefined;
    "standard_space_res"?: number | null | undefined;
    "exclude_filtered_func_flag": boolean;
}
type FeatregapplyParametersTagged = Required<Pick<FeatregapplyParameters, '@type'>> & FeatregapplyParameters;


/**
 * Output object returned when calling `FeatregapplyParameters(...)`.
 *
 * @interface
 */
interface FeatregapplyOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Directory where the output files will be stored
     */
    output_directory: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param feat_directory FEAT directory from which registration will be taken
 * @param force_flag Force featregapply to run even if it has already been run on this FEAT directory
 * @param cleanup_flag Cleanup, i.e. remove all featregapply output
 * @param upsample_trilinear Upsample functional-space image to standard space using trilinear interpolation
 * @param upsample_spline Upsample functional-space image to standard space using spline (like sinc) interpolation
 * @param standard_space_res Specify the standard space resolution for melodic (e.g. 3 for 3mm)
 * @param exclude_filtered_func_flag Exclude filtered func when processing melodic directories (for FEAT directories filtered func is never processed)
 *
 * @returns Parameter dictionary
 */
function featregapply_params(
    feat_directory: string,
    force_flag: boolean = false,
    cleanup_flag: boolean = false,
    upsample_trilinear: InputPathType | null = null,
    upsample_spline: InputPathType | null = null,
    standard_space_res: number | null = null,
    exclude_filtered_func_flag: boolean = false,
): FeatregapplyParametersTagged {
    const params = {
        "@type": "fsl/featregapply" as const,
        "feat_directory": feat_directory,
        "force_flag": force_flag,
        "cleanup_flag": cleanup_flag,
        "exclude_filtered_func_flag": exclude_filtered_func_flag,
    };
    if (upsample_trilinear !== null) {
        params["upsample_trilinear"] = upsample_trilinear;
    }
    if (upsample_spline !== null) {
        params["upsample_spline"] = upsample_spline;
    }
    if (standard_space_res !== null) {
        params["standard_space_res"] = standard_space_res;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function featregapply_cargs(
    params: FeatregapplyParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("featregapply");
    cargs.push((params["feat_directory"] ?? null));
    if ((params["force_flag"] ?? false)) {
        cargs.push("-f");
    }
    if ((params["cleanup_flag"] ?? false)) {
        cargs.push("-c");
    }
    if ((params["upsample_trilinear"] ?? null) !== null) {
        cargs.push(
            "-l",
            execution.inputFile((params["upsample_trilinear"] ?? null))
        );
    }
    if ((params["upsample_spline"] ?? null) !== null) {
        cargs.push(
            "-s",
            execution.inputFile((params["upsample_spline"] ?? null))
        );
    }
    if ((params["standard_space_res"] ?? null) !== null) {
        cargs.push(
            "-r",
            String((params["standard_space_res"] ?? null))
        );
    }
    if ((params["exclude_filtered_func_flag"] ?? false)) {
        cargs.push("-e");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function featregapply_outputs(
    params: FeatregapplyParameters,
    execution: Execution,
): FeatregapplyOutputs {
    const ret: FeatregapplyOutputs = {
        root: execution.outputFile("."),
        output_directory: execution.outputFile([(params["feat_directory"] ?? null), "/reg_standard"].join('')),
    };
    return ret;
}


/**
 * featregapply
 *
 * Apply registration from FEAT analysis to other images.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FeatregapplyOutputs`).
 */
function featregapply_execute(
    params: FeatregapplyParameters,
    runner: Runner | null = null,
): FeatregapplyOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(FEATREGAPPLY_METADATA);
    params = execution.params(params)
    const cargs = featregapply_cargs(params, execution)
    const ret = featregapply_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * featregapply
 *
 * Apply registration from FEAT analysis to other images.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param feat_directory FEAT directory from which registration will be taken
 * @param force_flag Force featregapply to run even if it has already been run on this FEAT directory
 * @param cleanup_flag Cleanup, i.e. remove all featregapply output
 * @param upsample_trilinear Upsample functional-space image to standard space using trilinear interpolation
 * @param upsample_spline Upsample functional-space image to standard space using spline (like sinc) interpolation
 * @param standard_space_res Specify the standard space resolution for melodic (e.g. 3 for 3mm)
 * @param exclude_filtered_func_flag Exclude filtered func when processing melodic directories (for FEAT directories filtered func is never processed)
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FeatregapplyOutputs`).
 */
function featregapply(
    feat_directory: string,
    force_flag: boolean = false,
    cleanup_flag: boolean = false,
    upsample_trilinear: InputPathType | null = null,
    upsample_spline: InputPathType | null = null,
    standard_space_res: number | null = null,
    exclude_filtered_func_flag: boolean = false,
    runner: Runner | null = null,
): FeatregapplyOutputs {
    const params = featregapply_params(feat_directory, force_flag, cleanup_flag, upsample_trilinear, upsample_spline, standard_space_res, exclude_filtered_func_flag)
    return featregapply_execute(params, runner);
}


export {
      FEATREGAPPLY_METADATA,
      FeatregapplyOutputs,
      featregapply,
      featregapply_execute,
      featregapply_params,
};
