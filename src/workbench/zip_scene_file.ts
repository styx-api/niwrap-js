// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const ZIP_SCENE_FILE_METADATA: Metadata = {
    id: "85d5fb1af707c34c6db735360187816616cc1dda.boutiques",
    name: "zip-scene-file",
    package: "workbench",
    container_image_tag: "brainlife/connectome_workbench:1.5.0-freesurfer-update",
};


interface ZipSceneFileParameters {
    "@type": "workbench.zip-scene-file";
    "scene_file": string;
    "extract_folder": string;
    "zip_file": string;
    "opt_base_dir_directory"?: string | null | undefined;
    "opt_skip_missing": boolean;
    "opt_write_scene_file": boolean;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "workbench.zip-scene-file": zip_scene_file_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `zip_scene_file(...)`.
 *
 * @interface
 */
interface ZipSceneFileOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
}


/**
 * Build parameters.
 *
 * @param scene_file the scene file to make the zip file from
 * @param extract_folder the name of the folder created when the zip file is unzipped
 * @param zip_file out - the zip file that will be created
 * @param opt_base_dir_directory specify a directory that all data files are somewhere within, this will become the root of the zipfile's directory structure: the directory
 * @param opt_skip_missing any missing files will generate only warnings, and the zip file will be created anyway
 * @param opt_write_scene_file rewrite the scene file before zipping, to store a new base path or fix extra '..'s in paths that might break
 *
 * @returns Parameter dictionary
 */
function zip_scene_file_params(
    scene_file: string,
    extract_folder: string,
    zip_file: string,
    opt_base_dir_directory: string | null = null,
    opt_skip_missing: boolean = false,
    opt_write_scene_file: boolean = false,
): ZipSceneFileParameters {
    const params = {
        "@type": "workbench.zip-scene-file" as const,
        "scene_file": scene_file,
        "extract_folder": extract_folder,
        "zip_file": zip_file,
        "opt_skip_missing": opt_skip_missing,
        "opt_write_scene_file": opt_write_scene_file,
    };
    if (opt_base_dir_directory !== null) {
        params["opt_base_dir_directory"] = opt_base_dir_directory;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function zip_scene_file_cargs(
    params: ZipSceneFileParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("wb_command");
    cargs.push("-zip-scene-file");
    cargs.push((params["scene_file"] ?? null));
    cargs.push((params["extract_folder"] ?? null));
    cargs.push((params["zip_file"] ?? null));
    if ((params["opt_base_dir_directory"] ?? null) !== null) {
        cargs.push(
            "-base-dir",
            (params["opt_base_dir_directory"] ?? null)
        );
    }
    if ((params["opt_skip_missing"] ?? null)) {
        cargs.push("-skip-missing");
    }
    if ((params["opt_write_scene_file"] ?? null)) {
        cargs.push("-write-scene-file");
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function zip_scene_file_outputs(
    params: ZipSceneFileParameters,
    execution: Execution,
): ZipSceneFileOutputs {
    const ret: ZipSceneFileOutputs = {
        root: execution.outputFile("."),
    };
    return ret;
}


/**
 * zip-scene-file
 *
 * Zip a scene file and its data files.
 *
 * If zip-file already exists, it will be overwritten.  If -base-dir is not specified, the base directory will be automatically set to the lowest level directory containing all files.  The scene file must contain only relative paths, and no data files may be outside the base directory.
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ZipSceneFileOutputs`).
 */
function zip_scene_file_execute(
    params: ZipSceneFileParameters,
    runner: Runner | null = null,
): ZipSceneFileOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(ZIP_SCENE_FILE_METADATA);
    params = execution.params(params)
    const cargs = zip_scene_file_cargs(params, execution)
    const ret = zip_scene_file_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * zip-scene-file
 *
 * Zip a scene file and its data files.
 *
 * If zip-file already exists, it will be overwritten.  If -base-dir is not specified, the base directory will be automatically set to the lowest level directory containing all files.  The scene file must contain only relative paths, and no data files may be outside the base directory.
 *
 * Author: Connectome Workbench Developers
 *
 * URL: https://github.com/Washington-University/workbench
 *
 * @param scene_file the scene file to make the zip file from
 * @param extract_folder the name of the folder created when the zip file is unzipped
 * @param zip_file out - the zip file that will be created
 * @param opt_base_dir_directory specify a directory that all data files are somewhere within, this will become the root of the zipfile's directory structure: the directory
 * @param opt_skip_missing any missing files will generate only warnings, and the zip file will be created anyway
 * @param opt_write_scene_file rewrite the scene file before zipping, to store a new base path or fix extra '..'s in paths that might break
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `ZipSceneFileOutputs`).
 */
function zip_scene_file(
    scene_file: string,
    extract_folder: string,
    zip_file: string,
    opt_base_dir_directory: string | null = null,
    opt_skip_missing: boolean = false,
    opt_write_scene_file: boolean = false,
    runner: Runner | null = null,
): ZipSceneFileOutputs {
    const params = zip_scene_file_params(scene_file, extract_folder, zip_file, opt_base_dir_directory, opt_skip_missing, opt_write_scene_file)
    return zip_scene_file_execute(params, runner);
}


export {
      ZIP_SCENE_FILE_METADATA,
      ZipSceneFileOutputs,
      ZipSceneFileParameters,
      zip_scene_file,
      zip_scene_file_execute,
      zip_scene_file_params,
};
