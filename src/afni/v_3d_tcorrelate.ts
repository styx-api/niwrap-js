// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const V_3D_TCORRELATE_METADATA: Metadata = {
    id: "ecc97c11254ea3d0a351c5592302c585980958d1.boutiques",
    name: "3dTcorrelate",
    package: "afni",
    container_image_tag: "afni/afni_make_build:AFNI_24.2.06",
};


interface V3dTcorrelateParameters {
    "@type": "afni.3dTcorrelate";
    "xset": InputPathType;
    "yset": InputPathType;
    "pearson": boolean;
    "spearman": boolean;
    "quadrant": boolean;
    "ktaub": boolean;
    "covariance": boolean;
    "partial"?: InputPathType | null | undefined;
    "ycoef": boolean;
    "fisher": boolean;
    "polort"?: number | null | undefined;
    "ort"?: InputPathType | null | undefined;
    "autoclip": boolean;
    "automask": boolean;
    "zcensor": boolean;
    "prefix"?: string | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "afni.3dTcorrelate": v_3d_tcorrelate_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "afni.3dTcorrelate": v_3d_tcorrelate_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `v_3d_tcorrelate(...)`.
 *
 * @interface
 */
interface V3dTcorrelateOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Output image file name.
     */
    out_file: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param xset Input xset.
 * @param yset Input yset.
 * @param pearson Correlation is the normal pearson correlation coefficient.
 * @param spearman Correlation is the Spearman (rank) correlation coefficient.
 * @param quadrant Correlation is the quadrant coefficient.
 * @param ktaub Correlation is Kendall's tau_b coefficient. For continuous or finely discretized data, tau_b and rank correlation are nearly equivalent.
 * @param covariance Covariance instead of correlation. That would be Pearson correlation without scaling by the product of the standard deviations.
 * @param partial Partial Pearson's correlation of X & Y, adjusting for Z (the dataset provided here).
 * @param ycoef Least squares coefficient that best fits y(t) to x(t), after detrending. That is, if yd(t) is the detrended y(t) and xd(t) is the detrended x(t), then the ycoef value is from the OLSQ fit to xd(t) = ycoef & y(t) + error.
 * @param fisher Apply the Fisher (inverse hyperbolic tangent) transformation to correlation results. Does not make sense with ktaub, covariance, or ycoef.
 * @param polort Remove polynomial trend of order m. Using m=-1 mean no detrending; this is only useful fro data that has been preprocessed.
 * @param ort A 1D file. Also detrend using the columbs of the 1D file provided here. Only one -ort option can be given, so if you would like to use more than one, create a temporary file using 1dcat.
 * @param autoclip Clip off low-intensity regions in the two datasets, so that the correlation is only computed between high-intensity (presumably brain) voxels. The intensity level is determined the same way that 3dClipLevel works.
 * @param automask Clip off low-intensity regions in the two datasets, so that the correlation is only computed between high-intensity (presumably brain) voxels. The intensity level is determined the same way that 3dClipLevel works.
 * @param zcensor Omit (censor out) any time points where the xset volume is all zero OR where the yset volume is all zero (in mask). Please note that using -zcensor with any detrending is unlikely to be useful.
 * @param prefix Save output into a dataset with this prefix.
 *
 * @returns Parameter dictionary
 */
function v_3d_tcorrelate_params(
    xset: InputPathType,
    yset: InputPathType,
    pearson: boolean = false,
    spearman: boolean = false,
    quadrant: boolean = false,
    ktaub: boolean = false,
    covariance: boolean = false,
    partial: InputPathType | null = null,
    ycoef: boolean = false,
    fisher: boolean = false,
    polort: number | null = null,
    ort: InputPathType | null = null,
    autoclip: boolean = false,
    automask: boolean = false,
    zcensor: boolean = false,
    prefix: string | null = null,
): V3dTcorrelateParameters {
    const params = {
        "@type": "afni.3dTcorrelate" as const,
        "xset": xset,
        "yset": yset,
        "pearson": pearson,
        "spearman": spearman,
        "quadrant": quadrant,
        "ktaub": ktaub,
        "covariance": covariance,
        "ycoef": ycoef,
        "fisher": fisher,
        "autoclip": autoclip,
        "automask": automask,
        "zcensor": zcensor,
    };
    if (partial !== null) {
        params["partial"] = partial;
    }
    if (polort !== null) {
        params["polort"] = polort;
    }
    if (ort !== null) {
        params["ort"] = ort;
    }
    if (prefix !== null) {
        params["prefix"] = prefix;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function v_3d_tcorrelate_cargs(
    params: V3dTcorrelateParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("3dTcorrelate");
    cargs.push(execution.inputFile((params["xset"] ?? null)));
    cargs.push(execution.inputFile((params["yset"] ?? null)));
    if ((params["pearson"] ?? null)) {
        cargs.push("-pearson");
    }
    if ((params["spearman"] ?? null)) {
        cargs.push("-spearman");
    }
    if ((params["quadrant"] ?? null)) {
        cargs.push("-quadrant");
    }
    if ((params["ktaub"] ?? null)) {
        cargs.push("-ktaub");
    }
    if ((params["covariance"] ?? null)) {
        cargs.push("-covariance");
    }
    if ((params["partial"] ?? null) !== null) {
        cargs.push(
            "-partial",
            execution.inputFile((params["partial"] ?? null))
        );
    }
    if ((params["ycoef"] ?? null)) {
        cargs.push("-ycoef");
    }
    if ((params["fisher"] ?? null)) {
        cargs.push("-Fisher");
    }
    if ((params["polort"] ?? null) !== null) {
        cargs.push(
            "-polort",
            String((params["polort"] ?? null))
        );
    }
    if ((params["ort"] ?? null) !== null) {
        cargs.push(
            "-ort",
            execution.inputFile((params["ort"] ?? null))
        );
    }
    if ((params["autoclip"] ?? null)) {
        cargs.push("-autoclip");
    }
    if ((params["automask"] ?? null)) {
        cargs.push("-automask");
    }
    if ((params["zcensor"] ?? null)) {
        cargs.push("-zcensor");
    }
    if ((params["prefix"] ?? null) !== null) {
        cargs.push(
            "-prefix",
            (params["prefix"] ?? null)
        );
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function v_3d_tcorrelate_outputs(
    params: V3dTcorrelateParameters,
    execution: Execution,
): V3dTcorrelateOutputs {
    const ret: V3dTcorrelateOutputs = {
        root: execution.outputFile("."),
        out_file: ((params["prefix"] ?? null) !== null) ? execution.outputFile([(params["prefix"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * 3dTcorrelate
 *
 * 3dTcorrelate. Computes the correlation coefficient between corresponding voxel time series in two input 3D+time datasets 'xset' and 'yset'.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dTcorrelateOutputs`).
 */
function v_3d_tcorrelate_execute(
    params: V3dTcorrelateParameters,
    runner: Runner | null = null,
): V3dTcorrelateOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(V_3D_TCORRELATE_METADATA);
    params = execution.params(params)
    const cargs = v_3d_tcorrelate_cargs(params, execution)
    const ret = v_3d_tcorrelate_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * 3dTcorrelate
 *
 * 3dTcorrelate. Computes the correlation coefficient between corresponding voxel time series in two input 3D+time datasets 'xset' and 'yset'.
 *
 * Author: AFNI Developers
 *
 * URL: https://afni.nimh.nih.gov/
 *
 * @param xset Input xset.
 * @param yset Input yset.
 * @param pearson Correlation is the normal pearson correlation coefficient.
 * @param spearman Correlation is the Spearman (rank) correlation coefficient.
 * @param quadrant Correlation is the quadrant coefficient.
 * @param ktaub Correlation is Kendall's tau_b coefficient. For continuous or finely discretized data, tau_b and rank correlation are nearly equivalent.
 * @param covariance Covariance instead of correlation. That would be Pearson correlation without scaling by the product of the standard deviations.
 * @param partial Partial Pearson's correlation of X & Y, adjusting for Z (the dataset provided here).
 * @param ycoef Least squares coefficient that best fits y(t) to x(t), after detrending. That is, if yd(t) is the detrended y(t) and xd(t) is the detrended x(t), then the ycoef value is from the OLSQ fit to xd(t) = ycoef & y(t) + error.
 * @param fisher Apply the Fisher (inverse hyperbolic tangent) transformation to correlation results. Does not make sense with ktaub, covariance, or ycoef.
 * @param polort Remove polynomial trend of order m. Using m=-1 mean no detrending; this is only useful fro data that has been preprocessed.
 * @param ort A 1D file. Also detrend using the columbs of the 1D file provided here. Only one -ort option can be given, so if you would like to use more than one, create a temporary file using 1dcat.
 * @param autoclip Clip off low-intensity regions in the two datasets, so that the correlation is only computed between high-intensity (presumably brain) voxels. The intensity level is determined the same way that 3dClipLevel works.
 * @param automask Clip off low-intensity regions in the two datasets, so that the correlation is only computed between high-intensity (presumably brain) voxels. The intensity level is determined the same way that 3dClipLevel works.
 * @param zcensor Omit (censor out) any time points where the xset volume is all zero OR where the yset volume is all zero (in mask). Please note that using -zcensor with any detrending is unlikely to be useful.
 * @param prefix Save output into a dataset with this prefix.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `V3dTcorrelateOutputs`).
 */
function v_3d_tcorrelate(
    xset: InputPathType,
    yset: InputPathType,
    pearson: boolean = false,
    spearman: boolean = false,
    quadrant: boolean = false,
    ktaub: boolean = false,
    covariance: boolean = false,
    partial: InputPathType | null = null,
    ycoef: boolean = false,
    fisher: boolean = false,
    polort: number | null = null,
    ort: InputPathType | null = null,
    autoclip: boolean = false,
    automask: boolean = false,
    zcensor: boolean = false,
    prefix: string | null = null,
    runner: Runner | null = null,
): V3dTcorrelateOutputs {
    const params = v_3d_tcorrelate_params(xset, yset, pearson, spearman, quadrant, ktaub, covariance, partial, ycoef, fisher, polort, ort, autoclip, automask, zcensor, prefix)
    return v_3d_tcorrelate_execute(params, runner);
}


export {
      V3dTcorrelateOutputs,
      V3dTcorrelateParameters,
      V_3D_TCORRELATE_METADATA,
      v_3d_tcorrelate,
      v_3d_tcorrelate_execute,
      v_3d_tcorrelate_params,
};
