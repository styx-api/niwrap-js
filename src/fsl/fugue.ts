// This file was auto generated by Styx.
// Do not edit this file directly.

import { Runner, Execution, Metadata, InputPathType, OutputPathType, getGlobalRunner } from 'styxdefs';

const FUGUE_METADATA: Metadata = {
    id: "b05c6e4c10dbf1a89e74880d796cdc5f9d30e3c3.boutiques",
    name: "fugue",
    package: "fsl",
    container_image_tag: "brainlife/fsl:6.0.4-patched2",
};


interface FugueParameters {
    "@type": "fsl.fugue";
    "asym_se_time"?: number | null | undefined;
    "despike_2dfilter": boolean;
    "despike_threshold"?: number | null | undefined;
    "dwell_time"?: number | null | undefined;
    "dwell_to_asym_ratio"?: number | null | undefined;
    "fmap_in_file"?: InputPathType | null | undefined;
    "fmap_out_file"?: string | null | undefined;
    "forward_warping": boolean;
    "fourier_order"?: number | null | undefined;
    "icorr": boolean;
    "icorr_only": boolean;
    "in_file"?: InputPathType | null | undefined;
    "mask_file"?: InputPathType | null | undefined;
    "median_2dfilter": boolean;
    "no_extend": boolean;
    "no_gap_fill": boolean;
    "nokspace": boolean;
    "output_type"?: "NIFTI" | "NIFTI_PAIR" | "NIFTI_GZ" | "NIFTI_PAIR_GZ" | null | undefined;
    "pava": boolean;
    "phase_conjugate": boolean;
    "phasemap_in_file"?: InputPathType | null | undefined;
    "poly_order"?: number | null | undefined;
    "save_fmap": boolean;
    "save_shift": boolean;
    "save_unmasked_fmap": boolean;
    "save_unmasked_shift": boolean;
    "shift_in_file"?: InputPathType | null | undefined;
    "shift_out_file"?: string | null | undefined;
    "smooth2d"?: number | null | undefined;
    "smooth3d"?: number | null | undefined;
    "unwarp_direction"?: "x" | "y" | "z" | "x-" | "y-" | "z-" | null | undefined;
    "unwarped_file"?: string | null | undefined;
    "warped_file"?: string | null | undefined;
}


/**
 * Get build cargs function by command type.
 *
 * @param t Command type
 *
 * @returns Build cargs function.
 */
function dynCargs(
    t: string,
): Function | undefined {
    const cargsFuncs = {
        "fsl.fugue": fugue_cargs,
    };
    return cargsFuncs[t];
}


/**
 * Get build outputs function by command type.
 *
 * @param t Command type
 *
 * @returns Build outputs function.
 */
function dynOutputs(
    t: string,
): Function | undefined {
    const outputsFuncs = {
        "fsl.fugue": fugue_outputs,
    };
    return outputsFuncs[t];
}


/**
 * Output object returned when calling `fugue(...)`.
 *
 * @interface
 */
interface FugueOutputs {
    /**
     * Output root folder. This is the root folder for all outputs.
     */
    root: OutputPathType;
    /**
     * Fieldmap file.
     */
    fmap_out_file_outfile: OutputPathType | null;
    /**
     * Voxel shift map file.
     */
    shift_out_file_outfile: OutputPathType | null;
    /**
     * Unwarped file.
     */
    unwarped_file_outfile: OutputPathType | null;
    /**
     * Forward warped file.
     */
    warped_file_outfile: OutputPathType | null;
}


/**
 * Build parameters.
 *
 * @param asym_se_time Set the fieldmap asymmetric spin echo time (sec).
 * @param despike_2dfilter Apply a 2d de-spiking filter.
 * @param despike_threshold Specify the threshold for de-spiking (default=3.0).
 * @param dwell_time Set the epi dwell time per phase-encode line - same as echo spacing - (sec).
 * @param dwell_to_asym_ratio Set the dwell to asym time ratio.
 * @param fmap_in_file Filename for loading fieldmap (rad/s).
 * @param fmap_out_file Filename for saving fieldmap (rad/s).
 * @param forward_warping Apply forward warping instead of unwarping.
 * @param fourier_order Apply fourier (sinusoidal) fitting of order n.
 * @param icorr Apply intensity correction to unwarping (pixel shift method only).
 * @param icorr_only Apply intensity correction only.
 * @param in_file Filename of input volume.
 * @param mask_file Filename for loading valid mask.
 * @param median_2dfilter Apply 2d median filtering.
 * @param no_extend Do not apply rigid-body extrapolation to the fieldmap.
 * @param no_gap_fill Do not apply gap-filling measure to the fieldmap.
 * @param nokspace Do not use k-space forward warping.
 * @param output_type 'nifti' or 'nifti_pair' or 'nifti_gz' or 'nifti_pair_gz'. Fsl output type.
 * @param pava Apply monotonic enforcement via pava.
 * @param phase_conjugate Apply phase conjugate method of unwarping.
 * @param phasemap_in_file Filename for input phase image.
 * @param poly_order Apply polynomial fitting of order n.
 * @param save_fmap Write field map volume.
 * @param save_shift Write pixel shift volume.
 * @param save_unmasked_fmap Saves the unmasked fieldmap when using --savefmap.
 * @param save_unmasked_shift Saves the unmasked shiftmap when using --saveshift.
 * @param shift_in_file Filename for reading pixel shift volume.
 * @param shift_out_file Filename for saving pixel shift volume.
 * @param smooth2d Apply 2d gaussian smoothing of sigma n (in mm).
 * @param smooth3d Apply 3d gaussian smoothing of sigma n (in mm).
 * @param unwarp_direction 'x' or 'y' or 'z' or 'x-' or 'y-' or 'z-'. Specifies direction of warping (default y).
 * @param unwarped_file Apply unwarping and save as filename.
 * @param warped_file Apply forward warping and save as filename.
 *
 * @returns Parameter dictionary
 */
function fugue_params(
    asym_se_time: number | null = null,
    despike_2dfilter: boolean = false,
    despike_threshold: number | null = null,
    dwell_time: number | null = null,
    dwell_to_asym_ratio: number | null = null,
    fmap_in_file: InputPathType | null = null,
    fmap_out_file: string | null = null,
    forward_warping: boolean = false,
    fourier_order: number | null = null,
    icorr: boolean = false,
    icorr_only: boolean = false,
    in_file: InputPathType | null = null,
    mask_file: InputPathType | null = null,
    median_2dfilter: boolean = false,
    no_extend: boolean = false,
    no_gap_fill: boolean = false,
    nokspace: boolean = false,
    output_type: "NIFTI" | "NIFTI_PAIR" | "NIFTI_GZ" | "NIFTI_PAIR_GZ" | null = null,
    pava: boolean = false,
    phase_conjugate: boolean = false,
    phasemap_in_file: InputPathType | null = null,
    poly_order: number | null = null,
    save_fmap: boolean = false,
    save_shift: boolean = false,
    save_unmasked_fmap: boolean = false,
    save_unmasked_shift: boolean = false,
    shift_in_file: InputPathType | null = null,
    shift_out_file: string | null = null,
    smooth2d: number | null = null,
    smooth3d: number | null = null,
    unwarp_direction: "x" | "y" | "z" | "x-" | "y-" | "z-" | null = null,
    unwarped_file: string | null = null,
    warped_file: string | null = null,
): FugueParameters {
    const params = {
        "@type": "fsl.fugue" as const,
        "despike_2dfilter": despike_2dfilter,
        "forward_warping": forward_warping,
        "icorr": icorr,
        "icorr_only": icorr_only,
        "median_2dfilter": median_2dfilter,
        "no_extend": no_extend,
        "no_gap_fill": no_gap_fill,
        "nokspace": nokspace,
        "pava": pava,
        "phase_conjugate": phase_conjugate,
        "save_fmap": save_fmap,
        "save_shift": save_shift,
        "save_unmasked_fmap": save_unmasked_fmap,
        "save_unmasked_shift": save_unmasked_shift,
    };
    if (asym_se_time !== null) {
        params["asym_se_time"] = asym_se_time;
    }
    if (despike_threshold !== null) {
        params["despike_threshold"] = despike_threshold;
    }
    if (dwell_time !== null) {
        params["dwell_time"] = dwell_time;
    }
    if (dwell_to_asym_ratio !== null) {
        params["dwell_to_asym_ratio"] = dwell_to_asym_ratio;
    }
    if (fmap_in_file !== null) {
        params["fmap_in_file"] = fmap_in_file;
    }
    if (fmap_out_file !== null) {
        params["fmap_out_file"] = fmap_out_file;
    }
    if (fourier_order !== null) {
        params["fourier_order"] = fourier_order;
    }
    if (in_file !== null) {
        params["in_file"] = in_file;
    }
    if (mask_file !== null) {
        params["mask_file"] = mask_file;
    }
    if (output_type !== null) {
        params["output_type"] = output_type;
    }
    if (phasemap_in_file !== null) {
        params["phasemap_in_file"] = phasemap_in_file;
    }
    if (poly_order !== null) {
        params["poly_order"] = poly_order;
    }
    if (shift_in_file !== null) {
        params["shift_in_file"] = shift_in_file;
    }
    if (shift_out_file !== null) {
        params["shift_out_file"] = shift_out_file;
    }
    if (smooth2d !== null) {
        params["smooth2d"] = smooth2d;
    }
    if (smooth3d !== null) {
        params["smooth3d"] = smooth3d;
    }
    if (unwarp_direction !== null) {
        params["unwarp_direction"] = unwarp_direction;
    }
    if (unwarped_file !== null) {
        params["unwarped_file"] = unwarped_file;
    }
    if (warped_file !== null) {
        params["warped_file"] = warped_file;
    }
    return params;
}


/**
 * Build command-line arguments from parameters.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Command-line arguments.
 */
function fugue_cargs(
    params: FugueParameters,
    execution: Execution,
): string[] {
    const cargs: string[] = [];
    cargs.push("fugue");
    if ((params["asym_se_time"] ?? null) !== null) {
        cargs.push(["--asym=", String((params["asym_se_time"] ?? null))].join(''));
    }
    if ((params["despike_2dfilter"] ?? null)) {
        cargs.push("--despike");
    }
    if ((params["despike_threshold"] ?? null) !== null) {
        cargs.push(["--despikethreshold=", String((params["despike_threshold"] ?? null))].join(''));
    }
    if ((params["dwell_time"] ?? null) !== null) {
        cargs.push(["--dwell=", String((params["dwell_time"] ?? null))].join(''));
    }
    if ((params["dwell_to_asym_ratio"] ?? null) !== null) {
        cargs.push(["--dwelltoasym=", String((params["dwell_to_asym_ratio"] ?? null))].join(''));
    }
    if ((params["fmap_in_file"] ?? null) !== null) {
        cargs.push(["--loadfmap=", execution.inputFile((params["fmap_in_file"] ?? null))].join(''));
    }
    if ((params["fmap_out_file"] ?? null) !== null) {
        cargs.push(["--savefmap=", (params["fmap_out_file"] ?? null)].join(''));
    }
    if ((params["forward_warping"] ?? null)) {
        cargs.push("--forward_warping");
    }
    if ((params["fourier_order"] ?? null) !== null) {
        cargs.push(["--fourier=", String((params["fourier_order"] ?? null))].join(''));
    }
    if ((params["icorr"] ?? null)) {
        cargs.push("--icorr");
    }
    if ((params["icorr_only"] ?? null)) {
        cargs.push("--icorronly");
    }
    if ((params["in_file"] ?? null) !== null) {
        cargs.push(["--in=", execution.inputFile((params["in_file"] ?? null))].join(''));
    }
    if ((params["mask_file"] ?? null) !== null) {
        cargs.push(["--mask=", execution.inputFile((params["mask_file"] ?? null))].join(''));
    }
    if ((params["median_2dfilter"] ?? null)) {
        cargs.push("--median");
    }
    if ((params["no_extend"] ?? null)) {
        cargs.push("--noextend");
    }
    if ((params["no_gap_fill"] ?? null)) {
        cargs.push("--nofill");
    }
    if ((params["nokspace"] ?? null)) {
        cargs.push("--nokspace");
    }
    if ((params["output_type"] ?? null) !== null) {
        cargs.push((params["output_type"] ?? null));
    }
    if ((params["pava"] ?? null)) {
        cargs.push("--pava");
    }
    if ((params["phase_conjugate"] ?? null)) {
        cargs.push("--phaseconj");
    }
    if ((params["phasemap_in_file"] ?? null) !== null) {
        cargs.push(["--phasemap=", execution.inputFile((params["phasemap_in_file"] ?? null))].join(''));
    }
    if ((params["poly_order"] ?? null) !== null) {
        cargs.push(["--poly=", String((params["poly_order"] ?? null))].join(''));
    }
    if ((params["save_fmap"] ?? null)) {
        cargs.push("--save_fmap");
    }
    if ((params["save_shift"] ?? null)) {
        cargs.push("--save_shift");
    }
    if ((params["save_unmasked_fmap"] ?? null)) {
        cargs.push("--unmaskfmap");
    }
    if ((params["save_unmasked_shift"] ?? null)) {
        cargs.push("--unmaskshift");
    }
    if ((params["shift_in_file"] ?? null) !== null) {
        cargs.push(["--loadshift=", execution.inputFile((params["shift_in_file"] ?? null))].join(''));
    }
    if ((params["shift_out_file"] ?? null) !== null) {
        cargs.push(["--saveshift=", (params["shift_out_file"] ?? null)].join(''));
    }
    if ((params["smooth2d"] ?? null) !== null) {
        cargs.push(["--smooth2=", String((params["smooth2d"] ?? null))].join(''));
    }
    if ((params["smooth3d"] ?? null) !== null) {
        cargs.push(["--smooth3=", String((params["smooth3d"] ?? null))].join(''));
    }
    if ((params["unwarp_direction"] ?? null) !== null) {
        cargs.push(["--unwarpdir=", (params["unwarp_direction"] ?? null)].join(''));
    }
    if ((params["unwarped_file"] ?? null) !== null) {
        cargs.push(["--unwarp=", (params["unwarped_file"] ?? null)].join(''));
    }
    if ((params["warped_file"] ?? null) !== null) {
        cargs.push(["--warp=", (params["warped_file"] ?? null)].join(''));
    }
    return cargs;
}


/**
 * Build outputs object containing output file paths and possibly stdout/stderr.
 *
 * @param params The parameters.
 * @param execution The execution object for resolving input paths.
 *
 * @returns Outputs object.
 */
function fugue_outputs(
    params: FugueParameters,
    execution: Execution,
): FugueOutputs {
    const ret: FugueOutputs = {
        root: execution.outputFile("."),
        fmap_out_file_outfile: ((params["fmap_out_file"] ?? null) !== null) ? execution.outputFile([(params["fmap_out_file"] ?? null)].join('')) : null,
        shift_out_file_outfile: ((params["shift_out_file"] ?? null) !== null) ? execution.outputFile([(params["shift_out_file"] ?? null)].join('')) : null,
        unwarped_file_outfile: ((params["unwarped_file"] ?? null) !== null) ? execution.outputFile([(params["unwarped_file"] ?? null)].join('')) : null,
        warped_file_outfile: ((params["warped_file"] ?? null) !== null) ? execution.outputFile([(params["warped_file"] ?? null)].join('')) : null,
    };
    return ret;
}


/**
 * fugue
 *
 * FMRIB's Utility for Geometric Unwarping of EPIs.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param params The parameters.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FugueOutputs`).
 */
function fugue_execute(
    params: FugueParameters,
    runner: Runner | null = null,
): FugueOutputs {
    runner = runner || getGlobalRunner();
    const execution = runner.startExecution(FUGUE_METADATA);
    params = execution.params(params)
    const cargs = fugue_cargs(params, execution)
    const ret = fugue_outputs(params, execution)
    execution.run(cargs, undefined);
    return ret;
}


/**
 * fugue
 *
 * FMRIB's Utility for Geometric Unwarping of EPIs.
 *
 * Author: FMRIB Analysis Group, University of Oxford
 *
 * URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
 *
 * @param asym_se_time Set the fieldmap asymmetric spin echo time (sec).
 * @param despike_2dfilter Apply a 2d de-spiking filter.
 * @param despike_threshold Specify the threshold for de-spiking (default=3.0).
 * @param dwell_time Set the epi dwell time per phase-encode line - same as echo spacing - (sec).
 * @param dwell_to_asym_ratio Set the dwell to asym time ratio.
 * @param fmap_in_file Filename for loading fieldmap (rad/s).
 * @param fmap_out_file Filename for saving fieldmap (rad/s).
 * @param forward_warping Apply forward warping instead of unwarping.
 * @param fourier_order Apply fourier (sinusoidal) fitting of order n.
 * @param icorr Apply intensity correction to unwarping (pixel shift method only).
 * @param icorr_only Apply intensity correction only.
 * @param in_file Filename of input volume.
 * @param mask_file Filename for loading valid mask.
 * @param median_2dfilter Apply 2d median filtering.
 * @param no_extend Do not apply rigid-body extrapolation to the fieldmap.
 * @param no_gap_fill Do not apply gap-filling measure to the fieldmap.
 * @param nokspace Do not use k-space forward warping.
 * @param output_type 'nifti' or 'nifti_pair' or 'nifti_gz' or 'nifti_pair_gz'. Fsl output type.
 * @param pava Apply monotonic enforcement via pava.
 * @param phase_conjugate Apply phase conjugate method of unwarping.
 * @param phasemap_in_file Filename for input phase image.
 * @param poly_order Apply polynomial fitting of order n.
 * @param save_fmap Write field map volume.
 * @param save_shift Write pixel shift volume.
 * @param save_unmasked_fmap Saves the unmasked fieldmap when using --savefmap.
 * @param save_unmasked_shift Saves the unmasked shiftmap when using --saveshift.
 * @param shift_in_file Filename for reading pixel shift volume.
 * @param shift_out_file Filename for saving pixel shift volume.
 * @param smooth2d Apply 2d gaussian smoothing of sigma n (in mm).
 * @param smooth3d Apply 3d gaussian smoothing of sigma n (in mm).
 * @param unwarp_direction 'x' or 'y' or 'z' or 'x-' or 'y-' or 'z-'. Specifies direction of warping (default y).
 * @param unwarped_file Apply unwarping and save as filename.
 * @param warped_file Apply forward warping and save as filename.
 * @param runner Command runner
 *
 * @returns NamedTuple of outputs (described in `FugueOutputs`).
 */
function fugue(
    asym_se_time: number | null = null,
    despike_2dfilter: boolean = false,
    despike_threshold: number | null = null,
    dwell_time: number | null = null,
    dwell_to_asym_ratio: number | null = null,
    fmap_in_file: InputPathType | null = null,
    fmap_out_file: string | null = null,
    forward_warping: boolean = false,
    fourier_order: number | null = null,
    icorr: boolean = false,
    icorr_only: boolean = false,
    in_file: InputPathType | null = null,
    mask_file: InputPathType | null = null,
    median_2dfilter: boolean = false,
    no_extend: boolean = false,
    no_gap_fill: boolean = false,
    nokspace: boolean = false,
    output_type: "NIFTI" | "NIFTI_PAIR" | "NIFTI_GZ" | "NIFTI_PAIR_GZ" | null = null,
    pava: boolean = false,
    phase_conjugate: boolean = false,
    phasemap_in_file: InputPathType | null = null,
    poly_order: number | null = null,
    save_fmap: boolean = false,
    save_shift: boolean = false,
    save_unmasked_fmap: boolean = false,
    save_unmasked_shift: boolean = false,
    shift_in_file: InputPathType | null = null,
    shift_out_file: string | null = null,
    smooth2d: number | null = null,
    smooth3d: number | null = null,
    unwarp_direction: "x" | "y" | "z" | "x-" | "y-" | "z-" | null = null,
    unwarped_file: string | null = null,
    warped_file: string | null = null,
    runner: Runner | null = null,
): FugueOutputs {
    const params = fugue_params(asym_se_time, despike_2dfilter, despike_threshold, dwell_time, dwell_to_asym_ratio, fmap_in_file, fmap_out_file, forward_warping, fourier_order, icorr, icorr_only, in_file, mask_file, median_2dfilter, no_extend, no_gap_fill, nokspace, output_type, pava, phase_conjugate, phasemap_in_file, poly_order, save_fmap, save_shift, save_unmasked_fmap, save_unmasked_shift, shift_in_file, shift_out_file, smooth2d, smooth3d, unwarp_direction, unwarped_file, warped_file)
    return fugue_execute(params, runner);
}


export {
      FUGUE_METADATA,
      FugueOutputs,
      FugueParameters,
      fugue,
      fugue_execute,
      fugue_params,
};
